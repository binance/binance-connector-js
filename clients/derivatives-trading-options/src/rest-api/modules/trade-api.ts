/**
 * Binance Public Derivatives Trading Options REST API
 *
 * OpenAPI Specification for the Binance Public Derivatives Trading Options REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
    ConfigurationRestAPI,
    TimeUnit,
    RestApiResponse,
    assertParamExists,
    sendRequest,
    type RequestArgs,
} from '@binance/common';
import type {
    AccountTradeListResponse,
    CancelAllOptionOrdersByUnderlyingResponse,
    CancelAllOptionOrdersOnSpecificSymbolResponse,
    CancelMultipleOptionOrdersResponse,
    CancelOptionOrderResponse,
    NewOrderResponse,
    OptionPositionInformationResponse,
    PlaceMultipleOrdersOrdersParameterInner,
    PlaceMultipleOrdersResponse,
    QueryCurrentOpenOptionOrdersResponse,
    QueryOptionOrderHistoryResponse,
    QuerySingleOrderResponse,
    UserExerciseRecordResponse,
} from '../types';

/**
 * TradeApi - axios parameter creator
 */
const TradeApiAxiosParamCreator = function (configuration: ConfigurationRestAPI) {
    return {
        /**
         * Get trades for a specific account and symbol.
         *
         * Weight: 5
         *
         * @summary Account Trade List (USER_DATA)
         * @param {string} [symbol] Option trading pair, e.g BTC-200730-9000-C
         * @param {number} [fromId] The UniqueId ID from which to return. The latest deal record is returned by default
         * @param {number} [startTime] Start Time, e.g 1593511200000
         * @param {number} [endTime] End Time, e.g 1593512200000
         * @param {number} [limit] Number of result sets returned Default:100 Max:1000
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        accountTradeList: async (
            symbol?: string,
            fromId?: number,
            startTime?: number,
            endTime?: number,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (fromId !== undefined && fromId !== null) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/eapi/v1/userTrades',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel all active orders on specified underlying.
         *
         * Weight: 1
         *
         * @summary Cancel All Option Orders By Underlying (TRADE)
         * @param {string} underlying Option underlying, e.g BTCUSDT
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cancelAllOptionOrdersByUnderlying: async (
            underlying: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'underlying' is not null or undefined
            assertParamExists('cancelAllOptionOrdersByUnderlying', 'underlying', underlying);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (underlying !== undefined && underlying !== null) {
                localVarQueryParameter['underlying'] = underlying;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/eapi/v1/allOpenOrdersByUnderlying',
                method: 'DELETE',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel all active order on a symbol.
         *
         * Weight: 1
         *
         * @summary Cancel all Option orders on specific symbol (TRADE)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cancelAllOptionOrdersOnSpecificSymbol: async (
            symbol: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cancelAllOptionOrdersOnSpecificSymbol', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/eapi/v1/allOpenOrders',
                method: 'DELETE',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel multiple orders.
         *
         * At least one instance of `orderId` and `clientOrderId` must be sent.
         *
         * Weight: 1
         *
         * @summary Cancel Multiple Option Orders (TRADE)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {Array<number>} [orderIds] Order ID, e.g [4611875134427365377,4611875134427365378]
         * @param {Array<string>} [clientOrderIds] User-defined order ID, e.g ["my_id_1","my_id_2"]
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cancelMultipleOptionOrders: async (
            symbol: string,
            orderIds?: Array<number>,
            clientOrderIds?: Array<string>,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cancelMultipleOptionOrders', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderIds) {
                localVarQueryParameter['orderIds'] = orderIds;
            }

            if (clientOrderIds) {
                localVarQueryParameter['clientOrderIds'] = clientOrderIds;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/eapi/v1/batchOrders',
                method: 'DELETE',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel an active order.
         *
         * At least one instance of `orderId` and `clientOrderId` must be sent.
         *
         * Weight: 1
         *
         * @summary Cancel Option Order (TRADE)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} [orderId] Order ID, e.g 4611875134427365377
         * @param {string} [clientOrderId] User-defined order ID, e.g 10000
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cancelOptionOrder: async (
            symbol: string,
            orderId?: number,
            clientOrderId?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cancelOptionOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (clientOrderId !== undefined && clientOrderId !== null) {
                localVarQueryParameter['clientOrderId'] = clientOrderId;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/eapi/v1/order',
                method: 'DELETE',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Send a new order.
         *
         * Weight: 0
         *
         * @summary New Order (TRADE)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {NewOrderSideEnum} side BUY or SELL
         * @param {NewOrderTypeEnum} type Order Type: LIMIT(only support limit)
         * @param {number} quantity Order Quantity
         * @param {number} [price] Order Price
         * @param {NewOrderTimeInForceEnum} [timeInForce] Time in force method（Default GTC）
         * @param {boolean} [reduceOnly] Reduce Only（Default false）
         * @param {boolean} [postOnly] Post Only（Default false）
         * @param {NewOrderNewOrderRespTypeEnum} [newOrderRespType] "ACK", "RESULT", Default "ACK"
         * @param {string} [clientOrderId] User-defined order ID, e.g 10000
         * @param {boolean} [isMmp] is market maker protection order, true/false
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        newOrder: async (
            symbol: string,
            side: NewOrderSideEnum,
            type: NewOrderTypeEnum,
            quantity: number,
            price?: number,
            timeInForce?: NewOrderTimeInForceEnum,
            reduceOnly?: boolean,
            postOnly?: boolean,
            newOrderRespType?: NewOrderNewOrderRespTypeEnum,
            clientOrderId?: string,
            isMmp?: boolean,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('newOrder', 'symbol', symbol);
            // verify required parameter 'side' is not null or undefined
            assertParamExists('newOrder', 'side', side);
            // verify required parameter 'type' is not null or undefined
            assertParamExists('newOrder', 'type', type);
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('newOrder', 'quantity', quantity);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }

            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }

            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }

            if (timeInForce !== undefined && timeInForce !== null) {
                localVarQueryParameter['timeInForce'] = timeInForce;
            }

            if (reduceOnly !== undefined && reduceOnly !== null) {
                localVarQueryParameter['reduceOnly'] = reduceOnly;
            }

            if (postOnly !== undefined && postOnly !== null) {
                localVarQueryParameter['postOnly'] = postOnly;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (clientOrderId !== undefined && clientOrderId !== null) {
                localVarQueryParameter['clientOrderId'] = clientOrderId;
            }

            if (isMmp !== undefined && isMmp !== null) {
                localVarQueryParameter['isMmp'] = isMmp;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/eapi/v1/order',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get current position information.
         *
         * Weight: 5
         *
         * @summary Option Position Information (USER_DATA)
         * @param {string} [symbol] Option trading pair, e.g BTC-200730-9000-C
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        optionPositionInformation: async (
            symbol?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/eapi/v1/position',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Send multiple option orders.
         *
         * Parameter rules are same with New Order
         * Batch orders are processed concurrently, and the order of matching is not guaranteed.
         *
         * Weight: 5
         *
         * @summary Place Multiple Orders(TRADE)
         * @param {Array<PlaceMultipleOrdersOrdersParameterInner>} orders order list. Max 5 orders
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        placeMultipleOrders: async (
            orders: Array<PlaceMultipleOrdersOrdersParameterInner>,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'orders' is not null or undefined
            assertParamExists('placeMultipleOrders', 'orders', orders);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (orders) {
                localVarQueryParameter['orders'] = orders;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/eapi/v1/batchOrders',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query current all open orders, status: ACCEPTED PARTIALLY_FILLED
         *
         * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
         *
         * @summary Query Current Open Option Orders (USER_DATA)
         * @param {string} [symbol] Option trading pair, e.g BTC-200730-9000-C
         * @param {number} [orderId] Order ID, e.g 4611875134427365377
         * @param {number} [startTime] Start Time, e.g 1593511200000
         * @param {number} [endTime] End Time, e.g 1593512200000
         * @param {number} [limit] Number of result sets returned Default:100 Max:1000
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryCurrentOpenOptionOrders: async (
            symbol?: string,
            orderId?: number,
            startTime?: number,
            endTime?: number,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/eapi/v1/openOrders',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query all finished orders within 5 days, finished status: CANCELLED FILLED REJECTED.
         *
         * Weight: 3
         *
         * @summary Query Option Order History (TRADE)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} [orderId] Order ID, e.g 4611875134427365377
         * @param {number} [startTime] Start Time, e.g 1593511200000
         * @param {number} [endTime] End Time, e.g 1593512200000
         * @param {number} [limit] Number of result sets returned Default:100 Max:1000
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryOptionOrderHistory: async (
            symbol: string,
            orderId?: number,
            startTime?: number,
            endTime?: number,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryOptionOrderHistory', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/eapi/v1/historyOrders',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Check an order status.
         *
         * These orders will not be found:
         * order status is `CANCELED` or `REJECTED`, **AND**
         * order has NO filled trade, **AND**
         * created time + 3 days < current time
         *
         *
         * Either `orderId` or `clientOrderId ` must be sent.
         *
         * Weight: 1
         *
         * @summary Query Single Order (TRADE)
         * @param {string} symbol Option trading pair, e.g BTC-200730-9000-C
         * @param {number} [orderId] Order ID, e.g 4611875134427365377
         * @param {string} [clientOrderId] User-defined order ID, e.g 10000
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        querySingleOrder: async (
            symbol: string,
            orderId?: number,
            clientOrderId?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('querySingleOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (clientOrderId !== undefined && clientOrderId !== null) {
                localVarQueryParameter['clientOrderId'] = clientOrderId;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/eapi/v1/order',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get account exercise records.
         *
         * Weight: 5
         *
         * @summary User Exercise Record (USER_DATA)
         * @param {string} [symbol] Option trading pair, e.g BTC-200730-9000-C
         * @param {number} [startTime] Start Time, e.g 1593511200000
         * @param {number} [endTime] End Time, e.g 1593512200000
         * @param {number} [limit] Number of result sets returned Default:100 Max:1000
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        userExerciseRecord: async (
            symbol?: string,
            startTime?: number,
            endTime?: number,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/eapi/v1/exerciseRecord',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
    };
};

/**
 * TradeApi - interface
 * @interface TradeApi
 */
export interface TradeApiInterface {
    /**
     * Get trades for a specific account and symbol.
     *
     * Weight: 5
     *
     * @summary Account Trade List (USER_DATA)
     * @param {AccountTradeListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    accountTradeList(
        requestParameters?: AccountTradeListRequest
    ): Promise<RestApiResponse<AccountTradeListResponse>>;
    /**
     * Cancel all active orders on specified underlying.
     *
     * Weight: 1
     *
     * @summary Cancel All Option Orders By Underlying (TRADE)
     * @param {CancelAllOptionOrdersByUnderlyingRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cancelAllOptionOrdersByUnderlying(
        requestParameters: CancelAllOptionOrdersByUnderlyingRequest
    ): Promise<RestApiResponse<CancelAllOptionOrdersByUnderlyingResponse>>;
    /**
     * Cancel all active order on a symbol.
     *
     * Weight: 1
     *
     * @summary Cancel all Option orders on specific symbol (TRADE)
     * @param {CancelAllOptionOrdersOnSpecificSymbolRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cancelAllOptionOrdersOnSpecificSymbol(
        requestParameters: CancelAllOptionOrdersOnSpecificSymbolRequest
    ): Promise<RestApiResponse<CancelAllOptionOrdersOnSpecificSymbolResponse>>;
    /**
     * Cancel multiple orders.
     *
     * At least one instance of `orderId` and `clientOrderId` must be sent.
     *
     * Weight: 1
     *
     * @summary Cancel Multiple Option Orders (TRADE)
     * @param {CancelMultipleOptionOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cancelMultipleOptionOrders(
        requestParameters: CancelMultipleOptionOrdersRequest
    ): Promise<RestApiResponse<CancelMultipleOptionOrdersResponse>>;
    /**
     * Cancel an active order.
     *
     * At least one instance of `orderId` and `clientOrderId` must be sent.
     *
     * Weight: 1
     *
     * @summary Cancel Option Order (TRADE)
     * @param {CancelOptionOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cancelOptionOrder(
        requestParameters: CancelOptionOrderRequest
    ): Promise<RestApiResponse<CancelOptionOrderResponse>>;
    /**
     * Send a new order.
     *
     * Weight: 0
     *
     * @summary New Order (TRADE)
     * @param {NewOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    newOrder(requestParameters: NewOrderRequest): Promise<RestApiResponse<NewOrderResponse>>;
    /**
     * Get current position information.
     *
     * Weight: 5
     *
     * @summary Option Position Information (USER_DATA)
     * @param {OptionPositionInformationRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    optionPositionInformation(
        requestParameters?: OptionPositionInformationRequest
    ): Promise<RestApiResponse<OptionPositionInformationResponse>>;
    /**
     * Send multiple option orders.
     *
     * Parameter rules are same with New Order
     * Batch orders are processed concurrently, and the order of matching is not guaranteed.
     *
     * Weight: 5
     *
     * @summary Place Multiple Orders(TRADE)
     * @param {PlaceMultipleOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    placeMultipleOrders(
        requestParameters: PlaceMultipleOrdersRequest
    ): Promise<RestApiResponse<PlaceMultipleOrdersResponse>>;
    /**
     * Query current all open orders, status: ACCEPTED PARTIALLY_FILLED
     *
     * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
     *
     * @summary Query Current Open Option Orders (USER_DATA)
     * @param {QueryCurrentOpenOptionOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryCurrentOpenOptionOrders(
        requestParameters?: QueryCurrentOpenOptionOrdersRequest
    ): Promise<RestApiResponse<QueryCurrentOpenOptionOrdersResponse>>;
    /**
     * Query all finished orders within 5 days, finished status: CANCELLED FILLED REJECTED.
     *
     * Weight: 3
     *
     * @summary Query Option Order History (TRADE)
     * @param {QueryOptionOrderHistoryRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryOptionOrderHistory(
        requestParameters: QueryOptionOrderHistoryRequest
    ): Promise<RestApiResponse<QueryOptionOrderHistoryResponse>>;
    /**
     * Check an order status.
     *
     * These orders will not be found:
     * order status is `CANCELED` or `REJECTED`, **AND**
     * order has NO filled trade, **AND**
     * created time + 3 days < current time
     *
     *
     * Either `orderId` or `clientOrderId ` must be sent.
     *
     * Weight: 1
     *
     * @summary Query Single Order (TRADE)
     * @param {QuerySingleOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    querySingleOrder(
        requestParameters: QuerySingleOrderRequest
    ): Promise<RestApiResponse<QuerySingleOrderResponse>>;
    /**
     * Get account exercise records.
     *
     * Weight: 5
     *
     * @summary User Exercise Record (USER_DATA)
     * @param {UserExerciseRecordRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    userExerciseRecord(
        requestParameters?: UserExerciseRecordRequest
    ): Promise<RestApiResponse<UserExerciseRecordResponse>>;
}

/**
 * Request parameters for accountTradeList operation in TradeApi.
 * @interface AccountTradeListRequest
 */
export interface AccountTradeListRequest {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof TradeApiAccountTradeList
     */
    readonly symbol?: string;

    /**
     * The UniqueId ID from which to return. The latest deal record is returned by default
     * @type {number}
     * @memberof TradeApiAccountTradeList
     */
    readonly fromId?: number;

    /**
     * Start Time, e.g 1593511200000
     * @type {number}
     * @memberof TradeApiAccountTradeList
     */
    readonly startTime?: number;

    /**
     * End Time, e.g 1593512200000
     * @type {number}
     * @memberof TradeApiAccountTradeList
     */
    readonly endTime?: number;

    /**
     * Number of result sets returned Default:100 Max:1000
     * @type {number}
     * @memberof TradeApiAccountTradeList
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiAccountTradeList
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for cancelAllOptionOrdersByUnderlying operation in TradeApi.
 * @interface CancelAllOptionOrdersByUnderlyingRequest
 */
export interface CancelAllOptionOrdersByUnderlyingRequest {
    /**
     * Option underlying, e.g BTCUSDT
     * @type {string}
     * @memberof TradeApiCancelAllOptionOrdersByUnderlying
     */
    readonly underlying: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiCancelAllOptionOrdersByUnderlying
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for cancelAllOptionOrdersOnSpecificSymbol operation in TradeApi.
 * @interface CancelAllOptionOrdersOnSpecificSymbolRequest
 */
export interface CancelAllOptionOrdersOnSpecificSymbolRequest {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof TradeApiCancelAllOptionOrdersOnSpecificSymbol
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiCancelAllOptionOrdersOnSpecificSymbol
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for cancelMultipleOptionOrders operation in TradeApi.
 * @interface CancelMultipleOptionOrdersRequest
 */
export interface CancelMultipleOptionOrdersRequest {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof TradeApiCancelMultipleOptionOrders
     */
    readonly symbol: string;

    /**
     * Order ID, e.g [4611875134427365377,4611875134427365378]
     * @type {Array<number>}
     * @memberof TradeApiCancelMultipleOptionOrders
     */
    readonly orderIds?: Array<number>;

    /**
     * User-defined order ID, e.g ["my_id_1","my_id_2"]
     * @type {Array<string>}
     * @memberof TradeApiCancelMultipleOptionOrders
     */
    readonly clientOrderIds?: Array<string>;

    /**
     *
     * @type {number}
     * @memberof TradeApiCancelMultipleOptionOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for cancelOptionOrder operation in TradeApi.
 * @interface CancelOptionOrderRequest
 */
export interface CancelOptionOrderRequest {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof TradeApiCancelOptionOrder
     */
    readonly symbol: string;

    /**
     * Order ID, e.g 4611875134427365377
     * @type {number}
     * @memberof TradeApiCancelOptionOrder
     */
    readonly orderId?: number;

    /**
     * User-defined order ID, e.g 10000
     * @type {string}
     * @memberof TradeApiCancelOptionOrder
     */
    readonly clientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiCancelOptionOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for newOrder operation in TradeApi.
 * @interface NewOrderRequest
 */
export interface NewOrderRequest {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof TradeApiNewOrder
     */
    readonly symbol: string;

    /**
     * BUY or SELL
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiNewOrder
     */
    readonly side: NewOrderSideEnum;

    /**
     * Order Type: LIMIT(only support limit)
     * @type {'LIMIT'}
     * @memberof TradeApiNewOrder
     */
    readonly type: NewOrderTypeEnum;

    /**
     * Order Quantity
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly quantity: number;

    /**
     * Order Price
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly price?: number;

    /**
     * Time in force method（Default GTC）
     * @type {'GTC' | 'IOC' | 'FOK'}
     * @memberof TradeApiNewOrder
     */
    readonly timeInForce?: NewOrderTimeInForceEnum;

    /**
     * Reduce Only（Default false）
     * @type {boolean}
     * @memberof TradeApiNewOrder
     */
    readonly reduceOnly?: boolean;

    /**
     * Post Only（Default false）
     * @type {boolean}
     * @memberof TradeApiNewOrder
     */
    readonly postOnly?: boolean;

    /**
     * "ACK", "RESULT", Default "ACK"
     * @type {'ACK' | 'RESULT'}
     * @memberof TradeApiNewOrder
     */
    readonly newOrderRespType?: NewOrderNewOrderRespTypeEnum;

    /**
     * User-defined order ID, e.g 10000
     * @type {string}
     * @memberof TradeApiNewOrder
     */
    readonly clientOrderId?: string;

    /**
     * is market maker protection order, true/false
     * @type {boolean}
     * @memberof TradeApiNewOrder
     */
    readonly isMmp?: boolean;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for optionPositionInformation operation in TradeApi.
 * @interface OptionPositionInformationRequest
 */
export interface OptionPositionInformationRequest {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof TradeApiOptionPositionInformation
     */
    readonly symbol?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiOptionPositionInformation
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for placeMultipleOrders operation in TradeApi.
 * @interface PlaceMultipleOrdersRequest
 */
export interface PlaceMultipleOrdersRequest {
    /**
     * order list. Max 5 orders
     * @type {Array<PlaceMultipleOrdersOrdersParameterInner>}
     * @memberof TradeApiPlaceMultipleOrders
     */
    readonly orders: Array<PlaceMultipleOrdersOrdersParameterInner>;

    /**
     *
     * @type {number}
     * @memberof TradeApiPlaceMultipleOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for queryCurrentOpenOptionOrders operation in TradeApi.
 * @interface QueryCurrentOpenOptionOrdersRequest
 */
export interface QueryCurrentOpenOptionOrdersRequest {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof TradeApiQueryCurrentOpenOptionOrders
     */
    readonly symbol?: string;

    /**
     * Order ID, e.g 4611875134427365377
     * @type {number}
     * @memberof TradeApiQueryCurrentOpenOptionOrders
     */
    readonly orderId?: number;

    /**
     * Start Time, e.g 1593511200000
     * @type {number}
     * @memberof TradeApiQueryCurrentOpenOptionOrders
     */
    readonly startTime?: number;

    /**
     * End Time, e.g 1593512200000
     * @type {number}
     * @memberof TradeApiQueryCurrentOpenOptionOrders
     */
    readonly endTime?: number;

    /**
     * Number of result sets returned Default:100 Max:1000
     * @type {number}
     * @memberof TradeApiQueryCurrentOpenOptionOrders
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiQueryCurrentOpenOptionOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for queryOptionOrderHistory operation in TradeApi.
 * @interface QueryOptionOrderHistoryRequest
 */
export interface QueryOptionOrderHistoryRequest {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof TradeApiQueryOptionOrderHistory
     */
    readonly symbol: string;

    /**
     * Order ID, e.g 4611875134427365377
     * @type {number}
     * @memberof TradeApiQueryOptionOrderHistory
     */
    readonly orderId?: number;

    /**
     * Start Time, e.g 1593511200000
     * @type {number}
     * @memberof TradeApiQueryOptionOrderHistory
     */
    readonly startTime?: number;

    /**
     * End Time, e.g 1593512200000
     * @type {number}
     * @memberof TradeApiQueryOptionOrderHistory
     */
    readonly endTime?: number;

    /**
     * Number of result sets returned Default:100 Max:1000
     * @type {number}
     * @memberof TradeApiQueryOptionOrderHistory
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiQueryOptionOrderHistory
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for querySingleOrder operation in TradeApi.
 * @interface QuerySingleOrderRequest
 */
export interface QuerySingleOrderRequest {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof TradeApiQuerySingleOrder
     */
    readonly symbol: string;

    /**
     * Order ID, e.g 4611875134427365377
     * @type {number}
     * @memberof TradeApiQuerySingleOrder
     */
    readonly orderId?: number;

    /**
     * User-defined order ID, e.g 10000
     * @type {string}
     * @memberof TradeApiQuerySingleOrder
     */
    readonly clientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiQuerySingleOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for userExerciseRecord operation in TradeApi.
 * @interface UserExerciseRecordRequest
 */
export interface UserExerciseRecordRequest {
    /**
     * Option trading pair, e.g BTC-200730-9000-C
     * @type {string}
     * @memberof TradeApiUserExerciseRecord
     */
    readonly symbol?: string;

    /**
     * Start Time, e.g 1593511200000
     * @type {number}
     * @memberof TradeApiUserExerciseRecord
     */
    readonly startTime?: number;

    /**
     * End Time, e.g 1593512200000
     * @type {number}
     * @memberof TradeApiUserExerciseRecord
     */
    readonly endTime?: number;

    /**
     * Number of result sets returned Default:100 Max:1000
     * @type {number}
     * @memberof TradeApiUserExerciseRecord
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiUserExerciseRecord
     */
    readonly recvWindow?: number;
}

/**
 * TradeApi - object-oriented interface
 * @class TradeApi
 */
export class TradeApi implements TradeApiInterface {
    private readonly configuration: ConfigurationRestAPI;
    private localVarAxiosParamCreator;

    constructor(configuration: ConfigurationRestAPI) {
        this.configuration = configuration;
        this.localVarAxiosParamCreator = TradeApiAxiosParamCreator(configuration);
    }

    /**
     * Get trades for a specific account and symbol.
     *
     * Weight: 5
     *
     * @summary Account Trade List (USER_DATA)
     * @param {AccountTradeListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<AccountTradeListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/option/trade/Account-Trade-List Binance API Documentation}
     */
    public async accountTradeList(
        requestParameters: AccountTradeListRequest = {}
    ): Promise<RestApiResponse<AccountTradeListResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.accountTradeList(
            requestParameters?.symbol,
            requestParameters?.fromId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<AccountTradeListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel all active orders on specified underlying.
     *
     * Weight: 1
     *
     * @summary Cancel All Option Orders By Underlying (TRADE)
     * @param {CancelAllOptionOrdersByUnderlyingRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CancelAllOptionOrdersByUnderlyingResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/option/trade/Cancel-All-Option-Orders-By-Underlying Binance API Documentation}
     */
    public async cancelAllOptionOrdersByUnderlying(
        requestParameters: CancelAllOptionOrdersByUnderlyingRequest
    ): Promise<RestApiResponse<CancelAllOptionOrdersByUnderlyingResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.cancelAllOptionOrdersByUnderlying(
                requestParameters?.underlying,
                requestParameters?.recvWindow
            );
        return sendRequest<CancelAllOptionOrdersByUnderlyingResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel all active order on a symbol.
     *
     * Weight: 1
     *
     * @summary Cancel all Option orders on specific symbol (TRADE)
     * @param {CancelAllOptionOrdersOnSpecificSymbolRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CancelAllOptionOrdersOnSpecificSymbolResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/option/trade/Cancel-all-Option-orders-on-specific-symbol Binance API Documentation}
     */
    public async cancelAllOptionOrdersOnSpecificSymbol(
        requestParameters: CancelAllOptionOrdersOnSpecificSymbolRequest
    ): Promise<RestApiResponse<CancelAllOptionOrdersOnSpecificSymbolResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.cancelAllOptionOrdersOnSpecificSymbol(
                requestParameters?.symbol,
                requestParameters?.recvWindow
            );
        return sendRequest<CancelAllOptionOrdersOnSpecificSymbolResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel multiple orders.
     *
     * At least one instance of `orderId` and `clientOrderId` must be sent.
     *
     * Weight: 1
     *
     * @summary Cancel Multiple Option Orders (TRADE)
     * @param {CancelMultipleOptionOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CancelMultipleOptionOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/option/trade/Cancel-Multiple-Option-Orders Binance API Documentation}
     */
    public async cancelMultipleOptionOrders(
        requestParameters: CancelMultipleOptionOrdersRequest
    ): Promise<RestApiResponse<CancelMultipleOptionOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.cancelMultipleOptionOrders(
            requestParameters?.symbol,
            requestParameters?.orderIds,
            requestParameters?.clientOrderIds,
            requestParameters?.recvWindow
        );
        return sendRequest<CancelMultipleOptionOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel an active order.
     *
     * At least one instance of `orderId` and `clientOrderId` must be sent.
     *
     * Weight: 1
     *
     * @summary Cancel Option Order (TRADE)
     * @param {CancelOptionOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CancelOptionOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/option/trade/Cancel-Option-Order Binance API Documentation}
     */
    public async cancelOptionOrder(
        requestParameters: CancelOptionOrderRequest
    ): Promise<RestApiResponse<CancelOptionOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.cancelOptionOrder(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.clientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<CancelOptionOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Send a new order.
     *
     * Weight: 0
     *
     * @summary New Order (TRADE)
     * @param {NewOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<NewOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/option/trade/New-Order Binance API Documentation}
     */
    public async newOrder(
        requestParameters: NewOrderRequest
    ): Promise<RestApiResponse<NewOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.newOrder(
            requestParameters?.symbol,
            requestParameters?.side,
            requestParameters?.type,
            requestParameters?.quantity,
            requestParameters?.price,
            requestParameters?.timeInForce,
            requestParameters?.reduceOnly,
            requestParameters?.postOnly,
            requestParameters?.newOrderRespType,
            requestParameters?.clientOrderId,
            requestParameters?.isMmp,
            requestParameters?.recvWindow
        );
        return sendRequest<NewOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get current position information.
     *
     * Weight: 5
     *
     * @summary Option Position Information (USER_DATA)
     * @param {OptionPositionInformationRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OptionPositionInformationResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/option/trade/Option-Position-Information Binance API Documentation}
     */
    public async optionPositionInformation(
        requestParameters: OptionPositionInformationRequest = {}
    ): Promise<RestApiResponse<OptionPositionInformationResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.optionPositionInformation(
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<OptionPositionInformationResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Send multiple option orders.
     *
     * Parameter rules are same with New Order
     * Batch orders are processed concurrently, and the order of matching is not guaranteed.
     *
     * Weight: 5
     *
     * @summary Place Multiple Orders(TRADE)
     * @param {PlaceMultipleOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<PlaceMultipleOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/option/trade/Place-Multiple-Orders Binance API Documentation}
     */
    public async placeMultipleOrders(
        requestParameters: PlaceMultipleOrdersRequest
    ): Promise<RestApiResponse<PlaceMultipleOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.placeMultipleOrders(
            requestParameters?.orders,
            requestParameters?.recvWindow
        );
        return sendRequest<PlaceMultipleOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query current all open orders, status: ACCEPTED PARTIALLY_FILLED
     *
     * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
     *
     * @summary Query Current Open Option Orders (USER_DATA)
     * @param {QueryCurrentOpenOptionOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryCurrentOpenOptionOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/option/trade/Query-Current-Open-Option-Orders Binance API Documentation}
     */
    public async queryCurrentOpenOptionOrders(
        requestParameters: QueryCurrentOpenOptionOrdersRequest = {}
    ): Promise<RestApiResponse<QueryCurrentOpenOptionOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryCurrentOpenOptionOrders(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryCurrentOpenOptionOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query all finished orders within 5 days, finished status: CANCELLED FILLED REJECTED.
     *
     * Weight: 3
     *
     * @summary Query Option Order History (TRADE)
     * @param {QueryOptionOrderHistoryRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryOptionOrderHistoryResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/option/trade/Query-Option-Order-History Binance API Documentation}
     */
    public async queryOptionOrderHistory(
        requestParameters: QueryOptionOrderHistoryRequest
    ): Promise<RestApiResponse<QueryOptionOrderHistoryResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryOptionOrderHistory(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryOptionOrderHistoryResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Check an order status.
     *
     * These orders will not be found:
     * order status is `CANCELED` or `REJECTED`, **AND**
     * order has NO filled trade, **AND**
     * created time + 3 days < current time
     *
     *
     * Either `orderId` or `clientOrderId ` must be sent.
     *
     * Weight: 1
     *
     * @summary Query Single Order (TRADE)
     * @param {QuerySingleOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QuerySingleOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/option/trade/Query-Single-Order Binance API Documentation}
     */
    public async querySingleOrder(
        requestParameters: QuerySingleOrderRequest
    ): Promise<RestApiResponse<QuerySingleOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.querySingleOrder(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.clientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<QuerySingleOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get account exercise records.
     *
     * Weight: 5
     *
     * @summary User Exercise Record (USER_DATA)
     * @param {UserExerciseRecordRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<UserExerciseRecordResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/option/trade/User-Exercise-Record Binance API Documentation}
     */
    public async userExerciseRecord(
        requestParameters: UserExerciseRecordRequest = {}
    ): Promise<RestApiResponse<UserExerciseRecordResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.userExerciseRecord(
            requestParameters?.symbol,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<UserExerciseRecordResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }
}

export const NewOrderSideEnum = {
    BUY: 'BUY',
    SELL: 'SELL',
} as const;
export type NewOrderSideEnum = (typeof NewOrderSideEnum)[keyof typeof NewOrderSideEnum];

export const NewOrderTypeEnum = {
    LIMIT: 'LIMIT',
} as const;
export type NewOrderTypeEnum = (typeof NewOrderTypeEnum)[keyof typeof NewOrderTypeEnum];

export const NewOrderTimeInForceEnum = {
    GTC: 'GTC',
    IOC: 'IOC',
    FOK: 'FOK',
} as const;
export type NewOrderTimeInForceEnum =
    (typeof NewOrderTimeInForceEnum)[keyof typeof NewOrderTimeInForceEnum];

export const NewOrderNewOrderRespTypeEnum = {
    ACK: 'ACK',
    RESULT: 'RESULT',
} as const;
export type NewOrderNewOrderRespTypeEnum =
    (typeof NewOrderNewOrderRespTypeEnum)[keyof typeof NewOrderNewOrderRespTypeEnum];
