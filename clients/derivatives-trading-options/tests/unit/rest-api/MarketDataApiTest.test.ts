/**
 * Binance Derivatives Trading Options REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading Options REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { MarketDataApi } from '../../../src/rest-api';
import {
    HistoricalExerciseRecordsRequest,
    KlineCandlestickDataRequest,
    OldTradesLookupRequest,
    OpenInterestRequest,
    OptionMarkPriceRequest,
    OrderBookRequest,
    RecentBlockTradesListRequest,
    RecentTradesListRequest,
    SymbolPriceTickerRequest,
    Ticker24hrPriceChangeStatisticsRequest,
} from '../../../src/rest-api';
import type {
    CheckServerTimeResponse,
    ExchangeInformationResponse,
    HistoricalExerciseRecordsResponse,
    KlineCandlestickDataResponse,
    OldTradesLookupResponse,
    OpenInterestResponse,
    OptionMarkPriceResponse,
    OrderBookResponse,
    RecentBlockTradesListResponse,
    RecentTradesListResponse,
    SymbolPriceTickerResponse,
    Ticker24hrPriceChangeStatisticsResponse,
} from '../../../src/rest-api/types';

describe('MarketDataApi', () => {
    let client: MarketDataApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new MarketDataApi(config);
    });

    describe('checkServerTime()', () => {
        it('should execute checkServerTime() successfully with required parameters only', async () => {
            mockResponse = { serverTime: 1499827319559 };

            const spy = jest.spyOn(client, 'checkServerTime').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CheckServerTimeResponse>)
            );
            const response = await client.checkServerTime();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'checkServerTime').mockRejectedValueOnce(mockError);
            await expect(client.checkServerTime()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('exchangeInformation()', () => {
        it('should execute exchangeInformation() successfully with required parameters only', async () => {
            mockResponse = {
                timezone: 'UTC',
                serverTime: 1592387337630,
                optionContracts: [
                    {
                        baseAsset: 'BTC',
                        quoteAsset: 'USDT',
                        underlying: 'BTCUSDT',
                        settleAsset: 'USDT',
                    },
                ],
                optionAssets: [{ name: 'USDT' }],
                optionSymbols: [
                    {
                        expiryDate: 1660521600000,
                        filters: [
                            {
                                filterType: 'PRICE_FILTER',
                                minPrice: '0.02',
                                maxPrice: '80000.01',
                                tickSize: '0.01',
                            },
                            {
                                filterType: 'LOT_SIZE',
                                minQty: '0.01',
                                maxQty: '100',
                                stepSize: '0.01',
                            },
                        ],
                        symbol: 'BTC-220815-50000-C',
                        side: 'CALL',
                        strikePrice: '50000',
                        underlying: 'BTCUSDT',
                        unit: 1,
                        makerFeeRate: '0.0002',
                        takerFeeRate: '0.0002',
                        minQty: '0.01',
                        maxQty: '100',
                        initialMargin: '0.15',
                        maintenanceMargin: '0.075',
                        minInitialMargin: '0.1',
                        minMaintenanceMargin: '0.05',
                        priceScale: 2,
                        quantityScale: 2,
                        quoteAsset: 'USDT',
                    },
                ],
                rateLimits: [
                    {
                        rateLimitType: 'REQUEST_WEIGHT',
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 2400,
                    },
                    { rateLimitType: 'ORDERS', interval: 'MINUTE', intervalNum: 1, limit: 1200 },
                    { rateLimitType: 'ORDERS', interval: 'SECOND', intervalNum: 10, limit: 300 },
                ],
            };

            const spy = jest.spyOn(client, 'exchangeInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ExchangeInformationResponse>)
            );
            const response = await client.exchangeInformation();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'exchangeInformation').mockRejectedValueOnce(mockError);
            await expect(client.exchangeInformation()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('historicalExerciseRecords()', () => {
        it('should execute historicalExerciseRecords() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    symbol: 'BTC-220121-60000-P',
                    strikePrice: '60000',
                    realStrikePrice: '38844.69652571',
                    expiryDate: 1642752000000,
                    strikeResult: 'REALISTIC_VALUE_STRICKEN',
                },
            ];

            const spy = jest.spyOn(client, 'historicalExerciseRecords').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<HistoricalExerciseRecordsResponse>)
            );
            const response = await client.historicalExerciseRecords();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute historicalExerciseRecords() successfully with optional parameters', async () => {
            const params: HistoricalExerciseRecordsRequest = {
                underlying: 'underlying_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = [
                {
                    symbol: 'BTC-220121-60000-P',
                    strikePrice: '60000',
                    realStrikePrice: '38844.69652571',
                    expiryDate: 1642752000000,
                    strikeResult: 'REALISTIC_VALUE_STRICKEN',
                },
            ];

            const spy = jest.spyOn(client, 'historicalExerciseRecords').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<HistoricalExerciseRecordsResponse>)
            );
            const response = await client.historicalExerciseRecords(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'historicalExerciseRecords')
                .mockRejectedValueOnce(mockError);
            await expect(client.historicalExerciseRecords()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('klineCandlestickData()', () => {
        it('should execute klineCandlestickData() successfully with required parameters only', async () => {
            const params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: 'interval_example',
            };

            mockResponse = [
                {
                    open: '950',
                    high: '1100',
                    low: '900',
                    close: '1000',
                    volume: '100',
                    amount: '2',
                    interval: '5m',
                    tradeCount: 10,
                    takerVolume: '100',
                    takerAmount: '10000',
                    openTime: 1499040000000,
                    closeTime: 1499644799999,
                },
            ];

            const spy = jest.spyOn(client, 'klineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<KlineCandlestickDataResponse>)
            );
            const response = await client.klineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute klineCandlestickData() successfully with optional parameters', async () => {
            const params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: 'interval_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = [
                {
                    open: '950',
                    high: '1100',
                    low: '900',
                    close: '1000',
                    volume: '100',
                    amount: '2',
                    interval: '5m',
                    tradeCount: 10,
                    takerVolume: '100',
                    takerAmount: '10000',
                    openTime: 1499040000000,
                    closeTime: 1499644799999,
                },
            ];

            const spy = jest.spyOn(client, 'klineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<KlineCandlestickDataResponse>)
            );
            const response = await client.klineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: 'interval_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.klineCandlestickData(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling klineCandlestickData.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: 'interval_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.klineCandlestickData(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling klineCandlestickData.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: 'interval_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'klineCandlestickData').mockRejectedValueOnce(mockError);
            await expect(client.klineCandlestickData(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('oldTradesLookup()', () => {
        it('should execute oldTradesLookup() successfully with required parameters only', async () => {
            const params: OldTradesLookupRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    id: '1',
                    tradeId: '159244329455993',
                    price: '1000',
                    qty: '-0.1',
                    quoteQty: '-100',
                    side: -1,
                    time: 1592449455993,
                },
            ];

            const spy = jest.spyOn(client, 'oldTradesLookup').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OldTradesLookupResponse>)
            );
            const response = await client.oldTradesLookup(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute oldTradesLookup() successfully with optional parameters', async () => {
            const params: OldTradesLookupRequest = {
                symbol: 'symbol_example',
                fromId: 1,
                limit: 100,
            };

            mockResponse = [
                {
                    id: '1',
                    tradeId: '159244329455993',
                    price: '1000',
                    qty: '-0.1',
                    quoteQty: '-100',
                    side: -1,
                    time: 1592449455993,
                },
            ];

            const spy = jest.spyOn(client, 'oldTradesLookup').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OldTradesLookupResponse>)
            );
            const response = await client.oldTradesLookup(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OldTradesLookupRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.oldTradesLookup(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling oldTradesLookup.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OldTradesLookupRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'oldTradesLookup').mockRejectedValueOnce(mockError);
            await expect(client.oldTradesLookup(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('openInterest()', () => {
        it('should execute openInterest() successfully with required parameters only', async () => {
            const params: OpenInterestRequest = {
                underlyingAsset: 'underlyingAsset_example',
                expiration: 'expiration_example',
            };

            mockResponse = [
                {
                    symbol: 'ETH-221119-1175-P',
                    sumOpenInterest: '4.01',
                    sumOpenInterestUsd: '4880.2985615624',
                    timestamp: '1668754020000',
                },
            ];

            const spy = jest.spyOn(client, 'openInterest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenInterestResponse>)
            );
            const response = await client.openInterest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute openInterest() successfully with optional parameters', async () => {
            const params: OpenInterestRequest = {
                underlyingAsset: 'underlyingAsset_example',
                expiration: 'expiration_example',
            };

            mockResponse = [
                {
                    symbol: 'ETH-221119-1175-P',
                    sumOpenInterest: '4.01',
                    sumOpenInterestUsd: '4880.2985615624',
                    timestamp: '1668754020000',
                },
            ];

            const spy = jest.spyOn(client, 'openInterest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenInterestResponse>)
            );
            const response = await client.openInterest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when underlyingAsset is missing', async () => {
            const _params: OpenInterestRequest = {
                underlyingAsset: 'underlyingAsset_example',
                expiration: 'expiration_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.underlyingAsset;

            await expect(client.openInterest(params)).rejects.toThrow(
                'Required parameter underlyingAsset was null or undefined when calling openInterest.'
            );
        });

        it('should throw RequiredError when expiration is missing', async () => {
            const _params: OpenInterestRequest = {
                underlyingAsset: 'underlyingAsset_example',
                expiration: 'expiration_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.expiration;

            await expect(client.openInterest(params)).rejects.toThrow(
                'Required parameter expiration was null or undefined when calling openInterest.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OpenInterestRequest = {
                underlyingAsset: 'underlyingAsset_example',
                expiration: 'expiration_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'openInterest').mockRejectedValueOnce(mockError);
            await expect(client.openInterest(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('optionMarkPrice()', () => {
        it('should execute optionMarkPrice() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    symbol: 'BTC-200730-9000-C',
                    markPrice: '1343.2883',
                    bidIV: '1.40000077',
                    askIV: '1.50000153',
                    markIV: '1.45000000',
                    delta: '0.55937056',
                    theta: '3739.82509871',
                    gamma: '0.00010969',
                    vega: '978.58874732',
                    highPriceLimit: '1618.241',
                    lowPriceLimit: '1068.3356',
                    riskFreeInterest: '0.1',
                },
            ];

            const spy = jest.spyOn(client, 'optionMarkPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OptionMarkPriceResponse>)
            );
            const response = await client.optionMarkPrice();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute optionMarkPrice() successfully with optional parameters', async () => {
            const params: OptionMarkPriceRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    symbol: 'BTC-200730-9000-C',
                    markPrice: '1343.2883',
                    bidIV: '1.40000077',
                    askIV: '1.50000153',
                    markIV: '1.45000000',
                    delta: '0.55937056',
                    theta: '3739.82509871',
                    gamma: '0.00010969',
                    vega: '978.58874732',
                    highPriceLimit: '1618.241',
                    lowPriceLimit: '1068.3356',
                    riskFreeInterest: '0.1',
                },
            ];

            const spy = jest.spyOn(client, 'optionMarkPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OptionMarkPriceResponse>)
            );
            const response = await client.optionMarkPrice(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'optionMarkPrice').mockRejectedValueOnce(mockError);
            await expect(client.optionMarkPrice()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderBook()', () => {
        it('should execute orderBook() successfully with required parameters only', async () => {
            const params: OrderBookRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                T: 1589436922972,
                u: 37461,
                bids: [['1000', '0.9']],
                asks: [['1100', '0.1']],
            };

            const spy = jest.spyOn(client, 'orderBook').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderBookResponse>)
            );
            const response = await client.orderBook(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderBook() successfully with optional parameters', async () => {
            const params: OrderBookRequest = {
                symbol: 'symbol_example',
                limit: 100,
            };

            mockResponse = {
                T: 1589436922972,
                u: 37461,
                bids: [['1000', '0.9']],
                asks: [['1100', '0.1']],
            };

            const spy = jest.spyOn(client, 'orderBook').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderBookResponse>)
            );
            const response = await client.orderBook(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderBookRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderBook(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderBook.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderBookRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderBook').mockRejectedValueOnce(mockError);
            await expect(client.orderBook(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('recentBlockTradesList()', () => {
        it('should execute recentBlockTradesList() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    id: 1125899906901081100,
                    tradeId: 389,
                    symbol: 'ETH-250725-1200-P',
                    price: '342.40',
                    qty: '-2167.20',
                    quoteQty: '-4.90',
                    side: -1,
                    time: 1733950676483,
                },
                {
                    id: 1125899906901081000,
                    tradeId: 161,
                    symbol: 'XRP-250904-0.086-P',
                    price: '3.0',
                    qty: '-6.0',
                    quoteQty: '-2.02',
                    side: -1,
                    time: 1733950488444,
                },
            ];

            const spy = jest.spyOn(client, 'recentBlockTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RecentBlockTradesListResponse>)
            );
            const response = await client.recentBlockTradesList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute recentBlockTradesList() successfully with optional parameters', async () => {
            const params: RecentBlockTradesListRequest = {
                symbol: 'symbol_example',
                limit: 100,
            };

            mockResponse = [
                {
                    id: 1125899906901081100,
                    tradeId: 389,
                    symbol: 'ETH-250725-1200-P',
                    price: '342.40',
                    qty: '-2167.20',
                    quoteQty: '-4.90',
                    side: -1,
                    time: 1733950676483,
                },
                {
                    id: 1125899906901081000,
                    tradeId: 161,
                    symbol: 'XRP-250904-0.086-P',
                    price: '3.0',
                    qty: '-6.0',
                    quoteQty: '-2.02',
                    side: -1,
                    time: 1733950488444,
                },
            ];

            const spy = jest.spyOn(client, 'recentBlockTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RecentBlockTradesListResponse>)
            );
            const response = await client.recentBlockTradesList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'recentBlockTradesList')
                .mockRejectedValueOnce(mockError);
            await expect(client.recentBlockTradesList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('recentTradesList()', () => {
        it('should execute recentTradesList() successfully with required parameters only', async () => {
            const params: RecentTradesListRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    id: '1',
                    symbol: 'BTC-220722-19000-C',
                    price: '1000',
                    qty: '-0.1',
                    quoteQty: '-100',
                    side: -1,
                    time: 1592449455993,
                },
            ];

            const spy = jest.spyOn(client, 'recentTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RecentTradesListResponse>)
            );
            const response = await client.recentTradesList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute recentTradesList() successfully with optional parameters', async () => {
            const params: RecentTradesListRequest = {
                symbol: 'symbol_example',
                limit: 100,
            };

            mockResponse = [
                {
                    id: '1',
                    symbol: 'BTC-220722-19000-C',
                    price: '1000',
                    qty: '-0.1',
                    quoteQty: '-100',
                    side: -1,
                    time: 1592449455993,
                },
            ];

            const spy = jest.spyOn(client, 'recentTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RecentTradesListResponse>)
            );
            const response = await client.recentTradesList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: RecentTradesListRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.recentTradesList(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling recentTradesList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: RecentTradesListRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'recentTradesList').mockRejectedValueOnce(mockError);
            await expect(client.recentTradesList(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('symbolPriceTicker()', () => {
        it('should execute symbolPriceTicker() successfully with required parameters only', async () => {
            const params: SymbolPriceTickerRequest = {
                underlying: 'underlying_example',
            };

            mockResponse = { time: 1656647305000, indexPrice: '9200' };

            const spy = jest.spyOn(client, 'symbolPriceTicker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolPriceTickerResponse>)
            );
            const response = await client.symbolPriceTicker(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute symbolPriceTicker() successfully with optional parameters', async () => {
            const params: SymbolPriceTickerRequest = {
                underlying: 'underlying_example',
            };

            mockResponse = { time: 1656647305000, indexPrice: '9200' };

            const spy = jest.spyOn(client, 'symbolPriceTicker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolPriceTickerResponse>)
            );
            const response = await client.symbolPriceTicker(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when underlying is missing', async () => {
            const _params: SymbolPriceTickerRequest = {
                underlying: 'underlying_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.underlying;

            await expect(client.symbolPriceTicker(params)).rejects.toThrow(
                'Required parameter underlying was null or undefined when calling symbolPriceTicker.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SymbolPriceTickerRequest = {
                underlying: 'underlying_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'symbolPriceTicker').mockRejectedValueOnce(mockError);
            await expect(client.symbolPriceTicker(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('testConnectivity()', () => {
        it('should execute testConnectivity() successfully with required parameters only', async () => {
            const spy = jest.spyOn(client, 'testConnectivity').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.testConnectivity();

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'testConnectivity').mockRejectedValueOnce(mockError);
            await expect(client.testConnectivity()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('ticker24hrPriceChangeStatistics()', () => {
        it('should execute ticker24hrPriceChangeStatistics() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    symbol: 'BTC-200730-9000-C',
                    priceChange: '-16.2038',
                    priceChangePercent: '-0.0162',
                    lastPrice: '1000',
                    lastQty: '1000',
                    open: '1016.2038',
                    high: '1016.2038',
                    low: '0',
                    volume: '5',
                    amount: '1',
                    bidPrice: '999.34',
                    askPrice: '1000.23',
                    openTime: 1592317127349,
                    closeTime: 1592380593516,
                    firstTradeId: 1,
                    tradeCount: 5,
                    strikePrice: '9000',
                    exercisePrice: '3000.3356',
                },
            ];

            const spy = jest.spyOn(client, 'ticker24hrPriceChangeStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<Ticker24hrPriceChangeStatisticsResponse>)
            );
            const response = await client.ticker24hrPriceChangeStatistics();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute ticker24hrPriceChangeStatistics() successfully with optional parameters', async () => {
            const params: Ticker24hrPriceChangeStatisticsRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    symbol: 'BTC-200730-9000-C',
                    priceChange: '-16.2038',
                    priceChangePercent: '-0.0162',
                    lastPrice: '1000',
                    lastQty: '1000',
                    open: '1016.2038',
                    high: '1016.2038',
                    low: '0',
                    volume: '5',
                    amount: '1',
                    bidPrice: '999.34',
                    askPrice: '1000.23',
                    openTime: 1592317127349,
                    closeTime: 1592380593516,
                    firstTradeId: 1,
                    tradeCount: 5,
                    strikePrice: '9000',
                    exercisePrice: '3000.3356',
                },
            ];

            const spy = jest.spyOn(client, 'ticker24hrPriceChangeStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<Ticker24hrPriceChangeStatisticsResponse>)
            );
            const response = await client.ticker24hrPriceChangeStatistics(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'ticker24hrPriceChangeStatistics')
                .mockRejectedValueOnce(mockError);
            await expect(client.ticker24hrPriceChangeStatistics()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
