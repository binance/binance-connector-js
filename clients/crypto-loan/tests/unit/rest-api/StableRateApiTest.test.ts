/**
 * Binance Crypto Loan REST API
 *
 * OpenAPI Specification for the Binance Crypto Loan REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { StableRateApi } from '../../../src/rest-api';
import {
    CheckCollateralRepayRateStableRateRequest,
    CryptoLoanAdjustLtvRequest,
    CryptoLoanBorrowRequest,
    CryptoLoanCustomizeMarginCallRequest,
    CryptoLoanRepayRequest,
    GetCollateralAssetsDataRequest,
    GetCryptoLoansIncomeHistoryRequest,
    GetLoanBorrowHistoryRequest,
    GetLoanLtvAdjustmentHistoryRequest,
    GetLoanOngoingOrdersRequest,
    GetLoanRepaymentHistoryRequest,
    GetLoanableAssetsDataRequest,
} from '../../../src/rest-api';
import type {
    CheckCollateralRepayRateStableRateResponse,
    CryptoLoanAdjustLtvResponse,
    CryptoLoanBorrowResponse,
    CryptoLoanCustomizeMarginCallResponse,
    CryptoLoanRepayResponse,
    GetCollateralAssetsDataResponse,
    GetCryptoLoansIncomeHistoryResponse,
    GetLoanBorrowHistoryResponse,
    GetLoanLtvAdjustmentHistoryResponse,
    GetLoanOngoingOrdersResponse,
    GetLoanRepaymentHistoryResponse,
    GetLoanableAssetsDataResponse,
} from '../../../src/rest-api/types';

describe('StableRateApi', () => {
    let client: StableRateApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new StableRateApi(config);
    });

    describe('checkCollateralRepayRateStableRate()', () => {
        it('should execute checkCollateralRepayRateStableRate() successfully with required parameters only', async () => {
            const params: CheckCollateralRepayRateStableRateRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                repayAmount: 1,
            };

            mockResponse = {
                loanlCoin: 'BUSD',
                collateralCoin: 'BNB',
                repayAmount: '1000',
                rate: '300.36781234',
            };

            const spy = jest.spyOn(client, 'checkCollateralRepayRateStableRate').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CheckCollateralRepayRateStableRateResponse>)
            );
            const response = await client.checkCollateralRepayRateStableRate(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute checkCollateralRepayRateStableRate() successfully with optional parameters', async () => {
            const params: CheckCollateralRepayRateStableRateRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                repayAmount: 1,
                recvWindow: 5000,
            };

            mockResponse = {
                loanlCoin: 'BUSD',
                collateralCoin: 'BNB',
                repayAmount: '1000',
                rate: '300.36781234',
            };

            const spy = jest.spyOn(client, 'checkCollateralRepayRateStableRate').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CheckCollateralRepayRateStableRateResponse>)
            );
            const response = await client.checkCollateralRepayRateStableRate(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when loanCoin is missing', async () => {
            const _params: CheckCollateralRepayRateStableRateRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                repayAmount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.loanCoin;

            await expect(client.checkCollateralRepayRateStableRate(params)).rejects.toThrow(
                'Required parameter loanCoin was null or undefined when calling checkCollateralRepayRateStableRate.'
            );
        });

        it('should throw RequiredError when collateralCoin is missing', async () => {
            const _params: CheckCollateralRepayRateStableRateRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                repayAmount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.collateralCoin;

            await expect(client.checkCollateralRepayRateStableRate(params)).rejects.toThrow(
                'Required parameter collateralCoin was null or undefined when calling checkCollateralRepayRateStableRate.'
            );
        });

        it('should throw RequiredError when repayAmount is missing', async () => {
            const _params: CheckCollateralRepayRateStableRateRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                repayAmount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.repayAmount;

            await expect(client.checkCollateralRepayRateStableRate(params)).rejects.toThrow(
                'Required parameter repayAmount was null or undefined when calling checkCollateralRepayRateStableRate.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CheckCollateralRepayRateStableRateRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                repayAmount: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'checkCollateralRepayRateStableRate')
                .mockRejectedValueOnce(mockError);
            await expect(client.checkCollateralRepayRateStableRate(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('cryptoLoanAdjustLtv()', () => {
        it('should execute cryptoLoanAdjustLtv() successfully with required parameters only', async () => {
            const params: CryptoLoanAdjustLtvRequest = {
                orderId: 1,
                amount: 1,
                direction: 'direction_example',
            };

            mockResponse = {
                loanCoin: 'BUSD',
                collateralCoin: 'BNB',
                direction: 'ADDITIONAL',
                amount: '5.235',
                currentLTV: '0.52',
            };

            const spy = jest.spyOn(client, 'cryptoLoanAdjustLtv').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CryptoLoanAdjustLtvResponse>)
            );
            const response = await client.cryptoLoanAdjustLtv(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cryptoLoanAdjustLtv() successfully with optional parameters', async () => {
            const params: CryptoLoanAdjustLtvRequest = {
                orderId: 1,
                amount: 1,
                direction: 'direction_example',
                recvWindow: 5000,
            };

            mockResponse = {
                loanCoin: 'BUSD',
                collateralCoin: 'BNB',
                direction: 'ADDITIONAL',
                amount: '5.235',
                currentLTV: '0.52',
            };

            const spy = jest.spyOn(client, 'cryptoLoanAdjustLtv').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CryptoLoanAdjustLtvResponse>)
            );
            const response = await client.cryptoLoanAdjustLtv(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when orderId is missing', async () => {
            const _params: CryptoLoanAdjustLtvRequest = {
                orderId: 1,
                amount: 1,
                direction: 'direction_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.orderId;

            await expect(client.cryptoLoanAdjustLtv(params)).rejects.toThrow(
                'Required parameter orderId was null or undefined when calling cryptoLoanAdjustLtv.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: CryptoLoanAdjustLtvRequest = {
                orderId: 1,
                amount: 1,
                direction: 'direction_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.cryptoLoanAdjustLtv(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling cryptoLoanAdjustLtv.'
            );
        });

        it('should throw RequiredError when direction is missing', async () => {
            const _params: CryptoLoanAdjustLtvRequest = {
                orderId: 1,
                amount: 1,
                direction: 'direction_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.direction;

            await expect(client.cryptoLoanAdjustLtv(params)).rejects.toThrow(
                'Required parameter direction was null or undefined when calling cryptoLoanAdjustLtv.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CryptoLoanAdjustLtvRequest = {
                orderId: 1,
                amount: 1,
                direction: 'direction_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'cryptoLoanAdjustLtv').mockRejectedValueOnce(mockError);
            await expect(client.cryptoLoanAdjustLtv(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cryptoLoanBorrow()', () => {
        it('should execute cryptoLoanBorrow() successfully with required parameters only', async () => {
            const params: CryptoLoanBorrowRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                loanTerm: 789,
            };

            mockResponse = {
                loanCoin: 'BUSD',
                loanAmount: '100.5',
                collateralCoin: 'BNB',
                collateralAmount: '50.5',
                hourlyInterestRate: '0.001234',
                orderId: '100000001',
            };

            const spy = jest.spyOn(client, 'cryptoLoanBorrow').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CryptoLoanBorrowResponse>)
            );
            const response = await client.cryptoLoanBorrow(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cryptoLoanBorrow() successfully with optional parameters', async () => {
            const params: CryptoLoanBorrowRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                loanTerm: 789,
                recvWindow: 5000,
            };

            mockResponse = {
                loanCoin: 'BUSD',
                loanAmount: '100.5',
                collateralCoin: 'BNB',
                collateralAmount: '50.5',
                hourlyInterestRate: '0.001234',
                orderId: '100000001',
            };

            const spy = jest.spyOn(client, 'cryptoLoanBorrow').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CryptoLoanBorrowResponse>)
            );
            const response = await client.cryptoLoanBorrow(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when loanCoin is missing', async () => {
            const _params: CryptoLoanBorrowRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                loanTerm: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.loanCoin;

            await expect(client.cryptoLoanBorrow(params)).rejects.toThrow(
                'Required parameter loanCoin was null or undefined when calling cryptoLoanBorrow.'
            );
        });

        it('should throw RequiredError when collateralCoin is missing', async () => {
            const _params: CryptoLoanBorrowRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                loanTerm: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.collateralCoin;

            await expect(client.cryptoLoanBorrow(params)).rejects.toThrow(
                'Required parameter collateralCoin was null or undefined when calling cryptoLoanBorrow.'
            );
        });

        it('should throw RequiredError when loanTerm is missing', async () => {
            const _params: CryptoLoanBorrowRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                loanTerm: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.loanTerm;

            await expect(client.cryptoLoanBorrow(params)).rejects.toThrow(
                'Required parameter loanTerm was null or undefined when calling cryptoLoanBorrow.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CryptoLoanBorrowRequest = {
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                loanTerm: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'cryptoLoanBorrow').mockRejectedValueOnce(mockError);
            await expect(client.cryptoLoanBorrow(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cryptoLoanCustomizeMarginCall()', () => {
        it('should execute cryptoLoanCustomizeMarginCall() successfully with required parameters only', async () => {
            const params: CryptoLoanCustomizeMarginCallRequest = {
                marginCall: 1,
            };

            mockResponse = {
                rows: [
                    {
                        orderId: '100000001',
                        collateralCoin: 'BNB',
                        preMarginCall: '0.8',
                        afterMarginCall: '0.7',
                        customizeTime: 1575018510000,
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'cryptoLoanCustomizeMarginCall').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CryptoLoanCustomizeMarginCallResponse>)
            );
            const response = await client.cryptoLoanCustomizeMarginCall(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cryptoLoanCustomizeMarginCall() successfully with optional parameters', async () => {
            const params: CryptoLoanCustomizeMarginCallRequest = {
                marginCall: 1,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        orderId: '100000001',
                        collateralCoin: 'BNB',
                        preMarginCall: '0.8',
                        afterMarginCall: '0.7',
                        customizeTime: 1575018510000,
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'cryptoLoanCustomizeMarginCall').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CryptoLoanCustomizeMarginCallResponse>)
            );
            const response = await client.cryptoLoanCustomizeMarginCall(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when marginCall is missing', async () => {
            const _params: CryptoLoanCustomizeMarginCallRequest = {
                marginCall: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.marginCall;

            await expect(client.cryptoLoanCustomizeMarginCall(params)).rejects.toThrow(
                'Required parameter marginCall was null or undefined when calling cryptoLoanCustomizeMarginCall.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CryptoLoanCustomizeMarginCallRequest = {
                marginCall: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'cryptoLoanCustomizeMarginCall')
                .mockRejectedValueOnce(mockError);
            await expect(client.cryptoLoanCustomizeMarginCall(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('cryptoLoanRepay()', () => {
        it('should execute cryptoLoanRepay() successfully with required parameters only', async () => {
            const params: CryptoLoanRepayRequest = {
                orderId: 1,
                amount: 1,
            };

            mockResponse = {
                loanCoin: 'BUSD',
                remainingPrincipal: '100.5',
                remainingInterest: '0',
                collateralCoin: 'BNB',
                remainingCollateral: '5.253',
                currentLTV: '0.25',
                repayStatus: 'Repaid',
            };

            const spy = jest.spyOn(client, 'cryptoLoanRepay').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CryptoLoanRepayResponse>)
            );
            const response = await client.cryptoLoanRepay(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cryptoLoanRepay() successfully with optional parameters', async () => {
            const params: CryptoLoanRepayRequest = {
                orderId: 1,
                amount: 1,
                type: 1,
                collateralReturn: true,
                recvWindow: 5000,
            };

            mockResponse = {
                loanCoin: 'BUSD',
                remainingPrincipal: '100.5',
                remainingInterest: '0',
                collateralCoin: 'BNB',
                remainingCollateral: '5.253',
                currentLTV: '0.25',
                repayStatus: 'Repaid',
            };

            const spy = jest.spyOn(client, 'cryptoLoanRepay').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CryptoLoanRepayResponse>)
            );
            const response = await client.cryptoLoanRepay(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when orderId is missing', async () => {
            const _params: CryptoLoanRepayRequest = {
                orderId: 1,
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.orderId;

            await expect(client.cryptoLoanRepay(params)).rejects.toThrow(
                'Required parameter orderId was null or undefined when calling cryptoLoanRepay.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: CryptoLoanRepayRequest = {
                orderId: 1,
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.cryptoLoanRepay(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling cryptoLoanRepay.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CryptoLoanRepayRequest = {
                orderId: 1,
                amount: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'cryptoLoanRepay').mockRejectedValueOnce(mockError);
            await expect(client.cryptoLoanRepay(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getCollateralAssetsData()', () => {
        it('should execute getCollateralAssetsData() successfully with required parameters only', async () => {
            mockResponse = {
                rows: [
                    {
                        collateralCoin: 'BNB',
                        initialLTV: '0.65',
                        marginCallLTV: '0.75',
                        liquidationLTV: '0.83',
                        maxLimit: '1000000',
                        vipLevel: 1,
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getCollateralAssetsData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCollateralAssetsDataResponse>)
            );
            const response = await client.getCollateralAssetsData();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getCollateralAssetsData() successfully with optional parameters', async () => {
            const params: GetCollateralAssetsDataRequest = {
                collateralCoin: 'collateralCoin_example',
                vipLevel: 1,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        collateralCoin: 'BNB',
                        initialLTV: '0.65',
                        marginCallLTV: '0.75',
                        liquidationLTV: '0.83',
                        maxLimit: '1000000',
                        vipLevel: 1,
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getCollateralAssetsData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCollateralAssetsDataResponse>)
            );
            const response = await client.getCollateralAssetsData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getCollateralAssetsData')
                .mockRejectedValueOnce(mockError);
            await expect(client.getCollateralAssetsData()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getCryptoLoansIncomeHistory()', () => {
        it('should execute getCryptoLoansIncomeHistory() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    asset: 'BUSD',
                    type: 'borrowIn',
                    amount: '100',
                    timestamp: 1633771139847,
                    tranId: '80423589583',
                },
                {
                    asset: 'BUSD',
                    type: 'borrowIn',
                    amount: '100',
                    timestamp: 1634638371496,
                    tranId: '81685123491',
                },
            ];

            const spy = jest.spyOn(client, 'getCryptoLoansIncomeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCryptoLoansIncomeHistoryResponse>)
            );
            const response = await client.getCryptoLoansIncomeHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getCryptoLoansIncomeHistory() successfully with optional parameters', async () => {
            const params: GetCryptoLoansIncomeHistoryRequest = {
                asset: 'asset_example',
                type: '0',
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 10,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    asset: 'BUSD',
                    type: 'borrowIn',
                    amount: '100',
                    timestamp: 1633771139847,
                    tranId: '80423589583',
                },
                {
                    asset: 'BUSD',
                    type: 'borrowIn',
                    amount: '100',
                    timestamp: 1634638371496,
                    tranId: '81685123491',
                },
            ];

            const spy = jest.spyOn(client, 'getCryptoLoansIncomeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCryptoLoansIncomeHistoryResponse>)
            );
            const response = await client.getCryptoLoansIncomeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getCryptoLoansIncomeHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getCryptoLoansIncomeHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getLoanBorrowHistory()', () => {
        it('should execute getLoanBorrowHistory() successfully with required parameters only', async () => {
            mockResponse = {
                rows: [
                    {
                        orderId: 100000001,
                        loanCoin: 'BUSD',
                        initialLoanAmount: '10000',
                        hourlyInterestRate: '0.000057',
                        loanTerm: '7',
                        collateralCoin: 'BNB',
                        initialCollateralAmount: '49.27565492',
                        borrowTime: 1575018510000,
                        status: 'Repaid',
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getLoanBorrowHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLoanBorrowHistoryResponse>)
            );
            const response = await client.getLoanBorrowHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getLoanBorrowHistory() successfully with optional parameters', async () => {
            const params: GetLoanBorrowHistoryRequest = {
                orderId: 1,
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                limit: 10,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        orderId: 100000001,
                        loanCoin: 'BUSD',
                        initialLoanAmount: '10000',
                        hourlyInterestRate: '0.000057',
                        loanTerm: '7',
                        collateralCoin: 'BNB',
                        initialCollateralAmount: '49.27565492',
                        borrowTime: 1575018510000,
                        status: 'Repaid',
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getLoanBorrowHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLoanBorrowHistoryResponse>)
            );
            const response = await client.getLoanBorrowHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getLoanBorrowHistory').mockRejectedValueOnce(mockError);
            await expect(client.getLoanBorrowHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getLoanLtvAdjustmentHistory()', () => {
        it('should execute getLoanLtvAdjustmentHistory() successfully with required parameters only', async () => {
            mockResponse = {
                rows: [
                    {
                        loanCoin: 'BUSD',
                        collateralCoin: 'BNB',
                        direction: 'ADDITIONAL',
                        amount: '5.235',
                        preLTV: '0.78',
                        afterLTV: '0.56',
                        adjustTime: 1575018510000,
                        orderId: 756783308056935400,
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getLoanLtvAdjustmentHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLoanLtvAdjustmentHistoryResponse>)
            );
            const response = await client.getLoanLtvAdjustmentHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getLoanLtvAdjustmentHistory() successfully with optional parameters', async () => {
            const params: GetLoanLtvAdjustmentHistoryRequest = {
                orderId: 1,
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                limit: 10,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        loanCoin: 'BUSD',
                        collateralCoin: 'BNB',
                        direction: 'ADDITIONAL',
                        amount: '5.235',
                        preLTV: '0.78',
                        afterLTV: '0.56',
                        adjustTime: 1575018510000,
                        orderId: 756783308056935400,
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getLoanLtvAdjustmentHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLoanLtvAdjustmentHistoryResponse>)
            );
            const response = await client.getLoanLtvAdjustmentHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getLoanLtvAdjustmentHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getLoanLtvAdjustmentHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getLoanOngoingOrders()', () => {
        it('should execute getLoanOngoingOrders() successfully with required parameters only', async () => {
            mockResponse = {
                rows: [
                    {
                        orderId: 100000001,
                        loanCoin: 'BUSD',
                        totalDebt: '10000',
                        residualInterest: '10.27687923',
                        collateralCoin: 'BNB',
                        collateralAmount: '49.27565492',
                        currentLTV: '0.57',
                        expirationTime: 1575018510000,
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getLoanOngoingOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLoanOngoingOrdersResponse>)
            );
            const response = await client.getLoanOngoingOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getLoanOngoingOrders() successfully with optional parameters', async () => {
            const params: GetLoanOngoingOrdersRequest = {
                orderId: 1,
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                current: 1,
                limit: 10,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        orderId: 100000001,
                        loanCoin: 'BUSD',
                        totalDebt: '10000',
                        residualInterest: '10.27687923',
                        collateralCoin: 'BNB',
                        collateralAmount: '49.27565492',
                        currentLTV: '0.57',
                        expirationTime: 1575018510000,
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getLoanOngoingOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLoanOngoingOrdersResponse>)
            );
            const response = await client.getLoanOngoingOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getLoanOngoingOrders').mockRejectedValueOnce(mockError);
            await expect(client.getLoanOngoingOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getLoanRepaymentHistory()', () => {
        it('should execute getLoanRepaymentHistory() successfully with required parameters only', async () => {
            mockResponse = {
                rows: [
                    {
                        loanCoin: 'BUSD',
                        repayAmount: '10000',
                        collateralCoin: 'BNB',
                        collateralUsed: '0',
                        collateralReturn: '49.27565492',
                        repayType: '1',
                        repayStatus: 'Repaid',
                        repayTime: 1575018510000,
                        orderId: 756783308056935400,
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getLoanRepaymentHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLoanRepaymentHistoryResponse>)
            );
            const response = await client.getLoanRepaymentHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getLoanRepaymentHistory() successfully with optional parameters', async () => {
            const params: GetLoanRepaymentHistoryRequest = {
                orderId: 1,
                loanCoin: 'loanCoin_example',
                collateralCoin: 'collateralCoin_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                limit: 10,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        loanCoin: 'BUSD',
                        repayAmount: '10000',
                        collateralCoin: 'BNB',
                        collateralUsed: '0',
                        collateralReturn: '49.27565492',
                        repayType: '1',
                        repayStatus: 'Repaid',
                        repayTime: 1575018510000,
                        orderId: 756783308056935400,
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getLoanRepaymentHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLoanRepaymentHistoryResponse>)
            );
            const response = await client.getLoanRepaymentHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getLoanRepaymentHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getLoanRepaymentHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getLoanableAssetsData()', () => {
        it('should execute getLoanableAssetsData() successfully with required parameters only', async () => {
            mockResponse = {
                rows: [
                    {
                        loanCoin: 'BUSD',
                        _7dHourlyInterestRate: '0.00000491',
                        _7dDailyInterestRate: '0.000118',
                        _14dHourlyInterestRate: '0.00000491',
                        _14dDailyInterestRate: '0.000118',
                        _30dHourlyInterestRate: '0.00000567',
                        _30dDailyInterestRate: '0.000136',
                        _90dHourlyInterestRate: '0.00000596',
                        _90dDailyInterestRate: '0.000143',
                        _180dHourlyInterestRate: '0.00000631',
                        _180dDailyInterestRate: '0.000151',
                        minLimit: '100',
                        maxLimit: '1000000',
                        vipLevel: 1,
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getLoanableAssetsData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLoanableAssetsDataResponse>)
            );
            const response = await client.getLoanableAssetsData();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getLoanableAssetsData() successfully with optional parameters', async () => {
            const params: GetLoanableAssetsDataRequest = {
                loanCoin: 'loanCoin_example',
                vipLevel: 1,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        loanCoin: 'BUSD',
                        _7dHourlyInterestRate: '0.00000491',
                        _7dDailyInterestRate: '0.000118',
                        _14dHourlyInterestRate: '0.00000491',
                        _14dDailyInterestRate: '0.000118',
                        _30dHourlyInterestRate: '0.00000567',
                        _30dDailyInterestRate: '0.000136',
                        _90dHourlyInterestRate: '0.00000596',
                        _90dDailyInterestRate: '0.000143',
                        _180dHourlyInterestRate: '0.00000631',
                        _180dDailyInterestRate: '0.000151',
                        minLimit: '100',
                        maxLimit: '1000000',
                        vipLevel: 1,
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getLoanableAssetsData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLoanableAssetsDataResponse>)
            );
            const response = await client.getLoanableAssetsData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getLoanableAssetsData')
                .mockRejectedValueOnce(mockError);
            await expect(client.getLoanableAssetsData()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
