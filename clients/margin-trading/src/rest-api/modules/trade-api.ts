/**
 * Binance Margin Trading REST API
 *
 * OpenAPI Specification for the Binance Margin Trading REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
    ConfigurationRestAPI,
    TimeUnit,
    RestApiResponse,
    assertParamExists,
    sendRequest,
    type RequestArgs,
} from '@binance/common';
import type {
    CreateSpecialKeyResponse,
    GetForceLiquidationRecordResponse,
    GetSmallLiabilityExchangeCoinListResponse,
    GetSmallLiabilityExchangeHistoryResponse,
    MarginAccountCancelAllOpenOrdersOnASymbolResponse,
    MarginAccountCancelOcoResponse,
    MarginAccountCancelOrderResponse,
    MarginAccountNewOcoResponse,
    MarginAccountNewOrderResponse,
    MarginAccountNewOtoResponse,
    MarginAccountNewOtocoResponse,
    MarginManualLiquidationResponse,
    QueryCurrentMarginOrderCountUsageResponse,
    QueryMarginAccountsAllOcoResponse,
    QueryMarginAccountsAllOrdersResponse,
    QueryMarginAccountsOcoResponse,
    QueryMarginAccountsOpenOcoResponse,
    QueryMarginAccountsOpenOrdersResponse,
    QueryMarginAccountsOrderResponse,
    QueryMarginAccountsTradeListResponse,
    QuerySpecialKeyListResponse,
    QuerySpecialKeyResponse,
} from '../types';

/**
 * TradeApi - axios parameter creator
 */
const TradeApiAxiosParamCreator = function (configuration: ConfigurationRestAPI) {
    return {
        /**
         * **Binance Margin offers low-latency trading through a [special key](https://www.binance.com/en/support/faq/frequently-asked-questions-on-margin-special-api-key-3208663e900d4d2e9fec4140e1832f4e), available exclusively to users with VIP level 4 or higher. **
         *
         **If you are VIP level 3 or below, please contact your VIP manager for eligibility criterias.**
         *
         * We support several types of API keys:
         *
         * Ed25519 (recommended)
         * HMAC
         * RSA
         *
         * We recommend to **use Ed25519 API keys** as it should provide the best performance and security out of all supported key types. We accept PKCS#8 (BEGIN PUBLIC KEY). For how to generate an RSA key pair to send API requests on Binance. Please refer to the document below [FAQ](https://www.binance.com/en/support/faq/how-to-generate-an-rsa-key-pair-to-send-api-requests-on-binance-2b79728f331e43079b27440d9d15c5db) .
         *
         * Read [REST API](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md#signed-trade-and-user_data-endpoint-security) or [WebSocket API](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-api.md#request-security) documentation to learn how to use different API keys
         *
         * You need to enable Permits “Enable Spot & Margin Trading” option for the API Key which requests this endpoint.
         *
         * Weight: 1(UID)
         *
         * @summary Create Special Key(Low-Latency Trading)(TRADE)
         * @param {string} apiName
         * @param {string} [symbol] isolated margin pair
         * @param {string} [ip] Can be added in batches, separated by commas. Max 30 for an API key
         * @param {string} [publicKey] 1. If publicKey is inputted it will create an RSA or Ed25519 key. <br />2. Need to be encoded to URL-encoded format
         * @param {string} [permissionMode] This parameter is only for the Ed25519 API key, and does not effact for other encryption methods. The value can be TRADE (TRADE for all permissions) or READ (READ for USER_DATA, FIX_API_READ_ONLY). The default value is TRADE.
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        createSpecialKey: async (
            apiName: string,
            symbol?: string,
            ip?: string,
            publicKey?: string,
            permissionMode?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'apiName' is not null or undefined
            assertParamExists('createSpecialKey', 'apiName', apiName);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (apiName !== undefined && apiName !== null) {
                localVarQueryParameter['apiName'] = apiName;
            }

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (ip !== undefined && ip !== null) {
                localVarQueryParameter['ip'] = ip;
            }

            if (publicKey !== undefined && publicKey !== null) {
                localVarQueryParameter['publicKey'] = publicKey;
            }

            if (permissionMode !== undefined && permissionMode !== null) {
                localVarQueryParameter['permissionMode'] = permissionMode;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/apiKey',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * This only applies to Special Key for Low Latency Trading.
         *
         * If apiKey is given, apiName will be ignored. If apiName is given with no apiKey, all apikeys with given apiName will be deleted.
         *
         * You need to enable Permits “Enable Spot & Margin Trading” option for the API Key which requests this endpoint.
         *
         * Weight: 1(UID)
         *
         * @summary Delete Special Key(Low-Latency Trading)(TRADE)
         * @param {string} [apiName]
         * @param {string} [symbol] isolated margin pair
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        deleteSpecialKey: async (
            apiName?: string,
            symbol?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (apiName !== undefined && apiName !== null) {
                localVarQueryParameter['apiName'] = apiName;
            }

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/apiKey',
                method: 'DELETE',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Edit ip restriction. This only applies to Special Key for Low Latency Trading.
         *
         * You need to enable Permits “Enable Spot & Margin Trading” option for the API Key which requests this endpoint.
         *
         * Weight: 1(UID)
         *
         * @summary Edit ip for Special Key(Low-Latency Trading)(TRADE)
         * @param {string} ip Can be added in batches, separated by commas. Max 30 for an API key
         * @param {string} [symbol] isolated margin pair
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        editIpForSpecialKey: async (
            ip: string,
            symbol?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'ip' is not null or undefined
            assertParamExists('editIpForSpecialKey', 'ip', ip);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (ip !== undefined && ip !== null) {
                localVarQueryParameter['ip'] = ip;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/apiKey/ip',
                method: 'PUT',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get Force Liquidation Record
         *
         * Response in descending order
         *
         * Weight: 1(IP)
         *
         * @summary Get Force Liquidation Record (USER_DATA)
         * @param {number} [startTime] 只支持查询最近90天的数据
         * @param {number} [endTime]
         * @param {string} [isolatedSymbol] isolated symbol
         * @param {number} [current] Currently querying page. Start from 1. Default:1
         * @param {number} [size] Default:10 Max:100
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        getForceLiquidationRecord: async (
            startTime?: number,
            endTime?: number,
            isolatedSymbol?: string,
            current?: number,
            size?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (isolatedSymbol !== undefined && isolatedSymbol !== null) {
                localVarQueryParameter['isolatedSymbol'] = isolatedSymbol;
            }

            if (current !== undefined && current !== null) {
                localVarQueryParameter['current'] = current;
            }

            if (size !== undefined && size !== null) {
                localVarQueryParameter['size'] = size;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/forceLiquidationRec',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query the coins which can be small liability exchange
         *
         * Weight: 100
         *
         * @summary Get Small Liability Exchange Coin List (USER_DATA)
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        getSmallLiabilityExchangeCoinList: async (recvWindow?: number): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/exchange-small-liability',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get Small liability Exchange History
         *
         * Weight: 100(UID)
         *
         * @summary Get Small Liability Exchange History (USER_DATA)
         * @param {number} current Currently querying page. Start from 1. Default:1
         * @param {number} size Default:10, Max:100
         * @param {number} [startTime] 只支持查询最近90天的数据
         * @param {number} [endTime]
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        getSmallLiabilityExchangeHistory: async (
            current: number,
            size: number,
            startTime?: number,
            endTime?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'current' is not null or undefined
            assertParamExists('getSmallLiabilityExchangeHistory', 'current', current);
            // verify required parameter 'size' is not null or undefined
            assertParamExists('getSmallLiabilityExchangeHistory', 'size', size);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (current !== undefined && current !== null) {
                localVarQueryParameter['current'] = current;
            }

            if (size !== undefined && size !== null) {
                localVarQueryParameter['size'] = size;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/exchange-small-liability-history',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancels all active orders on a symbol for margin account.<br></br>
         * This includes OCO orders.
         *
         * Weight: 1
         *
         * @summary Margin Account Cancel all Open Orders on a Symbol (TRADE)
         * @param {string} symbol
         * @param {string} [isIsolated] for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        marginAccountCancelAllOpenOrdersOnASymbol: async (
            symbol: string,
            isIsolated?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('marginAccountCancelAllOpenOrdersOnASymbol', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (isIsolated !== undefined && isIsolated !== null) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/openOrders',
                method: 'DELETE',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel an entire Order List for a margin account.
         *
         * Canceling an individual leg will cancel the entire OCO
         *
         * Weight: 1(UID)
         *
         * @summary Margin Account Cancel OCO (TRADE)
         * @param {string} symbol
         * @param {string} [isIsolated] for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
         * @param {number} [orderListId] Either `orderListId` or `listClientOrderId` must be provided
         * @param {string} [listClientOrderId] Either `orderListId` or `listClientOrderId` must be provided
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        marginAccountCancelOco: async (
            symbol: string,
            isIsolated?: string,
            orderListId?: number,
            listClientOrderId?: string,
            newClientOrderId?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('marginAccountCancelOco', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (isIsolated !== undefined && isIsolated !== null) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (orderListId !== undefined && orderListId !== null) {
                localVarQueryParameter['orderListId'] = orderListId;
            }

            if (listClientOrderId !== undefined && listClientOrderId !== null) {
                localVarQueryParameter['listClientOrderId'] = listClientOrderId;
            }

            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/orderList',
                method: 'DELETE',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel an active order for margin account.
         *
         * Either orderId or origClientOrderId must be sent.
         *
         * Weight: 10(IP)
         *
         * @summary Margin Account Cancel Order (TRADE)
         * @param {string} symbol
         * @param {string} [isIsolated] for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
         * @param {number} [orderId]
         * @param {string} [origClientOrderId]
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        marginAccountCancelOrder: async (
            symbol: string,
            isIsolated?: string,
            orderId?: number,
            origClientOrderId?: string,
            newClientOrderId?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('marginAccountCancelOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (isIsolated !== undefined && isIsolated !== null) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/order',
                method: 'DELETE',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Send in a new OCO for a margin account
         *
         * autoRepayAtCancel is suggested to set as “FALSE” to keep liability unrepaid under high frequent new order/cancel order execution
         *
         * Weight: 6(UID)
         *
         * @summary Margin Account New OCO (TRADE)
         * @param {string} symbol
         * @param {MarginAccountNewOcoSideEnum} side
         * @param {number} quantity
         * @param {number} price
         * @param {number} stopPrice
         * @param {string} [isIsolated] for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
         * @param {string} [listClientOrderId] Either `orderListId` or `listClientOrderId` must be provided
         * @param {string} [limitClientOrderId] A unique Id for the limit order
         * @param {number} [limitIcebergQty]
         * @param {string} [stopClientOrderId] A unique Id for the stop loss/stop loss limit leg
         * @param {number} [stopLimitPrice] If provided, `stopLimitTimeInForce` is required.
         * @param {number} [stopIcebergQty]
         * @param {string} [stopLimitTimeInForce] Valid values are `GTC`/`FOK`/`IOC`
         * @param {MarginAccountNewOcoNewOrderRespTypeEnum} [newOrderRespType] Set the response JSON. ACK, RESULT, or FULL; MARKET and LIMIT order types default to FULL, all other orders default to ACK.
         * @param {string} [sideEffectType] NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY,AUTO_BORROW_REPAY; default NO_SIDE_EFFECT. More info in [FAQ](https://www.binance.com/en/support/faq/how-to-use-the-sideeffecttype-parameter-with-the-margin-order-endpoints-f9fc51cda1984bf08b95e0d96c4570bc)
         * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE
         * @param {boolean} [autoRepayAtCancel] Only when MARGIN_BUY or AUTO_BORROW_REPAY order takes effect, true means that the debt generated by the order needs to be repay after the order is cancelled. The default is true
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        marginAccountNewOco: async (
            symbol: string,
            side: MarginAccountNewOcoSideEnum,
            quantity: number,
            price: number,
            stopPrice: number,
            isIsolated?: string,
            listClientOrderId?: string,
            limitClientOrderId?: string,
            limitIcebergQty?: number,
            stopClientOrderId?: string,
            stopLimitPrice?: number,
            stopIcebergQty?: number,
            stopLimitTimeInForce?: string,
            newOrderRespType?: MarginAccountNewOcoNewOrderRespTypeEnum,
            sideEffectType?: string,
            selfTradePreventionMode?: string,
            autoRepayAtCancel?: boolean,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('marginAccountNewOco', 'symbol', symbol);
            // verify required parameter 'side' is not null or undefined
            assertParamExists('marginAccountNewOco', 'side', side);
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('marginAccountNewOco', 'quantity', quantity);
            // verify required parameter 'price' is not null or undefined
            assertParamExists('marginAccountNewOco', 'price', price);
            // verify required parameter 'stopPrice' is not null or undefined
            assertParamExists('marginAccountNewOco', 'stopPrice', stopPrice);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (isIsolated !== undefined && isIsolated !== null) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (listClientOrderId !== undefined && listClientOrderId !== null) {
                localVarQueryParameter['listClientOrderId'] = listClientOrderId;
            }

            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }

            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (limitClientOrderId !== undefined && limitClientOrderId !== null) {
                localVarQueryParameter['limitClientOrderId'] = limitClientOrderId;
            }

            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }

            if (limitIcebergQty !== undefined && limitIcebergQty !== null) {
                localVarQueryParameter['limitIcebergQty'] = limitIcebergQty;
            }

            if (stopClientOrderId !== undefined && stopClientOrderId !== null) {
                localVarQueryParameter['stopClientOrderId'] = stopClientOrderId;
            }

            if (stopPrice !== undefined && stopPrice !== null) {
                localVarQueryParameter['stopPrice'] = stopPrice;
            }

            if (stopLimitPrice !== undefined && stopLimitPrice !== null) {
                localVarQueryParameter['stopLimitPrice'] = stopLimitPrice;
            }

            if (stopIcebergQty !== undefined && stopIcebergQty !== null) {
                localVarQueryParameter['stopIcebergQty'] = stopIcebergQty;
            }

            if (stopLimitTimeInForce !== undefined && stopLimitTimeInForce !== null) {
                localVarQueryParameter['stopLimitTimeInForce'] = stopLimitTimeInForce;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (sideEffectType !== undefined && sideEffectType !== null) {
                localVarQueryParameter['sideEffectType'] = sideEffectType;
            }

            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }

            if (autoRepayAtCancel !== undefined && autoRepayAtCancel !== null) {
                localVarQueryParameter['autoRepayAtCancel'] = autoRepayAtCancel;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/order/oco',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Post a new order for margin account.
         *
         * autoRepayAtCancel is suggested to set as “FALSE” to keep liability unrepaid under high frequent new order/cancel order execution
         *
         * Weight: 6(UID)
         *
         * @summary Margin Account New Order (TRADE)
         * @param {string} symbol
         * @param {MarginAccountNewOrderSideEnum} side
         * @param {string} type `MARGIN`,`ISOLATED`
         * @param {string} [isIsolated] for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
         * @param {number} [quantity]
         * @param {number} [quoteOrderQty]
         * @param {number} [price]
         * @param {number} [stopPrice] Used with `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, and `TAKE_PROFIT_LIMIT` orders.
         * @param {string} [newClientOrderId] Used to uniquely identify this cancel. Automatically generated by default
         * @param {number} [icebergQty] Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order.
         * @param {MarginAccountNewOrderNewOrderRespTypeEnum} [newOrderRespType] Set the response JSON. ACK, RESULT, or FULL; MARKET and LIMIT order types default to FULL, all other orders default to ACK.
         * @param {string} [sideEffectType] NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY,AUTO_BORROW_REPAY; default NO_SIDE_EFFECT. More info in [FAQ](https://www.binance.com/en/support/faq/how-to-use-the-sideeffecttype-parameter-with-the-margin-order-endpoints-f9fc51cda1984bf08b95e0d96c4570bc)
         * @param {MarginAccountNewOrderTimeInForceEnum} [timeInForce] GTC,IOC,FOK
         * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE
         * @param {boolean} [autoRepayAtCancel] Only when MARGIN_BUY or AUTO_BORROW_REPAY order takes effect, true means that the debt generated by the order needs to be repay after the order is cancelled. The default is true
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        marginAccountNewOrder: async (
            symbol: string,
            side: MarginAccountNewOrderSideEnum,
            type: string,
            isIsolated?: string,
            quantity?: number,
            quoteOrderQty?: number,
            price?: number,
            stopPrice?: number,
            newClientOrderId?: string,
            icebergQty?: number,
            newOrderRespType?: MarginAccountNewOrderNewOrderRespTypeEnum,
            sideEffectType?: string,
            timeInForce?: MarginAccountNewOrderTimeInForceEnum,
            selfTradePreventionMode?: string,
            autoRepayAtCancel?: boolean,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('marginAccountNewOrder', 'symbol', symbol);
            // verify required parameter 'side' is not null or undefined
            assertParamExists('marginAccountNewOrder', 'side', side);
            // verify required parameter 'type' is not null or undefined
            assertParamExists('marginAccountNewOrder', 'type', type);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (isIsolated !== undefined && isIsolated !== null) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }

            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }

            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (quoteOrderQty !== undefined && quoteOrderQty !== null) {
                localVarQueryParameter['quoteOrderQty'] = quoteOrderQty;
            }

            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }

            if (stopPrice !== undefined && stopPrice !== null) {
                localVarQueryParameter['stopPrice'] = stopPrice;
            }

            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (icebergQty !== undefined && icebergQty !== null) {
                localVarQueryParameter['icebergQty'] = icebergQty;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (sideEffectType !== undefined && sideEffectType !== null) {
                localVarQueryParameter['sideEffectType'] = sideEffectType;
            }

            if (timeInForce !== undefined && timeInForce !== null) {
                localVarQueryParameter['timeInForce'] = timeInForce;
            }

            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }

            if (autoRepayAtCancel !== undefined && autoRepayAtCancel !== null) {
                localVarQueryParameter['autoRepayAtCancel'] = autoRepayAtCancel;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/order',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Post a new OTO order for margin account:
         *
         * - An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders.
         * - The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
         * - The second order is called the **pending order**. It can be any order type except for `MARKET` orders using parameter `quoteOrderQty`. The pending order is only placed on the order book when the working order gets **fully filled**.
         * - If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired.
         * - When the order list is placed, if the working order gets **immediately fully filled**, the placement response will show the working order as `FILLED` but the pending order will still appear as `PENDING_NEW`. You need to query the status of the pending order again to see its updated status.
         * - OTOs add **2 orders** to the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
         *
         * autoRepayAtCancel is suggested to set as “FALSE” to keep liability unrepaid under high frequent new order/cancel order execution
         * Depending on the `pendingType` or `workingType`, some optional parameters will become mandatory:
         *
         * Weight: 6(UID)
         *
         * @summary Margin Account New OTO (TRADE)
         * @param {string} symbol
         * @param {string} workingType Supported values: `LIMIT`, `LIMIT_MAKER`
         * @param {string} workingSide BUY, SELL
         * @param {number} workingPrice
         * @param {number} workingQuantity
         * @param {number} workingIcebergQty This can only be used if `workingTimeInForce` is `GTC`.
         * @param {string} pendingType Supported values: [Order Types](https://developers.binance.com/docs/binance-spot-api-docs/enums#order-types-ordertypes-type) Note that `MARKET` orders using `quoteOrderQty` are not supported.
         * @param {string} pendingSide BUY, SELL
         * @param {number} pendingQuantity
         * @param {string} [isIsolated] for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
         * @param {string} [listClientOrderId] Either `orderListId` or `listClientOrderId` must be provided
         * @param {MarginAccountNewOtoNewOrderRespTypeEnum} [newOrderRespType] Set the response JSON. ACK, RESULT, or FULL; MARKET and LIMIT order types default to FULL, all other orders default to ACK.
         * @param {string} [sideEffectType] NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY,AUTO_BORROW_REPAY; default NO_SIDE_EFFECT. More info in [FAQ](https://www.binance.com/en/support/faq/how-to-use-the-sideeffecttype-parameter-with-the-margin-order-endpoints-f9fc51cda1984bf08b95e0d96c4570bc)
         * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE
         * @param {boolean} [autoRepayAtCancel] Only when MARGIN_BUY or AUTO_BORROW_REPAY order takes effect, true means that the debt generated by the order needs to be repay after the order is cancelled. The default is true
         * @param {string} [workingClientOrderId] Arbitrary unique ID among open orders for the working order. Automatically generated if not sent.
         * @param {string} [workingTimeInForce] GTC,IOC,FOK
         * @param {string} [pendingClientOrderId] Arbitrary unique ID among open orders for the pending order. Automatically generated if not sent.
         * @param {number} [pendingPrice]
         * @param {number} [pendingStopPrice]
         * @param {number} [pendingTrailingDelta]
         * @param {number} [pendingIcebergQty] This can only be used if `pendingTimeInForce` is `GTC`.
         * @param {string} [pendingTimeInForce] GTC,IOC,FOK
         *
         * @throws {RequiredError}
         */
        marginAccountNewOto: async (
            symbol: string,
            workingType: string,
            workingSide: string,
            workingPrice: number,
            workingQuantity: number,
            workingIcebergQty: number,
            pendingType: string,
            pendingSide: string,
            pendingQuantity: number,
            isIsolated?: string,
            listClientOrderId?: string,
            newOrderRespType?: MarginAccountNewOtoNewOrderRespTypeEnum,
            sideEffectType?: string,
            selfTradePreventionMode?: string,
            autoRepayAtCancel?: boolean,
            workingClientOrderId?: string,
            workingTimeInForce?: string,
            pendingClientOrderId?: string,
            pendingPrice?: number,
            pendingStopPrice?: number,
            pendingTrailingDelta?: number,
            pendingIcebergQty?: number,
            pendingTimeInForce?: string
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('marginAccountNewOto', 'symbol', symbol);
            // verify required parameter 'workingType' is not null or undefined
            assertParamExists('marginAccountNewOto', 'workingType', workingType);
            // verify required parameter 'workingSide' is not null or undefined
            assertParamExists('marginAccountNewOto', 'workingSide', workingSide);
            // verify required parameter 'workingPrice' is not null or undefined
            assertParamExists('marginAccountNewOto', 'workingPrice', workingPrice);
            // verify required parameter 'workingQuantity' is not null or undefined
            assertParamExists('marginAccountNewOto', 'workingQuantity', workingQuantity);
            // verify required parameter 'workingIcebergQty' is not null or undefined
            assertParamExists('marginAccountNewOto', 'workingIcebergQty', workingIcebergQty);
            // verify required parameter 'pendingType' is not null or undefined
            assertParamExists('marginAccountNewOto', 'pendingType', pendingType);
            // verify required parameter 'pendingSide' is not null or undefined
            assertParamExists('marginAccountNewOto', 'pendingSide', pendingSide);
            // verify required parameter 'pendingQuantity' is not null or undefined
            assertParamExists('marginAccountNewOto', 'pendingQuantity', pendingQuantity);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (isIsolated !== undefined && isIsolated !== null) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (listClientOrderId !== undefined && listClientOrderId !== null) {
                localVarQueryParameter['listClientOrderId'] = listClientOrderId;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (sideEffectType !== undefined && sideEffectType !== null) {
                localVarQueryParameter['sideEffectType'] = sideEffectType;
            }

            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }

            if (autoRepayAtCancel !== undefined && autoRepayAtCancel !== null) {
                localVarQueryParameter['autoRepayAtCancel'] = autoRepayAtCancel;
            }

            if (workingType !== undefined && workingType !== null) {
                localVarQueryParameter['workingType'] = workingType;
            }

            if (workingSide !== undefined && workingSide !== null) {
                localVarQueryParameter['workingSide'] = workingSide;
            }

            if (workingClientOrderId !== undefined && workingClientOrderId !== null) {
                localVarQueryParameter['workingClientOrderId'] = workingClientOrderId;
            }

            if (workingPrice !== undefined && workingPrice !== null) {
                localVarQueryParameter['workingPrice'] = workingPrice;
            }

            if (workingQuantity !== undefined && workingQuantity !== null) {
                localVarQueryParameter['workingQuantity'] = workingQuantity;
            }

            if (workingIcebergQty !== undefined && workingIcebergQty !== null) {
                localVarQueryParameter['workingIcebergQty'] = workingIcebergQty;
            }

            if (workingTimeInForce !== undefined && workingTimeInForce !== null) {
                localVarQueryParameter['workingTimeInForce'] = workingTimeInForce;
            }

            if (pendingType !== undefined && pendingType !== null) {
                localVarQueryParameter['pendingType'] = pendingType;
            }

            if (pendingSide !== undefined && pendingSide !== null) {
                localVarQueryParameter['pendingSide'] = pendingSide;
            }

            if (pendingClientOrderId !== undefined && pendingClientOrderId !== null) {
                localVarQueryParameter['pendingClientOrderId'] = pendingClientOrderId;
            }

            if (pendingPrice !== undefined && pendingPrice !== null) {
                localVarQueryParameter['pendingPrice'] = pendingPrice;
            }

            if (pendingStopPrice !== undefined && pendingStopPrice !== null) {
                localVarQueryParameter['pendingStopPrice'] = pendingStopPrice;
            }

            if (pendingTrailingDelta !== undefined && pendingTrailingDelta !== null) {
                localVarQueryParameter['pendingTrailingDelta'] = pendingTrailingDelta;
            }

            if (pendingQuantity !== undefined && pendingQuantity !== null) {
                localVarQueryParameter['pendingQuantity'] = pendingQuantity;
            }

            if (pendingIcebergQty !== undefined && pendingIcebergQty !== null) {
                localVarQueryParameter['pendingIcebergQty'] = pendingIcebergQty;
            }

            if (pendingTimeInForce !== undefined && pendingTimeInForce !== null) {
                localVarQueryParameter['pendingTimeInForce'] = pendingTimeInForce;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/order/oto',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Post a new OTOCO order for margin account：
         *
         * - An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders.
         * - The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
         * - The behavior of the working order is the same as the OTO.
         * - OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets **fully filled**.
         * - The rules of the pending above and pending below follow the same rules as the [Order List OCO](https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-OCO).
         * - OTOCOs add **3 orders** against the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter, and `MAX_NUM_ORDERS` filter.
         *
         * autoRepayAtCancel is suggested to set as “FALSE” to keep liability unrepaid under high frequent new order/cancel order execution
         * Depending on the `pendingAboveType`/`pendingBelowType` or `workingType`, some optional parameters will become mandatory:
         *
         * Weight: 6(UID)
         *
         * @summary Margin Account New OTOCO (TRADE)
         * @param {string} symbol
         * @param {string} workingType Supported values: `LIMIT`, `LIMIT_MAKER`
         * @param {string} workingSide BUY, SELL
         * @param {number} workingPrice
         * @param {number} workingQuantity
         * @param {string} pendingSide BUY, SELL
         * @param {number} pendingQuantity
         * @param {string} pendingAboveType Supported values: `LIMIT_MAKER`, `STOP_LOSS`, and `STOP_LOSS_LIMIT`
         * @param {string} [isIsolated] for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
         * @param {string} [sideEffectType] NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY,AUTO_BORROW_REPAY; default NO_SIDE_EFFECT. More info in [FAQ](https://www.binance.com/en/support/faq/how-to-use-the-sideeffecttype-parameter-with-the-margin-order-endpoints-f9fc51cda1984bf08b95e0d96c4570bc)
         * @param {boolean} [autoRepayAtCancel] Only when MARGIN_BUY or AUTO_BORROW_REPAY order takes effect, true means that the debt generated by the order needs to be repay after the order is cancelled. The default is true
         * @param {string} [listClientOrderId] Either `orderListId` or `listClientOrderId` must be provided
         * @param {MarginAccountNewOtocoNewOrderRespTypeEnum} [newOrderRespType] Set the response JSON. ACK, RESULT, or FULL; MARKET and LIMIT order types default to FULL, all other orders default to ACK.
         * @param {string} [selfTradePreventionMode] The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE
         * @param {string} [workingClientOrderId] Arbitrary unique ID among open orders for the working order. Automatically generated if not sent.
         * @param {number} [workingIcebergQty] This can only be used if `workingTimeInForce` is `GTC`.
         * @param {string} [workingTimeInForce] GTC,IOC,FOK
         * @param {string} [pendingAboveClientOrderId] Arbitrary unique ID among open orders for the pending above order. Automatically generated if not sent.
         * @param {number} [pendingAbovePrice]
         * @param {number} [pendingAboveStopPrice]
         * @param {number} [pendingAboveTrailingDelta]
         * @param {number} [pendingAboveIcebergQty] This can only be used if `pendingAboveTimeInForce` is `GTC`.
         * @param {string} [pendingAboveTimeInForce]
         * @param {string} [pendingBelowType] Supported values: `LIMIT_MAKER`, `STOP_LOSS`, and `STOP_LOSS_LIMIT`
         * @param {string} [pendingBelowClientOrderId] Arbitrary unique ID among open orders for the pending below order. Automatically generated if not sent.
         * @param {number} [pendingBelowPrice]
         * @param {number} [pendingBelowStopPrice]
         * @param {number} [pendingBelowTrailingDelta]
         * @param {number} [pendingBelowIcebergQty] This can only be used if `pendingBelowTimeInForce` is `GTC`.
         * @param {string} [pendingBelowTimeInForce]
         *
         * @throws {RequiredError}
         */
        marginAccountNewOtoco: async (
            symbol: string,
            workingType: string,
            workingSide: string,
            workingPrice: number,
            workingQuantity: number,
            pendingSide: string,
            pendingQuantity: number,
            pendingAboveType: string,
            isIsolated?: string,
            sideEffectType?: string,
            autoRepayAtCancel?: boolean,
            listClientOrderId?: string,
            newOrderRespType?: MarginAccountNewOtocoNewOrderRespTypeEnum,
            selfTradePreventionMode?: string,
            workingClientOrderId?: string,
            workingIcebergQty?: number,
            workingTimeInForce?: string,
            pendingAboveClientOrderId?: string,
            pendingAbovePrice?: number,
            pendingAboveStopPrice?: number,
            pendingAboveTrailingDelta?: number,
            pendingAboveIcebergQty?: number,
            pendingAboveTimeInForce?: string,
            pendingBelowType?: string,
            pendingBelowClientOrderId?: string,
            pendingBelowPrice?: number,
            pendingBelowStopPrice?: number,
            pendingBelowTrailingDelta?: number,
            pendingBelowIcebergQty?: number,
            pendingBelowTimeInForce?: string
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('marginAccountNewOtoco', 'symbol', symbol);
            // verify required parameter 'workingType' is not null or undefined
            assertParamExists('marginAccountNewOtoco', 'workingType', workingType);
            // verify required parameter 'workingSide' is not null or undefined
            assertParamExists('marginAccountNewOtoco', 'workingSide', workingSide);
            // verify required parameter 'workingPrice' is not null or undefined
            assertParamExists('marginAccountNewOtoco', 'workingPrice', workingPrice);
            // verify required parameter 'workingQuantity' is not null or undefined
            assertParamExists('marginAccountNewOtoco', 'workingQuantity', workingQuantity);
            // verify required parameter 'pendingSide' is not null or undefined
            assertParamExists('marginAccountNewOtoco', 'pendingSide', pendingSide);
            // verify required parameter 'pendingQuantity' is not null or undefined
            assertParamExists('marginAccountNewOtoco', 'pendingQuantity', pendingQuantity);
            // verify required parameter 'pendingAboveType' is not null or undefined
            assertParamExists('marginAccountNewOtoco', 'pendingAboveType', pendingAboveType);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (isIsolated !== undefined && isIsolated !== null) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (sideEffectType !== undefined && sideEffectType !== null) {
                localVarQueryParameter['sideEffectType'] = sideEffectType;
            }

            if (autoRepayAtCancel !== undefined && autoRepayAtCancel !== null) {
                localVarQueryParameter['autoRepayAtCancel'] = autoRepayAtCancel;
            }

            if (listClientOrderId !== undefined && listClientOrderId !== null) {
                localVarQueryParameter['listClientOrderId'] = listClientOrderId;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }

            if (workingType !== undefined && workingType !== null) {
                localVarQueryParameter['workingType'] = workingType;
            }

            if (workingSide !== undefined && workingSide !== null) {
                localVarQueryParameter['workingSide'] = workingSide;
            }

            if (workingClientOrderId !== undefined && workingClientOrderId !== null) {
                localVarQueryParameter['workingClientOrderId'] = workingClientOrderId;
            }

            if (workingPrice !== undefined && workingPrice !== null) {
                localVarQueryParameter['workingPrice'] = workingPrice;
            }

            if (workingQuantity !== undefined && workingQuantity !== null) {
                localVarQueryParameter['workingQuantity'] = workingQuantity;
            }

            if (workingIcebergQty !== undefined && workingIcebergQty !== null) {
                localVarQueryParameter['workingIcebergQty'] = workingIcebergQty;
            }

            if (workingTimeInForce !== undefined && workingTimeInForce !== null) {
                localVarQueryParameter['workingTimeInForce'] = workingTimeInForce;
            }

            if (pendingSide !== undefined && pendingSide !== null) {
                localVarQueryParameter['pendingSide'] = pendingSide;
            }

            if (pendingQuantity !== undefined && pendingQuantity !== null) {
                localVarQueryParameter['pendingQuantity'] = pendingQuantity;
            }

            if (pendingAboveType !== undefined && pendingAboveType !== null) {
                localVarQueryParameter['pendingAboveType'] = pendingAboveType;
            }

            if (pendingAboveClientOrderId !== undefined && pendingAboveClientOrderId !== null) {
                localVarQueryParameter['pendingAboveClientOrderId'] = pendingAboveClientOrderId;
            }

            if (pendingAbovePrice !== undefined && pendingAbovePrice !== null) {
                localVarQueryParameter['pendingAbovePrice'] = pendingAbovePrice;
            }

            if (pendingAboveStopPrice !== undefined && pendingAboveStopPrice !== null) {
                localVarQueryParameter['pendingAboveStopPrice'] = pendingAboveStopPrice;
            }

            if (pendingAboveTrailingDelta !== undefined && pendingAboveTrailingDelta !== null) {
                localVarQueryParameter['pendingAboveTrailingDelta'] = pendingAboveTrailingDelta;
            }

            if (pendingAboveIcebergQty !== undefined && pendingAboveIcebergQty !== null) {
                localVarQueryParameter['pendingAboveIcebergQty'] = pendingAboveIcebergQty;
            }

            if (pendingAboveTimeInForce !== undefined && pendingAboveTimeInForce !== null) {
                localVarQueryParameter['pendingAboveTimeInForce'] = pendingAboveTimeInForce;
            }

            if (pendingBelowType !== undefined && pendingBelowType !== null) {
                localVarQueryParameter['pendingBelowType'] = pendingBelowType;
            }

            if (pendingBelowClientOrderId !== undefined && pendingBelowClientOrderId !== null) {
                localVarQueryParameter['pendingBelowClientOrderId'] = pendingBelowClientOrderId;
            }

            if (pendingBelowPrice !== undefined && pendingBelowPrice !== null) {
                localVarQueryParameter['pendingBelowPrice'] = pendingBelowPrice;
            }

            if (pendingBelowStopPrice !== undefined && pendingBelowStopPrice !== null) {
                localVarQueryParameter['pendingBelowStopPrice'] = pendingBelowStopPrice;
            }

            if (pendingBelowTrailingDelta !== undefined && pendingBelowTrailingDelta !== null) {
                localVarQueryParameter['pendingBelowTrailingDelta'] = pendingBelowTrailingDelta;
            }

            if (pendingBelowIcebergQty !== undefined && pendingBelowIcebergQty !== null) {
                localVarQueryParameter['pendingBelowIcebergQty'] = pendingBelowIcebergQty;
            }

            if (pendingBelowTimeInForce !== undefined && pendingBelowTimeInForce !== null) {
                localVarQueryParameter['pendingBelowTimeInForce'] = pendingBelowTimeInForce;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/order/otoco',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Margin Manual Liquidation
         *
         * This endpoint can support Cross Margin Classic Mode and Pro Mode.
         * And only support Isolated Margin for restricted region.
         *
         * Weight: 3000
         *
         * @summary Margin Manual Liquidation(MARGIN)
         * @param {string} type `MARGIN`,`ISOLATED`
         * @param {string} [symbol] isolated margin pair
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        marginManualLiquidation: async (
            type: string,
            symbol?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('marginManualLiquidation', 'type', type);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/manual-liquidation',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Displays the user's current margin order count usage for all intervals.
         *
         * Weight: 20(IP)
         *
         * @summary Query Current Margin Order Count Usage (TRADE)
         * @param {string} [isIsolated] for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
         * @param {string} [symbol] isolated margin pair
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        queryCurrentMarginOrderCountUsage: async (
            isIsolated?: string,
            symbol?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (isIsolated !== undefined && isIsolated !== null) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/rateLimit/order',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Retrieves all OCO for a specific margin account based on provided optional parameters
         *
         * Weight: 200(IP)
         *
         * @summary Query Margin Account\'s all OCO (USER_DATA)
         * @param {string} [isIsolated] for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
         * @param {string} [symbol] isolated margin pair
         * @param {number} [fromId] 如设置fromId, 将返回id > fromId的数据。否则将返回最新数据
         * @param {number} [startTime] 只支持查询最近90天的数据
         * @param {number} [endTime]
         * @param {number} [limit] Default Value: 500; Max Value: 1000
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        queryMarginAccountsAllOco: async (
            isIsolated?: string,
            symbol?: string,
            fromId?: number,
            startTime?: number,
            endTime?: number,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (isIsolated !== undefined && isIsolated !== null) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (fromId !== undefined && fromId !== null) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/allOrderList',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query Margin Account's All Orders
         *
         * If orderId is set, it will get orders >= that orderId. Otherwise the orders within 24 hours are returned.
         * For some historical orders cummulativeQuoteQty will be < 0, meaning the data is not available at this time.
         * Less than 24 hours between startTime and endTime.
         *
         * Weight: 200(IP)
         *
         * @summary Query Margin Account\'s All Orders (USER_DATA)
         * @param {string} symbol
         * @param {string} [isIsolated] for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
         * @param {number} [orderId]
         * @param {number} [startTime] 只支持查询最近90天的数据
         * @param {number} [endTime]
         * @param {number} [limit] Default Value: 500; Max Value: 1000
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        queryMarginAccountsAllOrders: async (
            symbol: string,
            isIsolated?: string,
            orderId?: number,
            startTime?: number,
            endTime?: number,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryMarginAccountsAllOrders', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (isIsolated !== undefined && isIsolated !== null) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/allOrders',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Retrieves a specific OCO based on provided optional parameters
         *
         * Weight: 10(IP)
         *
         * @summary Query Margin Account\'s OCO (USER_DATA)
         * @param {string} [isIsolated] for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
         * @param {string} [symbol] isolated margin pair
         * @param {number} [orderListId] Either `orderListId` or `listClientOrderId` must be provided
         * @param {string} [origClientOrderId]
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        queryMarginAccountsOco: async (
            isIsolated?: string,
            symbol?: string,
            orderListId?: number,
            origClientOrderId?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (isIsolated !== undefined && isIsolated !== null) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderListId !== undefined && orderListId !== null) {
                localVarQueryParameter['orderListId'] = orderListId;
            }

            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/orderList',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query Margin Account's Open OCO
         *
         * Weight: 10(IP)
         *
         * @summary Query Margin Account\'s Open OCO (USER_DATA)
         * @param {string} [isIsolated] for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
         * @param {string} [symbol] isolated margin pair
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        queryMarginAccountsOpenOco: async (
            isIsolated?: string,
            symbol?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (isIsolated !== undefined && isIsolated !== null) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/openOrderList',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query Margin Account's Open Orders
         *
         * If the symbol is not sent, orders for all symbols will be returned in an array.
         * When all symbols are returned, the number of requests counted against the rate limiter is equal to the number of symbols currently trading on the exchange.
         * If isIsolated ="TRUE", symbol must be sent.
         *
         * Weight: 10(IP)
         *
         * @summary Query Margin Account\'s Open Orders (USER_DATA)
         * @param {string} [symbol] isolated margin pair
         * @param {string} [isIsolated] for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        queryMarginAccountsOpenOrders: async (
            symbol?: string,
            isIsolated?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (isIsolated !== undefined && isIsolated !== null) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/openOrders',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query Margin Account's Order
         *
         * Either orderId or origClientOrderId must be sent.
         * For some historical orders cummulativeQuoteQty will be < 0, meaning the data is not available at this time.
         *
         * Weight: 10(IP)
         *
         * @summary Query Margin Account\'s Order (USER_DATA)
         * @param {string} symbol
         * @param {string} [isIsolated] for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
         * @param {number} [orderId]
         * @param {string} [origClientOrderId]
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        queryMarginAccountsOrder: async (
            symbol: string,
            isIsolated?: string,
            orderId?: number,
            origClientOrderId?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryMarginAccountsOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (isIsolated !== undefined && isIsolated !== null) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/order',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query Margin Account's Trade List
         *
         * If fromId is set, it will get trades >= that fromId. Otherwise the trades within 24 hours are returned.
         * Less than 24 hours between startTime and endTime.
         *
         * Weight: 10(IP)
         *
         * @summary Query Margin Account\'s Trade List (USER_DATA)
         * @param {string} symbol
         * @param {string} [isIsolated] for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
         * @param {number} [orderId]
         * @param {number} [startTime] 只支持查询最近90天的数据
         * @param {number} [endTime]
         * @param {number} [fromId] 如设置fromId, 将返回id > fromId的数据。否则将返回最新数据
         * @param {number} [limit] Default Value: 500; Max Value: 1000
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        queryMarginAccountsTradeList: async (
            symbol: string,
            isIsolated?: string,
            orderId?: number,
            startTime?: number,
            endTime?: number,
            fromId?: number,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryMarginAccountsTradeList', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (isIsolated !== undefined && isIsolated !== null) {
                localVarQueryParameter['isIsolated'] = isIsolated;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (fromId !== undefined && fromId !== null) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/myTrades',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query Special Key Information.
         *
         * This only applies to Special Key for Low Latency Trading.
         *
         * Weight: 1(UID)
         *
         * @summary Query Special key(Low Latency Trading)(TRADE)
         * @param {string} [symbol] isolated margin pair
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        querySpecialKey: async (symbol?: string, recvWindow?: number): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/apiKey',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * This only applies to Special Key for Low Latency Trading.
         *
         * Weight: 1(UID)
         *
         * @summary Query Special key List(Low Latency Trading)(TRADE)
         * @param {string} [symbol] isolated margin pair
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        querySpecialKeyList: async (symbol?: string, recvWindow?: number): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/api-key-list',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Small Liability Exchange
         *
         * Only convert once within 6 hours
         * Only liability valuation less than 10 USDT are supported
         * The maximum number of coin is 10
         *
         * Weight: 3000(UID)
         *
         * @summary Small Liability Exchange (MARGIN)
         * @param {Array<string>} assetNames The assets list of small liability exchange， Example: assetNames = BTC,ETH
         * @param {number} [recvWindow] No more than 60000
         *
         * @throws {RequiredError}
         */
        smallLiabilityExchange: async (
            assetNames: Array<string>,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'assetNames' is not null or undefined
            assertParamExists('smallLiabilityExchange', 'assetNames', assetNames);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (assetNames) {
                localVarQueryParameter['assetNames'] = assetNames;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/sapi/v1/margin/exchange-small-liability',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
    };
};

/**
 * TradeApi - interface
 * @interface TradeApi
 */
export interface TradeApiInterface {
    /**
     * **Binance Margin offers low-latency trading through a [special key](https://www.binance.com/en/support/faq/frequently-asked-questions-on-margin-special-api-key-3208663e900d4d2e9fec4140e1832f4e), available exclusively to users with VIP level 4 or higher. **
     *
     **If you are VIP level 3 or below, please contact your VIP manager for eligibility criterias.**
     *
     * We support several types of API keys:
     *
     * Ed25519 (recommended)
     * HMAC
     * RSA
     *
     * We recommend to **use Ed25519 API keys** as it should provide the best performance and security out of all supported key types. We accept PKCS#8 (BEGIN PUBLIC KEY). For how to generate an RSA key pair to send API requests on Binance. Please refer to the document below [FAQ](https://www.binance.com/en/support/faq/how-to-generate-an-rsa-key-pair-to-send-api-requests-on-binance-2b79728f331e43079b27440d9d15c5db) .
     *
     * Read [REST API](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md#signed-trade-and-user_data-endpoint-security) or [WebSocket API](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-api.md#request-security) documentation to learn how to use different API keys
     *
     * You need to enable Permits “Enable Spot & Margin Trading” option for the API Key which requests this endpoint.
     *
     * Weight: 1(UID)
     *
     * @summary Create Special Key(Low-Latency Trading)(TRADE)
     * @param {CreateSpecialKeyRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    createSpecialKey(
        requestParameters: CreateSpecialKeyRequest
    ): Promise<RestApiResponse<CreateSpecialKeyResponse>>;
    /**
     * This only applies to Special Key for Low Latency Trading.
     *
     * If apiKey is given, apiName will be ignored. If apiName is given with no apiKey, all apikeys with given apiName will be deleted.
     *
     * You need to enable Permits “Enable Spot & Margin Trading” option for the API Key which requests this endpoint.
     *
     * Weight: 1(UID)
     *
     * @summary Delete Special Key(Low-Latency Trading)(TRADE)
     * @param {DeleteSpecialKeyRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    deleteSpecialKey(requestParameters?: DeleteSpecialKeyRequest): Promise<RestApiResponse<void>>;
    /**
     * Edit ip restriction. This only applies to Special Key for Low Latency Trading.
     *
     * You need to enable Permits “Enable Spot & Margin Trading” option for the API Key which requests this endpoint.
     *
     * Weight: 1(UID)
     *
     * @summary Edit ip for Special Key(Low-Latency Trading)(TRADE)
     * @param {EditIpForSpecialKeyRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    editIpForSpecialKey(
        requestParameters: EditIpForSpecialKeyRequest
    ): Promise<RestApiResponse<void>>;
    /**
     * Get Force Liquidation Record
     *
     * Response in descending order
     *
     * Weight: 1(IP)
     *
     * @summary Get Force Liquidation Record (USER_DATA)
     * @param {GetForceLiquidationRecordRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    getForceLiquidationRecord(
        requestParameters?: GetForceLiquidationRecordRequest
    ): Promise<RestApiResponse<GetForceLiquidationRecordResponse>>;
    /**
     * Query the coins which can be small liability exchange
     *
     * Weight: 100
     *
     * @summary Get Small Liability Exchange Coin List (USER_DATA)
     * @param {GetSmallLiabilityExchangeCoinListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    getSmallLiabilityExchangeCoinList(
        requestParameters?: GetSmallLiabilityExchangeCoinListRequest
    ): Promise<RestApiResponse<GetSmallLiabilityExchangeCoinListResponse>>;
    /**
     * Get Small liability Exchange History
     *
     * Weight: 100(UID)
     *
     * @summary Get Small Liability Exchange History (USER_DATA)
     * @param {GetSmallLiabilityExchangeHistoryRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    getSmallLiabilityExchangeHistory(
        requestParameters: GetSmallLiabilityExchangeHistoryRequest
    ): Promise<RestApiResponse<GetSmallLiabilityExchangeHistoryResponse>>;
    /**
     * Cancels all active orders on a symbol for margin account.<br></br>
     * This includes OCO orders.
     *
     * Weight: 1
     *
     * @summary Margin Account Cancel all Open Orders on a Symbol (TRADE)
     * @param {MarginAccountCancelAllOpenOrdersOnASymbolRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    marginAccountCancelAllOpenOrdersOnASymbol(
        requestParameters: MarginAccountCancelAllOpenOrdersOnASymbolRequest
    ): Promise<RestApiResponse<MarginAccountCancelAllOpenOrdersOnASymbolResponse>>;
    /**
     * Cancel an entire Order List for a margin account.
     *
     * Canceling an individual leg will cancel the entire OCO
     *
     * Weight: 1(UID)
     *
     * @summary Margin Account Cancel OCO (TRADE)
     * @param {MarginAccountCancelOcoRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    marginAccountCancelOco(
        requestParameters: MarginAccountCancelOcoRequest
    ): Promise<RestApiResponse<MarginAccountCancelOcoResponse>>;
    /**
     * Cancel an active order for margin account.
     *
     * Either orderId or origClientOrderId must be sent.
     *
     * Weight: 10(IP)
     *
     * @summary Margin Account Cancel Order (TRADE)
     * @param {MarginAccountCancelOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    marginAccountCancelOrder(
        requestParameters: MarginAccountCancelOrderRequest
    ): Promise<RestApiResponse<MarginAccountCancelOrderResponse>>;
    /**
     * Send in a new OCO for a margin account
     *
     * autoRepayAtCancel is suggested to set as “FALSE” to keep liability unrepaid under high frequent new order/cancel order execution
     *
     * Weight: 6(UID)
     *
     * @summary Margin Account New OCO (TRADE)
     * @param {MarginAccountNewOcoRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    marginAccountNewOco(
        requestParameters: MarginAccountNewOcoRequest
    ): Promise<RestApiResponse<MarginAccountNewOcoResponse>>;
    /**
     * Post a new order for margin account.
     *
     * autoRepayAtCancel is suggested to set as “FALSE” to keep liability unrepaid under high frequent new order/cancel order execution
     *
     * Weight: 6(UID)
     *
     * @summary Margin Account New Order (TRADE)
     * @param {MarginAccountNewOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    marginAccountNewOrder(
        requestParameters: MarginAccountNewOrderRequest
    ): Promise<RestApiResponse<MarginAccountNewOrderResponse>>;
    /**
     * Post a new OTO order for margin account:
     *
     * - An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders.
     * - The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
     * - The second order is called the **pending order**. It can be any order type except for `MARKET` orders using parameter `quoteOrderQty`. The pending order is only placed on the order book when the working order gets **fully filled**.
     * - If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired.
     * - When the order list is placed, if the working order gets **immediately fully filled**, the placement response will show the working order as `FILLED` but the pending order will still appear as `PENDING_NEW`. You need to query the status of the pending order again to see its updated status.
     * - OTOs add **2 orders** to the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
     *
     * autoRepayAtCancel is suggested to set as “FALSE” to keep liability unrepaid under high frequent new order/cancel order execution
     * Depending on the `pendingType` or `workingType`, some optional parameters will become mandatory:
     *
     * Weight: 6(UID)
     *
     * @summary Margin Account New OTO (TRADE)
     * @param {MarginAccountNewOtoRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    marginAccountNewOto(
        requestParameters: MarginAccountNewOtoRequest
    ): Promise<RestApiResponse<MarginAccountNewOtoResponse>>;
    /**
     * Post a new OTOCO order for margin account：
     *
     * - An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders.
     * - The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
     * - The behavior of the working order is the same as the OTO.
     * - OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets **fully filled**.
     * - The rules of the pending above and pending below follow the same rules as the [Order List OCO](https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-OCO).
     * - OTOCOs add **3 orders** against the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter, and `MAX_NUM_ORDERS` filter.
     *
     * autoRepayAtCancel is suggested to set as “FALSE” to keep liability unrepaid under high frequent new order/cancel order execution
     * Depending on the `pendingAboveType`/`pendingBelowType` or `workingType`, some optional parameters will become mandatory:
     *
     * Weight: 6(UID)
     *
     * @summary Margin Account New OTOCO (TRADE)
     * @param {MarginAccountNewOtocoRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    marginAccountNewOtoco(
        requestParameters: MarginAccountNewOtocoRequest
    ): Promise<RestApiResponse<MarginAccountNewOtocoResponse>>;
    /**
     * Margin Manual Liquidation
     *
     * This endpoint can support Cross Margin Classic Mode and Pro Mode.
     * And only support Isolated Margin for restricted region.
     *
     * Weight: 3000
     *
     * @summary Margin Manual Liquidation(MARGIN)
     * @param {MarginManualLiquidationRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    marginManualLiquidation(
        requestParameters: MarginManualLiquidationRequest
    ): Promise<RestApiResponse<MarginManualLiquidationResponse>>;
    /**
     * Displays the user's current margin order count usage for all intervals.
     *
     * Weight: 20(IP)
     *
     * @summary Query Current Margin Order Count Usage (TRADE)
     * @param {QueryCurrentMarginOrderCountUsageRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryCurrentMarginOrderCountUsage(
        requestParameters?: QueryCurrentMarginOrderCountUsageRequest
    ): Promise<RestApiResponse<QueryCurrentMarginOrderCountUsageResponse>>;
    /**
     * Retrieves all OCO for a specific margin account based on provided optional parameters
     *
     * Weight: 200(IP)
     *
     * @summary Query Margin Account\'s all OCO (USER_DATA)
     * @param {QueryMarginAccountsAllOcoRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryMarginAccountsAllOco(
        requestParameters?: QueryMarginAccountsAllOcoRequest
    ): Promise<RestApiResponse<QueryMarginAccountsAllOcoResponse>>;
    /**
     * Query Margin Account's All Orders
     *
     * If orderId is set, it will get orders >= that orderId. Otherwise the orders within 24 hours are returned.
     * For some historical orders cummulativeQuoteQty will be < 0, meaning the data is not available at this time.
     * Less than 24 hours between startTime and endTime.
     *
     * Weight: 200(IP)
     *
     * @summary Query Margin Account\'s All Orders (USER_DATA)
     * @param {QueryMarginAccountsAllOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryMarginAccountsAllOrders(
        requestParameters: QueryMarginAccountsAllOrdersRequest
    ): Promise<RestApiResponse<QueryMarginAccountsAllOrdersResponse>>;
    /**
     * Retrieves a specific OCO based on provided optional parameters
     *
     * Weight: 10(IP)
     *
     * @summary Query Margin Account\'s OCO (USER_DATA)
     * @param {QueryMarginAccountsOcoRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryMarginAccountsOco(
        requestParameters?: QueryMarginAccountsOcoRequest
    ): Promise<RestApiResponse<QueryMarginAccountsOcoResponse>>;
    /**
     * Query Margin Account's Open OCO
     *
     * Weight: 10(IP)
     *
     * @summary Query Margin Account\'s Open OCO (USER_DATA)
     * @param {QueryMarginAccountsOpenOcoRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryMarginAccountsOpenOco(
        requestParameters?: QueryMarginAccountsOpenOcoRequest
    ): Promise<RestApiResponse<QueryMarginAccountsOpenOcoResponse>>;
    /**
     * Query Margin Account's Open Orders
     *
     * If the symbol is not sent, orders for all symbols will be returned in an array.
     * When all symbols are returned, the number of requests counted against the rate limiter is equal to the number of symbols currently trading on the exchange.
     * If isIsolated ="TRUE", symbol must be sent.
     *
     * Weight: 10(IP)
     *
     * @summary Query Margin Account\'s Open Orders (USER_DATA)
     * @param {QueryMarginAccountsOpenOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryMarginAccountsOpenOrders(
        requestParameters?: QueryMarginAccountsOpenOrdersRequest
    ): Promise<RestApiResponse<QueryMarginAccountsOpenOrdersResponse>>;
    /**
     * Query Margin Account's Order
     *
     * Either orderId or origClientOrderId must be sent.
     * For some historical orders cummulativeQuoteQty will be < 0, meaning the data is not available at this time.
     *
     * Weight: 10(IP)
     *
     * @summary Query Margin Account\'s Order (USER_DATA)
     * @param {QueryMarginAccountsOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryMarginAccountsOrder(
        requestParameters: QueryMarginAccountsOrderRequest
    ): Promise<RestApiResponse<QueryMarginAccountsOrderResponse>>;
    /**
     * Query Margin Account's Trade List
     *
     * If fromId is set, it will get trades >= that fromId. Otherwise the trades within 24 hours are returned.
     * Less than 24 hours between startTime and endTime.
     *
     * Weight: 10(IP)
     *
     * @summary Query Margin Account\'s Trade List (USER_DATA)
     * @param {QueryMarginAccountsTradeListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryMarginAccountsTradeList(
        requestParameters: QueryMarginAccountsTradeListRequest
    ): Promise<RestApiResponse<QueryMarginAccountsTradeListResponse>>;
    /**
     * Query Special Key Information.
     *
     * This only applies to Special Key for Low Latency Trading.
     *
     * Weight: 1(UID)
     *
     * @summary Query Special key(Low Latency Trading)(TRADE)
     * @param {QuerySpecialKeyRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    querySpecialKey(
        requestParameters?: QuerySpecialKeyRequest
    ): Promise<RestApiResponse<QuerySpecialKeyResponse>>;
    /**
     * This only applies to Special Key for Low Latency Trading.
     *
     * Weight: 1(UID)
     *
     * @summary Query Special key List(Low Latency Trading)(TRADE)
     * @param {QuerySpecialKeyListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    querySpecialKeyList(
        requestParameters?: QuerySpecialKeyListRequest
    ): Promise<RestApiResponse<QuerySpecialKeyListResponse>>;
    /**
     * Small Liability Exchange
     *
     * Only convert once within 6 hours
     * Only liability valuation less than 10 USDT are supported
     * The maximum number of coin is 10
     *
     * Weight: 3000(UID)
     *
     * @summary Small Liability Exchange (MARGIN)
     * @param {SmallLiabilityExchangeRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    smallLiabilityExchange(
        requestParameters: SmallLiabilityExchangeRequest
    ): Promise<RestApiResponse<void>>;
}

/**
 * Request parameters for createSpecialKey operation in TradeApi.
 * @interface CreateSpecialKeyRequest
 */
export interface CreateSpecialKeyRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiCreateSpecialKey
     */
    readonly apiName: string;

    /**
     * isolated margin pair
     * @type {string}
     * @memberof TradeApiCreateSpecialKey
     */
    readonly symbol?: string;

    /**
     * Can be added in batches, separated by commas. Max 30 for an API key
     * @type {string}
     * @memberof TradeApiCreateSpecialKey
     */
    readonly ip?: string;

    /**
     * 1. If publicKey is inputted it will create an RSA or Ed25519 key. <br />2. Need to be encoded to URL-encoded format
     * @type {string}
     * @memberof TradeApiCreateSpecialKey
     */
    readonly publicKey?: string;

    /**
     * This parameter is only for the Ed25519 API key, and does not effact for other encryption methods. The value can be TRADE (TRADE for all permissions) or READ (READ for USER_DATA, FIX_API_READ_ONLY). The default value is TRADE.
     * @type {string}
     * @memberof TradeApiCreateSpecialKey
     */
    readonly permissionMode?: string;

    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiCreateSpecialKey
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for deleteSpecialKey operation in TradeApi.
 * @interface DeleteSpecialKeyRequest
 */
export interface DeleteSpecialKeyRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiDeleteSpecialKey
     */
    readonly apiName?: string;

    /**
     * isolated margin pair
     * @type {string}
     * @memberof TradeApiDeleteSpecialKey
     */
    readonly symbol?: string;

    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiDeleteSpecialKey
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for editIpForSpecialKey operation in TradeApi.
 * @interface EditIpForSpecialKeyRequest
 */
export interface EditIpForSpecialKeyRequest {
    /**
     * Can be added in batches, separated by commas. Max 30 for an API key
     * @type {string}
     * @memberof TradeApiEditIpForSpecialKey
     */
    readonly ip: string;

    /**
     * isolated margin pair
     * @type {string}
     * @memberof TradeApiEditIpForSpecialKey
     */
    readonly symbol?: string;

    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiEditIpForSpecialKey
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for getForceLiquidationRecord operation in TradeApi.
 * @interface GetForceLiquidationRecordRequest
 */
export interface GetForceLiquidationRecordRequest {
    /**
     * 只支持查询最近90天的数据
     * @type {number}
     * @memberof TradeApiGetForceLiquidationRecord
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiGetForceLiquidationRecord
     */
    readonly endTime?: number;

    /**
     * isolated symbol
     * @type {string}
     * @memberof TradeApiGetForceLiquidationRecord
     */
    readonly isolatedSymbol?: string;

    /**
     * Currently querying page. Start from 1. Default:1
     * @type {number}
     * @memberof TradeApiGetForceLiquidationRecord
     */
    readonly current?: number;

    /**
     * Default:10 Max:100
     * @type {number}
     * @memberof TradeApiGetForceLiquidationRecord
     */
    readonly size?: number;

    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiGetForceLiquidationRecord
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for getSmallLiabilityExchangeCoinList operation in TradeApi.
 * @interface GetSmallLiabilityExchangeCoinListRequest
 */
export interface GetSmallLiabilityExchangeCoinListRequest {
    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiGetSmallLiabilityExchangeCoinList
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for getSmallLiabilityExchangeHistory operation in TradeApi.
 * @interface GetSmallLiabilityExchangeHistoryRequest
 */
export interface GetSmallLiabilityExchangeHistoryRequest {
    /**
     * Currently querying page. Start from 1. Default:1
     * @type {number}
     * @memberof TradeApiGetSmallLiabilityExchangeHistory
     */
    readonly current: number;

    /**
     * Default:10, Max:100
     * @type {number}
     * @memberof TradeApiGetSmallLiabilityExchangeHistory
     */
    readonly size: number;

    /**
     * 只支持查询最近90天的数据
     * @type {number}
     * @memberof TradeApiGetSmallLiabilityExchangeHistory
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiGetSmallLiabilityExchangeHistory
     */
    readonly endTime?: number;

    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiGetSmallLiabilityExchangeHistory
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for marginAccountCancelAllOpenOrdersOnASymbol operation in TradeApi.
 * @interface MarginAccountCancelAllOpenOrdersOnASymbolRequest
 */
export interface MarginAccountCancelAllOpenOrdersOnASymbolRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiMarginAccountCancelAllOpenOrdersOnASymbol
     */
    readonly symbol: string;

    /**
     * for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
     * @type {string}
     * @memberof TradeApiMarginAccountCancelAllOpenOrdersOnASymbol
     */
    readonly isIsolated?: string;

    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiMarginAccountCancelAllOpenOrdersOnASymbol
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for marginAccountCancelOco operation in TradeApi.
 * @interface MarginAccountCancelOcoRequest
 */
export interface MarginAccountCancelOcoRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiMarginAccountCancelOco
     */
    readonly symbol: string;

    /**
     * for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
     * @type {string}
     * @memberof TradeApiMarginAccountCancelOco
     */
    readonly isIsolated?: string;

    /**
     * Either `orderListId` or `listClientOrderId` must be provided
     * @type {number}
     * @memberof TradeApiMarginAccountCancelOco
     */
    readonly orderListId?: number;

    /**
     * Either `orderListId` or `listClientOrderId` must be provided
     * @type {string}
     * @memberof TradeApiMarginAccountCancelOco
     */
    readonly listClientOrderId?: string;

    /**
     * Used to uniquely identify this cancel. Automatically generated by default
     * @type {string}
     * @memberof TradeApiMarginAccountCancelOco
     */
    readonly newClientOrderId?: string;

    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiMarginAccountCancelOco
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for marginAccountCancelOrder operation in TradeApi.
 * @interface MarginAccountCancelOrderRequest
 */
export interface MarginAccountCancelOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiMarginAccountCancelOrder
     */
    readonly symbol: string;

    /**
     * for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
     * @type {string}
     * @memberof TradeApiMarginAccountCancelOrder
     */
    readonly isIsolated?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountCancelOrder
     */
    readonly orderId?: number;

    /**
     *
     * @type {string}
     * @memberof TradeApiMarginAccountCancelOrder
     */
    readonly origClientOrderId?: string;

    /**
     * Used to uniquely identify this cancel. Automatically generated by default
     * @type {string}
     * @memberof TradeApiMarginAccountCancelOrder
     */
    readonly newClientOrderId?: string;

    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiMarginAccountCancelOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for marginAccountNewOco operation in TradeApi.
 * @interface MarginAccountNewOcoRequest
 */
export interface MarginAccountNewOcoRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly symbol: string;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly side: MarginAccountNewOcoSideEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly quantity: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly price: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly stopPrice: number;

    /**
     * for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
     * @type {string}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly isIsolated?: string;

    /**
     * Either `orderListId` or `listClientOrderId` must be provided
     * @type {string}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly listClientOrderId?: string;

    /**
     * A unique Id for the limit order
     * @type {string}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly limitClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly limitIcebergQty?: number;

    /**
     * A unique Id for the stop loss/stop loss limit leg
     * @type {string}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly stopClientOrderId?: string;

    /**
     * If provided, `stopLimitTimeInForce` is required.
     * @type {number}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly stopLimitPrice?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly stopIcebergQty?: number;

    /**
     * Valid values are `GTC`/`FOK`/`IOC`
     * @type {string}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly stopLimitTimeInForce?: string;

    /**
     * Set the response JSON. ACK, RESULT, or FULL; MARKET and LIMIT order types default to FULL, all other orders default to ACK.
     * @type {'ACK' | 'RESULT' | 'FULL'}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly newOrderRespType?: MarginAccountNewOcoNewOrderRespTypeEnum;

    /**
     * NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY,AUTO_BORROW_REPAY; default NO_SIDE_EFFECT. More info in [FAQ](https://www.binance.com/en/support/faq/how-to-use-the-sideeffecttype-parameter-with-the-margin-order-endpoints-f9fc51cda1984bf08b95e0d96c4570bc)
     * @type {string}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly sideEffectType?: string;

    /**
     * The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE
     * @type {string}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly selfTradePreventionMode?: string;

    /**
     * Only when MARGIN_BUY or AUTO_BORROW_REPAY order takes effect, true means that the debt generated by the order needs to be repay after the order is cancelled. The default is true
     * @type {boolean}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly autoRepayAtCancel?: boolean;

    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiMarginAccountNewOco
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for marginAccountNewOrder operation in TradeApi.
 * @interface MarginAccountNewOrderRequest
 */
export interface MarginAccountNewOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiMarginAccountNewOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiMarginAccountNewOrder
     */
    readonly side: MarginAccountNewOrderSideEnum;

    /**
     * `MARGIN`,`ISOLATED`
     * @type {string}
     * @memberof TradeApiMarginAccountNewOrder
     */
    readonly type: string;

    /**
     * for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
     * @type {string}
     * @memberof TradeApiMarginAccountNewOrder
     */
    readonly isIsolated?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOrder
     */
    readonly quantity?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOrder
     */
    readonly quoteOrderQty?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOrder
     */
    readonly price?: number;

    /**
     * Used with `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, and `TAKE_PROFIT_LIMIT` orders.
     * @type {number}
     * @memberof TradeApiMarginAccountNewOrder
     */
    readonly stopPrice?: number;

    /**
     * Used to uniquely identify this cancel. Automatically generated by default
     * @type {string}
     * @memberof TradeApiMarginAccountNewOrder
     */
    readonly newClientOrderId?: string;

    /**
     * Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order.
     * @type {number}
     * @memberof TradeApiMarginAccountNewOrder
     */
    readonly icebergQty?: number;

    /**
     * Set the response JSON. ACK, RESULT, or FULL; MARKET and LIMIT order types default to FULL, all other orders default to ACK.
     * @type {'ACK' | 'RESULT' | 'FULL'}
     * @memberof TradeApiMarginAccountNewOrder
     */
    readonly newOrderRespType?: MarginAccountNewOrderNewOrderRespTypeEnum;

    /**
     * NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY,AUTO_BORROW_REPAY; default NO_SIDE_EFFECT. More info in [FAQ](https://www.binance.com/en/support/faq/how-to-use-the-sideeffecttype-parameter-with-the-margin-order-endpoints-f9fc51cda1984bf08b95e0d96c4570bc)
     * @type {string}
     * @memberof TradeApiMarginAccountNewOrder
     */
    readonly sideEffectType?: string;

    /**
     * GTC,IOC,FOK
     * @type {'GTC' | 'IOC' | 'FOK'}
     * @memberof TradeApiMarginAccountNewOrder
     */
    readonly timeInForce?: MarginAccountNewOrderTimeInForceEnum;

    /**
     * The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE
     * @type {string}
     * @memberof TradeApiMarginAccountNewOrder
     */
    readonly selfTradePreventionMode?: string;

    /**
     * Only when MARGIN_BUY or AUTO_BORROW_REPAY order takes effect, true means that the debt generated by the order needs to be repay after the order is cancelled. The default is true
     * @type {boolean}
     * @memberof TradeApiMarginAccountNewOrder
     */
    readonly autoRepayAtCancel?: boolean;

    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiMarginAccountNewOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for marginAccountNewOto operation in TradeApi.
 * @interface MarginAccountNewOtoRequest
 */
export interface MarginAccountNewOtoRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly symbol: string;

    /**
     * Supported values: `LIMIT`, `LIMIT_MAKER`
     * @type {string}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly workingType: string;

    /**
     * BUY, SELL
     * @type {string}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly workingSide: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly workingPrice: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly workingQuantity: number;

    /**
     * This can only be used if `workingTimeInForce` is `GTC`.
     * @type {number}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly workingIcebergQty: number;

    /**
     * Supported values: [Order Types](https://developers.binance.com/docs/binance-spot-api-docs/enums#order-types-ordertypes-type) Note that `MARKET` orders using `quoteOrderQty` are not supported.
     * @type {string}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly pendingType: string;

    /**
     * BUY, SELL
     * @type {string}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly pendingSide: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly pendingQuantity: number;

    /**
     * for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
     * @type {string}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly isIsolated?: string;

    /**
     * Either `orderListId` or `listClientOrderId` must be provided
     * @type {string}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly listClientOrderId?: string;

    /**
     * Set the response JSON. ACK, RESULT, or FULL; MARKET and LIMIT order types default to FULL, all other orders default to ACK.
     * @type {'ACK' | 'RESULT' | 'FULL'}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly newOrderRespType?: MarginAccountNewOtoNewOrderRespTypeEnum;

    /**
     * NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY,AUTO_BORROW_REPAY; default NO_SIDE_EFFECT. More info in [FAQ](https://www.binance.com/en/support/faq/how-to-use-the-sideeffecttype-parameter-with-the-margin-order-endpoints-f9fc51cda1984bf08b95e0d96c4570bc)
     * @type {string}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly sideEffectType?: string;

    /**
     * The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE
     * @type {string}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly selfTradePreventionMode?: string;

    /**
     * Only when MARGIN_BUY or AUTO_BORROW_REPAY order takes effect, true means that the debt generated by the order needs to be repay after the order is cancelled. The default is true
     * @type {boolean}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly autoRepayAtCancel?: boolean;

    /**
     * Arbitrary unique ID among open orders for the working order. Automatically generated if not sent.
     * @type {string}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly workingClientOrderId?: string;

    /**
     * GTC,IOC,FOK
     * @type {string}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly workingTimeInForce?: string;

    /**
     * Arbitrary unique ID among open orders for the pending order. Automatically generated if not sent.
     * @type {string}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly pendingClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly pendingPrice?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly pendingStopPrice?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly pendingTrailingDelta?: number;

    /**
     * This can only be used if `pendingTimeInForce` is `GTC`.
     * @type {number}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly pendingIcebergQty?: number;

    /**
     * GTC,IOC,FOK
     * @type {string}
     * @memberof TradeApiMarginAccountNewOto
     */
    readonly pendingTimeInForce?: string;
}

/**
 * Request parameters for marginAccountNewOtoco operation in TradeApi.
 * @interface MarginAccountNewOtocoRequest
 */
export interface MarginAccountNewOtocoRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly symbol: string;

    /**
     * Supported values: `LIMIT`, `LIMIT_MAKER`
     * @type {string}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly workingType: string;

    /**
     * BUY, SELL
     * @type {string}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly workingSide: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly workingPrice: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly workingQuantity: number;

    /**
     * BUY, SELL
     * @type {string}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly pendingSide: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly pendingQuantity: number;

    /**
     * Supported values: `LIMIT_MAKER`, `STOP_LOSS`, and `STOP_LOSS_LIMIT`
     * @type {string}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly pendingAboveType: string;

    /**
     * for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
     * @type {string}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly isIsolated?: string;

    /**
     * NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY,AUTO_BORROW_REPAY; default NO_SIDE_EFFECT. More info in [FAQ](https://www.binance.com/en/support/faq/how-to-use-the-sideeffecttype-parameter-with-the-margin-order-endpoints-f9fc51cda1984bf08b95e0d96c4570bc)
     * @type {string}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly sideEffectType?: string;

    /**
     * Only when MARGIN_BUY or AUTO_BORROW_REPAY order takes effect, true means that the debt generated by the order needs to be repay after the order is cancelled. The default is true
     * @type {boolean}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly autoRepayAtCancel?: boolean;

    /**
     * Either `orderListId` or `listClientOrderId` must be provided
     * @type {string}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly listClientOrderId?: string;

    /**
     * Set the response JSON. ACK, RESULT, or FULL; MARKET and LIMIT order types default to FULL, all other orders default to ACK.
     * @type {'ACK' | 'RESULT' | 'FULL'}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly newOrderRespType?: MarginAccountNewOtocoNewOrderRespTypeEnum;

    /**
     * The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE
     * @type {string}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly selfTradePreventionMode?: string;

    /**
     * Arbitrary unique ID among open orders for the working order. Automatically generated if not sent.
     * @type {string}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly workingClientOrderId?: string;

    /**
     * This can only be used if `workingTimeInForce` is `GTC`.
     * @type {number}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly workingIcebergQty?: number;

    /**
     * GTC,IOC,FOK
     * @type {string}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly workingTimeInForce?: string;

    /**
     * Arbitrary unique ID among open orders for the pending above order. Automatically generated if not sent.
     * @type {string}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly pendingAboveClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly pendingAbovePrice?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly pendingAboveStopPrice?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly pendingAboveTrailingDelta?: number;

    /**
     * This can only be used if `pendingAboveTimeInForce` is `GTC`.
     * @type {number}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly pendingAboveIcebergQty?: number;

    /**
     *
     * @type {string}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly pendingAboveTimeInForce?: string;

    /**
     * Supported values: `LIMIT_MAKER`, `STOP_LOSS`, and `STOP_LOSS_LIMIT`
     * @type {string}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly pendingBelowType?: string;

    /**
     * Arbitrary unique ID among open orders for the pending below order. Automatically generated if not sent.
     * @type {string}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly pendingBelowClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly pendingBelowPrice?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly pendingBelowStopPrice?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly pendingBelowTrailingDelta?: number;

    /**
     * This can only be used if `pendingBelowTimeInForce` is `GTC`.
     * @type {number}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly pendingBelowIcebergQty?: number;

    /**
     *
     * @type {string}
     * @memberof TradeApiMarginAccountNewOtoco
     */
    readonly pendingBelowTimeInForce?: string;
}

/**
 * Request parameters for marginManualLiquidation operation in TradeApi.
 * @interface MarginManualLiquidationRequest
 */
export interface MarginManualLiquidationRequest {
    /**
     * `MARGIN`,`ISOLATED`
     * @type {string}
     * @memberof TradeApiMarginManualLiquidation
     */
    readonly type: string;

    /**
     * isolated margin pair
     * @type {string}
     * @memberof TradeApiMarginManualLiquidation
     */
    readonly symbol?: string;

    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiMarginManualLiquidation
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for queryCurrentMarginOrderCountUsage operation in TradeApi.
 * @interface QueryCurrentMarginOrderCountUsageRequest
 */
export interface QueryCurrentMarginOrderCountUsageRequest {
    /**
     * for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
     * @type {string}
     * @memberof TradeApiQueryCurrentMarginOrderCountUsage
     */
    readonly isIsolated?: string;

    /**
     * isolated margin pair
     * @type {string}
     * @memberof TradeApiQueryCurrentMarginOrderCountUsage
     */
    readonly symbol?: string;

    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiQueryCurrentMarginOrderCountUsage
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for queryMarginAccountsAllOco operation in TradeApi.
 * @interface QueryMarginAccountsAllOcoRequest
 */
export interface QueryMarginAccountsAllOcoRequest {
    /**
     * for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
     * @type {string}
     * @memberof TradeApiQueryMarginAccountsAllOco
     */
    readonly isIsolated?: string;

    /**
     * isolated margin pair
     * @type {string}
     * @memberof TradeApiQueryMarginAccountsAllOco
     */
    readonly symbol?: string;

    /**
     * 如设置fromId, 将返回id > fromId的数据。否则将返回最新数据
     * @type {number}
     * @memberof TradeApiQueryMarginAccountsAllOco
     */
    readonly fromId?: number;

    /**
     * 只支持查询最近90天的数据
     * @type {number}
     * @memberof TradeApiQueryMarginAccountsAllOco
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiQueryMarginAccountsAllOco
     */
    readonly endTime?: number;

    /**
     * Default Value: 500; Max Value: 1000
     * @type {number}
     * @memberof TradeApiQueryMarginAccountsAllOco
     */
    readonly limit?: number;

    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiQueryMarginAccountsAllOco
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for queryMarginAccountsAllOrders operation in TradeApi.
 * @interface QueryMarginAccountsAllOrdersRequest
 */
export interface QueryMarginAccountsAllOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryMarginAccountsAllOrders
     */
    readonly symbol: string;

    /**
     * for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
     * @type {string}
     * @memberof TradeApiQueryMarginAccountsAllOrders
     */
    readonly isIsolated?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiQueryMarginAccountsAllOrders
     */
    readonly orderId?: number;

    /**
     * 只支持查询最近90天的数据
     * @type {number}
     * @memberof TradeApiQueryMarginAccountsAllOrders
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiQueryMarginAccountsAllOrders
     */
    readonly endTime?: number;

    /**
     * Default Value: 500; Max Value: 1000
     * @type {number}
     * @memberof TradeApiQueryMarginAccountsAllOrders
     */
    readonly limit?: number;

    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiQueryMarginAccountsAllOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for queryMarginAccountsOco operation in TradeApi.
 * @interface QueryMarginAccountsOcoRequest
 */
export interface QueryMarginAccountsOcoRequest {
    /**
     * for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
     * @type {string}
     * @memberof TradeApiQueryMarginAccountsOco
     */
    readonly isIsolated?: string;

    /**
     * isolated margin pair
     * @type {string}
     * @memberof TradeApiQueryMarginAccountsOco
     */
    readonly symbol?: string;

    /**
     * Either `orderListId` or `listClientOrderId` must be provided
     * @type {number}
     * @memberof TradeApiQueryMarginAccountsOco
     */
    readonly orderListId?: number;

    /**
     *
     * @type {string}
     * @memberof TradeApiQueryMarginAccountsOco
     */
    readonly origClientOrderId?: string;

    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiQueryMarginAccountsOco
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for queryMarginAccountsOpenOco operation in TradeApi.
 * @interface QueryMarginAccountsOpenOcoRequest
 */
export interface QueryMarginAccountsOpenOcoRequest {
    /**
     * for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
     * @type {string}
     * @memberof TradeApiQueryMarginAccountsOpenOco
     */
    readonly isIsolated?: string;

    /**
     * isolated margin pair
     * @type {string}
     * @memberof TradeApiQueryMarginAccountsOpenOco
     */
    readonly symbol?: string;

    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiQueryMarginAccountsOpenOco
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for queryMarginAccountsOpenOrders operation in TradeApi.
 * @interface QueryMarginAccountsOpenOrdersRequest
 */
export interface QueryMarginAccountsOpenOrdersRequest {
    /**
     * isolated margin pair
     * @type {string}
     * @memberof TradeApiQueryMarginAccountsOpenOrders
     */
    readonly symbol?: string;

    /**
     * for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
     * @type {string}
     * @memberof TradeApiQueryMarginAccountsOpenOrders
     */
    readonly isIsolated?: string;

    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiQueryMarginAccountsOpenOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for queryMarginAccountsOrder operation in TradeApi.
 * @interface QueryMarginAccountsOrderRequest
 */
export interface QueryMarginAccountsOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryMarginAccountsOrder
     */
    readonly symbol: string;

    /**
     * for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
     * @type {string}
     * @memberof TradeApiQueryMarginAccountsOrder
     */
    readonly isIsolated?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiQueryMarginAccountsOrder
     */
    readonly orderId?: number;

    /**
     *
     * @type {string}
     * @memberof TradeApiQueryMarginAccountsOrder
     */
    readonly origClientOrderId?: string;

    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiQueryMarginAccountsOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for queryMarginAccountsTradeList operation in TradeApi.
 * @interface QueryMarginAccountsTradeListRequest
 */
export interface QueryMarginAccountsTradeListRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryMarginAccountsTradeList
     */
    readonly symbol: string;

    /**
     * for isolated margin or not, "TRUE", "FALSE"，default "FALSE"
     * @type {string}
     * @memberof TradeApiQueryMarginAccountsTradeList
     */
    readonly isIsolated?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiQueryMarginAccountsTradeList
     */
    readonly orderId?: number;

    /**
     * 只支持查询最近90天的数据
     * @type {number}
     * @memberof TradeApiQueryMarginAccountsTradeList
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiQueryMarginAccountsTradeList
     */
    readonly endTime?: number;

    /**
     * 如设置fromId, 将返回id > fromId的数据。否则将返回最新数据
     * @type {number}
     * @memberof TradeApiQueryMarginAccountsTradeList
     */
    readonly fromId?: number;

    /**
     * Default Value: 500; Max Value: 1000
     * @type {number}
     * @memberof TradeApiQueryMarginAccountsTradeList
     */
    readonly limit?: number;

    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiQueryMarginAccountsTradeList
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for querySpecialKey operation in TradeApi.
 * @interface QuerySpecialKeyRequest
 */
export interface QuerySpecialKeyRequest {
    /**
     * isolated margin pair
     * @type {string}
     * @memberof TradeApiQuerySpecialKey
     */
    readonly symbol?: string;

    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiQuerySpecialKey
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for querySpecialKeyList operation in TradeApi.
 * @interface QuerySpecialKeyListRequest
 */
export interface QuerySpecialKeyListRequest {
    /**
     * isolated margin pair
     * @type {string}
     * @memberof TradeApiQuerySpecialKeyList
     */
    readonly symbol?: string;

    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiQuerySpecialKeyList
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for smallLiabilityExchange operation in TradeApi.
 * @interface SmallLiabilityExchangeRequest
 */
export interface SmallLiabilityExchangeRequest {
    /**
     * The assets list of small liability exchange， Example: assetNames = BTC,ETH
     * @type {Array<string>}
     * @memberof TradeApiSmallLiabilityExchange
     */
    readonly assetNames: Array<string>;

    /**
     * No more than 60000
     * @type {number}
     * @memberof TradeApiSmallLiabilityExchange
     */
    readonly recvWindow?: number;
}

/**
 * TradeApi - object-oriented interface
 * @class TradeApi
 */
export class TradeApi implements TradeApiInterface {
    private readonly configuration: ConfigurationRestAPI;
    private localVarAxiosParamCreator;

    constructor(configuration: ConfigurationRestAPI) {
        this.configuration = configuration;
        this.localVarAxiosParamCreator = TradeApiAxiosParamCreator(configuration);
    }

    /**
     * **Binance Margin offers low-latency trading through a [special key](https://www.binance.com/en/support/faq/frequently-asked-questions-on-margin-special-api-key-3208663e900d4d2e9fec4140e1832f4e), available exclusively to users with VIP level 4 or higher. **
     *
     **If you are VIP level 3 or below, please contact your VIP manager for eligibility criterias.**
     *
     * We support several types of API keys:
     *
     * Ed25519 (recommended)
     * HMAC
     * RSA
     *
     * We recommend to **use Ed25519 API keys** as it should provide the best performance and security out of all supported key types. We accept PKCS#8 (BEGIN PUBLIC KEY). For how to generate an RSA key pair to send API requests on Binance. Please refer to the document below [FAQ](https://www.binance.com/en/support/faq/how-to-generate-an-rsa-key-pair-to-send-api-requests-on-binance-2b79728f331e43079b27440d9d15c5db) .
     *
     * Read [REST API](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md#signed-trade-and-user_data-endpoint-security) or [WebSocket API](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-api.md#request-security) documentation to learn how to use different API keys
     *
     * You need to enable Permits “Enable Spot & Margin Trading” option for the API Key which requests this endpoint.
     *
     * Weight: 1(UID)
     *
     * @summary Create Special Key(Low-Latency Trading)(TRADE)
     * @param {CreateSpecialKeyRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CreateSpecialKeyResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Create-Special-Key-of-Low-Latency-Trading Binance API Documentation}
     */
    public async createSpecialKey(
        requestParameters: CreateSpecialKeyRequest
    ): Promise<RestApiResponse<CreateSpecialKeyResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.createSpecialKey(
            requestParameters?.apiName,
            requestParameters?.symbol,
            requestParameters?.ip,
            requestParameters?.publicKey,
            requestParameters?.permissionMode,
            requestParameters?.recvWindow
        );
        return sendRequest<CreateSpecialKeyResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * This only applies to Special Key for Low Latency Trading.
     *
     * If apiKey is given, apiName will be ignored. If apiName is given with no apiKey, all apikeys with given apiName will be deleted.
     *
     * You need to enable Permits “Enable Spot & Margin Trading” option for the API Key which requests this endpoint.
     *
     * Weight: 1(UID)
     *
     * @summary Delete Special Key(Low-Latency Trading)(TRADE)
     * @param {DeleteSpecialKeyRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<void>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Delete-Special-Key-of-Low-Latency-Trading Binance API Documentation}
     */
    public async deleteSpecialKey(
        requestParameters: DeleteSpecialKeyRequest = {}
    ): Promise<RestApiResponse<void>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.deleteSpecialKey(
            requestParameters?.apiName,
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<void>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Edit ip restriction. This only applies to Special Key for Low Latency Trading.
     *
     * You need to enable Permits “Enable Spot & Margin Trading” option for the API Key which requests this endpoint.
     *
     * Weight: 1(UID)
     *
     * @summary Edit ip for Special Key(Low-Latency Trading)(TRADE)
     * @param {EditIpForSpecialKeyRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<void>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Edit-ip-for-Special-Key-of-Low-Latency-Trading Binance API Documentation}
     */
    public async editIpForSpecialKey(
        requestParameters: EditIpForSpecialKeyRequest
    ): Promise<RestApiResponse<void>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.editIpForSpecialKey(
            requestParameters?.ip,
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<void>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get Force Liquidation Record
     *
     * Response in descending order
     *
     * Weight: 1(IP)
     *
     * @summary Get Force Liquidation Record (USER_DATA)
     * @param {GetForceLiquidationRecordRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetForceLiquidationRecordResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Get-Force-Liquidation-Record Binance API Documentation}
     */
    public async getForceLiquidationRecord(
        requestParameters: GetForceLiquidationRecordRequest = {}
    ): Promise<RestApiResponse<GetForceLiquidationRecordResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getForceLiquidationRecord(
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.isolatedSymbol,
            requestParameters?.current,
            requestParameters?.size,
            requestParameters?.recvWindow
        );
        return sendRequest<GetForceLiquidationRecordResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query the coins which can be small liability exchange
     *
     * Weight: 100
     *
     * @summary Get Small Liability Exchange Coin List (USER_DATA)
     * @param {GetSmallLiabilityExchangeCoinListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetSmallLiabilityExchangeCoinListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Get-Small-Liability-Exchange-Coin-List Binance API Documentation}
     */
    public async getSmallLiabilityExchangeCoinList(
        requestParameters: GetSmallLiabilityExchangeCoinListRequest = {}
    ): Promise<RestApiResponse<GetSmallLiabilityExchangeCoinListResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.getSmallLiabilityExchangeCoinList(
                requestParameters?.recvWindow
            );
        return sendRequest<GetSmallLiabilityExchangeCoinListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get Small liability Exchange History
     *
     * Weight: 100(UID)
     *
     * @summary Get Small Liability Exchange History (USER_DATA)
     * @param {GetSmallLiabilityExchangeHistoryRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetSmallLiabilityExchangeHistoryResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Get-Small-Liability-Exchange-History Binance API Documentation}
     */
    public async getSmallLiabilityExchangeHistory(
        requestParameters: GetSmallLiabilityExchangeHistoryRequest
    ): Promise<RestApiResponse<GetSmallLiabilityExchangeHistoryResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.getSmallLiabilityExchangeHistory(
                requestParameters?.current,
                requestParameters?.size,
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.recvWindow
            );
        return sendRequest<GetSmallLiabilityExchangeHistoryResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancels all active orders on a symbol for margin account.<br></br>
     * This includes OCO orders.
     *
     * Weight: 1
     *
     * @summary Margin Account Cancel all Open Orders on a Symbol (TRADE)
     * @param {MarginAccountCancelAllOpenOrdersOnASymbolRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MarginAccountCancelAllOpenOrdersOnASymbolResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Margin-Account-Cancel-All-Open-Orders Binance API Documentation}
     */
    public async marginAccountCancelAllOpenOrdersOnASymbol(
        requestParameters: MarginAccountCancelAllOpenOrdersOnASymbolRequest
    ): Promise<RestApiResponse<MarginAccountCancelAllOpenOrdersOnASymbolResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.marginAccountCancelAllOpenOrdersOnASymbol(
                requestParameters?.symbol,
                requestParameters?.isIsolated,
                requestParameters?.recvWindow
            );
        return sendRequest<MarginAccountCancelAllOpenOrdersOnASymbolResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel an entire Order List for a margin account.
     *
     * Canceling an individual leg will cancel the entire OCO
     *
     * Weight: 1(UID)
     *
     * @summary Margin Account Cancel OCO (TRADE)
     * @param {MarginAccountCancelOcoRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MarginAccountCancelOcoResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Margin-Account-Cancel-OCO Binance API Documentation}
     */
    public async marginAccountCancelOco(
        requestParameters: MarginAccountCancelOcoRequest
    ): Promise<RestApiResponse<MarginAccountCancelOcoResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.marginAccountCancelOco(
            requestParameters?.symbol,
            requestParameters?.isIsolated,
            requestParameters?.orderListId,
            requestParameters?.listClientOrderId,
            requestParameters?.newClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<MarginAccountCancelOcoResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel an active order for margin account.
     *
     * Either orderId or origClientOrderId must be sent.
     *
     * Weight: 10(IP)
     *
     * @summary Margin Account Cancel Order (TRADE)
     * @param {MarginAccountCancelOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MarginAccountCancelOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Margin-Account-Cancel-Order Binance API Documentation}
     */
    public async marginAccountCancelOrder(
        requestParameters: MarginAccountCancelOrderRequest
    ): Promise<RestApiResponse<MarginAccountCancelOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.marginAccountCancelOrder(
            requestParameters?.symbol,
            requestParameters?.isIsolated,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.newClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<MarginAccountCancelOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Send in a new OCO for a margin account
     *
     * autoRepayAtCancel is suggested to set as “FALSE” to keep liability unrepaid under high frequent new order/cancel order execution
     *
     * Weight: 6(UID)
     *
     * @summary Margin Account New OCO (TRADE)
     * @param {MarginAccountNewOcoRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MarginAccountNewOcoResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-OCO Binance API Documentation}
     */
    public async marginAccountNewOco(
        requestParameters: MarginAccountNewOcoRequest
    ): Promise<RestApiResponse<MarginAccountNewOcoResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.marginAccountNewOco(
            requestParameters?.symbol,
            requestParameters?.side,
            requestParameters?.quantity,
            requestParameters?.price,
            requestParameters?.stopPrice,
            requestParameters?.isIsolated,
            requestParameters?.listClientOrderId,
            requestParameters?.limitClientOrderId,
            requestParameters?.limitIcebergQty,
            requestParameters?.stopClientOrderId,
            requestParameters?.stopLimitPrice,
            requestParameters?.stopIcebergQty,
            requestParameters?.stopLimitTimeInForce,
            requestParameters?.newOrderRespType,
            requestParameters?.sideEffectType,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.autoRepayAtCancel,
            requestParameters?.recvWindow
        );
        return sendRequest<MarginAccountNewOcoResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Post a new order for margin account.
     *
     * autoRepayAtCancel is suggested to set as “FALSE” to keep liability unrepaid under high frequent new order/cancel order execution
     *
     * Weight: 6(UID)
     *
     * @summary Margin Account New Order (TRADE)
     * @param {MarginAccountNewOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MarginAccountNewOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-Order Binance API Documentation}
     */
    public async marginAccountNewOrder(
        requestParameters: MarginAccountNewOrderRequest
    ): Promise<RestApiResponse<MarginAccountNewOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.marginAccountNewOrder(
            requestParameters?.symbol,
            requestParameters?.side,
            requestParameters?.type,
            requestParameters?.isIsolated,
            requestParameters?.quantity,
            requestParameters?.quoteOrderQty,
            requestParameters?.price,
            requestParameters?.stopPrice,
            requestParameters?.newClientOrderId,
            requestParameters?.icebergQty,
            requestParameters?.newOrderRespType,
            requestParameters?.sideEffectType,
            requestParameters?.timeInForce,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.autoRepayAtCancel,
            requestParameters?.recvWindow
        );
        return sendRequest<MarginAccountNewOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Post a new OTO order for margin account:
     *
     * - An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders.
     * - The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
     * - The second order is called the **pending order**. It can be any order type except for `MARKET` orders using parameter `quoteOrderQty`. The pending order is only placed on the order book when the working order gets **fully filled**.
     * - If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired.
     * - When the order list is placed, if the working order gets **immediately fully filled**, the placement response will show the working order as `FILLED` but the pending order will still appear as `PENDING_NEW`. You need to query the status of the pending order again to see its updated status.
     * - OTOs add **2 orders** to the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
     *
     * autoRepayAtCancel is suggested to set as “FALSE” to keep liability unrepaid under high frequent new order/cancel order execution
     * Depending on the `pendingType` or `workingType`, some optional parameters will become mandatory:
     *
     * Weight: 6(UID)
     *
     * @summary Margin Account New OTO (TRADE)
     * @param {MarginAccountNewOtoRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MarginAccountNewOtoResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-OTO Binance API Documentation}
     */
    public async marginAccountNewOto(
        requestParameters: MarginAccountNewOtoRequest
    ): Promise<RestApiResponse<MarginAccountNewOtoResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.marginAccountNewOto(
            requestParameters?.symbol,
            requestParameters?.workingType,
            requestParameters?.workingSide,
            requestParameters?.workingPrice,
            requestParameters?.workingQuantity,
            requestParameters?.workingIcebergQty,
            requestParameters?.pendingType,
            requestParameters?.pendingSide,
            requestParameters?.pendingQuantity,
            requestParameters?.isIsolated,
            requestParameters?.listClientOrderId,
            requestParameters?.newOrderRespType,
            requestParameters?.sideEffectType,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.autoRepayAtCancel,
            requestParameters?.workingClientOrderId,
            requestParameters?.workingTimeInForce,
            requestParameters?.pendingClientOrderId,
            requestParameters?.pendingPrice,
            requestParameters?.pendingStopPrice,
            requestParameters?.pendingTrailingDelta,
            requestParameters?.pendingIcebergQty,
            requestParameters?.pendingTimeInForce
        );
        return sendRequest<MarginAccountNewOtoResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Post a new OTOCO order for margin account：
     *
     * - An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders.
     * - The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
     * - The behavior of the working order is the same as the OTO.
     * - OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets **fully filled**.
     * - The rules of the pending above and pending below follow the same rules as the [Order List OCO](https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-OCO).
     * - OTOCOs add **3 orders** against the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter, and `MAX_NUM_ORDERS` filter.
     *
     * autoRepayAtCancel is suggested to set as “FALSE” to keep liability unrepaid under high frequent new order/cancel order execution
     * Depending on the `pendingAboveType`/`pendingBelowType` or `workingType`, some optional parameters will become mandatory:
     *
     * Weight: 6(UID)
     *
     * @summary Margin Account New OTOCO (TRADE)
     * @param {MarginAccountNewOtocoRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MarginAccountNewOtocoResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-OTOCO Binance API Documentation}
     */
    public async marginAccountNewOtoco(
        requestParameters: MarginAccountNewOtocoRequest
    ): Promise<RestApiResponse<MarginAccountNewOtocoResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.marginAccountNewOtoco(
            requestParameters?.symbol,
            requestParameters?.workingType,
            requestParameters?.workingSide,
            requestParameters?.workingPrice,
            requestParameters?.workingQuantity,
            requestParameters?.pendingSide,
            requestParameters?.pendingQuantity,
            requestParameters?.pendingAboveType,
            requestParameters?.isIsolated,
            requestParameters?.sideEffectType,
            requestParameters?.autoRepayAtCancel,
            requestParameters?.listClientOrderId,
            requestParameters?.newOrderRespType,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.workingClientOrderId,
            requestParameters?.workingIcebergQty,
            requestParameters?.workingTimeInForce,
            requestParameters?.pendingAboveClientOrderId,
            requestParameters?.pendingAbovePrice,
            requestParameters?.pendingAboveStopPrice,
            requestParameters?.pendingAboveTrailingDelta,
            requestParameters?.pendingAboveIcebergQty,
            requestParameters?.pendingAboveTimeInForce,
            requestParameters?.pendingBelowType,
            requestParameters?.pendingBelowClientOrderId,
            requestParameters?.pendingBelowPrice,
            requestParameters?.pendingBelowStopPrice,
            requestParameters?.pendingBelowTrailingDelta,
            requestParameters?.pendingBelowIcebergQty,
            requestParameters?.pendingBelowTimeInForce
        );
        return sendRequest<MarginAccountNewOtocoResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Margin Manual Liquidation
     *
     * This endpoint can support Cross Margin Classic Mode and Pro Mode.
     * And only support Isolated Margin for restricted region.
     *
     * Weight: 3000
     *
     * @summary Margin Manual Liquidation(MARGIN)
     * @param {MarginManualLiquidationRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MarginManualLiquidationResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Margin-Manual-Liquidation Binance API Documentation}
     */
    public async marginManualLiquidation(
        requestParameters: MarginManualLiquidationRequest
    ): Promise<RestApiResponse<MarginManualLiquidationResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.marginManualLiquidation(
            requestParameters?.type,
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<MarginManualLiquidationResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Displays the user's current margin order count usage for all intervals.
     *
     * Weight: 20(IP)
     *
     * @summary Query Current Margin Order Count Usage (TRADE)
     * @param {QueryCurrentMarginOrderCountUsageRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryCurrentMarginOrderCountUsageResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Query-Current-Margin-Order-Count-Usage Binance API Documentation}
     */
    public async queryCurrentMarginOrderCountUsage(
        requestParameters: QueryCurrentMarginOrderCountUsageRequest = {}
    ): Promise<RestApiResponse<QueryCurrentMarginOrderCountUsageResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.queryCurrentMarginOrderCountUsage(
                requestParameters?.isIsolated,
                requestParameters?.symbol,
                requestParameters?.recvWindow
            );
        return sendRequest<QueryCurrentMarginOrderCountUsageResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Retrieves all OCO for a specific margin account based on provided optional parameters
     *
     * Weight: 200(IP)
     *
     * @summary Query Margin Account\'s all OCO (USER_DATA)
     * @param {QueryMarginAccountsAllOcoRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryMarginAccountsAllOcoResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-all-OCO Binance API Documentation}
     */
    public async queryMarginAccountsAllOco(
        requestParameters: QueryMarginAccountsAllOcoRequest = {}
    ): Promise<RestApiResponse<QueryMarginAccountsAllOcoResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryMarginAccountsAllOco(
            requestParameters?.isIsolated,
            requestParameters?.symbol,
            requestParameters?.fromId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryMarginAccountsAllOcoResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query Margin Account's All Orders
     *
     * If orderId is set, it will get orders >= that orderId. Otherwise the orders within 24 hours are returned.
     * For some historical orders cummulativeQuoteQty will be < 0, meaning the data is not available at this time.
     * Less than 24 hours between startTime and endTime.
     *
     * Weight: 200(IP)
     *
     * @summary Query Margin Account\'s All Orders (USER_DATA)
     * @param {QueryMarginAccountsAllOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryMarginAccountsAllOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-All-Orders Binance API Documentation}
     */
    public async queryMarginAccountsAllOrders(
        requestParameters: QueryMarginAccountsAllOrdersRequest
    ): Promise<RestApiResponse<QueryMarginAccountsAllOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryMarginAccountsAllOrders(
            requestParameters?.symbol,
            requestParameters?.isIsolated,
            requestParameters?.orderId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryMarginAccountsAllOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Retrieves a specific OCO based on provided optional parameters
     *
     * Weight: 10(IP)
     *
     * @summary Query Margin Account\'s OCO (USER_DATA)
     * @param {QueryMarginAccountsOcoRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryMarginAccountsOcoResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-OCO Binance API Documentation}
     */
    public async queryMarginAccountsOco(
        requestParameters: QueryMarginAccountsOcoRequest = {}
    ): Promise<RestApiResponse<QueryMarginAccountsOcoResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryMarginAccountsOco(
            requestParameters?.isIsolated,
            requestParameters?.symbol,
            requestParameters?.orderListId,
            requestParameters?.origClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryMarginAccountsOcoResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query Margin Account's Open OCO
     *
     * Weight: 10(IP)
     *
     * @summary Query Margin Account\'s Open OCO (USER_DATA)
     * @param {QueryMarginAccountsOpenOcoRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryMarginAccountsOpenOcoResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-Open-OCO Binance API Documentation}
     */
    public async queryMarginAccountsOpenOco(
        requestParameters: QueryMarginAccountsOpenOcoRequest = {}
    ): Promise<RestApiResponse<QueryMarginAccountsOpenOcoResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryMarginAccountsOpenOco(
            requestParameters?.isIsolated,
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryMarginAccountsOpenOcoResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query Margin Account's Open Orders
     *
     * If the symbol is not sent, orders for all symbols will be returned in an array.
     * When all symbols are returned, the number of requests counted against the rate limiter is equal to the number of symbols currently trading on the exchange.
     * If isIsolated ="TRUE", symbol must be sent.
     *
     * Weight: 10(IP)
     *
     * @summary Query Margin Account\'s Open Orders (USER_DATA)
     * @param {QueryMarginAccountsOpenOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryMarginAccountsOpenOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-Open-Orders Binance API Documentation}
     */
    public async queryMarginAccountsOpenOrders(
        requestParameters: QueryMarginAccountsOpenOrdersRequest = {}
    ): Promise<RestApiResponse<QueryMarginAccountsOpenOrdersResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.queryMarginAccountsOpenOrders(
                requestParameters?.symbol,
                requestParameters?.isIsolated,
                requestParameters?.recvWindow
            );
        return sendRequest<QueryMarginAccountsOpenOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query Margin Account's Order
     *
     * Either orderId or origClientOrderId must be sent.
     * For some historical orders cummulativeQuoteQty will be < 0, meaning the data is not available at this time.
     *
     * Weight: 10(IP)
     *
     * @summary Query Margin Account\'s Order (USER_DATA)
     * @param {QueryMarginAccountsOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryMarginAccountsOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-Order Binance API Documentation}
     */
    public async queryMarginAccountsOrder(
        requestParameters: QueryMarginAccountsOrderRequest
    ): Promise<RestApiResponse<QueryMarginAccountsOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryMarginAccountsOrder(
            requestParameters?.symbol,
            requestParameters?.isIsolated,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryMarginAccountsOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query Margin Account's Trade List
     *
     * If fromId is set, it will get trades >= that fromId. Otherwise the trades within 24 hours are returned.
     * Less than 24 hours between startTime and endTime.
     *
     * Weight: 10(IP)
     *
     * @summary Query Margin Account\'s Trade List (USER_DATA)
     * @param {QueryMarginAccountsTradeListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryMarginAccountsTradeListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-Trade-List Binance API Documentation}
     */
    public async queryMarginAccountsTradeList(
        requestParameters: QueryMarginAccountsTradeListRequest
    ): Promise<RestApiResponse<QueryMarginAccountsTradeListResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryMarginAccountsTradeList(
            requestParameters?.symbol,
            requestParameters?.isIsolated,
            requestParameters?.orderId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.fromId,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryMarginAccountsTradeListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query Special Key Information.
     *
     * This only applies to Special Key for Low Latency Trading.
     *
     * Weight: 1(UID)
     *
     * @summary Query Special key(Low Latency Trading)(TRADE)
     * @param {QuerySpecialKeyRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QuerySpecialKeyResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Query-Special-Key-of-Low-Latency-Trading Binance API Documentation}
     */
    public async querySpecialKey(
        requestParameters: QuerySpecialKeyRequest = {}
    ): Promise<RestApiResponse<QuerySpecialKeyResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.querySpecialKey(
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<QuerySpecialKeyResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * This only applies to Special Key for Low Latency Trading.
     *
     * Weight: 1(UID)
     *
     * @summary Query Special key List(Low Latency Trading)(TRADE)
     * @param {QuerySpecialKeyListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QuerySpecialKeyListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Query-Special-Key-List-of-Low-Latency-Trading Binance API Documentation}
     */
    public async querySpecialKeyList(
        requestParameters: QuerySpecialKeyListRequest = {}
    ): Promise<RestApiResponse<QuerySpecialKeyListResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.querySpecialKeyList(
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<QuerySpecialKeyListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Small Liability Exchange
     *
     * Only convert once within 6 hours
     * Only liability valuation less than 10 USDT are supported
     * The maximum number of coin is 10
     *
     * Weight: 3000(UID)
     *
     * @summary Small Liability Exchange (MARGIN)
     * @param {SmallLiabilityExchangeRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<void>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/margin_trading/trade/Small-Liability-Exchange Binance API Documentation}
     */
    public async smallLiabilityExchange(
        requestParameters: SmallLiabilityExchangeRequest
    ): Promise<RestApiResponse<void>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.smallLiabilityExchange(
            requestParameters?.assetNames,
            requestParameters?.recvWindow
        );
        return sendRequest<void>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }
}

export const MarginAccountNewOcoSideEnum = {
    BUY: 'BUY',
    SELL: 'SELL',
} as const;
export type MarginAccountNewOcoSideEnum =
    (typeof MarginAccountNewOcoSideEnum)[keyof typeof MarginAccountNewOcoSideEnum];

export const MarginAccountNewOcoNewOrderRespTypeEnum = {
    ACK: 'ACK',
    RESULT: 'RESULT',
    FULL: 'FULL',
} as const;
export type MarginAccountNewOcoNewOrderRespTypeEnum =
    (typeof MarginAccountNewOcoNewOrderRespTypeEnum)[keyof typeof MarginAccountNewOcoNewOrderRespTypeEnum];

export const MarginAccountNewOrderSideEnum = {
    BUY: 'BUY',
    SELL: 'SELL',
} as const;
export type MarginAccountNewOrderSideEnum =
    (typeof MarginAccountNewOrderSideEnum)[keyof typeof MarginAccountNewOrderSideEnum];

export const MarginAccountNewOrderNewOrderRespTypeEnum = {
    ACK: 'ACK',
    RESULT: 'RESULT',
    FULL: 'FULL',
} as const;
export type MarginAccountNewOrderNewOrderRespTypeEnum =
    (typeof MarginAccountNewOrderNewOrderRespTypeEnum)[keyof typeof MarginAccountNewOrderNewOrderRespTypeEnum];

export const MarginAccountNewOrderTimeInForceEnum = {
    GTC: 'GTC',
    IOC: 'IOC',
    FOK: 'FOK',
} as const;
export type MarginAccountNewOrderTimeInForceEnum =
    (typeof MarginAccountNewOrderTimeInForceEnum)[keyof typeof MarginAccountNewOrderTimeInForceEnum];

export const MarginAccountNewOtoNewOrderRespTypeEnum = {
    ACK: 'ACK',
    RESULT: 'RESULT',
    FULL: 'FULL',
} as const;
export type MarginAccountNewOtoNewOrderRespTypeEnum =
    (typeof MarginAccountNewOtoNewOrderRespTypeEnum)[keyof typeof MarginAccountNewOtoNewOrderRespTypeEnum];

export const MarginAccountNewOtocoNewOrderRespTypeEnum = {
    ACK: 'ACK',
    RESULT: 'RESULT',
    FULL: 'FULL',
} as const;
export type MarginAccountNewOtocoNewOrderRespTypeEnum =
    (typeof MarginAccountNewOtocoNewOrderRespTypeEnum)[keyof typeof MarginAccountNewOtocoNewOrderRespTypeEnum];
