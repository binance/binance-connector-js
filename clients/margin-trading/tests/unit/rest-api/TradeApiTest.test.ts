/**
 * Binance Margin Trading REST API
 *
 * OpenAPI Specification for the Binance Margin Trading REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import {
    TradeApi,
    MarginAccountNewOcoSideEnum,
    MarginAccountNewOcoNewOrderRespTypeEnum,
    MarginAccountNewOrderSideEnum,
    MarginAccountNewOrderNewOrderRespTypeEnum,
    MarginAccountNewOrderTimeInForceEnum,
    MarginAccountNewOtoNewOrderRespTypeEnum,
    MarginAccountNewOtocoNewOrderRespTypeEnum,
} from '../../../src/rest-api';
import {
    CreateSpecialKeyRequest,
    DeleteSpecialKeyRequest,
    EditIpForSpecialKeyRequest,
    GetForceLiquidationRecordRequest,
    GetSmallLiabilityExchangeCoinListRequest,
    GetSmallLiabilityExchangeHistoryRequest,
    MarginAccountCancelAllOpenOrdersOnASymbolRequest,
    MarginAccountCancelOcoRequest,
    MarginAccountCancelOrderRequest,
    MarginAccountNewOcoRequest,
    MarginAccountNewOrderRequest,
    MarginAccountNewOtoRequest,
    MarginAccountNewOtocoRequest,
    MarginManualLiquidationRequest,
    QueryCurrentMarginOrderCountUsageRequest,
    QueryMarginAccountsAllOcoRequest,
    QueryMarginAccountsAllOrdersRequest,
    QueryMarginAccountsOcoRequest,
    QueryMarginAccountsOpenOcoRequest,
    QueryMarginAccountsOpenOrdersRequest,
    QueryMarginAccountsOrderRequest,
    QueryMarginAccountsTradeListRequest,
    QuerySpecialKeyRequest,
    QuerySpecialKeyListRequest,
    SmallLiabilityExchangeRequest,
} from '../../../src/rest-api';
import type {
    CreateSpecialKeyResponse,
    GetForceLiquidationRecordResponse,
    GetSmallLiabilityExchangeCoinListResponse,
    GetSmallLiabilityExchangeHistoryResponse,
    MarginAccountCancelAllOpenOrdersOnASymbolResponse,
    MarginAccountCancelOcoResponse,
    MarginAccountCancelOrderResponse,
    MarginAccountNewOcoResponse,
    MarginAccountNewOrderResponse,
    MarginAccountNewOtoResponse,
    MarginAccountNewOtocoResponse,
    MarginManualLiquidationResponse,
    QueryCurrentMarginOrderCountUsageResponse,
    QueryMarginAccountsAllOcoResponse,
    QueryMarginAccountsAllOrdersResponse,
    QueryMarginAccountsOcoResponse,
    QueryMarginAccountsOpenOcoResponse,
    QueryMarginAccountsOpenOrdersResponse,
    QueryMarginAccountsOrderResponse,
    QueryMarginAccountsTradeListResponse,
    QuerySpecialKeyListResponse,
    QuerySpecialKeyResponse,
} from '../../../src/rest-api/types';

describe('TradeApi', () => {
    let client: TradeApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new TradeApi(config);
    });

    describe('createSpecialKey()', () => {
        it('should execute createSpecialKey() successfully with required parameters only', async () => {
            const params: CreateSpecialKeyRequest = {
                apiName: 'apiName_example',
            };

            mockResponse = {
                apiKey: 'npOzOAeLVgr2TuxWfNo43AaPWpBbJEoKezh1o8mSQb6ryE2odE11A4AoVlJbQoGx',
                secretKey: '87ssWB7azoy6ACRfyp6OVOL5U3rtZptX31QWw2kWjl1jHEYRbyM1pd6qykRBQw8p',
                type: 'HMAC_SHA256',
            };

            const spy = jest.spyOn(client, 'createSpecialKey').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CreateSpecialKeyResponse>)
            );
            const response = await client.createSpecialKey(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute createSpecialKey() successfully with optional parameters', async () => {
            const params: CreateSpecialKeyRequest = {
                apiName: 'apiName_example',
                symbol: 'symbol_example',
                ip: 'ip_example',
                publicKey: 'publicKey_example',
                permissionMode: 'value',
                recvWindow: 5000,
            };

            mockResponse = {
                apiKey: 'npOzOAeLVgr2TuxWfNo43AaPWpBbJEoKezh1o8mSQb6ryE2odE11A4AoVlJbQoGx',
                secretKey: '87ssWB7azoy6ACRfyp6OVOL5U3rtZptX31QWw2kWjl1jHEYRbyM1pd6qykRBQw8p',
                type: 'HMAC_SHA256',
            };

            const spy = jest.spyOn(client, 'createSpecialKey').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CreateSpecialKeyResponse>)
            );
            const response = await client.createSpecialKey(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when apiName is missing', async () => {
            const _params: CreateSpecialKeyRequest = {
                apiName: 'apiName_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.apiName;

            await expect(client.createSpecialKey(params)).rejects.toThrow(
                'Required parameter apiName was null or undefined when calling createSpecialKey.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CreateSpecialKeyRequest = {
                apiName: 'apiName_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'createSpecialKey').mockRejectedValueOnce(mockError);
            await expect(client.createSpecialKey(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('deleteSpecialKey()', () => {
        it('should execute deleteSpecialKey() successfully with required parameters only', async () => {
            const spy = jest.spyOn(client, 'deleteSpecialKey').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.deleteSpecialKey();

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should execute deleteSpecialKey() successfully with optional parameters', async () => {
            const params: DeleteSpecialKeyRequest = {
                apiName: 'apiName_example',
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            const spy = jest.spyOn(client, 'deleteSpecialKey').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.deleteSpecialKey(params);

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'deleteSpecialKey').mockRejectedValueOnce(mockError);
            await expect(client.deleteSpecialKey()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('editIpForSpecialKey()', () => {
        it('should execute editIpForSpecialKey() successfully with required parameters only', async () => {
            const params: EditIpForSpecialKeyRequest = {
                ip: 'ip_example',
            };

            const spy = jest.spyOn(client, 'editIpForSpecialKey').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.editIpForSpecialKey(params);

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should execute editIpForSpecialKey() successfully with optional parameters', async () => {
            const params: EditIpForSpecialKeyRequest = {
                ip: 'ip_example',
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            const spy = jest.spyOn(client, 'editIpForSpecialKey').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.editIpForSpecialKey(params);

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should throw RequiredError when ip is missing', async () => {
            const _params: EditIpForSpecialKeyRequest = {
                ip: 'ip_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.ip;

            await expect(client.editIpForSpecialKey(params)).rejects.toThrow(
                'Required parameter ip was null or undefined when calling editIpForSpecialKey.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: EditIpForSpecialKeyRequest = {
                ip: 'ip_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'editIpForSpecialKey').mockRejectedValueOnce(mockError);
            await expect(client.editIpForSpecialKey(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getForceLiquidationRecord()', () => {
        it('should execute getForceLiquidationRecord() successfully with required parameters only', async () => {
            mockResponse = {
                rows: [
                    {
                        avgPrice: '0.00388359',
                        executedQty: '31.39000000',
                        orderId: 180015097,
                        price: '0.00388110',
                        qty: '31.39000000',
                        side: 'SELL',
                        symbol: 'BNBBTC',
                        timeInForce: 'GTC',
                        isIsolated: true,
                        updatedTime: 1558941374745,
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getForceLiquidationRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetForceLiquidationRecordResponse>)
            );
            const response = await client.getForceLiquidationRecord();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getForceLiquidationRecord() successfully with optional parameters', async () => {
            const params: GetForceLiquidationRecordRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                isolatedSymbol: 'isolatedSymbol_example',
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        avgPrice: '0.00388359',
                        executedQty: '31.39000000',
                        orderId: 180015097,
                        price: '0.00388110',
                        qty: '31.39000000',
                        side: 'SELL',
                        symbol: 'BNBBTC',
                        timeInForce: 'GTC',
                        isIsolated: true,
                        updatedTime: 1558941374745,
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getForceLiquidationRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetForceLiquidationRecordResponse>)
            );
            const response = await client.getForceLiquidationRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getForceLiquidationRecord')
                .mockRejectedValueOnce(mockError);
            await expect(client.getForceLiquidationRecord()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getSmallLiabilityExchangeCoinList()', () => {
        it('should execute getSmallLiabilityExchangeCoinList() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    asset: 'ETH',
                    interest: '0.00083334',
                    principal: '0.001',
                    liabilityAsset: 'USDT',
                    liabilityQty: 0.3552,
                },
            ];

            const spy = jest.spyOn(client, 'getSmallLiabilityExchangeCoinList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSmallLiabilityExchangeCoinListResponse>)
            );
            const response = await client.getSmallLiabilityExchangeCoinList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSmallLiabilityExchangeCoinList() successfully with optional parameters', async () => {
            const params: GetSmallLiabilityExchangeCoinListRequest = {
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    asset: 'ETH',
                    interest: '0.00083334',
                    principal: '0.001',
                    liabilityAsset: 'USDT',
                    liabilityQty: 0.3552,
                },
            ];

            const spy = jest.spyOn(client, 'getSmallLiabilityExchangeCoinList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSmallLiabilityExchangeCoinListResponse>)
            );
            const response = await client.getSmallLiabilityExchangeCoinList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getSmallLiabilityExchangeCoinList')
                .mockRejectedValueOnce(mockError);
            await expect(client.getSmallLiabilityExchangeCoinList()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getSmallLiabilityExchangeHistory()', () => {
        it('should execute getSmallLiabilityExchangeHistory() successfully with required parameters only', async () => {
            const params: GetSmallLiabilityExchangeHistoryRequest = {
                current: 1,
                size: 10,
            };

            mockResponse = {
                total: 1,
                rows: [
                    {
                        asset: 'ETH',
                        amount: '0.00083434',
                        targetAsset: 'BUSD',
                        targetAmount: '1.37576819',
                        bizType: 'EXCHANGE_SMALL_LIABILITY',
                        timestamp: 1672801339253,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'getSmallLiabilityExchangeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSmallLiabilityExchangeHistoryResponse>)
            );
            const response = await client.getSmallLiabilityExchangeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSmallLiabilityExchangeHistory() successfully with optional parameters', async () => {
            const params: GetSmallLiabilityExchangeHistoryRequest = {
                current: 1,
                size: 10,
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = {
                total: 1,
                rows: [
                    {
                        asset: 'ETH',
                        amount: '0.00083434',
                        targetAsset: 'BUSD',
                        targetAmount: '1.37576819',
                        bizType: 'EXCHANGE_SMALL_LIABILITY',
                        timestamp: 1672801339253,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'getSmallLiabilityExchangeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSmallLiabilityExchangeHistoryResponse>)
            );
            const response = await client.getSmallLiabilityExchangeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when current is missing', async () => {
            const _params: GetSmallLiabilityExchangeHistoryRequest = {
                current: 1,
                size: 10,
            };
            const params = Object.assign({ ..._params });
            delete params?.current;

            await expect(client.getSmallLiabilityExchangeHistory(params)).rejects.toThrow(
                'Required parameter current was null or undefined when calling getSmallLiabilityExchangeHistory.'
            );
        });

        it('should throw RequiredError when size is missing', async () => {
            const _params: GetSmallLiabilityExchangeHistoryRequest = {
                current: 1,
                size: 10,
            };
            const params = Object.assign({ ..._params });
            delete params?.size;

            await expect(client.getSmallLiabilityExchangeHistory(params)).rejects.toThrow(
                'Required parameter size was null or undefined when calling getSmallLiabilityExchangeHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetSmallLiabilityExchangeHistoryRequest = {
                current: 1,
                size: 10,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getSmallLiabilityExchangeHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getSmallLiabilityExchangeHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('marginAccountCancelAllOpenOrdersOnASymbol()', () => {
        it('should execute marginAccountCancelAllOpenOrdersOnASymbol() successfully with required parameters only', async () => {
            const params: MarginAccountCancelAllOpenOrdersOnASymbolRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    isIsolated: true,
                    origClientOrderId: 'E6APeyTJvkMvLMYMqu1KQ4',
                    orderId: 11,
                    orderListId: -1,
                    clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                    price: '0.089853',
                    origQty: '0.178622',
                    executedQty: '0.000000',
                    cummulativeQuoteQty: '0.000000',
                    status: 'CANCELED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    selfTradePreventionMode: 'NONE',
                },
                {
                    symbol: 'BTCUSDT',
                    isIsolated: false,
                    origClientOrderId: 'A3EF2HCwxgZPFMrfwbgrhv',
                    orderId: 13,
                    orderListId: -1,
                    clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                    price: '0.090430',
                    origQty: '0.178622',
                    executedQty: '0.000000',
                    cummulativeQuoteQty: '0.000000',
                    status: 'CANCELED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    selfTradePreventionMode: 'NONE',
                },
                {
                    orderListId: 1929,
                    contingencyType: 'OCO',
                    listStatusType: 'ALL_DONE',
                    listOrderStatus: 'ALL_DONE',
                    listClientOrderId: '2inzWQdDvZLHbbAmAozX2N',
                    transactionTime: 1585230948299,
                    symbol: 'BTCUSDT',
                    isIsolated: true,
                    orders: [
                        { symbol: 'BTCUSDT', orderId: 20, clientOrderId: 'CwOOIPHSmYywx6jZX77TdL' },
                        { symbol: 'BTCUSDT', orderId: 21, clientOrderId: '461cPg51vQjV3zIMOXNz39' },
                    ],
                    orderReports: [
                        {
                            symbol: 'BTCUSDT',
                            origClientOrderId: 'CwOOIPHSmYywx6jZX77TdL',
                            orderId: 20,
                            orderListId: 1929,
                            clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                            price: '0.668611',
                            origQty: '0.690354',
                            executedQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'STOP_LOSS_LIMIT',
                            side: 'BUY',
                            stopPrice: '0.378131',
                            icebergQty: '0.017083',
                        },
                        {
                            symbol: 'BTCUSDT',
                            origClientOrderId: '461cPg51vQjV3zIMOXNz39',
                            orderId: 21,
                            orderListId: 1929,
                            clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                            price: '0.008791',
                            origQty: '0.690354',
                            executedQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'BUY',
                            icebergQty: '0.639962',
                        },
                    ],
                },
            ];

            const spy = jest
                .spyOn(client, 'marginAccountCancelAllOpenOrdersOnASymbol')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<MarginAccountCancelAllOpenOrdersOnASymbolResponse>)
                );
            const response = await client.marginAccountCancelAllOpenOrdersOnASymbol(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute marginAccountCancelAllOpenOrdersOnASymbol() successfully with optional parameters', async () => {
            const params: MarginAccountCancelAllOpenOrdersOnASymbolRequest = {
                symbol: 'symbol_example',
                isIsolated: 'false',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    isIsolated: true,
                    origClientOrderId: 'E6APeyTJvkMvLMYMqu1KQ4',
                    orderId: 11,
                    orderListId: -1,
                    clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                    price: '0.089853',
                    origQty: '0.178622',
                    executedQty: '0.000000',
                    cummulativeQuoteQty: '0.000000',
                    status: 'CANCELED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    selfTradePreventionMode: 'NONE',
                },
                {
                    symbol: 'BTCUSDT',
                    isIsolated: false,
                    origClientOrderId: 'A3EF2HCwxgZPFMrfwbgrhv',
                    orderId: 13,
                    orderListId: -1,
                    clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                    price: '0.090430',
                    origQty: '0.178622',
                    executedQty: '0.000000',
                    cummulativeQuoteQty: '0.000000',
                    status: 'CANCELED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    selfTradePreventionMode: 'NONE',
                },
                {
                    orderListId: 1929,
                    contingencyType: 'OCO',
                    listStatusType: 'ALL_DONE',
                    listOrderStatus: 'ALL_DONE',
                    listClientOrderId: '2inzWQdDvZLHbbAmAozX2N',
                    transactionTime: 1585230948299,
                    symbol: 'BTCUSDT',
                    isIsolated: true,
                    orders: [
                        { symbol: 'BTCUSDT', orderId: 20, clientOrderId: 'CwOOIPHSmYywx6jZX77TdL' },
                        { symbol: 'BTCUSDT', orderId: 21, clientOrderId: '461cPg51vQjV3zIMOXNz39' },
                    ],
                    orderReports: [
                        {
                            symbol: 'BTCUSDT',
                            origClientOrderId: 'CwOOIPHSmYywx6jZX77TdL',
                            orderId: 20,
                            orderListId: 1929,
                            clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                            price: '0.668611',
                            origQty: '0.690354',
                            executedQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'STOP_LOSS_LIMIT',
                            side: 'BUY',
                            stopPrice: '0.378131',
                            icebergQty: '0.017083',
                        },
                        {
                            symbol: 'BTCUSDT',
                            origClientOrderId: '461cPg51vQjV3zIMOXNz39',
                            orderId: 21,
                            orderListId: 1929,
                            clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                            price: '0.008791',
                            origQty: '0.690354',
                            executedQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'BUY',
                            icebergQty: '0.639962',
                        },
                    ],
                },
            ];

            const spy = jest
                .spyOn(client, 'marginAccountCancelAllOpenOrdersOnASymbol')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<MarginAccountCancelAllOpenOrdersOnASymbolResponse>)
                );
            const response = await client.marginAccountCancelAllOpenOrdersOnASymbol(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MarginAccountCancelAllOpenOrdersOnASymbolRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.marginAccountCancelAllOpenOrdersOnASymbol(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling marginAccountCancelAllOpenOrdersOnASymbol.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MarginAccountCancelAllOpenOrdersOnASymbolRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'marginAccountCancelAllOpenOrdersOnASymbol')
                .mockRejectedValueOnce(mockError);
            await expect(client.marginAccountCancelAllOpenOrdersOnASymbol(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('marginAccountCancelOco()', () => {
        it('should execute marginAccountCancelOco() successfully with required parameters only', async () => {
            const params: MarginAccountCancelOcoRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                orderListId: 0,
                contingencyType: 'OCO',
                listStatusType: 'ALL_DONE',
                listOrderStatus: 'ALL_DONE',
                listClientOrderId: 'C3wyj4WVEktd7u9aVBRXcN',
                transactionTime: 1574040868128,
                symbol: 'LTCBTC',
                isIsolated: false,
                orders: [
                    { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'pO9ufTiFGg3nw2fOdgeOXa' },
                    { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'TXOvglzXuaubXAaENpaRCB' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        origClientOrderId: 'pO9ufTiFGg3nw2fOdgeOXa',
                        orderId: 2,
                        orderListId: 0,
                        clientOrderId: 'unfWT8ig8i0uj6lPuYLez6',
                        price: '1.00000000',
                        origQty: '10.00000000',
                        executedQty: '0.00000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'STOP_LOSS_LIMIT',
                        side: 'SELL',
                        stopPrice: '1.00000000',
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        origClientOrderId: 'TXOvglzXuaubXAaENpaRCB',
                        orderId: 3,
                        orderListId: 0,
                        clientOrderId: 'unfWT8ig8i0uj6lPuYLez6',
                        price: '3.00000000',
                        origQty: '10.00000000',
                        executedQty: '0.00000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'SELL',
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'marginAccountCancelOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountCancelOcoResponse>)
            );
            const response = await client.marginAccountCancelOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute marginAccountCancelOco() successfully with optional parameters', async () => {
            const params: MarginAccountCancelOcoRequest = {
                symbol: 'symbol_example',
                isIsolated: 'false',
                orderListId: 1,
                listClientOrderId: '1',
                newClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                orderListId: 0,
                contingencyType: 'OCO',
                listStatusType: 'ALL_DONE',
                listOrderStatus: 'ALL_DONE',
                listClientOrderId: 'C3wyj4WVEktd7u9aVBRXcN',
                transactionTime: 1574040868128,
                symbol: 'LTCBTC',
                isIsolated: false,
                orders: [
                    { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'pO9ufTiFGg3nw2fOdgeOXa' },
                    { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'TXOvglzXuaubXAaENpaRCB' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        origClientOrderId: 'pO9ufTiFGg3nw2fOdgeOXa',
                        orderId: 2,
                        orderListId: 0,
                        clientOrderId: 'unfWT8ig8i0uj6lPuYLez6',
                        price: '1.00000000',
                        origQty: '10.00000000',
                        executedQty: '0.00000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'STOP_LOSS_LIMIT',
                        side: 'SELL',
                        stopPrice: '1.00000000',
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        origClientOrderId: 'TXOvglzXuaubXAaENpaRCB',
                        orderId: 3,
                        orderListId: 0,
                        clientOrderId: 'unfWT8ig8i0uj6lPuYLez6',
                        price: '3.00000000',
                        origQty: '10.00000000',
                        executedQty: '0.00000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'SELL',
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'marginAccountCancelOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountCancelOcoResponse>)
            );
            const response = await client.marginAccountCancelOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MarginAccountCancelOcoRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.marginAccountCancelOco(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling marginAccountCancelOco.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MarginAccountCancelOcoRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'marginAccountCancelOco')
                .mockRejectedValueOnce(mockError);
            await expect(client.marginAccountCancelOco(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('marginAccountCancelOrder()', () => {
        it('should execute marginAccountCancelOrder() successfully with required parameters only', async () => {
            const params: MarginAccountCancelOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                symbol: 'LTCBTC',
                isIsolated: true,
                orderId: '28',
                origClientOrderId: 'myOrder1',
                clientOrderId: 'cancelMyOrder1',
                price: '1.00000000',
                origQty: '10.00000000',
                executedQty: '8.00000000',
                cummulativeQuoteQty: '8.00000000',
                status: 'CANCELED',
                timeInForce: 'GTC',
                type: 'LIMIT',
                side: 'SELL',
            };

            const spy = jest.spyOn(client, 'marginAccountCancelOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountCancelOrderResponse>)
            );
            const response = await client.marginAccountCancelOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute marginAccountCancelOrder() successfully with optional parameters', async () => {
            const params: MarginAccountCancelOrderRequest = {
                symbol: 'symbol_example',
                isIsolated: 'false',
                orderId: 1,
                origClientOrderId: '1',
                newClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                symbol: 'LTCBTC',
                isIsolated: true,
                orderId: '28',
                origClientOrderId: 'myOrder1',
                clientOrderId: 'cancelMyOrder1',
                price: '1.00000000',
                origQty: '10.00000000',
                executedQty: '8.00000000',
                cummulativeQuoteQty: '8.00000000',
                status: 'CANCELED',
                timeInForce: 'GTC',
                type: 'LIMIT',
                side: 'SELL',
            };

            const spy = jest.spyOn(client, 'marginAccountCancelOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountCancelOrderResponse>)
            );
            const response = await client.marginAccountCancelOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MarginAccountCancelOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.marginAccountCancelOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling marginAccountCancelOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MarginAccountCancelOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'marginAccountCancelOrder')
                .mockRejectedValueOnce(mockError);
            await expect(client.marginAccountCancelOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('marginAccountNewOco()', () => {
        it('should execute marginAccountNewOco() successfully with required parameters only', async () => {
            const params: MarginAccountNewOcoRequest = {
                symbol: 'symbol_example',
                side: MarginAccountNewOcoSideEnum.BUY,
                quantity: 1,
                price: 1,
                stopPrice: 1,
            };

            mockResponse = {
                orderListId: 0,
                contingencyType: 'OCO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'JYVpp3F0f5CAG15DhtrqLp',
                transactionTime: 1563417480525,
                symbol: 'LTCBTC',
                marginBuyBorrowAmount: '5',
                marginBuyBorrowAsset: 'BTC',
                isIsolated: false,
                orders: [
                    { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'Kk7sqHb9J6mJWTMDVW7Vos' },
                    { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'xTXKaGYd4bluPVp78IVRvl' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        orderId: 2,
                        orderListId: 0,
                        clientOrderId: 'Kk7sqHb9J6mJWTMDVW7Vos',
                        transactTime: 1563417480525,
                        price: '0.000000',
                        origQty: '0.624363',
                        executedQty: '0.000000',
                        cummulativeQuoteQty: '0.000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'STOP_LOSS',
                        side: 'BUY',
                        stopPrice: '0.960664',
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 3,
                        orderListId: 0,
                        clientOrderId: 'xTXKaGYd4bluPVp78IVRvl',
                        transactTime: 1563417480525,
                        price: '0.036435',
                        origQty: '0.624363',
                        executedQty: '0.000000',
                        cummulativeQuoteQty: '0.000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'BUY',
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'marginAccountNewOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountNewOcoResponse>)
            );
            const response = await client.marginAccountNewOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute marginAccountNewOco() successfully with optional parameters', async () => {
            const params: MarginAccountNewOcoRequest = {
                symbol: 'symbol_example',
                side: MarginAccountNewOcoSideEnum.BUY,
                quantity: 1,
                price: 1,
                stopPrice: 1,
                isIsolated: 'false',
                listClientOrderId: '1',
                limitClientOrderId: '1',
                limitIcebergQty: 1,
                stopClientOrderId: '1',
                stopLimitPrice: 1,
                stopIcebergQty: 1,
                stopLimitTimeInForce: 'stopLimitTimeInForce_example',
                newOrderRespType: MarginAccountNewOcoNewOrderRespTypeEnum.ACK,
                sideEffectType: 'NO_SIDE_EFFECT',
                selfTradePreventionMode: 'NONE',
                autoRepayAtCancel: true,
                recvWindow: 5000,
            };

            mockResponse = {
                orderListId: 0,
                contingencyType: 'OCO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'JYVpp3F0f5CAG15DhtrqLp',
                transactionTime: 1563417480525,
                symbol: 'LTCBTC',
                marginBuyBorrowAmount: '5',
                marginBuyBorrowAsset: 'BTC',
                isIsolated: false,
                orders: [
                    { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'Kk7sqHb9J6mJWTMDVW7Vos' },
                    { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'xTXKaGYd4bluPVp78IVRvl' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        orderId: 2,
                        orderListId: 0,
                        clientOrderId: 'Kk7sqHb9J6mJWTMDVW7Vos',
                        transactTime: 1563417480525,
                        price: '0.000000',
                        origQty: '0.624363',
                        executedQty: '0.000000',
                        cummulativeQuoteQty: '0.000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'STOP_LOSS',
                        side: 'BUY',
                        stopPrice: '0.960664',
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 3,
                        orderListId: 0,
                        clientOrderId: 'xTXKaGYd4bluPVp78IVRvl',
                        transactTime: 1563417480525,
                        price: '0.036435',
                        origQty: '0.624363',
                        executedQty: '0.000000',
                        cummulativeQuoteQty: '0.000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'BUY',
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'marginAccountNewOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountNewOcoResponse>)
            );
            const response = await client.marginAccountNewOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MarginAccountNewOcoRequest = {
                symbol: 'symbol_example',
                side: MarginAccountNewOcoSideEnum.BUY,
                quantity: 1,
                price: 1,
                stopPrice: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.marginAccountNewOco(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling marginAccountNewOco.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: MarginAccountNewOcoRequest = {
                symbol: 'symbol_example',
                side: MarginAccountNewOcoSideEnum.BUY,
                quantity: 1,
                price: 1,
                stopPrice: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.marginAccountNewOco(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling marginAccountNewOco.'
            );
        });

        it('should throw RequiredError when quantity is missing', async () => {
            const _params: MarginAccountNewOcoRequest = {
                symbol: 'symbol_example',
                side: MarginAccountNewOcoSideEnum.BUY,
                quantity: 1,
                price: 1,
                stopPrice: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.quantity;

            await expect(client.marginAccountNewOco(params)).rejects.toThrow(
                'Required parameter quantity was null or undefined when calling marginAccountNewOco.'
            );
        });

        it('should throw RequiredError when price is missing', async () => {
            const _params: MarginAccountNewOcoRequest = {
                symbol: 'symbol_example',
                side: MarginAccountNewOcoSideEnum.BUY,
                quantity: 1,
                price: 1,
                stopPrice: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.price;

            await expect(client.marginAccountNewOco(params)).rejects.toThrow(
                'Required parameter price was null or undefined when calling marginAccountNewOco.'
            );
        });

        it('should throw RequiredError when stopPrice is missing', async () => {
            const _params: MarginAccountNewOcoRequest = {
                symbol: 'symbol_example',
                side: MarginAccountNewOcoSideEnum.BUY,
                quantity: 1,
                price: 1,
                stopPrice: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.stopPrice;

            await expect(client.marginAccountNewOco(params)).rejects.toThrow(
                'Required parameter stopPrice was null or undefined when calling marginAccountNewOco.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MarginAccountNewOcoRequest = {
                symbol: 'symbol_example',
                side: MarginAccountNewOcoSideEnum.BUY,
                quantity: 1,
                price: 1,
                stopPrice: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'marginAccountNewOco').mockRejectedValueOnce(mockError);
            await expect(client.marginAccountNewOco(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('marginAccountNewOrder()', () => {
        it('should execute marginAccountNewOrder() successfully with required parameters only', async () => {
            const params: MarginAccountNewOrderRequest = {
                symbol: 'symbol_example',
                side: MarginAccountNewOrderSideEnum.BUY,
                type: 'type_example',
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                orderId: 28,
                clientOrderId: '6gCrw2kRUAF9CvJDGP16IP',
                isIsolated: true,
                transactTime: 1507725176595,
            };

            const spy = jest.spyOn(client, 'marginAccountNewOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountNewOrderResponse>)
            );
            const response = await client.marginAccountNewOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute marginAccountNewOrder() successfully with optional parameters', async () => {
            const params: MarginAccountNewOrderRequest = {
                symbol: 'symbol_example',
                side: MarginAccountNewOrderSideEnum.BUY,
                type: 'type_example',
                isIsolated: 'false',
                quantity: 1,
                quoteOrderQty: 1,
                price: 1,
                stopPrice: 1,
                newClientOrderId: '1',
                icebergQty: 1,
                newOrderRespType: MarginAccountNewOrderNewOrderRespTypeEnum.ACK,
                sideEffectType: 'NO_SIDE_EFFECT',
                timeInForce: MarginAccountNewOrderTimeInForceEnum.GTC,
                selfTradePreventionMode: 'NONE',
                autoRepayAtCancel: true,
                recvWindow: 5000,
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                orderId: 28,
                clientOrderId: '6gCrw2kRUAF9CvJDGP16IP',
                isIsolated: true,
                transactTime: 1507725176595,
            };

            const spy = jest.spyOn(client, 'marginAccountNewOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountNewOrderResponse>)
            );
            const response = await client.marginAccountNewOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MarginAccountNewOrderRequest = {
                symbol: 'symbol_example',
                side: MarginAccountNewOrderSideEnum.BUY,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.marginAccountNewOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling marginAccountNewOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: MarginAccountNewOrderRequest = {
                symbol: 'symbol_example',
                side: MarginAccountNewOrderSideEnum.BUY,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.marginAccountNewOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling marginAccountNewOrder.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: MarginAccountNewOrderRequest = {
                symbol: 'symbol_example',
                side: MarginAccountNewOrderSideEnum.BUY,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.marginAccountNewOrder(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling marginAccountNewOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MarginAccountNewOrderRequest = {
                symbol: 'symbol_example',
                side: MarginAccountNewOrderSideEnum.BUY,
                type: 'type_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'marginAccountNewOrder')
                .mockRejectedValueOnce(mockError);
            await expect(client.marginAccountNewOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('marginAccountNewOto()', () => {
        it('should execute marginAccountNewOto() successfully with required parameters only', async () => {
            const params: MarginAccountNewOtoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                workingIcebergQty: 1,
                pendingType: 'Order Types',
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
            };

            mockResponse = {
                orderListId: 13551,
                contingencyType: 'OTO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'JDuOrsu0Ge8GTyvx8J7VTD',
                transactionTime: 1725521998054,
                symbol: 'BTCUSDT',
                isIsolated: false,
                orders: [
                    {
                        symbol: 'BTCUSDT',
                        orderId: 29896699,
                        clientOrderId: 'y8RB6tQEMuHUXybqbtzTxk',
                    },
                    {
                        symbol: 'BTCUSDT',
                        orderId: 29896700,
                        clientOrderId: 'dKQEdh5HhXb7Lpp85jz1dQ',
                    },
                ],
                orderReports: [
                    {
                        symbol: 'BTCUSDT',
                        orderId: 29896699,
                        orderListId: 13551,
                        clientOrderId: 'y8RB6tQEMuHUXybqbtzTxk',
                        transactTime: 1725521998054,
                        price: '80000.00000000',
                        origQty: '0.02000000',
                        executedQty: '0',
                        cummulativeQuoteQty: '0',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'SELL',
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'BTCUSDT',
                        orderId: 29896700,
                        orderListId: 13551,
                        clientOrderId: 'dKQEdh5HhXb7Lpp85jz1dQ',
                        transactTime: 1725521998054,
                        price: '50000.00000000',
                        origQty: '0.02000000',
                        executedQty: '0',
                        cummulativeQuoteQty: '0',
                        status: 'PENDING_NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'BUY',
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'marginAccountNewOto').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountNewOtoResponse>)
            );
            const response = await client.marginAccountNewOto(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute marginAccountNewOto() successfully with optional parameters', async () => {
            const params: MarginAccountNewOtoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                workingIcebergQty: 1,
                pendingType: 'Order Types',
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
                isIsolated: 'false',
                listClientOrderId: '1',
                newOrderRespType: MarginAccountNewOtoNewOrderRespTypeEnum.ACK,
                sideEffectType: 'NO_SIDE_EFFECT',
                selfTradePreventionMode: 'NONE',
                autoRepayAtCancel: true,
                workingClientOrderId: '1',
                workingTimeInForce: 'workingTimeInForce_example',
                pendingClientOrderId: '1',
                pendingPrice: 1,
                pendingStopPrice: 1,
                pendingTrailingDelta: 1,
                pendingIcebergQty: 1,
                pendingTimeInForce: 'pendingTimeInForce_example',
            };

            mockResponse = {
                orderListId: 13551,
                contingencyType: 'OTO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'JDuOrsu0Ge8GTyvx8J7VTD',
                transactionTime: 1725521998054,
                symbol: 'BTCUSDT',
                isIsolated: false,
                orders: [
                    {
                        symbol: 'BTCUSDT',
                        orderId: 29896699,
                        clientOrderId: 'y8RB6tQEMuHUXybqbtzTxk',
                    },
                    {
                        symbol: 'BTCUSDT',
                        orderId: 29896700,
                        clientOrderId: 'dKQEdh5HhXb7Lpp85jz1dQ',
                    },
                ],
                orderReports: [
                    {
                        symbol: 'BTCUSDT',
                        orderId: 29896699,
                        orderListId: 13551,
                        clientOrderId: 'y8RB6tQEMuHUXybqbtzTxk',
                        transactTime: 1725521998054,
                        price: '80000.00000000',
                        origQty: '0.02000000',
                        executedQty: '0',
                        cummulativeQuoteQty: '0',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'SELL',
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'BTCUSDT',
                        orderId: 29896700,
                        orderListId: 13551,
                        clientOrderId: 'dKQEdh5HhXb7Lpp85jz1dQ',
                        transactTime: 1725521998054,
                        price: '50000.00000000',
                        origQty: '0.02000000',
                        executedQty: '0',
                        cummulativeQuoteQty: '0',
                        status: 'PENDING_NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'BUY',
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'marginAccountNewOto').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountNewOtoResponse>)
            );
            const response = await client.marginAccountNewOto(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MarginAccountNewOtoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                workingIcebergQty: 1,
                pendingType: 'Order Types',
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.marginAccountNewOto(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling marginAccountNewOto.'
            );
        });

        it('should throw RequiredError when workingType is missing', async () => {
            const _params: MarginAccountNewOtoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                workingIcebergQty: 1,
                pendingType: 'Order Types',
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingType;

            await expect(client.marginAccountNewOto(params)).rejects.toThrow(
                'Required parameter workingType was null or undefined when calling marginAccountNewOto.'
            );
        });

        it('should throw RequiredError when workingSide is missing', async () => {
            const _params: MarginAccountNewOtoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                workingIcebergQty: 1,
                pendingType: 'Order Types',
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingSide;

            await expect(client.marginAccountNewOto(params)).rejects.toThrow(
                'Required parameter workingSide was null or undefined when calling marginAccountNewOto.'
            );
        });

        it('should throw RequiredError when workingPrice is missing', async () => {
            const _params: MarginAccountNewOtoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                workingIcebergQty: 1,
                pendingType: 'Order Types',
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingPrice;

            await expect(client.marginAccountNewOto(params)).rejects.toThrow(
                'Required parameter workingPrice was null or undefined when calling marginAccountNewOto.'
            );
        });

        it('should throw RequiredError when workingQuantity is missing', async () => {
            const _params: MarginAccountNewOtoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                workingIcebergQty: 1,
                pendingType: 'Order Types',
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingQuantity;

            await expect(client.marginAccountNewOto(params)).rejects.toThrow(
                'Required parameter workingQuantity was null or undefined when calling marginAccountNewOto.'
            );
        });

        it('should throw RequiredError when workingIcebergQty is missing', async () => {
            const _params: MarginAccountNewOtoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                workingIcebergQty: 1,
                pendingType: 'Order Types',
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingIcebergQty;

            await expect(client.marginAccountNewOto(params)).rejects.toThrow(
                'Required parameter workingIcebergQty was null or undefined when calling marginAccountNewOto.'
            );
        });

        it('should throw RequiredError when pendingType is missing', async () => {
            const _params: MarginAccountNewOtoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                workingIcebergQty: 1,
                pendingType: 'Order Types',
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingType;

            await expect(client.marginAccountNewOto(params)).rejects.toThrow(
                'Required parameter pendingType was null or undefined when calling marginAccountNewOto.'
            );
        });

        it('should throw RequiredError when pendingSide is missing', async () => {
            const _params: MarginAccountNewOtoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                workingIcebergQty: 1,
                pendingType: 'Order Types',
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingSide;

            await expect(client.marginAccountNewOto(params)).rejects.toThrow(
                'Required parameter pendingSide was null or undefined when calling marginAccountNewOto.'
            );
        });

        it('should throw RequiredError when pendingQuantity is missing', async () => {
            const _params: MarginAccountNewOtoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                workingIcebergQty: 1,
                pendingType: 'Order Types',
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingQuantity;

            await expect(client.marginAccountNewOto(params)).rejects.toThrow(
                'Required parameter pendingQuantity was null or undefined when calling marginAccountNewOto.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MarginAccountNewOtoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                workingIcebergQty: 1,
                pendingType: 'Order Types',
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'marginAccountNewOto').mockRejectedValueOnce(mockError);
            await expect(client.marginAccountNewOto(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('marginAccountNewOtoco()', () => {
        it('should execute marginAccountNewOtoco() successfully with required parameters only', async () => {
            const params: MarginAccountNewOtocoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
                pendingAboveType: 'pendingAboveType_example',
            };

            mockResponse = {
                orderListId: 13509,
                contingencyType: 'OTO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'u2AUo48LLef5qVenRtwJZy',
                transactionTime: 1725521881300,
                symbol: 'BNBUSDT',
                isIsolated: false,
                orders: [
                    {
                        symbol: 'BNBUSDT',
                        orderId: 28282534,
                        clientOrderId: 'IfYDxvrZI4kiyqYpRH13iI',
                    },
                    {
                        symbol: 'BNBUSDT',
                        orderId: 28282535,
                        clientOrderId: '0HCSsPRxVfW8BkTUy9z4np',
                    },
                    {
                        symbol: 'BNBUSDT',
                        orderId: 28282536,
                        clientOrderId: 'dypsgdxWnLY75kwT930cbD',
                    },
                ],
                orderReports: [
                    {
                        symbol: 'BNBUSDT',
                        orderId: 28282534,
                        orderListId: 13509,
                        clientOrderId: 'IfYDxvrZI4kiyqYpRH13iI',
                        transactTime: 1725521881300,
                        price: '300.00000000',
                        origQty: '1.00000000',
                        executedQty: '0',
                        cummulativeQuoteQty: '0',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'BUY',
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'BNBUSDT',
                        orderId: 28282535,
                        orderListId: 13509,
                        clientOrderId: '0HCSsPRxVfW8BkTUy9z4np',
                        transactTime: 1725521881300,
                        price: '0E-8',
                        origQty: '1.00000000',
                        executedQty: '0',
                        cummulativeQuoteQty: '0',
                        status: 'PENDING_NEW',
                        timeInForce: 'GTC',
                        type: 'STOP_LOSS',
                        side: 'SELL',
                        stopPrice: '299.00000000',
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'BNBUSDT',
                        orderId: 28282536,
                        orderListId: 13509,
                        clientOrderId: 'dypsgdxWnLY75kwT930cbD',
                        transactTime: 1725521881300,
                        price: '301.00000000',
                        origQty: '1.00000000',
                        executedQty: '0',
                        cummulativeQuoteQty: '0',
                        status: 'PENDING_NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'SELL',
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'marginAccountNewOtoco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountNewOtocoResponse>)
            );
            const response = await client.marginAccountNewOtoco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute marginAccountNewOtoco() successfully with optional parameters', async () => {
            const params: MarginAccountNewOtocoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
                pendingAboveType: 'pendingAboveType_example',
                isIsolated: 'false',
                sideEffectType: 'NO_SIDE_EFFECT',
                autoRepayAtCancel: true,
                listClientOrderId: '1',
                newOrderRespType: MarginAccountNewOtocoNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: 'NONE',
                workingClientOrderId: '1',
                workingIcebergQty: 1,
                workingTimeInForce: 'workingTimeInForce_example',
                pendingAboveClientOrderId: '1',
                pendingAbovePrice: 1,
                pendingAboveStopPrice: 1,
                pendingAboveTrailingDelta: 1,
                pendingAboveIcebergQty: 1,
                pendingAboveTimeInForce: 'pendingAboveTimeInForce_example',
                pendingBelowType: 'pendingBelowType_example',
                pendingBelowClientOrderId: '1',
                pendingBelowPrice: 1,
                pendingBelowStopPrice: 1,
                pendingBelowTrailingDelta: 1,
                pendingBelowIcebergQty: 1,
                pendingBelowTimeInForce: 'pendingBelowTimeInForce_example',
            };

            mockResponse = {
                orderListId: 13509,
                contingencyType: 'OTO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'u2AUo48LLef5qVenRtwJZy',
                transactionTime: 1725521881300,
                symbol: 'BNBUSDT',
                isIsolated: false,
                orders: [
                    {
                        symbol: 'BNBUSDT',
                        orderId: 28282534,
                        clientOrderId: 'IfYDxvrZI4kiyqYpRH13iI',
                    },
                    {
                        symbol: 'BNBUSDT',
                        orderId: 28282535,
                        clientOrderId: '0HCSsPRxVfW8BkTUy9z4np',
                    },
                    {
                        symbol: 'BNBUSDT',
                        orderId: 28282536,
                        clientOrderId: 'dypsgdxWnLY75kwT930cbD',
                    },
                ],
                orderReports: [
                    {
                        symbol: 'BNBUSDT',
                        orderId: 28282534,
                        orderListId: 13509,
                        clientOrderId: 'IfYDxvrZI4kiyqYpRH13iI',
                        transactTime: 1725521881300,
                        price: '300.00000000',
                        origQty: '1.00000000',
                        executedQty: '0',
                        cummulativeQuoteQty: '0',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'BUY',
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'BNBUSDT',
                        orderId: 28282535,
                        orderListId: 13509,
                        clientOrderId: '0HCSsPRxVfW8BkTUy9z4np',
                        transactTime: 1725521881300,
                        price: '0E-8',
                        origQty: '1.00000000',
                        executedQty: '0',
                        cummulativeQuoteQty: '0',
                        status: 'PENDING_NEW',
                        timeInForce: 'GTC',
                        type: 'STOP_LOSS',
                        side: 'SELL',
                        stopPrice: '299.00000000',
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'BNBUSDT',
                        orderId: 28282536,
                        orderListId: 13509,
                        clientOrderId: 'dypsgdxWnLY75kwT930cbD',
                        transactTime: 1725521881300,
                        price: '301.00000000',
                        origQty: '1.00000000',
                        executedQty: '0',
                        cummulativeQuoteQty: '0',
                        status: 'PENDING_NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'SELL',
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'marginAccountNewOtoco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountNewOtocoResponse>)
            );
            const response = await client.marginAccountNewOtoco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MarginAccountNewOtocoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
                pendingAboveType: 'pendingAboveType_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.marginAccountNewOtoco(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling marginAccountNewOtoco.'
            );
        });

        it('should throw RequiredError when workingType is missing', async () => {
            const _params: MarginAccountNewOtocoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
                pendingAboveType: 'pendingAboveType_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.workingType;

            await expect(client.marginAccountNewOtoco(params)).rejects.toThrow(
                'Required parameter workingType was null or undefined when calling marginAccountNewOtoco.'
            );
        });

        it('should throw RequiredError when workingSide is missing', async () => {
            const _params: MarginAccountNewOtocoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
                pendingAboveType: 'pendingAboveType_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.workingSide;

            await expect(client.marginAccountNewOtoco(params)).rejects.toThrow(
                'Required parameter workingSide was null or undefined when calling marginAccountNewOtoco.'
            );
        });

        it('should throw RequiredError when workingPrice is missing', async () => {
            const _params: MarginAccountNewOtocoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
                pendingAboveType: 'pendingAboveType_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.workingPrice;

            await expect(client.marginAccountNewOtoco(params)).rejects.toThrow(
                'Required parameter workingPrice was null or undefined when calling marginAccountNewOtoco.'
            );
        });

        it('should throw RequiredError when workingQuantity is missing', async () => {
            const _params: MarginAccountNewOtocoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
                pendingAboveType: 'pendingAboveType_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.workingQuantity;

            await expect(client.marginAccountNewOtoco(params)).rejects.toThrow(
                'Required parameter workingQuantity was null or undefined when calling marginAccountNewOtoco.'
            );
        });

        it('should throw RequiredError when pendingSide is missing', async () => {
            const _params: MarginAccountNewOtocoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
                pendingAboveType: 'pendingAboveType_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingSide;

            await expect(client.marginAccountNewOtoco(params)).rejects.toThrow(
                'Required parameter pendingSide was null or undefined when calling marginAccountNewOtoco.'
            );
        });

        it('should throw RequiredError when pendingQuantity is missing', async () => {
            const _params: MarginAccountNewOtocoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
                pendingAboveType: 'pendingAboveType_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingQuantity;

            await expect(client.marginAccountNewOtoco(params)).rejects.toThrow(
                'Required parameter pendingQuantity was null or undefined when calling marginAccountNewOtoco.'
            );
        });

        it('should throw RequiredError when pendingAboveType is missing', async () => {
            const _params: MarginAccountNewOtocoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
                pendingAboveType: 'pendingAboveType_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingAboveType;

            await expect(client.marginAccountNewOtoco(params)).rejects.toThrow(
                'Required parameter pendingAboveType was null or undefined when calling marginAccountNewOtoco.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MarginAccountNewOtocoRequest = {
                symbol: 'symbol_example',
                workingType: 'workingType_example',
                workingSide: 'workingSide_example',
                workingPrice: 1,
                workingQuantity: 1,
                pendingSide: 'pendingSide_example',
                pendingQuantity: 1,
                pendingAboveType: 'pendingAboveType_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'marginAccountNewOtoco')
                .mockRejectedValueOnce(mockError);
            await expect(client.marginAccountNewOtoco(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('marginManualLiquidation()', () => {
        it('should execute marginManualLiquidation() successfully with required parameters only', async () => {
            const params: MarginManualLiquidationRequest = {
                type: 'type_example',
            };

            mockResponse = {
                asset: 'ETH',
                interest: '0.00083334',
                principal: '0.001',
                liabilityAsset: 'USDT',
                liabilityQty: 0.3552,
            };

            const spy = jest.spyOn(client, 'marginManualLiquidation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginManualLiquidationResponse>)
            );
            const response = await client.marginManualLiquidation(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute marginManualLiquidation() successfully with optional parameters', async () => {
            const params: MarginManualLiquidationRequest = {
                type: 'type_example',
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = {
                asset: 'ETH',
                interest: '0.00083334',
                principal: '0.001',
                liabilityAsset: 'USDT',
                liabilityQty: 0.3552,
            };

            const spy = jest.spyOn(client, 'marginManualLiquidation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginManualLiquidationResponse>)
            );
            const response = await client.marginManualLiquidation(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: MarginManualLiquidationRequest = {
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.marginManualLiquidation(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling marginManualLiquidation.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MarginManualLiquidationRequest = {
                type: 'type_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'marginManualLiquidation')
                .mockRejectedValueOnce(mockError);
            await expect(client.marginManualLiquidation(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryCurrentMarginOrderCountUsage()', () => {
        it('should execute queryCurrentMarginOrderCountUsage() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    rateLimitType: 'ORDERS',
                    interval: 'SECOND',
                    intervalNum: 10,
                    limit: 10000,
                    count: 0,
                },
                {
                    rateLimitType: 'ORDERS',
                    interval: 'DAY',
                    intervalNum: 1,
                    limit: 20000,
                    count: 0,
                },
            ];

            const spy = jest.spyOn(client, 'queryCurrentMarginOrderCountUsage').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCurrentMarginOrderCountUsageResponse>)
            );
            const response = await client.queryCurrentMarginOrderCountUsage();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryCurrentMarginOrderCountUsage() successfully with optional parameters', async () => {
            const params: QueryCurrentMarginOrderCountUsageRequest = {
                isIsolated: 'false',
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    rateLimitType: 'ORDERS',
                    interval: 'SECOND',
                    intervalNum: 10,
                    limit: 10000,
                    count: 0,
                },
                {
                    rateLimitType: 'ORDERS',
                    interval: 'DAY',
                    intervalNum: 1,
                    limit: 20000,
                    count: 0,
                },
            ];

            const spy = jest.spyOn(client, 'queryCurrentMarginOrderCountUsage').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCurrentMarginOrderCountUsageResponse>)
            );
            const response = await client.queryCurrentMarginOrderCountUsage(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryCurrentMarginOrderCountUsage')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryCurrentMarginOrderCountUsage()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryMarginAccountsAllOco()', () => {
        it('should execute queryMarginAccountsAllOco() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    orderListId: 29,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'amEEAXryFzFwYF1FeRpUoZ',
                    transactionTime: 1565245913483,
                    symbol: 'LTCBTC',
                    isIsolated: true,
                    orders: [
                        { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'oD7aesZqjEGlZrbtRpy5zB' },
                        { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'Jr1h6xirOxgeJOUuYQS7V3' },
                    ],
                },
                {
                    orderListId: 28,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'hG7hFNxJV6cZy3Ze4AUT4d',
                    transactionTime: 1565245913407,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'j6lFOfbmFMRjTYA7rRJ0LP' },
                        { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'z0KCjOdditiLS5ekAFtK81' },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'queryMarginAccountsAllOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginAccountsAllOcoResponse>)
            );
            const response = await client.queryMarginAccountsAllOco();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryMarginAccountsAllOco() successfully with optional parameters', async () => {
            const params: QueryMarginAccountsAllOcoRequest = {
                isIsolated: 'false',
                symbol: 'symbol_example',
                fromId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 500,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    orderListId: 29,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'amEEAXryFzFwYF1FeRpUoZ',
                    transactionTime: 1565245913483,
                    symbol: 'LTCBTC',
                    isIsolated: true,
                    orders: [
                        { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'oD7aesZqjEGlZrbtRpy5zB' },
                        { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'Jr1h6xirOxgeJOUuYQS7V3' },
                    ],
                },
                {
                    orderListId: 28,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'hG7hFNxJV6cZy3Ze4AUT4d',
                    transactionTime: 1565245913407,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'j6lFOfbmFMRjTYA7rRJ0LP' },
                        { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'z0KCjOdditiLS5ekAFtK81' },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'queryMarginAccountsAllOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginAccountsAllOcoResponse>)
            );
            const response = await client.queryMarginAccountsAllOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryMarginAccountsAllOco')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryMarginAccountsAllOco()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryMarginAccountsAllOrders()', () => {
        it('should execute queryMarginAccountsAllOrders() successfully with required parameters only', async () => {
            const params: QueryMarginAccountsAllOrdersRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    clientOrderId: 'D2KDy4DIeS56PvkM13f8cP',
                    cummulativeQuoteQty: '0.00000000',
                    executedQty: '0.00000000',
                    icebergQty: '0.00000000',
                    isWorking: false,
                    orderId: 41295,
                    origQty: '5.31000000',
                    price: '0.22500000',
                    side: 'SELL',
                    status: 'CANCELED',
                    stopPrice: '0.18000000',
                    symbol: 'BNBBTC',
                    isIsolated: false,
                    time: 1565769338806,
                    timeInForce: 'GTC',
                    type: 'TAKE_PROFIT_LIMIT',
                    selfTradePreventionMode: 'NONE',
                    updateTime: 1565769342148,
                },
                {
                    clientOrderId: 'gXYtqhcEAs2Rn9SUD9nRKx',
                    cummulativeQuoteQty: '0.00000000',
                    executedQty: '0.00000000',
                    icebergQty: '1.00000000',
                    isWorking: true,
                    orderId: 41296,
                    origQty: '6.65000000',
                    price: '0.18000000',
                    side: 'SELL',
                    status: 'CANCELED',
                    stopPrice: '0.00000000',
                    symbol: 'BNBBTC',
                    isIsolated: false,
                    time: 1565769348687,
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    selfTradePreventionMode: 'NONE',
                    updateTime: 1565769352226,
                },
            ];

            const spy = jest.spyOn(client, 'queryMarginAccountsAllOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginAccountsAllOrdersResponse>)
            );
            const response = await client.queryMarginAccountsAllOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryMarginAccountsAllOrders() successfully with optional parameters', async () => {
            const params: QueryMarginAccountsAllOrdersRequest = {
                symbol: 'symbol_example',
                isIsolated: 'false',
                orderId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 500,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    clientOrderId: 'D2KDy4DIeS56PvkM13f8cP',
                    cummulativeQuoteQty: '0.00000000',
                    executedQty: '0.00000000',
                    icebergQty: '0.00000000',
                    isWorking: false,
                    orderId: 41295,
                    origQty: '5.31000000',
                    price: '0.22500000',
                    side: 'SELL',
                    status: 'CANCELED',
                    stopPrice: '0.18000000',
                    symbol: 'BNBBTC',
                    isIsolated: false,
                    time: 1565769338806,
                    timeInForce: 'GTC',
                    type: 'TAKE_PROFIT_LIMIT',
                    selfTradePreventionMode: 'NONE',
                    updateTime: 1565769342148,
                },
                {
                    clientOrderId: 'gXYtqhcEAs2Rn9SUD9nRKx',
                    cummulativeQuoteQty: '0.00000000',
                    executedQty: '0.00000000',
                    icebergQty: '1.00000000',
                    isWorking: true,
                    orderId: 41296,
                    origQty: '6.65000000',
                    price: '0.18000000',
                    side: 'SELL',
                    status: 'CANCELED',
                    stopPrice: '0.00000000',
                    symbol: 'BNBBTC',
                    isIsolated: false,
                    time: 1565769348687,
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    selfTradePreventionMode: 'NONE',
                    updateTime: 1565769352226,
                },
            ];

            const spy = jest.spyOn(client, 'queryMarginAccountsAllOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginAccountsAllOrdersResponse>)
            );
            const response = await client.queryMarginAccountsAllOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryMarginAccountsAllOrdersRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryMarginAccountsAllOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryMarginAccountsAllOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryMarginAccountsAllOrdersRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryMarginAccountsAllOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryMarginAccountsAllOrders(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryMarginAccountsOco()', () => {
        it('should execute queryMarginAccountsOco() successfully with required parameters only', async () => {
            mockResponse = {
                orderListId: 27,
                contingencyType: 'OCO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'h2USkA5YQpaXHPIrkd96xE',
                transactionTime: 1565245656253,
                symbol: 'LTCBTC',
                isIsolated: false,
                orders: [
                    { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'qD1gy3kc3Gx0rihm9Y3xwS' },
                    { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'ARzZ9I00CPM8i3NhmU9Ega' },
                ],
            };

            const spy = jest.spyOn(client, 'queryMarginAccountsOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginAccountsOcoResponse>)
            );
            const response = await client.queryMarginAccountsOco();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryMarginAccountsOco() successfully with optional parameters', async () => {
            const params: QueryMarginAccountsOcoRequest = {
                isIsolated: 'false',
                symbol: 'symbol_example',
                orderListId: 1,
                origClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                orderListId: 27,
                contingencyType: 'OCO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'h2USkA5YQpaXHPIrkd96xE',
                transactionTime: 1565245656253,
                symbol: 'LTCBTC',
                isIsolated: false,
                orders: [
                    { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'qD1gy3kc3Gx0rihm9Y3xwS' },
                    { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'ARzZ9I00CPM8i3NhmU9Ega' },
                ],
            };

            const spy = jest.spyOn(client, 'queryMarginAccountsOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginAccountsOcoResponse>)
            );
            const response = await client.queryMarginAccountsOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryMarginAccountsOco')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryMarginAccountsOco()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryMarginAccountsOpenOco()', () => {
        it('should execute queryMarginAccountsOpenOco() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    orderListId: 31,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'wuB13fmulKj3YjdqWEcsnp',
                    transactionTime: 1565246080644,
                    symbol: 'LTCBTC',
                    isIsolated: false,
                    orders: [
                        { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'r3EH2N76dHfLoSZWIUw1bT' },
                        { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'Cv1SnyPD3qhqpbjpYEHbd2' },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'queryMarginAccountsOpenOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginAccountsOpenOcoResponse>)
            );
            const response = await client.queryMarginAccountsOpenOco();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryMarginAccountsOpenOco() successfully with optional parameters', async () => {
            const params: QueryMarginAccountsOpenOcoRequest = {
                isIsolated: 'false',
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    orderListId: 31,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'wuB13fmulKj3YjdqWEcsnp',
                    transactionTime: 1565246080644,
                    symbol: 'LTCBTC',
                    isIsolated: false,
                    orders: [
                        { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'r3EH2N76dHfLoSZWIUw1bT' },
                        { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'Cv1SnyPD3qhqpbjpYEHbd2' },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'queryMarginAccountsOpenOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginAccountsOpenOcoResponse>)
            );
            const response = await client.queryMarginAccountsOpenOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryMarginAccountsOpenOco')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryMarginAccountsOpenOco()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryMarginAccountsOpenOrders()', () => {
        it('should execute queryMarginAccountsOpenOrders() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    clientOrderId: 'qhcZw71gAkCCTv0t0k8LUK',
                    cummulativeQuoteQty: '0.00000000',
                    executedQty: '0.00000000',
                    icebergQty: '0.00000000',
                    isWorking: true,
                    orderId: 211842552,
                    origQty: '0.30000000',
                    price: '0.00475010',
                    side: 'SELL',
                    status: 'NEW',
                    stopPrice: '0.00000000',
                    symbol: 'BNBBTC',
                    isIsolated: true,
                    time: 1562040170089,
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    selfTradePreventionMode: 'NONE',
                    updateTime: 1562040170089,
                },
            ];

            const spy = jest.spyOn(client, 'queryMarginAccountsOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginAccountsOpenOrdersResponse>)
            );
            const response = await client.queryMarginAccountsOpenOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryMarginAccountsOpenOrders() successfully with optional parameters', async () => {
            const params: QueryMarginAccountsOpenOrdersRequest = {
                symbol: 'symbol_example',
                isIsolated: 'false',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    clientOrderId: 'qhcZw71gAkCCTv0t0k8LUK',
                    cummulativeQuoteQty: '0.00000000',
                    executedQty: '0.00000000',
                    icebergQty: '0.00000000',
                    isWorking: true,
                    orderId: 211842552,
                    origQty: '0.30000000',
                    price: '0.00475010',
                    side: 'SELL',
                    status: 'NEW',
                    stopPrice: '0.00000000',
                    symbol: 'BNBBTC',
                    isIsolated: true,
                    time: 1562040170089,
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    selfTradePreventionMode: 'NONE',
                    updateTime: 1562040170089,
                },
            ];

            const spy = jest.spyOn(client, 'queryMarginAccountsOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginAccountsOpenOrdersResponse>)
            );
            const response = await client.queryMarginAccountsOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryMarginAccountsOpenOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryMarginAccountsOpenOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryMarginAccountsOrder()', () => {
        it('should execute queryMarginAccountsOrder() successfully with required parameters only', async () => {
            const params: QueryMarginAccountsOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                clientOrderId: 'ZwfQzuDIGpceVhKW5DvCmO',
                cummulativeQuoteQty: '0.00000000',
                executedQty: '0.00000000',
                icebergQty: '0.00000000',
                isWorking: true,
                orderId: 213205622,
                origQty: '0.30000000',
                price: '0.00493630',
                side: 'SELL',
                status: 'NEW',
                stopPrice: '0.00000000',
                symbol: 'BNBBTC',
                isIsolated: true,
                time: 1562133008725,
                timeInForce: 'GTC',
                type: 'LIMIT',
                selfTradePreventionMode: 'NONE',
                updateTime: 1562133008725,
            };

            const spy = jest.spyOn(client, 'queryMarginAccountsOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginAccountsOrderResponse>)
            );
            const response = await client.queryMarginAccountsOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryMarginAccountsOrder() successfully with optional parameters', async () => {
            const params: QueryMarginAccountsOrderRequest = {
                symbol: 'symbol_example',
                isIsolated: 'false',
                orderId: 1,
                origClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                clientOrderId: 'ZwfQzuDIGpceVhKW5DvCmO',
                cummulativeQuoteQty: '0.00000000',
                executedQty: '0.00000000',
                icebergQty: '0.00000000',
                isWorking: true,
                orderId: 213205622,
                origQty: '0.30000000',
                price: '0.00493630',
                side: 'SELL',
                status: 'NEW',
                stopPrice: '0.00000000',
                symbol: 'BNBBTC',
                isIsolated: true,
                time: 1562133008725,
                timeInForce: 'GTC',
                type: 'LIMIT',
                selfTradePreventionMode: 'NONE',
                updateTime: 1562133008725,
            };

            const spy = jest.spyOn(client, 'queryMarginAccountsOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginAccountsOrderResponse>)
            );
            const response = await client.queryMarginAccountsOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryMarginAccountsOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryMarginAccountsOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryMarginAccountsOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryMarginAccountsOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryMarginAccountsOrder')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryMarginAccountsOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryMarginAccountsTradeList()', () => {
        it('should execute queryMarginAccountsTradeList() successfully with required parameters only', async () => {
            const params: QueryMarginAccountsTradeListRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    commission: '0.00006000',
                    commissionAsset: 'BTC',
                    id: 34,
                    isBestMatch: true,
                    isBuyer: false,
                    isMaker: false,
                    orderId: 39324,
                    price: '0.02000000',
                    qty: '3.00000000',
                    symbol: 'BNBBTC',
                    isIsolated: false,
                    time: 1561973357171,
                },
            ];

            const spy = jest.spyOn(client, 'queryMarginAccountsTradeList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginAccountsTradeListResponse>)
            );
            const response = await client.queryMarginAccountsTradeList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryMarginAccountsTradeList() successfully with optional parameters', async () => {
            const params: QueryMarginAccountsTradeListRequest = {
                symbol: 'symbol_example',
                isIsolated: 'false',
                orderId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                fromId: 1,
                limit: 500,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    commission: '0.00006000',
                    commissionAsset: 'BTC',
                    id: 34,
                    isBestMatch: true,
                    isBuyer: false,
                    isMaker: false,
                    orderId: 39324,
                    price: '0.02000000',
                    qty: '3.00000000',
                    symbol: 'BNBBTC',
                    isIsolated: false,
                    time: 1561973357171,
                },
            ];

            const spy = jest.spyOn(client, 'queryMarginAccountsTradeList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginAccountsTradeListResponse>)
            );
            const response = await client.queryMarginAccountsTradeList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryMarginAccountsTradeListRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryMarginAccountsTradeList(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryMarginAccountsTradeList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryMarginAccountsTradeListRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryMarginAccountsTradeList')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryMarginAccountsTradeList(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('querySpecialKey()', () => {
        it('should execute querySpecialKey() successfully with required parameters only', async () => {
            mockResponse = {
                apiKey: 'npOzOAeLVgr2TuxWfNo43AaPWpBbJEoKezh1o8mSQb6ryE2odE11A4AoVlJbQoGx',
                ip: '0.0.0.0,192.168.0.1,192.168.0.2',
                apiName: 'testName',
                type: 'RSA',
                permissionMode: 'TRADE',
            };

            const spy = jest.spyOn(client, 'querySpecialKey').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySpecialKeyResponse>)
            );
            const response = await client.querySpecialKey();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute querySpecialKey() successfully with optional parameters', async () => {
            const params: QuerySpecialKeyRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = {
                apiKey: 'npOzOAeLVgr2TuxWfNo43AaPWpBbJEoKezh1o8mSQb6ryE2odE11A4AoVlJbQoGx',
                ip: '0.0.0.0,192.168.0.1,192.168.0.2',
                apiName: 'testName',
                type: 'RSA',
                permissionMode: 'TRADE',
            };

            const spy = jest.spyOn(client, 'querySpecialKey').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySpecialKeyResponse>)
            );
            const response = await client.querySpecialKey(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'querySpecialKey').mockRejectedValueOnce(mockError);
            await expect(client.querySpecialKey()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('querySpecialKeyList()', () => {
        it('should execute querySpecialKeyList() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    apiName: 'testName1',
                    apiKey: 'znpOzOAeLVgr2TuxWfNo43AaPWpBbJEoKezh1o8mSQb6ryE2odE11A4AoVlJbQoG',
                    ip: '192.168.0.1,192.168.0.2',
                    type: 'RSA',
                    permissionMode: 'TRADE',
                },
                {
                    apiName: 'testName2',
                    apiKey: 'znpOzOAeLVgr2TuxWfNo43AaPWpBbJEoKezh1o8mSQb6ryE2odE11A4AoVlJbQoG',
                    ip: '192.168.0.1,192.168.0.2',
                    type: 'Ed25519',
                    permissionMode: 'READ',
                },
            ];

            const spy = jest.spyOn(client, 'querySpecialKeyList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySpecialKeyListResponse>)
            );
            const response = await client.querySpecialKeyList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute querySpecialKeyList() successfully with optional parameters', async () => {
            const params: QuerySpecialKeyListRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    apiName: 'testName1',
                    apiKey: 'znpOzOAeLVgr2TuxWfNo43AaPWpBbJEoKezh1o8mSQb6ryE2odE11A4AoVlJbQoG',
                    ip: '192.168.0.1,192.168.0.2',
                    type: 'RSA',
                    permissionMode: 'TRADE',
                },
                {
                    apiName: 'testName2',
                    apiKey: 'znpOzOAeLVgr2TuxWfNo43AaPWpBbJEoKezh1o8mSQb6ryE2odE11A4AoVlJbQoG',
                    ip: '192.168.0.1,192.168.0.2',
                    type: 'Ed25519',
                    permissionMode: 'READ',
                },
            ];

            const spy = jest.spyOn(client, 'querySpecialKeyList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySpecialKeyListResponse>)
            );
            const response = await client.querySpecialKeyList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'querySpecialKeyList').mockRejectedValueOnce(mockError);
            await expect(client.querySpecialKeyList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('smallLiabilityExchange()', () => {
        it('should execute smallLiabilityExchange() successfully with required parameters only', async () => {
            const params: SmallLiabilityExchangeRequest = {
                assetNames: ['BTC'],
            };

            const spy = jest.spyOn(client, 'smallLiabilityExchange').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.smallLiabilityExchange(params);

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should execute smallLiabilityExchange() successfully with optional parameters', async () => {
            const params: SmallLiabilityExchangeRequest = {
                assetNames: ['BTC'],
                recvWindow: 5000,
            };

            const spy = jest.spyOn(client, 'smallLiabilityExchange').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.smallLiabilityExchange(params);

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should throw RequiredError when assetNames is missing', async () => {
            const _params: SmallLiabilityExchangeRequest = {
                assetNames: ['BTC'],
            };
            const params = Object.assign({ ..._params });
            delete params?.assetNames;

            await expect(client.smallLiabilityExchange(params)).rejects.toThrow(
                'Required parameter assetNames was null or undefined when calling smallLiabilityExchange.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SmallLiabilityExchangeRequest = {
                assetNames: ['BTC'],
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'smallLiabilityExchange')
                .mockRejectedValueOnce(mockError);
            await expect(client.smallLiabilityExchange(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
