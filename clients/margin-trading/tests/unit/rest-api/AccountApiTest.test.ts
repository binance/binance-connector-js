/**
 * Binance Margin Trading REST API
 *
 * OpenAPI Specification for the Binance Margin Trading REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { AccountApi } from '../../../src/rest-api';
import {
    AdjustCrossMarginMaxLeverageRequest,
    DisableIsolatedMarginAccountRequest,
    EnableIsolatedMarginAccountRequest,
    GetBnbBurnStatusRequest,
    GetSummaryOfMarginAccountRequest,
    QueryCrossIsolatedMarginCapitalFlowRequest,
    QueryCrossMarginAccountDetailsRequest,
    QueryCrossMarginFeeDataRequest,
    QueryEnabledIsolatedMarginAccountLimitRequest,
    QueryIsolatedMarginAccountInfoRequest,
    QueryIsolatedMarginFeeDataRequest,
} from '../../../src/rest-api';
import type {
    AdjustCrossMarginMaxLeverageResponse,
    DisableIsolatedMarginAccountResponse,
    EnableIsolatedMarginAccountResponse,
    GetBnbBurnStatusResponse,
    GetSummaryOfMarginAccountResponse,
    QueryCrossIsolatedMarginCapitalFlowResponse,
    QueryCrossMarginAccountDetailsResponse,
    QueryCrossMarginFeeDataResponse,
    QueryEnabledIsolatedMarginAccountLimitResponse,
    QueryIsolatedMarginAccountInfoResponse,
    QueryIsolatedMarginFeeDataResponse,
} from '../../../src/rest-api/types';

describe('AccountApi', () => {
    let client: AccountApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new AccountApi(config);
    });

    describe('adjustCrossMarginMaxLeverage()', () => {
        it('should execute adjustCrossMarginMaxLeverage() successfully with required parameters only', async () => {
            const params: AdjustCrossMarginMaxLeverageRequest = {
                maxLeverage: 789,
            };

            mockResponse = { success: true };

            const spy = jest.spyOn(client, 'adjustCrossMarginMaxLeverage').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AdjustCrossMarginMaxLeverageResponse>)
            );
            const response = await client.adjustCrossMarginMaxLeverage(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute adjustCrossMarginMaxLeverage() successfully with optional parameters', async () => {
            const params: AdjustCrossMarginMaxLeverageRequest = {
                maxLeverage: 789,
            };

            mockResponse = { success: true };

            const spy = jest.spyOn(client, 'adjustCrossMarginMaxLeverage').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AdjustCrossMarginMaxLeverageResponse>)
            );
            const response = await client.adjustCrossMarginMaxLeverage(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when maxLeverage is missing', async () => {
            const _params: AdjustCrossMarginMaxLeverageRequest = {
                maxLeverage: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.maxLeverage;

            await expect(client.adjustCrossMarginMaxLeverage(params)).rejects.toThrow(
                'Required parameter maxLeverage was null or undefined when calling adjustCrossMarginMaxLeverage.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AdjustCrossMarginMaxLeverageRequest = {
                maxLeverage: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'adjustCrossMarginMaxLeverage')
                .mockRejectedValueOnce(mockError);
            await expect(client.adjustCrossMarginMaxLeverage(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('disableIsolatedMarginAccount()', () => {
        it('should execute disableIsolatedMarginAccount() successfully with required parameters only', async () => {
            const params: DisableIsolatedMarginAccountRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = { success: true, symbol: 'BTCUSDT' };

            const spy = jest.spyOn(client, 'disableIsolatedMarginAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DisableIsolatedMarginAccountResponse>)
            );
            const response = await client.disableIsolatedMarginAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute disableIsolatedMarginAccount() successfully with optional parameters', async () => {
            const params: DisableIsolatedMarginAccountRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = { success: true, symbol: 'BTCUSDT' };

            const spy = jest.spyOn(client, 'disableIsolatedMarginAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DisableIsolatedMarginAccountResponse>)
            );
            const response = await client.disableIsolatedMarginAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: DisableIsolatedMarginAccountRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.disableIsolatedMarginAccount(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling disableIsolatedMarginAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DisableIsolatedMarginAccountRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'disableIsolatedMarginAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.disableIsolatedMarginAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('enableIsolatedMarginAccount()', () => {
        it('should execute enableIsolatedMarginAccount() successfully with required parameters only', async () => {
            const params: EnableIsolatedMarginAccountRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = { success: true, symbol: 'BTCUSDT' };

            const spy = jest.spyOn(client, 'enableIsolatedMarginAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<EnableIsolatedMarginAccountResponse>)
            );
            const response = await client.enableIsolatedMarginAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute enableIsolatedMarginAccount() successfully with optional parameters', async () => {
            const params: EnableIsolatedMarginAccountRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = { success: true, symbol: 'BTCUSDT' };

            const spy = jest.spyOn(client, 'enableIsolatedMarginAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<EnableIsolatedMarginAccountResponse>)
            );
            const response = await client.enableIsolatedMarginAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: EnableIsolatedMarginAccountRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.enableIsolatedMarginAccount(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling enableIsolatedMarginAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: EnableIsolatedMarginAccountRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'enableIsolatedMarginAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.enableIsolatedMarginAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getBnbBurnStatus()', () => {
        it('should execute getBnbBurnStatus() successfully with required parameters only', async () => {
            mockResponse = { spotBNBBurn: true, interestBNBBurn: false };

            const spy = jest.spyOn(client, 'getBnbBurnStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetBnbBurnStatusResponse>)
            );
            const response = await client.getBnbBurnStatus();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getBnbBurnStatus() successfully with optional parameters', async () => {
            const params: GetBnbBurnStatusRequest = {
                recvWindow: 5000,
            };

            mockResponse = { spotBNBBurn: true, interestBNBBurn: false };

            const spy = jest.spyOn(client, 'getBnbBurnStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetBnbBurnStatusResponse>)
            );
            const response = await client.getBnbBurnStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getBnbBurnStatus').mockRejectedValueOnce(mockError);
            await expect(client.getBnbBurnStatus()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getSummaryOfMarginAccount()', () => {
        it('should execute getSummaryOfMarginAccount() successfully with required parameters only', async () => {
            mockResponse = { normalBar: '1.5', marginCallBar: '1.3', forceLiquidationBar: '1.1' };

            const spy = jest.spyOn(client, 'getSummaryOfMarginAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSummaryOfMarginAccountResponse>)
            );
            const response = await client.getSummaryOfMarginAccount();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSummaryOfMarginAccount() successfully with optional parameters', async () => {
            const params: GetSummaryOfMarginAccountRequest = {
                recvWindow: 5000,
            };

            mockResponse = { normalBar: '1.5', marginCallBar: '1.3', forceLiquidationBar: '1.1' };

            const spy = jest.spyOn(client, 'getSummaryOfMarginAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSummaryOfMarginAccountResponse>)
            );
            const response = await client.getSummaryOfMarginAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getSummaryOfMarginAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.getSummaryOfMarginAccount()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryCrossIsolatedMarginCapitalFlow()', () => {
        it('should execute queryCrossIsolatedMarginCapitalFlow() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    id: 123456,
                    tranId: 123123,
                    timestamp: 1691116657000,
                    asset: 'USDT',
                    symbol: 'BTCUSDT',
                    type: 'BORROW',
                    amount: '101',
                },
                {
                    id: 123457,
                    tranId: 123124,
                    timestamp: 1691116658000,
                    asset: 'BTC',
                    symbol: 'BTCUSDT',
                    type: 'REPAY',
                    amount: '10',
                },
            ];

            const spy = jest.spyOn(client, 'queryCrossIsolatedMarginCapitalFlow').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCrossIsolatedMarginCapitalFlowResponse>)
            );
            const response = await client.queryCrossIsolatedMarginCapitalFlow();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryCrossIsolatedMarginCapitalFlow() successfully with optional parameters', async () => {
            const params: QueryCrossIsolatedMarginCapitalFlowRequest = {
                asset: 'asset_example',
                symbol: 'symbol_example',
                type: 'type_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                fromId: 1,
                limit: 500,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    id: 123456,
                    tranId: 123123,
                    timestamp: 1691116657000,
                    asset: 'USDT',
                    symbol: 'BTCUSDT',
                    type: 'BORROW',
                    amount: '101',
                },
                {
                    id: 123457,
                    tranId: 123124,
                    timestamp: 1691116658000,
                    asset: 'BTC',
                    symbol: 'BTCUSDT',
                    type: 'REPAY',
                    amount: '10',
                },
            ];

            const spy = jest.spyOn(client, 'queryCrossIsolatedMarginCapitalFlow').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCrossIsolatedMarginCapitalFlowResponse>)
            );
            const response = await client.queryCrossIsolatedMarginCapitalFlow(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryCrossIsolatedMarginCapitalFlow')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryCrossIsolatedMarginCapitalFlow()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryCrossMarginAccountDetails()', () => {
        it('should execute queryCrossMarginAccountDetails() successfully with required parameters only', async () => {
            mockResponse = {
                created: true,
                borrowEnabled: true,
                marginLevel: '11.64405625',
                collateralMarginLevel: '3.2',
                totalAssetOfBtc: '6.82728457',
                totalLiabilityOfBtc: '0.58633215',
                totalNetAssetOfBtc: '6.24095242',
                TotalCollateralValueInUSDT: '5.82728457',
                totalOpenOrderLossInUSDT: '582.728457',
                tradeEnabled: true,
                transferInEnabled: true,
                transferOutEnabled: true,
                accountType: 'MARGIN_1',
                userAssets: [
                    {
                        asset: 'BTC',
                        borrowed: '0.00000000',
                        free: '0.00499500',
                        interest: '0.00000000',
                        locked: '0.00000000',
                        netAsset: '0.00499500',
                    },
                    {
                        asset: 'BNB',
                        borrowed: '201.66666672',
                        free: '2346.50000000',
                        interest: '0.00000000',
                        locked: '0.00000000',
                        netAsset: '2144.83333328',
                    },
                    {
                        asset: 'ETH',
                        borrowed: '0.00000000',
                        free: '0.00000000',
                        interest: '0.00000000',
                        locked: '0.00000000',
                        netAsset: '0.00000000',
                    },
                    {
                        asset: 'USDT',
                        borrowed: '0.00000000',
                        free: '0.00000000',
                        interest: '0.00000000',
                        locked: '0.00000000',
                        netAsset: '0.00000000',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'queryCrossMarginAccountDetails').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCrossMarginAccountDetailsResponse>)
            );
            const response = await client.queryCrossMarginAccountDetails();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryCrossMarginAccountDetails() successfully with optional parameters', async () => {
            const params: QueryCrossMarginAccountDetailsRequest = {
                recvWindow: 5000,
            };

            mockResponse = {
                created: true,
                borrowEnabled: true,
                marginLevel: '11.64405625',
                collateralMarginLevel: '3.2',
                totalAssetOfBtc: '6.82728457',
                totalLiabilityOfBtc: '0.58633215',
                totalNetAssetOfBtc: '6.24095242',
                TotalCollateralValueInUSDT: '5.82728457',
                totalOpenOrderLossInUSDT: '582.728457',
                tradeEnabled: true,
                transferInEnabled: true,
                transferOutEnabled: true,
                accountType: 'MARGIN_1',
                userAssets: [
                    {
                        asset: 'BTC',
                        borrowed: '0.00000000',
                        free: '0.00499500',
                        interest: '0.00000000',
                        locked: '0.00000000',
                        netAsset: '0.00499500',
                    },
                    {
                        asset: 'BNB',
                        borrowed: '201.66666672',
                        free: '2346.50000000',
                        interest: '0.00000000',
                        locked: '0.00000000',
                        netAsset: '2144.83333328',
                    },
                    {
                        asset: 'ETH',
                        borrowed: '0.00000000',
                        free: '0.00000000',
                        interest: '0.00000000',
                        locked: '0.00000000',
                        netAsset: '0.00000000',
                    },
                    {
                        asset: 'USDT',
                        borrowed: '0.00000000',
                        free: '0.00000000',
                        interest: '0.00000000',
                        locked: '0.00000000',
                        netAsset: '0.00000000',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'queryCrossMarginAccountDetails').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCrossMarginAccountDetailsResponse>)
            );
            const response = await client.queryCrossMarginAccountDetails(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryCrossMarginAccountDetails')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryCrossMarginAccountDetails()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryCrossMarginFeeData()', () => {
        it('should execute queryCrossMarginFeeData() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    vipLevel: 0,
                    coin: 'BTC',
                    transferIn: true,
                    borrowable: true,
                    dailyInterest: '0.00026125',
                    yearlyInterest: '0.0953',
                    borrowLimit: '180',
                    marginablePairs: ['BNBBTC', 'TRXBTC', 'ETHBTC', 'BTCUSDT'],
                },
            ];

            const spy = jest.spyOn(client, 'queryCrossMarginFeeData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCrossMarginFeeDataResponse>)
            );
            const response = await client.queryCrossMarginFeeData();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryCrossMarginFeeData() successfully with optional parameters', async () => {
            const params: QueryCrossMarginFeeDataRequest = {
                vipLevel: 1,
                coin: 'coin_example',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    vipLevel: 0,
                    coin: 'BTC',
                    transferIn: true,
                    borrowable: true,
                    dailyInterest: '0.00026125',
                    yearlyInterest: '0.0953',
                    borrowLimit: '180',
                    marginablePairs: ['BNBBTC', 'TRXBTC', 'ETHBTC', 'BTCUSDT'],
                },
            ];

            const spy = jest.spyOn(client, 'queryCrossMarginFeeData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCrossMarginFeeDataResponse>)
            );
            const response = await client.queryCrossMarginFeeData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryCrossMarginFeeData')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryCrossMarginFeeData()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryEnabledIsolatedMarginAccountLimit()', () => {
        it('should execute queryEnabledIsolatedMarginAccountLimit() successfully with required parameters only', async () => {
            mockResponse = { enabledAccount: 5, maxAccount: 20 };

            const spy = jest
                .spyOn(client, 'queryEnabledIsolatedMarginAccountLimit')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryEnabledIsolatedMarginAccountLimitResponse>)
                );
            const response = await client.queryEnabledIsolatedMarginAccountLimit();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryEnabledIsolatedMarginAccountLimit() successfully with optional parameters', async () => {
            const params: QueryEnabledIsolatedMarginAccountLimitRequest = {
                recvWindow: 5000,
            };

            mockResponse = { enabledAccount: 5, maxAccount: 20 };

            const spy = jest
                .spyOn(client, 'queryEnabledIsolatedMarginAccountLimit')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryEnabledIsolatedMarginAccountLimitResponse>)
                );
            const response = await client.queryEnabledIsolatedMarginAccountLimit(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryEnabledIsolatedMarginAccountLimit')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryEnabledIsolatedMarginAccountLimit()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryIsolatedMarginAccountInfo()', () => {
        it('should execute queryIsolatedMarginAccountInfo() successfully with required parameters only', async () => {
            mockResponse = {
                assets: [
                    {
                        baseAsset: {
                            asset: 'BTC',
                            borrowEnabled: true,
                            borrowed: '0.00000000',
                            free: '0.00000000',
                            interest: '0.00000000',
                            locked: '0.00000000',
                            netAsset: '0.00000000',
                            netAssetOfBtc: '0.00000000',
                            repayEnabled: true,
                            totalAsset: '0.00000000',
                        },
                        quoteAsset: {
                            asset: 'USDT',
                            borrowEnabled: true,
                            borrowed: '0.00000000',
                            free: '0.00000000',
                            interest: '0.00000000',
                            locked: '0.00000000',
                            netAsset: '0.00000000',
                            netAssetOfBtc: '0.00000000',
                            repayEnabled: true,
                            totalAsset: '0.00000000',
                        },
                        symbol: 'BTCUSDT',
                        isolatedCreated: true,
                        enabled: true,
                        marginLevel: '0.00000000',
                        marginLevelStatus: 'EXCESSIVE',
                        marginRatio: '0.00000000',
                        indexPrice: '10000.00000000',
                        liquidatePrice: '1000.00000000',
                        liquidateRate: '1.00000000',
                        tradeEnabled: true,
                    },
                ],
                totalAssetOfBtc: '0.00000000',
                totalLiabilityOfBtc: '0.00000000',
                totalNetAssetOfBtc: '0.00000000',
            };

            const spy = jest.spyOn(client, 'queryIsolatedMarginAccountInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryIsolatedMarginAccountInfoResponse>)
            );
            const response = await client.queryIsolatedMarginAccountInfo();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryIsolatedMarginAccountInfo() successfully with optional parameters', async () => {
            const params: QueryIsolatedMarginAccountInfoRequest = {
                symbols: 'symbols_example',
                recvWindow: 5000,
            };

            mockResponse = {
                assets: [
                    {
                        baseAsset: {
                            asset: 'BTC',
                            borrowEnabled: true,
                            borrowed: '0.00000000',
                            free: '0.00000000',
                            interest: '0.00000000',
                            locked: '0.00000000',
                            netAsset: '0.00000000',
                            netAssetOfBtc: '0.00000000',
                            repayEnabled: true,
                            totalAsset: '0.00000000',
                        },
                        quoteAsset: {
                            asset: 'USDT',
                            borrowEnabled: true,
                            borrowed: '0.00000000',
                            free: '0.00000000',
                            interest: '0.00000000',
                            locked: '0.00000000',
                            netAsset: '0.00000000',
                            netAssetOfBtc: '0.00000000',
                            repayEnabled: true,
                            totalAsset: '0.00000000',
                        },
                        symbol: 'BTCUSDT',
                        isolatedCreated: true,
                        enabled: true,
                        marginLevel: '0.00000000',
                        marginLevelStatus: 'EXCESSIVE',
                        marginRatio: '0.00000000',
                        indexPrice: '10000.00000000',
                        liquidatePrice: '1000.00000000',
                        liquidateRate: '1.00000000',
                        tradeEnabled: true,
                    },
                ],
                totalAssetOfBtc: '0.00000000',
                totalLiabilityOfBtc: '0.00000000',
                totalNetAssetOfBtc: '0.00000000',
            };

            const spy = jest.spyOn(client, 'queryIsolatedMarginAccountInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryIsolatedMarginAccountInfoResponse>)
            );
            const response = await client.queryIsolatedMarginAccountInfo(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryIsolatedMarginAccountInfo')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryIsolatedMarginAccountInfo()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryIsolatedMarginFeeData()', () => {
        it('should execute queryIsolatedMarginFeeData() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    vipLevel: 0,
                    symbol: 'BTCUSDT',
                    leverage: '10',
                    data: [
                        { coin: 'BTC', dailyInterest: '0.00026125', borrowLimit: '270' },
                        { coin: 'USDT', dailyInterest: '0.000475', borrowLimit: '2100000' },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'queryIsolatedMarginFeeData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryIsolatedMarginFeeDataResponse>)
            );
            const response = await client.queryIsolatedMarginFeeData();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryIsolatedMarginFeeData() successfully with optional parameters', async () => {
            const params: QueryIsolatedMarginFeeDataRequest = {
                vipLevel: 1,
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    vipLevel: 0,
                    symbol: 'BTCUSDT',
                    leverage: '10',
                    data: [
                        { coin: 'BTC', dailyInterest: '0.00026125', borrowLimit: '270' },
                        { coin: 'USDT', dailyInterest: '0.000475', borrowLimit: '2100000' },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'queryIsolatedMarginFeeData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryIsolatedMarginFeeDataResponse>)
            );
            const response = await client.queryIsolatedMarginFeeData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryIsolatedMarginFeeData')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryIsolatedMarginFeeData()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
