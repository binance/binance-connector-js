/**
 * Binance Margin Trading REST API
 *
 * OpenAPI Specification for the Binance Margin Trading REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { TradeDataStreamApi } from '../../../src/rest-api';
import {
    CloseIsolatedMarginUserDataStreamRequest,
    CloseMarginUserDataStreamRequest,
    KeepaliveIsolatedMarginUserDataStreamRequest,
    KeepaliveMarginUserDataStreamRequest,
    StartIsolatedMarginUserDataStreamRequest,
} from '../../../src/rest-api';
import type {
    StartIsolatedMarginUserDataStreamResponse,
    StartMarginUserDataStreamResponse,
} from '../../../src/rest-api/types';

describe('TradeDataStreamApi', () => {
    let client: TradeDataStreamApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new TradeDataStreamApi(config);
    });

    describe('closeIsolatedMarginUserDataStream()', () => {
        it('should execute closeIsolatedMarginUserDataStream() successfully with required parameters only', async () => {
            const params: CloseIsolatedMarginUserDataStreamRequest = {
                symbol: 'symbol_example',
                listenkey: 'listenkey_example',
            };

            const spy = jest.spyOn(client, 'closeIsolatedMarginUserDataStream').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.closeIsolatedMarginUserDataStream(params);

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should execute closeIsolatedMarginUserDataStream() successfully with optional parameters', async () => {
            const params: CloseIsolatedMarginUserDataStreamRequest = {
                symbol: 'symbol_example',
                listenkey: 'listenkey_example',
            };

            const spy = jest.spyOn(client, 'closeIsolatedMarginUserDataStream').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.closeIsolatedMarginUserDataStream(params);

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CloseIsolatedMarginUserDataStreamRequest = {
                symbol: 'symbol_example',
                listenkey: 'listenkey_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.closeIsolatedMarginUserDataStream(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling closeIsolatedMarginUserDataStream.'
            );
        });

        it('should throw RequiredError when listenkey is missing', async () => {
            const _params: CloseIsolatedMarginUserDataStreamRequest = {
                symbol: 'symbol_example',
                listenkey: 'listenkey_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.listenkey;

            await expect(client.closeIsolatedMarginUserDataStream(params)).rejects.toThrow(
                'Required parameter listenkey was null or undefined when calling closeIsolatedMarginUserDataStream.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CloseIsolatedMarginUserDataStreamRequest = {
                symbol: 'symbol_example',
                listenkey: 'listenkey_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'closeIsolatedMarginUserDataStream')
                .mockRejectedValueOnce(mockError);
            await expect(client.closeIsolatedMarginUserDataStream(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('closeMarginUserDataStream()', () => {
        it('should execute closeMarginUserDataStream() successfully with required parameters only', async () => {
            const params: CloseMarginUserDataStreamRequest = {
                listenkey: 'listenkey_example',
            };

            const spy = jest.spyOn(client, 'closeMarginUserDataStream').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.closeMarginUserDataStream(params);

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should execute closeMarginUserDataStream() successfully with optional parameters', async () => {
            const params: CloseMarginUserDataStreamRequest = {
                listenkey: 'listenkey_example',
            };

            const spy = jest.spyOn(client, 'closeMarginUserDataStream').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.closeMarginUserDataStream(params);

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should throw RequiredError when listenkey is missing', async () => {
            const _params: CloseMarginUserDataStreamRequest = {
                listenkey: 'listenkey_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.listenkey;

            await expect(client.closeMarginUserDataStream(params)).rejects.toThrow(
                'Required parameter listenkey was null or undefined when calling closeMarginUserDataStream.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CloseMarginUserDataStreamRequest = {
                listenkey: 'listenkey_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'closeMarginUserDataStream')
                .mockRejectedValueOnce(mockError);
            await expect(client.closeMarginUserDataStream(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('keepaliveIsolatedMarginUserDataStream()', () => {
        it('should execute keepaliveIsolatedMarginUserDataStream() successfully with required parameters only', async () => {
            const params: KeepaliveIsolatedMarginUserDataStreamRequest = {
                symbol: 'symbol_example',
                listenKey: 'listenKey_example',
            };

            const spy = jest.spyOn(client, 'keepaliveIsolatedMarginUserDataStream').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.keepaliveIsolatedMarginUserDataStream(params);

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should execute keepaliveIsolatedMarginUserDataStream() successfully with optional parameters', async () => {
            const params: KeepaliveIsolatedMarginUserDataStreamRequest = {
                symbol: 'symbol_example',
                listenKey: 'listenKey_example',
            };

            const spy = jest.spyOn(client, 'keepaliveIsolatedMarginUserDataStream').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.keepaliveIsolatedMarginUserDataStream(params);

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: KeepaliveIsolatedMarginUserDataStreamRequest = {
                symbol: 'symbol_example',
                listenKey: 'listenKey_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.keepaliveIsolatedMarginUserDataStream(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling keepaliveIsolatedMarginUserDataStream.'
            );
        });

        it('should throw RequiredError when listenKey is missing', async () => {
            const _params: KeepaliveIsolatedMarginUserDataStreamRequest = {
                symbol: 'symbol_example',
                listenKey: 'listenKey_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.listenKey;

            await expect(client.keepaliveIsolatedMarginUserDataStream(params)).rejects.toThrow(
                'Required parameter listenKey was null or undefined when calling keepaliveIsolatedMarginUserDataStream.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: KeepaliveIsolatedMarginUserDataStreamRequest = {
                symbol: 'symbol_example',
                listenKey: 'listenKey_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'keepaliveIsolatedMarginUserDataStream')
                .mockRejectedValueOnce(mockError);
            await expect(client.keepaliveIsolatedMarginUserDataStream(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('keepaliveMarginUserDataStream()', () => {
        it('should execute keepaliveMarginUserDataStream() successfully with required parameters only', async () => {
            const params: KeepaliveMarginUserDataStreamRequest = {
                listenKey: 'listenKey_example',
            };

            const spy = jest.spyOn(client, 'keepaliveMarginUserDataStream').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.keepaliveMarginUserDataStream(params);

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should execute keepaliveMarginUserDataStream() successfully with optional parameters', async () => {
            const params: KeepaliveMarginUserDataStreamRequest = {
                listenKey: 'listenKey_example',
            };

            const spy = jest.spyOn(client, 'keepaliveMarginUserDataStream').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.keepaliveMarginUserDataStream(params);

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should throw RequiredError when listenKey is missing', async () => {
            const _params: KeepaliveMarginUserDataStreamRequest = {
                listenKey: 'listenKey_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.listenKey;

            await expect(client.keepaliveMarginUserDataStream(params)).rejects.toThrow(
                'Required parameter listenKey was null or undefined when calling keepaliveMarginUserDataStream.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: KeepaliveMarginUserDataStreamRequest = {
                listenKey: 'listenKey_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'keepaliveMarginUserDataStream')
                .mockRejectedValueOnce(mockError);
            await expect(client.keepaliveMarginUserDataStream(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('startIsolatedMarginUserDataStream()', () => {
        it('should execute startIsolatedMarginUserDataStream() successfully with required parameters only', async () => {
            const params: StartIsolatedMarginUserDataStreamRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                listenKey: 'T3ee22BIYuWqmvne0HNq2A2WsFlEtLhvWCtItw6ffhhdmjifQ2tRbuKkTHhr',
            };

            const spy = jest.spyOn(client, 'startIsolatedMarginUserDataStream').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<StartIsolatedMarginUserDataStreamResponse>)
            );
            const response = await client.startIsolatedMarginUserDataStream(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute startIsolatedMarginUserDataStream() successfully with optional parameters', async () => {
            const params: StartIsolatedMarginUserDataStreamRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                listenKey: 'T3ee22BIYuWqmvne0HNq2A2WsFlEtLhvWCtItw6ffhhdmjifQ2tRbuKkTHhr',
            };

            const spy = jest.spyOn(client, 'startIsolatedMarginUserDataStream').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<StartIsolatedMarginUserDataStreamResponse>)
            );
            const response = await client.startIsolatedMarginUserDataStream(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: StartIsolatedMarginUserDataStreamRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.startIsolatedMarginUserDataStream(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling startIsolatedMarginUserDataStream.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: StartIsolatedMarginUserDataStreamRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'startIsolatedMarginUserDataStream')
                .mockRejectedValueOnce(mockError);
            await expect(client.startIsolatedMarginUserDataStream(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('startMarginUserDataStream()', () => {
        it('should execute startMarginUserDataStream() successfully with required parameters only', async () => {
            mockResponse = {
                listenKey: 'T3ee22BIYuWqmvne0HNq2A2WsFlEtLhvWCtItw6ffhhdmjifQ2tRbuKkTHhr',
            };

            const spy = jest.spyOn(client, 'startMarginUserDataStream').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<StartMarginUserDataStreamResponse>)
            );
            const response = await client.startMarginUserDataStream();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'startMarginUserDataStream')
                .mockRejectedValueOnce(mockError);
            await expect(client.startMarginUserDataStream()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
