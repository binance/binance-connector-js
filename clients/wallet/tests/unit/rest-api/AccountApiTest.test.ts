/**
 * Binance Public Wallet REST API
 *
 * OpenAPI Specification for the Binance Public Wallet REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { AccountApi } from '../../../src/rest-api';
import {
    AccountApiTradingStatusRequest,
    AccountInfoRequest,
    AccountStatusRequest,
    DailyAccountSnapshotRequest,
    DisableFastWithdrawSwitchRequest,
    EnableFastWithdrawSwitchRequest,
    GetApiKeyPermissionRequest,
} from '../../../src/rest-api';
import type {
    AccountApiTradingStatusResponse,
    AccountInfoResponse,
    AccountStatusResponse,
    DailyAccountSnapshotResponse,
    GetApiKeyPermissionResponse,
} from '../../../src/rest-api/types';

describe('AccountApi', () => {
    let client: AccountApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new AccountApi(config);
    });

    describe('accountApiTradingStatus()', () => {
        it('should execute accountApiTradingStatus() successfully with required parameters only', async () => {
            mockResponse = {
                data: {
                    isLocked: false,
                    plannedRecoverTime: 0,
                    triggerCondition: { GCR: 150, IFER: 150, UFR: 300 },
                    updateTime: 1547630471725,
                },
            };

            const spy = jest.spyOn(client, 'accountApiTradingStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountApiTradingStatusResponse>)
            );
            const response = await client.accountApiTradingStatus();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute accountApiTradingStatus() successfully with optional parameters', async () => {
            const params: AccountApiTradingStatusRequest = {
                recvWindow: 5000,
            };

            mockResponse = {
                data: {
                    isLocked: false,
                    plannedRecoverTime: 0,
                    triggerCondition: { GCR: 150, IFER: 150, UFR: 300 },
                    updateTime: 1547630471725,
                },
            };

            const spy = jest.spyOn(client, 'accountApiTradingStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountApiTradingStatusResponse>)
            );
            const response = await client.accountApiTradingStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'accountApiTradingStatus')
                .mockRejectedValueOnce(mockError);
            await expect(client.accountApiTradingStatus()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('accountInfo()', () => {
        it('should execute accountInfo() successfully with required parameters only', async () => {
            mockResponse = {
                vipLevel: 0,
                isMarginEnabled: true,
                isFutureEnabled: true,
                isOptionsEnabled: true,
                isPortfolioMarginRetailEnabled: true,
            };

            const spy = jest.spyOn(client, 'accountInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountInfoResponse>)
            );
            const response = await client.accountInfo();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute accountInfo() successfully with optional parameters', async () => {
            const params: AccountInfoRequest = {
                recvWindow: 5000,
            };

            mockResponse = {
                vipLevel: 0,
                isMarginEnabled: true,
                isFutureEnabled: true,
                isOptionsEnabled: true,
                isPortfolioMarginRetailEnabled: true,
            };

            const spy = jest.spyOn(client, 'accountInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountInfoResponse>)
            );
            const response = await client.accountInfo(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'accountInfo').mockRejectedValueOnce(mockError);
            await expect(client.accountInfo()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('accountStatus()', () => {
        it('should execute accountStatus() successfully with required parameters only', async () => {
            mockResponse = { data: 'Normal' };

            const spy = jest.spyOn(client, 'accountStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountStatusResponse>)
            );
            const response = await client.accountStatus();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute accountStatus() successfully with optional parameters', async () => {
            const params: AccountStatusRequest = {
                recvWindow: 5000,
            };

            mockResponse = { data: 'Normal' };

            const spy = jest.spyOn(client, 'accountStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountStatusResponse>)
            );
            const response = await client.accountStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'accountStatus').mockRejectedValueOnce(mockError);
            await expect(client.accountStatus()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('dailyAccountSnapshot()', () => {
        it('should execute dailyAccountSnapshot() successfully with required parameters only', async () => {
            const params: DailyAccountSnapshotRequest = {
                type: 'type_example',
            };

            mockResponse = {
                code: 200,
                msg: '',
                snapshotVos: [
                    {
                        data: {
                            balances: [
                                { asset: 'BTC', free: '0.09905021', locked: '0.00000000' },
                                { asset: 'USDT', free: '1.89109409', locked: '0.00000000' },
                            ],
                            totalAssetOfBtc: '0.09942700',
                        },
                        type: 'spot',
                        updateTime: 1576281599000,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'dailyAccountSnapshot').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DailyAccountSnapshotResponse>)
            );
            const response = await client.dailyAccountSnapshot(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute dailyAccountSnapshot() successfully with optional parameters', async () => {
            const params: DailyAccountSnapshotRequest = {
                type: 'type_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 7,
                recvWindow: 5000,
            };

            mockResponse = {
                code: 200,
                msg: '',
                snapshotVos: [
                    {
                        data: {
                            balances: [
                                { asset: 'BTC', free: '0.09905021', locked: '0.00000000' },
                                { asset: 'USDT', free: '1.89109409', locked: '0.00000000' },
                            ],
                            totalAssetOfBtc: '0.09942700',
                        },
                        type: 'spot',
                        updateTime: 1576281599000,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'dailyAccountSnapshot').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DailyAccountSnapshotResponse>)
            );
            const response = await client.dailyAccountSnapshot(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: DailyAccountSnapshotRequest = {
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.dailyAccountSnapshot(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling dailyAccountSnapshot.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DailyAccountSnapshotRequest = {
                type: 'type_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'dailyAccountSnapshot').mockRejectedValueOnce(mockError);
            await expect(client.dailyAccountSnapshot(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('disableFastWithdrawSwitch()', () => {
        it('should execute disableFastWithdrawSwitch() successfully with required parameters only', async () => {
            const spy = jest.spyOn(client, 'disableFastWithdrawSwitch').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.disableFastWithdrawSwitch();

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should execute disableFastWithdrawSwitch() successfully with optional parameters', async () => {
            const params: DisableFastWithdrawSwitchRequest = {
                recvWindow: 5000,
            };

            const spy = jest.spyOn(client, 'disableFastWithdrawSwitch').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.disableFastWithdrawSwitch(params);

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'disableFastWithdrawSwitch')
                .mockRejectedValueOnce(mockError);
            await expect(client.disableFastWithdrawSwitch()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('enableFastWithdrawSwitch()', () => {
        it('should execute enableFastWithdrawSwitch() successfully with required parameters only', async () => {
            const spy = jest.spyOn(client, 'enableFastWithdrawSwitch').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.enableFastWithdrawSwitch();

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should execute enableFastWithdrawSwitch() successfully with optional parameters', async () => {
            const params: EnableFastWithdrawSwitchRequest = {
                recvWindow: 5000,
            };

            const spy = jest.spyOn(client, 'enableFastWithdrawSwitch').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.enableFastWithdrawSwitch(params);

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'enableFastWithdrawSwitch')
                .mockRejectedValueOnce(mockError);
            await expect(client.enableFastWithdrawSwitch()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getApiKeyPermission()', () => {
        it('should execute getApiKeyPermission() successfully with required parameters only', async () => {
            mockResponse = {
                ipRestrict: false,
                createTime: 1698645219000,
                enableReading: true,
                enableWithdrawals: false,
                enableInternalTransfer: false,
                enableMargin: false,
                enableFutures: false,
                permitsUniversalTransfer: false,
                enableVanillaOptions: false,
                enableFixApiTrade: false,
                enableFixReadOnly: true,
                enableSpotAndMarginTrading: false,
                enablePortfolioMarginTrading: true,
            };

            const spy = jest.spyOn(client, 'getApiKeyPermission').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetApiKeyPermissionResponse>)
            );
            const response = await client.getApiKeyPermission();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getApiKeyPermission() successfully with optional parameters', async () => {
            const params: GetApiKeyPermissionRequest = {
                recvWindow: 5000,
            };

            mockResponse = {
                ipRestrict: false,
                createTime: 1698645219000,
                enableReading: true,
                enableWithdrawals: false,
                enableInternalTransfer: false,
                enableMargin: false,
                enableFutures: false,
                permitsUniversalTransfer: false,
                enableVanillaOptions: false,
                enableFixApiTrade: false,
                enableFixReadOnly: true,
                enableSpotAndMarginTrading: false,
                enablePortfolioMarginTrading: true,
            };

            const spy = jest.spyOn(client, 'getApiKeyPermission').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetApiKeyPermissionResponse>)
            );
            const response = await client.getApiKeyPermission(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getApiKeyPermission').mockRejectedValueOnce(mockError);
            await expect(client.getApiKeyPermission()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
