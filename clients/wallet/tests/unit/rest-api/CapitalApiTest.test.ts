/**
 * Binance Wallet REST API
 *
 * OpenAPI Specification for the Binance Wallet REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { CapitalApi } from '../../../src/rest-api';
import {
    AllCoinsInformationRequest,
    DepositAddressRequest,
    DepositHistoryRequest,
    FetchDepositAddressListWithNetworkRequest,
    OneClickArrivalDepositApplyRequest,
    WithdrawRequest,
    WithdrawHistoryRequest,
} from '../../../src/rest-api';
import type {
    AllCoinsInformationResponse,
    DepositAddressResponse,
    DepositHistoryResponse,
    FetchDepositAddressListWithNetworkResponse,
    FetchWithdrawAddressListResponse,
    FetchWithdrawQuotaResponse,
    OneClickArrivalDepositApplyResponse,
    WithdrawHistoryResponse,
    WithdrawResponse,
} from '../../../src/rest-api/types';

describe('CapitalApi', () => {
    let client: CapitalApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new CapitalApi(config);
    });

    describe('allCoinsInformation()', () => {
        it('should execute allCoinsInformation() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    coin: 'BTC',
                    depositAllEnable: true,
                    free: '0.08074558',
                    freeze: '0.00000000',
                    ipoable: '0.00000000',
                    ipoing: '0.00000000',
                    isLegalMoney: false,
                    locked: '0.00000000',
                    name: 'Bitcoin',
                    networkList: [
                        {
                            addressRegex: '^(bnb1)[0-9a-z]{38}$',
                            coin: 'BTC',
                            depositDesc: 'Wallet Maintenance, Deposit Suspended',
                            depositEnable: false,
                            isDefault: false,
                            memoRegex: '^[0-9A-Za-z\\-_]{1,120}$',
                            minConfirm: 1,
                            name: 'BEP2',
                            network: 'BNB',
                            specialTips:
                                'Both a MEMO and an Address are required to successfully deposit your BEP2-BTCB tokens to Binance.',
                            unLockConfirm: 0,
                            withdrawDesc: 'Wallet Maintenance, Withdrawal Suspended',
                            withdrawEnable: false,
                            withdrawFee: '0.00000220',
                            withdrawIntegerMultiple: '0.00000001',
                            withdrawMax: '9999999999.99999999',
                            withdrawMin: '0.00000440',
                            withdrawInternalMin: '0.00000440',
                            sameAddress: true,
                            estimatedArrivalTime: 25,
                            busy: false,
                            contractAddressUrl: 'https://bscscan.com/token/',
                            contractAddress: '0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c',
                        },
                        {
                            addressRegex:
                                '^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$|^(bc1)[0-9A-Za-z]{39,59}$',
                            coin: 'BTC',
                            depositEnable: true,
                            isDefault: true,
                            memoRegex: '',
                            minConfirm: 1,
                            name: 'BTC',
                            network: 'BTC',
                            specialTips: '',
                            unLockConfirm: 2,
                            withdrawEnable: true,
                            withdrawFee: '0.00050000',
                            withdrawIntegerMultiple: '0.00000001',
                            withdrawMax: '750',
                            withdrawMin: '0.00100000',
                            withdrawInternalMin: '0.00100000',
                            sameAddress: false,
                            estimatedArrivalTime: 25,
                            busy: false,
                            contractAddressUrl: '',
                            contractAddress: '',
                        },
                        {
                            coin: '1MBABYDOGE',
                            depositAllEnable: true,
                            withdrawAllEnable: true,
                            name: '1M x BABYDOGE',
                            free: '34941.1',
                            locked: '0',
                            freeze: '0',
                            withdrawing: '0',
                            ipoing: '0',
                            ipoable: '0',
                            storage: '0',
                            isLegalMoney: false,
                            trading: true,
                            networkList: [
                                {
                                    network: 'BSC',
                                    coin: '1MBABYDOGE',
                                    withdrawIntegerMultiple: '0.01',
                                    isDefault: false,
                                    depositEnable: true,
                                    withdrawEnable: true,
                                    depositDesc: '',
                                    withdrawDesc: '',
                                    specialTips: '',
                                    specialWithdrawTips: '',
                                    name: 'BNB Smart Chain (BEP20)',
                                    resetAddressStatus: false,
                                    addressRegex: '^(0x)[0-9A-Fa-f]{40}$',
                                    memoRegex: '',
                                    withdrawFee: '404',
                                    withdrawMin: '808',
                                    withdrawMax: '9999999999',
                                    withdrawInternalMin: '0.01',
                                    depositDust: '0.01',
                                    minConfirm: 15,
                                    unLockConfirm: 0,
                                    sameAddress: false,
                                    estimatedArrivalTime: 1,
                                    busy: false,
                                    contractAddressUrl: 'https://bscscan.com/token/',
                                    contractAddress: '0xc748673057861a797275cd8a068abb95a902e8de',
                                    denomination: 1000000,
                                },
                                {
                                    network: 'ETH',
                                    coin: '1MBABYDOGE',
                                    withdrawIntegerMultiple: '0.01',
                                    isDefault: true,
                                    depositEnable: true,
                                    withdrawEnable: true,
                                    depositDesc: '',
                                    withdrawDesc: '',
                                    specialTips: '',
                                    specialWithdrawTips: '',
                                    name: 'Ethereum (ERC20)',
                                    resetAddressStatus: false,
                                    addressRegex: '^(0x)[0-9A-Fa-f]{40}$',
                                    memoRegex: '',
                                    withdrawFee: '2313',
                                    withdrawMin: '4626',
                                    withdrawMax: '9999999999',
                                    withdrawInternalMin: '0.01',
                                    depositDust: '0.01',
                                    minConfirm: 6,
                                    unLockConfirm: 64,
                                    sameAddress: false,
                                    estimatedArrivalTime: 2,
                                    busy: false,
                                    contractAddressUrl: 'https://etherscan.io/address/',
                                    contractAddress: '0xac57de9c1a09fec648e93eb98875b212db0d460b',
                                    denomination: 1000000,
                                },
                            ],
                        },
                    ],
                    storage: '0.00000000',
                    trading: true,
                    withdrawAllEnable: true,
                    withdrawing: '0.00000000',
                },
            ];

            const spy = jest.spyOn(client, 'allCoinsInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AllCoinsInformationResponse>)
            );
            const response = await client.allCoinsInformation();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute allCoinsInformation() successfully with optional parameters', async () => {
            const params: AllCoinsInformationRequest = {
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    coin: 'BTC',
                    depositAllEnable: true,
                    free: '0.08074558',
                    freeze: '0.00000000',
                    ipoable: '0.00000000',
                    ipoing: '0.00000000',
                    isLegalMoney: false,
                    locked: '0.00000000',
                    name: 'Bitcoin',
                    networkList: [
                        {
                            addressRegex: '^(bnb1)[0-9a-z]{38}$',
                            coin: 'BTC',
                            depositDesc: 'Wallet Maintenance, Deposit Suspended',
                            depositEnable: false,
                            isDefault: false,
                            memoRegex: '^[0-9A-Za-z\\-_]{1,120}$',
                            minConfirm: 1,
                            name: 'BEP2',
                            network: 'BNB',
                            specialTips:
                                'Both a MEMO and an Address are required to successfully deposit your BEP2-BTCB tokens to Binance.',
                            unLockConfirm: 0,
                            withdrawDesc: 'Wallet Maintenance, Withdrawal Suspended',
                            withdrawEnable: false,
                            withdrawFee: '0.00000220',
                            withdrawIntegerMultiple: '0.00000001',
                            withdrawMax: '9999999999.99999999',
                            withdrawMin: '0.00000440',
                            withdrawInternalMin: '0.00000440',
                            sameAddress: true,
                            estimatedArrivalTime: 25,
                            busy: false,
                            contractAddressUrl: 'https://bscscan.com/token/',
                            contractAddress: '0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c',
                        },
                        {
                            addressRegex:
                                '^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$|^(bc1)[0-9A-Za-z]{39,59}$',
                            coin: 'BTC',
                            depositEnable: true,
                            isDefault: true,
                            memoRegex: '',
                            minConfirm: 1,
                            name: 'BTC',
                            network: 'BTC',
                            specialTips: '',
                            unLockConfirm: 2,
                            withdrawEnable: true,
                            withdrawFee: '0.00050000',
                            withdrawIntegerMultiple: '0.00000001',
                            withdrawMax: '750',
                            withdrawMin: '0.00100000',
                            withdrawInternalMin: '0.00100000',
                            sameAddress: false,
                            estimatedArrivalTime: 25,
                            busy: false,
                            contractAddressUrl: '',
                            contractAddress: '',
                        },
                        {
                            coin: '1MBABYDOGE',
                            depositAllEnable: true,
                            withdrawAllEnable: true,
                            name: '1M x BABYDOGE',
                            free: '34941.1',
                            locked: '0',
                            freeze: '0',
                            withdrawing: '0',
                            ipoing: '0',
                            ipoable: '0',
                            storage: '0',
                            isLegalMoney: false,
                            trading: true,
                            networkList: [
                                {
                                    network: 'BSC',
                                    coin: '1MBABYDOGE',
                                    withdrawIntegerMultiple: '0.01',
                                    isDefault: false,
                                    depositEnable: true,
                                    withdrawEnable: true,
                                    depositDesc: '',
                                    withdrawDesc: '',
                                    specialTips: '',
                                    specialWithdrawTips: '',
                                    name: 'BNB Smart Chain (BEP20)',
                                    resetAddressStatus: false,
                                    addressRegex: '^(0x)[0-9A-Fa-f]{40}$',
                                    memoRegex: '',
                                    withdrawFee: '404',
                                    withdrawMin: '808',
                                    withdrawMax: '9999999999',
                                    withdrawInternalMin: '0.01',
                                    depositDust: '0.01',
                                    minConfirm: 15,
                                    unLockConfirm: 0,
                                    sameAddress: false,
                                    estimatedArrivalTime: 1,
                                    busy: false,
                                    contractAddressUrl: 'https://bscscan.com/token/',
                                    contractAddress: '0xc748673057861a797275cd8a068abb95a902e8de',
                                    denomination: 1000000,
                                },
                                {
                                    network: 'ETH',
                                    coin: '1MBABYDOGE',
                                    withdrawIntegerMultiple: '0.01',
                                    isDefault: true,
                                    depositEnable: true,
                                    withdrawEnable: true,
                                    depositDesc: '',
                                    withdrawDesc: '',
                                    specialTips: '',
                                    specialWithdrawTips: '',
                                    name: 'Ethereum (ERC20)',
                                    resetAddressStatus: false,
                                    addressRegex: '^(0x)[0-9A-Fa-f]{40}$',
                                    memoRegex: '',
                                    withdrawFee: '2313',
                                    withdrawMin: '4626',
                                    withdrawMax: '9999999999',
                                    withdrawInternalMin: '0.01',
                                    depositDust: '0.01',
                                    minConfirm: 6,
                                    unLockConfirm: 64,
                                    sameAddress: false,
                                    estimatedArrivalTime: 2,
                                    busy: false,
                                    contractAddressUrl: 'https://etherscan.io/address/',
                                    contractAddress: '0xac57de9c1a09fec648e93eb98875b212db0d460b',
                                    denomination: 1000000,
                                },
                            ],
                        },
                    ],
                    storage: '0.00000000',
                    trading: true,
                    withdrawAllEnable: true,
                    withdrawing: '0.00000000',
                },
            ];

            const spy = jest.spyOn(client, 'allCoinsInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AllCoinsInformationResponse>)
            );
            const response = await client.allCoinsInformation(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'allCoinsInformation').mockRejectedValueOnce(mockError);
            await expect(client.allCoinsInformation()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('depositAddress()', () => {
        it('should execute depositAddress() successfully with required parameters only', async () => {
            const params: DepositAddressRequest = {
                coin: 'coin_example',
            };

            mockResponse = {
                address: '1HPn8Rx2y6nNSfagQBKy27GB99Vbzg89wv',
                coin: 'BTC',
                tag: '',
                url: 'https://btc.com/1HPn8Rx2y6nNSfagQBKy27GB99Vbzg89wv',
            };

            const spy = jest.spyOn(client, 'depositAddress').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepositAddressResponse>)
            );
            const response = await client.depositAddress(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute depositAddress() successfully with optional parameters', async () => {
            const params: DepositAddressRequest = {
                coin: 'coin_example',
                network: 'network_example',
                amount: 1,
                recvWindow: 5000,
            };

            mockResponse = {
                address: '1HPn8Rx2y6nNSfagQBKy27GB99Vbzg89wv',
                coin: 'BTC',
                tag: '',
                url: 'https://btc.com/1HPn8Rx2y6nNSfagQBKy27GB99Vbzg89wv',
            };

            const spy = jest.spyOn(client, 'depositAddress').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepositAddressResponse>)
            );
            const response = await client.depositAddress(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when coin is missing', async () => {
            const _params: DepositAddressRequest = {
                coin: 'coin_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.coin;

            await expect(client.depositAddress(params)).rejects.toThrow(
                'Required parameter coin was null or undefined when calling depositAddress.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DepositAddressRequest = {
                coin: 'coin_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'depositAddress').mockRejectedValueOnce(mockError);
            await expect(client.depositAddress(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('depositHistory()', () => {
        it('should execute depositHistory() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    id: '769800519366885376',
                    amount: '0.001',
                    coin: 'BNB',
                    network: 'BNB',
                    status: 1,
                    address: 'bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23',
                    addressTag: '101764890',
                    txId: '98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC',
                    insertTime: 1661493146000,
                    completeTime: 1661493146000,
                    transferType: 0,
                    confirmTimes: '1/1',
                    unlockConfirm: 0,
                    walletType: 0,
                },
                {
                    id: '769754833590042625',
                    amount: '0.50000000',
                    coin: 'IOTA',
                    network: 'IOTA',
                    status: 1,
                    address:
                        'SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW',
                    addressTag: '',
                    txId: 'ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999',
                    insertTime: 1599620082000,
                    completeTime: 1661493146000,
                    transferType: 0,
                    confirmTimes: '1/1',
                    unlockConfirm: 0,
                    walletType: 0,
                },
            ];

            const spy = jest.spyOn(client, 'depositHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepositHistoryResponse>)
            );
            const response = await client.depositHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute depositHistory() successfully with optional parameters', async () => {
            const params: DepositHistoryRequest = {
                includeSource: false,
                coin: 'coin_example',
                status: 789,
                startTime: 1623319461670,
                endTime: 1641782889000,
                offset: 0,
                limit: 7,
                recvWindow: 5000,
                txId: '1',
            };

            mockResponse = [
                {
                    id: '769800519366885376',
                    amount: '0.001',
                    coin: 'BNB',
                    network: 'BNB',
                    status: 1,
                    address: 'bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23',
                    addressTag: '101764890',
                    txId: '98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC',
                    insertTime: 1661493146000,
                    completeTime: 1661493146000,
                    transferType: 0,
                    confirmTimes: '1/1',
                    unlockConfirm: 0,
                    walletType: 0,
                },
                {
                    id: '769754833590042625',
                    amount: '0.50000000',
                    coin: 'IOTA',
                    network: 'IOTA',
                    status: 1,
                    address:
                        'SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW',
                    addressTag: '',
                    txId: 'ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999',
                    insertTime: 1599620082000,
                    completeTime: 1661493146000,
                    transferType: 0,
                    confirmTimes: '1/1',
                    unlockConfirm: 0,
                    walletType: 0,
                },
            ];

            const spy = jest.spyOn(client, 'depositHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepositHistoryResponse>)
            );
            const response = await client.depositHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'depositHistory').mockRejectedValueOnce(mockError);
            await expect(client.depositHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('fetchDepositAddressListWithNetwork()', () => {
        it('should execute fetchDepositAddressListWithNetwork() successfully with required parameters only', async () => {
            const params: FetchDepositAddressListWithNetworkRequest = {
                coin: 'coin_example',
            };

            mockResponse = [
                {
                    coin: 'ETH',
                    address: '0xD316E95Fd9E8E237Cb11f8200Babbc5D8D177BA4',
                    tag: '',
                    isDefault: 0,
                },
                {
                    coin: 'ETH',
                    address: '0xD316E95Fd9E8E237Cb11f8200Babbc5D8D177BA4',
                    tag: '',
                    isDefault: 0,
                },
                {
                    coin: 'ETH',
                    address: '0x00003ada75e7da97ba0db2fcde72131f712455e2',
                    tag: '',
                    isDefault: 1,
                },
            ];

            const spy = jest.spyOn(client, 'fetchDepositAddressListWithNetwork').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FetchDepositAddressListWithNetworkResponse>)
            );
            const response = await client.fetchDepositAddressListWithNetwork(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute fetchDepositAddressListWithNetwork() successfully with optional parameters', async () => {
            const params: FetchDepositAddressListWithNetworkRequest = {
                coin: 'coin_example',
                network: 'network_example',
            };

            mockResponse = [
                {
                    coin: 'ETH',
                    address: '0xD316E95Fd9E8E237Cb11f8200Babbc5D8D177BA4',
                    tag: '',
                    isDefault: 0,
                },
                {
                    coin: 'ETH',
                    address: '0xD316E95Fd9E8E237Cb11f8200Babbc5D8D177BA4',
                    tag: '',
                    isDefault: 0,
                },
                {
                    coin: 'ETH',
                    address: '0x00003ada75e7da97ba0db2fcde72131f712455e2',
                    tag: '',
                    isDefault: 1,
                },
            ];

            const spy = jest.spyOn(client, 'fetchDepositAddressListWithNetwork').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FetchDepositAddressListWithNetworkResponse>)
            );
            const response = await client.fetchDepositAddressListWithNetwork(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when coin is missing', async () => {
            const _params: FetchDepositAddressListWithNetworkRequest = {
                coin: 'coin_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.coin;

            await expect(client.fetchDepositAddressListWithNetwork(params)).rejects.toThrow(
                'Required parameter coin was null or undefined when calling fetchDepositAddressListWithNetwork.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: FetchDepositAddressListWithNetworkRequest = {
                coin: 'coin_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'fetchDepositAddressListWithNetwork')
                .mockRejectedValueOnce(mockError);
            await expect(client.fetchDepositAddressListWithNetwork(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('fetchWithdrawAddressList()', () => {
        it('should execute fetchWithdrawAddressList() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    address: '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa',
                    addressTag: '',
                    coin: 'BTC',
                    name: 'Satoshi',
                    network: 'BTC',
                    origin: 'bla',
                    originType: 'others',
                    whiteStatus: true,
                },
            ];

            const spy = jest.spyOn(client, 'fetchWithdrawAddressList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FetchWithdrawAddressListResponse>)
            );
            const response = await client.fetchWithdrawAddressList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'fetchWithdrawAddressList')
                .mockRejectedValueOnce(mockError);
            await expect(client.fetchWithdrawAddressList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('fetchWithdrawQuota()', () => {
        it('should execute fetchWithdrawQuota() successfully with required parameters only', async () => {
            mockResponse = { wdQuota: '10000', usedWdQuota: '1000' };

            const spy = jest.spyOn(client, 'fetchWithdrawQuota').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FetchWithdrawQuotaResponse>)
            );
            const response = await client.fetchWithdrawQuota();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'fetchWithdrawQuota').mockRejectedValueOnce(mockError);
            await expect(client.fetchWithdrawQuota()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('oneClickArrivalDepositApply()', () => {
        it('should execute oneClickArrivalDepositApply() successfully with required parameters only', async () => {
            mockResponse = { code: '000000', message: 'success', data: true, success: true };

            const spy = jest.spyOn(client, 'oneClickArrivalDepositApply').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OneClickArrivalDepositApplyResponse>)
            );
            const response = await client.oneClickArrivalDepositApply();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute oneClickArrivalDepositApply() successfully with optional parameters', async () => {
            const params: OneClickArrivalDepositApplyRequest = {
                depositId: 1,
                txId: '1',
                subAccountId: 1,
                subUserId: 1,
            };

            mockResponse = { code: '000000', message: 'success', data: true, success: true };

            const spy = jest.spyOn(client, 'oneClickArrivalDepositApply').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OneClickArrivalDepositApplyResponse>)
            );
            const response = await client.oneClickArrivalDepositApply(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'oneClickArrivalDepositApply')
                .mockRejectedValueOnce(mockError);
            await expect(client.oneClickArrivalDepositApply()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('withdraw()', () => {
        it('should execute withdraw() successfully with required parameters only', async () => {
            const params: WithdrawRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1,
            };

            mockResponse = { id: '7213fea8e94b4a5593d507237e5a555b' };

            const spy = jest.spyOn(client, 'withdraw').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<WithdrawResponse>)
            );
            const response = await client.withdraw(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute withdraw() successfully with optional parameters', async () => {
            const params: WithdrawRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1,
                withdrawOrderId: '1',
                network: 'network_example',
                addressTag: 'addressTag_example',
                transactionFeeFlag: false,
                name: 'name_example',
                walletType: 0,
                recvWindow: 5000,
            };

            mockResponse = { id: '7213fea8e94b4a5593d507237e5a555b' };

            const spy = jest.spyOn(client, 'withdraw').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<WithdrawResponse>)
            );
            const response = await client.withdraw(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when coin is missing', async () => {
            const _params: WithdrawRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.coin;

            await expect(client.withdraw(params)).rejects.toThrow(
                'Required parameter coin was null or undefined when calling withdraw.'
            );
        });

        it('should throw RequiredError when address is missing', async () => {
            const _params: WithdrawRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.address;

            await expect(client.withdraw(params)).rejects.toThrow(
                'Required parameter address was null or undefined when calling withdraw.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: WithdrawRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.withdraw(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling withdraw.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: WithdrawRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'withdraw').mockRejectedValueOnce(mockError);
            await expect(client.withdraw(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('withdrawHistory()', () => {
        it('should execute withdrawHistory() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    id: 'b6ae22b3aa844210a7041aee7589627c',
                    amount: '8.91000000',
                    transactionFee: '0.004',
                    coin: 'USDT',
                    status: 6,
                    address: '0x94df8b352de7f46f64b01d3666bf6e936e44ce60',
                    txId: '0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268',
                    applyTime: '2019-10-12 11:12:02',
                    network: 'ETH',
                    transferType: 0,
                    withdrawOrderId: 'WITHDRAWtest123',
                    info: 'The address is not valid. Please confirm with the recipient',
                    confirmNo: 3,
                    walletType: 1,
                    txKey: '',
                    completeTime: '2023-03-23 16:52:41',
                },
                {
                    id: '156ec387f49b41df8724fa744fa82719',
                    amount: '0.00150000',
                    transactionFee: '0.004',
                    coin: 'BTC',
                    status: 6,
                    address: '1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB',
                    txId: '60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354',
                    applyTime: '2019-09-24 12:43:45',
                    network: 'BTC',
                    transferType: 0,
                    info: '',
                    confirmNo: 2,
                    walletType: 1,
                    txKey: '',
                    completeTime: '2023-03-23 16:52:41',
                },
            ];

            const spy = jest.spyOn(client, 'withdrawHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<WithdrawHistoryResponse>)
            );
            const response = await client.withdrawHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute withdrawHistory() successfully with optional parameters', async () => {
            const params: WithdrawHistoryRequest = {
                coin: 'coin_example',
                withdrawOrderId: '1',
                status: 789,
                offset: 0,
                limit: 7,
                idList: 'idList_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    id: 'b6ae22b3aa844210a7041aee7589627c',
                    amount: '8.91000000',
                    transactionFee: '0.004',
                    coin: 'USDT',
                    status: 6,
                    address: '0x94df8b352de7f46f64b01d3666bf6e936e44ce60',
                    txId: '0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268',
                    applyTime: '2019-10-12 11:12:02',
                    network: 'ETH',
                    transferType: 0,
                    withdrawOrderId: 'WITHDRAWtest123',
                    info: 'The address is not valid. Please confirm with the recipient',
                    confirmNo: 3,
                    walletType: 1,
                    txKey: '',
                    completeTime: '2023-03-23 16:52:41',
                },
                {
                    id: '156ec387f49b41df8724fa744fa82719',
                    amount: '0.00150000',
                    transactionFee: '0.004',
                    coin: 'BTC',
                    status: 6,
                    address: '1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB',
                    txId: '60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354',
                    applyTime: '2019-09-24 12:43:45',
                    network: 'BTC',
                    transferType: 0,
                    info: '',
                    confirmNo: 2,
                    walletType: 1,
                    txKey: '',
                    completeTime: '2023-03-23 16:52:41',
                },
            ];

            const spy = jest.spyOn(client, 'withdrawHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<WithdrawHistoryResponse>)
            );
            const response = await client.withdrawHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'withdrawHistory').mockRejectedValueOnce(mockError);
            await expect(client.withdrawHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
