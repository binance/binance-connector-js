/**
 * Binance Public Wallet REST API
 *
 * OpenAPI Specification for the Binance Public Wallet REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { AssetApi } from '../../../src/rest-api';
import {
    AssetDetailRequest,
    AssetDividendRecordRequest,
    DustTransferRequest,
    DustlogRequest,
    FundingWalletRequest,
    GetAssetsThatCanBeConvertedIntoBnbRequest,
    GetCloudMiningPaymentAndRefundHistoryRequest,
    QueryUserDelegationHistoryRequest,
    QueryUserUniversalTransferHistoryRequest,
    QueryUserWalletBalanceRequest,
    ToggleBnbBurnOnSpotTradeAndMarginInterestRequest,
    TradeFeeRequest,
    UserAssetRequest,
    UserUniversalTransferRequest,
} from '../../../src/rest-api';
import type {
    AssetDetailResponse,
    AssetDividendRecordResponse,
    DustTransferResponse,
    DustlogResponse,
    FundingWalletResponse,
    GetAssetsThatCanBeConvertedIntoBnbResponse,
    GetCloudMiningPaymentAndRefundHistoryResponse,
    GetOpenSymbolListResponse,
    QueryUserDelegationHistoryResponse,
    QueryUserUniversalTransferHistoryResponse,
    QueryUserWalletBalanceResponse,
    ToggleBnbBurnOnSpotTradeAndMarginInterestResponse,
    TradeFeeResponse,
    UserAssetResponse,
    UserUniversalTransferResponse,
} from '../../../src/rest-api/types';

describe('AssetApi', () => {
    let client: AssetApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new AssetApi(config);
    });

    describe('assetDetail()', () => {
        it('should execute assetDetail() successfully with required parameters only', async () => {
            mockResponse = {
                CTR: {
                    minWithdrawAmount: '70.00000000',
                    depositStatus: false,
                    withdrawFee: 35,
                    withdrawStatus: true,
                    depositTip: 'Delisted, Deposit Suspended',
                },
                SKY: {
                    minWithdrawAmount: '0.02000000',
                    depositStatus: true,
                    withdrawFee: 0.01,
                    withdrawStatus: true,
                },
            };

            const spy = jest.spyOn(client, 'assetDetail').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AssetDetailResponse>)
            );
            const response = await client.assetDetail();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute assetDetail() successfully with optional parameters', async () => {
            const params: AssetDetailRequest = {
                recvWindow: 5000,
            };

            mockResponse = {
                CTR: {
                    minWithdrawAmount: '70.00000000',
                    depositStatus: false,
                    withdrawFee: 35,
                    withdrawStatus: true,
                    depositTip: 'Delisted, Deposit Suspended',
                },
                SKY: {
                    minWithdrawAmount: '0.02000000',
                    depositStatus: true,
                    withdrawFee: 0.01,
                    withdrawStatus: true,
                },
            };

            const spy = jest.spyOn(client, 'assetDetail').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AssetDetailResponse>)
            );
            const response = await client.assetDetail(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'assetDetail').mockRejectedValueOnce(mockError);
            await expect(client.assetDetail()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('assetDividendRecord()', () => {
        it('should execute assetDividendRecord() successfully with required parameters only', async () => {
            mockResponse = {
                rows: [
                    {
                        id: 1637366104,
                        amount: '10.00000000',
                        asset: 'BHFT',
                        divTime: 1563189166000,
                        enInfo: 'BHFT distribution',
                        tranId: 2968885920,
                    },
                    {
                        id: 1631750237,
                        amount: '10.00000000',
                        asset: 'BHFT',
                        divTime: 1563189165000,
                        enInfo: 'BHFT distribution',
                        tranId: 2968885920,
                    },
                ],
                total: 2,
            };

            const spy = jest.spyOn(client, 'assetDividendRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AssetDividendRecordResponse>)
            );
            const response = await client.assetDividendRecord();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute assetDividendRecord() successfully with optional parameters', async () => {
            const params: AssetDividendRecordRequest = {
                asset: 'asset_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 7,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        id: 1637366104,
                        amount: '10.00000000',
                        asset: 'BHFT',
                        divTime: 1563189166000,
                        enInfo: 'BHFT distribution',
                        tranId: 2968885920,
                    },
                    {
                        id: 1631750237,
                        amount: '10.00000000',
                        asset: 'BHFT',
                        divTime: 1563189165000,
                        enInfo: 'BHFT distribution',
                        tranId: 2968885920,
                    },
                ],
                total: 2,
            };

            const spy = jest.spyOn(client, 'assetDividendRecord').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AssetDividendRecordResponse>)
            );
            const response = await client.assetDividendRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'assetDividendRecord').mockRejectedValueOnce(mockError);
            await expect(client.assetDividendRecord()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('dustTransfer()', () => {
        it('should execute dustTransfer() successfully with required parameters only', async () => {
            const params: DustTransferRequest = {
                asset: 'asset_example',
            };

            mockResponse = {
                totalServiceCharge: '0.02102542',
                totalTransfered: '1.05127099',
                transferResult: [
                    {
                        amount: '0.03000000',
                        fromAsset: 'ETH',
                        operateTime: 1563368549307,
                        serviceChargeAmount: '0.00500000',
                        tranId: 2970932918,
                        transferedAmount: '0.25000000',
                    },
                    {
                        amount: '0.09000000',
                        fromAsset: 'LTC',
                        operateTime: 1563368549404,
                        serviceChargeAmount: '0.01548000',
                        tranId: 2970932918,
                        transferedAmount: '0.77400000',
                    },
                    {
                        amount: '248.61878453',
                        fromAsset: 'TRX',
                        operateTime: 1563368549489,
                        serviceChargeAmount: '0.00054542',
                        tranId: 2970932918,
                        transferedAmount: '0.02727099',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'dustTransfer').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DustTransferResponse>)
            );
            const response = await client.dustTransfer(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute dustTransfer() successfully with optional parameters', async () => {
            const params: DustTransferRequest = {
                asset: 'asset_example',
                accountType: 'SPOT',
                recvWindow: 5000,
            };

            mockResponse = {
                totalServiceCharge: '0.02102542',
                totalTransfered: '1.05127099',
                transferResult: [
                    {
                        amount: '0.03000000',
                        fromAsset: 'ETH',
                        operateTime: 1563368549307,
                        serviceChargeAmount: '0.00500000',
                        tranId: 2970932918,
                        transferedAmount: '0.25000000',
                    },
                    {
                        amount: '0.09000000',
                        fromAsset: 'LTC',
                        operateTime: 1563368549404,
                        serviceChargeAmount: '0.01548000',
                        tranId: 2970932918,
                        transferedAmount: '0.77400000',
                    },
                    {
                        amount: '248.61878453',
                        fromAsset: 'TRX',
                        operateTime: 1563368549489,
                        serviceChargeAmount: '0.00054542',
                        tranId: 2970932918,
                        transferedAmount: '0.02727099',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'dustTransfer').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DustTransferResponse>)
            );
            const response = await client.dustTransfer(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: DustTransferRequest = {
                asset: 'asset_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.dustTransfer(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling dustTransfer.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DustTransferRequest = {
                asset: 'asset_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'dustTransfer').mockRejectedValueOnce(mockError);
            await expect(client.dustTransfer(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('dustlog()', () => {
        it('should execute dustlog() successfully with required parameters only', async () => {
            mockResponse = {
                total: 8,
                userAssetDribblets: [
                    {
                        operateTime: 1615985535000,
                        totalTransferedAmount: '0.00132256',
                        totalServiceChargeAmount: '0.00002699',
                        transId: 45178372831,
                        userAssetDribbletDetails: [
                            {
                                transId: 4359321,
                                serviceChargeAmount: '0.000009',
                                amount: '0.0009',
                                operateTime: 1615985535000,
                                transferedAmount: '0.000441',
                                fromAsset: 'USDT',
                            },
                            {
                                transId: 4359321,
                                serviceChargeAmount: '0.00001799',
                                amount: '0.0009',
                                operateTime: 1615985535000,
                                transferedAmount: '0.00088156',
                                fromAsset: 'ETH',
                            },
                        ],
                    },
                    {
                        operateTime: 1616203180000,
                        totalTransferedAmount: '0.00058795',
                        totalServiceChargeAmount: '0.000012',
                        transId: 4357015,
                        userAssetDribbletDetails: [
                            {
                                transId: 4357015,
                                serviceChargeAmount: '0.00001',
                                amount: '0.001',
                                operateTime: 1616203180000,
                                transferedAmount: '0.00049',
                                fromAsset: 'USDT',
                            },
                            {
                                transId: 4357015,
                                serviceChargeAmount: '0.000002',
                                amount: '0.0001',
                                operateTime: 1616203180000,
                                transferedAmount: '0.00009795',
                                fromAsset: 'ETH',
                            },
                        ],
                    },
                ],
            };

            const spy = jest.spyOn(client, 'dustlog').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DustlogResponse>)
            );
            const response = await client.dustlog();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute dustlog() successfully with optional parameters', async () => {
            const params: DustlogRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = {
                total: 8,
                userAssetDribblets: [
                    {
                        operateTime: 1615985535000,
                        totalTransferedAmount: '0.00132256',
                        totalServiceChargeAmount: '0.00002699',
                        transId: 45178372831,
                        userAssetDribbletDetails: [
                            {
                                transId: 4359321,
                                serviceChargeAmount: '0.000009',
                                amount: '0.0009',
                                operateTime: 1615985535000,
                                transferedAmount: '0.000441',
                                fromAsset: 'USDT',
                            },
                            {
                                transId: 4359321,
                                serviceChargeAmount: '0.00001799',
                                amount: '0.0009',
                                operateTime: 1615985535000,
                                transferedAmount: '0.00088156',
                                fromAsset: 'ETH',
                            },
                        ],
                    },
                    {
                        operateTime: 1616203180000,
                        totalTransferedAmount: '0.00058795',
                        totalServiceChargeAmount: '0.000012',
                        transId: 4357015,
                        userAssetDribbletDetails: [
                            {
                                transId: 4357015,
                                serviceChargeAmount: '0.00001',
                                amount: '0.001',
                                operateTime: 1616203180000,
                                transferedAmount: '0.00049',
                                fromAsset: 'USDT',
                            },
                            {
                                transId: 4357015,
                                serviceChargeAmount: '0.000002',
                                amount: '0.0001',
                                operateTime: 1616203180000,
                                transferedAmount: '0.00009795',
                                fromAsset: 'ETH',
                            },
                        ],
                    },
                ],
            };

            const spy = jest.spyOn(client, 'dustlog').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DustlogResponse>)
            );
            const response = await client.dustlog(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'dustlog').mockRejectedValueOnce(mockError);
            await expect(client.dustlog()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('fundingWallet()', () => {
        it('should execute fundingWallet() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    asset: 'USDT',
                    free: '1',
                    locked: '0',
                    freeze: '0',
                    withdrawing: '0',
                    btcValuation: '0.00000091',
                },
            ];

            const spy = jest.spyOn(client, 'fundingWallet').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FundingWalletResponse>)
            );
            const response = await client.fundingWallet();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute fundingWallet() successfully with optional parameters', async () => {
            const params: FundingWalletRequest = {
                asset: 'asset_example',
                needBtcValuation: 'needBtcValuation_example',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    asset: 'USDT',
                    free: '1',
                    locked: '0',
                    freeze: '0',
                    withdrawing: '0',
                    btcValuation: '0.00000091',
                },
            ];

            const spy = jest.spyOn(client, 'fundingWallet').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FundingWalletResponse>)
            );
            const response = await client.fundingWallet(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'fundingWallet').mockRejectedValueOnce(mockError);
            await expect(client.fundingWallet()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getAssetsThatCanBeConvertedIntoBnb()', () => {
        it('should execute getAssetsThatCanBeConvertedIntoBnb() successfully with required parameters only', async () => {
            mockResponse = {
                details: [
                    {
                        asset: 'ADA',
                        assetFullName: 'ADA',
                        amountFree: '6.21',
                        toBTC: '0.00016848',
                        toBNB: '0.01777302',
                        toBNBOffExchange: '0.01741756',
                        exchange: '0.00035546',
                    },
                ],
                totalTransferBtc: '0.00016848',
                totalTransferBNB: '0.01777302',
                dribbletPercentage: '0.02',
            };

            const spy = jest.spyOn(client, 'getAssetsThatCanBeConvertedIntoBnb').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetAssetsThatCanBeConvertedIntoBnbResponse>)
            );
            const response = await client.getAssetsThatCanBeConvertedIntoBnb();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getAssetsThatCanBeConvertedIntoBnb() successfully with optional parameters', async () => {
            const params: GetAssetsThatCanBeConvertedIntoBnbRequest = {
                accountType: 'SPOT',
                recvWindow: 5000,
            };

            mockResponse = {
                details: [
                    {
                        asset: 'ADA',
                        assetFullName: 'ADA',
                        amountFree: '6.21',
                        toBTC: '0.00016848',
                        toBNB: '0.01777302',
                        toBNBOffExchange: '0.01741756',
                        exchange: '0.00035546',
                    },
                ],
                totalTransferBtc: '0.00016848',
                totalTransferBNB: '0.01777302',
                dribbletPercentage: '0.02',
            };

            const spy = jest.spyOn(client, 'getAssetsThatCanBeConvertedIntoBnb').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetAssetsThatCanBeConvertedIntoBnbResponse>)
            );
            const response = await client.getAssetsThatCanBeConvertedIntoBnb(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getAssetsThatCanBeConvertedIntoBnb')
                .mockRejectedValueOnce(mockError);
            await expect(client.getAssetsThatCanBeConvertedIntoBnb()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getCloudMiningPaymentAndRefundHistory()', () => {
        it('should execute getCloudMiningPaymentAndRefundHistory() successfully with required parameters only', async () => {
            const params: GetCloudMiningPaymentAndRefundHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = {
                total: 5,
                rows: [
                    {
                        createTime: 1667880112000,
                        tranId: 121230610120,
                        type: 248,
                        asset: 'USDT',
                        amount: '25.0068',
                        status: 'S',
                    },
                    {
                        createTime: 1666776366000,
                        tranId: 119991507468,
                        type: 249,
                        asset: 'USDT',
                        amount: '0.027',
                        status: 'S',
                    },
                    {
                        createTime: 1666764505000,
                        tranId: 119977966327,
                        type: 248,
                        asset: 'USDT',
                        amount: '0.027',
                        status: 'S',
                    },
                    {
                        createTime: 1666758189000,
                        tranId: 119973601721,
                        type: 248,
                        asset: 'USDT',
                        amount: '0.018',
                        status: 'S',
                    },
                    {
                        createTime: 1666757278000,
                        tranId: 119973028551,
                        type: 248,
                        asset: 'USDT',
                        amount: '0.018',
                        status: 'S',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'getCloudMiningPaymentAndRefundHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCloudMiningPaymentAndRefundHistoryResponse>)
            );
            const response = await client.getCloudMiningPaymentAndRefundHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getCloudMiningPaymentAndRefundHistory() successfully with optional parameters', async () => {
            const params: GetCloudMiningPaymentAndRefundHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                tranId: 1,
                clientTranId: '1',
                asset: 'asset_example',
                current: 1,
                size: 10,
            };

            mockResponse = {
                total: 5,
                rows: [
                    {
                        createTime: 1667880112000,
                        tranId: 121230610120,
                        type: 248,
                        asset: 'USDT',
                        amount: '25.0068',
                        status: 'S',
                    },
                    {
                        createTime: 1666776366000,
                        tranId: 119991507468,
                        type: 249,
                        asset: 'USDT',
                        amount: '0.027',
                        status: 'S',
                    },
                    {
                        createTime: 1666764505000,
                        tranId: 119977966327,
                        type: 248,
                        asset: 'USDT',
                        amount: '0.027',
                        status: 'S',
                    },
                    {
                        createTime: 1666758189000,
                        tranId: 119973601721,
                        type: 248,
                        asset: 'USDT',
                        amount: '0.018',
                        status: 'S',
                    },
                    {
                        createTime: 1666757278000,
                        tranId: 119973028551,
                        type: 248,
                        asset: 'USDT',
                        amount: '0.018',
                        status: 'S',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'getCloudMiningPaymentAndRefundHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCloudMiningPaymentAndRefundHistoryResponse>)
            );
            const response = await client.getCloudMiningPaymentAndRefundHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: GetCloudMiningPaymentAndRefundHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(client.getCloudMiningPaymentAndRefundHistory(params)).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling getCloudMiningPaymentAndRefundHistory.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: GetCloudMiningPaymentAndRefundHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(client.getCloudMiningPaymentAndRefundHistory(params)).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling getCloudMiningPaymentAndRefundHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetCloudMiningPaymentAndRefundHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getCloudMiningPaymentAndRefundHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getCloudMiningPaymentAndRefundHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getOpenSymbolList()', () => {
        it('should execute getOpenSymbolList() successfully with required parameters only', async () => {
            mockResponse = [
                { openTime: 1686161202000, symbols: ['BNBBTC', 'BNBETH'] },
                { openTime: 1686222232000, symbols: ['BTCUSDT'] },
            ];

            const spy = jest.spyOn(client, 'getOpenSymbolList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOpenSymbolListResponse>)
            );
            const response = await client.getOpenSymbolList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getOpenSymbolList').mockRejectedValueOnce(mockError);
            await expect(client.getOpenSymbolList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryUserDelegationHistory()', () => {
        it('should execute queryUserDelegationHistory() successfully with required parameters only', async () => {
            const params: QueryUserDelegationHistoryRequest = {
                email: 'email_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = {
                total: 3316,
                rows: [
                    {
                        clientTranId: '293915932290879488',
                        transferType: 'Undelegate',
                        asset: 'ETH',
                        amount: '1',
                        time: 1695205406000,
                    },
                    {
                        clientTranId: '293915892281413632',
                        transferType: 'Delegate',
                        asset: 'ETH',
                        amount: '1',
                        time: 1695205396000,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'queryUserDelegationHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUserDelegationHistoryResponse>)
            );
            const response = await client.queryUserDelegationHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryUserDelegationHistory() successfully with optional parameters', async () => {
            const params: QueryUserDelegationHistoryRequest = {
                email: 'email_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                type: 'type_example',
                asset: 'asset_example',
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = {
                total: 3316,
                rows: [
                    {
                        clientTranId: '293915932290879488',
                        transferType: 'Undelegate',
                        asset: 'ETH',
                        amount: '1',
                        time: 1695205406000,
                    },
                    {
                        clientTranId: '293915892281413632',
                        transferType: 'Delegate',
                        asset: 'ETH',
                        amount: '1',
                        time: 1695205396000,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'queryUserDelegationHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUserDelegationHistoryResponse>)
            );
            const response = await client.queryUserDelegationHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: QueryUserDelegationHistoryRequest = {
                email: 'email_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.queryUserDelegationHistory(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling queryUserDelegationHistory.'
            );
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: QueryUserDelegationHistoryRequest = {
                email: 'email_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(client.queryUserDelegationHistory(params)).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling queryUserDelegationHistory.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: QueryUserDelegationHistoryRequest = {
                email: 'email_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(client.queryUserDelegationHistory(params)).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling queryUserDelegationHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryUserDelegationHistoryRequest = {
                email: 'email_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryUserDelegationHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryUserDelegationHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryUserUniversalTransferHistory()', () => {
        it('should execute queryUserUniversalTransferHistory() successfully with required parameters only', async () => {
            const params: QueryUserUniversalTransferHistoryRequest = {
                type: 'type_example',
            };

            mockResponse = {
                total: 2,
                rows: [
                    {
                        asset: 'USDT',
                        amount: '1',
                        type: 'MAIN_UMFUTURE',
                        status: 'CONFIRMED',
                        tranId: 11415955596,
                        timestamp: 1544433328000,
                    },
                    {
                        asset: 'USDT',
                        amount: '2',
                        type: 'MAIN_UMFUTURE',
                        status: 'CONFIRMED',
                        tranId: 11366865406,
                        timestamp: 1544433328000,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'queryUserUniversalTransferHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUserUniversalTransferHistoryResponse>)
            );
            const response = await client.queryUserUniversalTransferHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryUserUniversalTransferHistory() successfully with optional parameters', async () => {
            const params: QueryUserUniversalTransferHistoryRequest = {
                type: 'type_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                fromSymbol: 'fromSymbol_example',
                toSymbol: 'toSymbol_example',
                recvWindow: 5000,
            };

            mockResponse = {
                total: 2,
                rows: [
                    {
                        asset: 'USDT',
                        amount: '1',
                        type: 'MAIN_UMFUTURE',
                        status: 'CONFIRMED',
                        tranId: 11415955596,
                        timestamp: 1544433328000,
                    },
                    {
                        asset: 'USDT',
                        amount: '2',
                        type: 'MAIN_UMFUTURE',
                        status: 'CONFIRMED',
                        tranId: 11366865406,
                        timestamp: 1544433328000,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'queryUserUniversalTransferHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUserUniversalTransferHistoryResponse>)
            );
            const response = await client.queryUserUniversalTransferHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: QueryUserUniversalTransferHistoryRequest = {
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.queryUserUniversalTransferHistory(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling queryUserUniversalTransferHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryUserUniversalTransferHistoryRequest = {
                type: 'type_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryUserUniversalTransferHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryUserUniversalTransferHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryUserWalletBalance()', () => {
        it('should execute queryUserWalletBalance() successfully with required parameters only', async () => {
            mockResponse = [
                { activate: true, balance: '0', walletName: 'Spot' },
                { activate: true, balance: '0', walletName: 'Funding' },
                { activate: true, balance: '0', walletName: 'Cross Margin' },
                { activate: true, balance: '0', walletName: 'Isolated Margin' },
                { activate: true, balance: '0.71842752', walletName: 'USDⓈ-M Futures' },
                { activate: true, balance: '0', walletName: 'COIN-M Futures' },
                { activate: true, balance: '0', walletName: 'Earn' },
                { activate: false, balance: '0', walletName: 'Options' },
                { activate: true, balance: '0', walletName: 'Trading Bots' },
                { activate: true, balance: '0', walletName: 'Copy Trading' },
            ];

            const spy = jest.spyOn(client, 'queryUserWalletBalance').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUserWalletBalanceResponse>)
            );
            const response = await client.queryUserWalletBalance();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryUserWalletBalance() successfully with optional parameters', async () => {
            const params: QueryUserWalletBalanceRequest = {
                quoteAsset: 'BTC',
                recvWindow: 5000,
            };

            mockResponse = [
                { activate: true, balance: '0', walletName: 'Spot' },
                { activate: true, balance: '0', walletName: 'Funding' },
                { activate: true, balance: '0', walletName: 'Cross Margin' },
                { activate: true, balance: '0', walletName: 'Isolated Margin' },
                { activate: true, balance: '0.71842752', walletName: 'USDⓈ-M Futures' },
                { activate: true, balance: '0', walletName: 'COIN-M Futures' },
                { activate: true, balance: '0', walletName: 'Earn' },
                { activate: false, balance: '0', walletName: 'Options' },
                { activate: true, balance: '0', walletName: 'Trading Bots' },
                { activate: true, balance: '0', walletName: 'Copy Trading' },
            ];

            const spy = jest.spyOn(client, 'queryUserWalletBalance').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUserWalletBalanceResponse>)
            );
            const response = await client.queryUserWalletBalance(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryUserWalletBalance')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryUserWalletBalance()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('toggleBnbBurnOnSpotTradeAndMarginInterest()', () => {
        it('should execute toggleBnbBurnOnSpotTradeAndMarginInterest() successfully with required parameters only', async () => {
            mockResponse = { spotBNBBurn: true, interestBNBBurn: false };

            const spy = jest
                .spyOn(client, 'toggleBnbBurnOnSpotTradeAndMarginInterest')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<ToggleBnbBurnOnSpotTradeAndMarginInterestResponse>)
                );
            const response = await client.toggleBnbBurnOnSpotTradeAndMarginInterest();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute toggleBnbBurnOnSpotTradeAndMarginInterest() successfully with optional parameters', async () => {
            const params: ToggleBnbBurnOnSpotTradeAndMarginInterestRequest = {
                spotBNBBurn: 'spotBNBBurn_example',
                interestBNBBurn: 'interestBNBBurn_example',
                recvWindow: 5000,
            };

            mockResponse = { spotBNBBurn: true, interestBNBBurn: false };

            const spy = jest
                .spyOn(client, 'toggleBnbBurnOnSpotTradeAndMarginInterest')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<ToggleBnbBurnOnSpotTradeAndMarginInterestResponse>)
                );
            const response = await client.toggleBnbBurnOnSpotTradeAndMarginInterest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'toggleBnbBurnOnSpotTradeAndMarginInterest')
                .mockRejectedValueOnce(mockError);
            await expect(client.toggleBnbBurnOnSpotTradeAndMarginInterest()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('tradeFee()', () => {
        it('should execute tradeFee() successfully with required parameters only', async () => {
            mockResponse = [
                { symbol: 'ADABNB', makerCommission: '0.001', takerCommission: '0.001' },
                { symbol: 'BNBBTC', makerCommission: '0.001', takerCommission: '0.001' },
            ];

            const spy = jest.spyOn(client, 'tradeFee').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TradeFeeResponse>)
            );
            const response = await client.tradeFee();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute tradeFee() successfully with optional parameters', async () => {
            const params: TradeFeeRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = [
                { symbol: 'ADABNB', makerCommission: '0.001', takerCommission: '0.001' },
                { symbol: 'BNBBTC', makerCommission: '0.001', takerCommission: '0.001' },
            ];

            const spy = jest.spyOn(client, 'tradeFee').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TradeFeeResponse>)
            );
            const response = await client.tradeFee(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'tradeFee').mockRejectedValueOnce(mockError);
            await expect(client.tradeFee()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('userAsset()', () => {
        it('should execute userAsset() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    asset: 'AVAX',
                    free: '1',
                    locked: '0',
                    freeze: '0',
                    withdrawing: '0',
                    ipoable: '0',
                    btcValuation: '0',
                },
                {
                    asset: 'BCH',
                    free: '0.9',
                    locked: '0',
                    freeze: '0',
                    withdrawing: '0',
                    ipoable: '0',
                    btcValuation: '0',
                },
                {
                    asset: 'BNB',
                    free: '887.47061626',
                    locked: '0',
                    freeze: '10.52',
                    withdrawing: '0.1',
                    ipoable: '0',
                    btcValuation: '0',
                },
                {
                    asset: 'BUSD',
                    free: '9999.7',
                    locked: '0',
                    freeze: '0',
                    withdrawing: '0',
                    ipoable: '0',
                    btcValuation: '0',
                },
                {
                    asset: 'SHIB',
                    free: '532.32',
                    locked: '0',
                    freeze: '0',
                    withdrawing: '0',
                    ipoable: '0',
                    btcValuation: '0',
                },
                {
                    asset: 'USDT',
                    free: '50300000001.44911105',
                    locked: '0',
                    freeze: '0',
                    withdrawing: '0',
                    ipoable: '0',
                    btcValuation: '0',
                },
                {
                    asset: 'WRZ',
                    free: '1',
                    locked: '0',
                    freeze: '0',
                    withdrawing: '0',
                    ipoable: '0',
                    btcValuation: '0',
                },
            ];

            const spy = jest.spyOn(client, 'userAsset').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UserAssetResponse>)
            );
            const response = await client.userAsset();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute userAsset() successfully with optional parameters', async () => {
            const params: UserAssetRequest = {
                asset: 'asset_example',
                needBtcValuation: true,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    asset: 'AVAX',
                    free: '1',
                    locked: '0',
                    freeze: '0',
                    withdrawing: '0',
                    ipoable: '0',
                    btcValuation: '0',
                },
                {
                    asset: 'BCH',
                    free: '0.9',
                    locked: '0',
                    freeze: '0',
                    withdrawing: '0',
                    ipoable: '0',
                    btcValuation: '0',
                },
                {
                    asset: 'BNB',
                    free: '887.47061626',
                    locked: '0',
                    freeze: '10.52',
                    withdrawing: '0.1',
                    ipoable: '0',
                    btcValuation: '0',
                },
                {
                    asset: 'BUSD',
                    free: '9999.7',
                    locked: '0',
                    freeze: '0',
                    withdrawing: '0',
                    ipoable: '0',
                    btcValuation: '0',
                },
                {
                    asset: 'SHIB',
                    free: '532.32',
                    locked: '0',
                    freeze: '0',
                    withdrawing: '0',
                    ipoable: '0',
                    btcValuation: '0',
                },
                {
                    asset: 'USDT',
                    free: '50300000001.44911105',
                    locked: '0',
                    freeze: '0',
                    withdrawing: '0',
                    ipoable: '0',
                    btcValuation: '0',
                },
                {
                    asset: 'WRZ',
                    free: '1',
                    locked: '0',
                    freeze: '0',
                    withdrawing: '0',
                    ipoable: '0',
                    btcValuation: '0',
                },
            ];

            const spy = jest.spyOn(client, 'userAsset').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UserAssetResponse>)
            );
            const response = await client.userAsset(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'userAsset').mockRejectedValueOnce(mockError);
            await expect(client.userAsset()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('userUniversalTransfer()', () => {
        it('should execute userUniversalTransfer() successfully with required parameters only', async () => {
            const params: UserUniversalTransferRequest = {
                type: 'type_example',
                asset: 'asset_example',
                amount: 1,
            };

            mockResponse = { tranId: 13526853623 };

            const spy = jest.spyOn(client, 'userUniversalTransfer').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UserUniversalTransferResponse>)
            );
            const response = await client.userUniversalTransfer(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute userUniversalTransfer() successfully with optional parameters', async () => {
            const params: UserUniversalTransferRequest = {
                type: 'type_example',
                asset: 'asset_example',
                amount: 1,
                fromSymbol: 'fromSymbol_example',
                toSymbol: 'toSymbol_example',
                recvWindow: 5000,
            };

            mockResponse = { tranId: 13526853623 };

            const spy = jest.spyOn(client, 'userUniversalTransfer').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UserUniversalTransferResponse>)
            );
            const response = await client.userUniversalTransfer(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: UserUniversalTransferRequest = {
                type: 'type_example',
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.userUniversalTransfer(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling userUniversalTransfer.'
            );
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: UserUniversalTransferRequest = {
                type: 'type_example',
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.userUniversalTransfer(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling userUniversalTransfer.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: UserUniversalTransferRequest = {
                type: 'type_example',
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.userUniversalTransfer(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling userUniversalTransfer.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: UserUniversalTransferRequest = {
                type: 'type_example',
                asset: 'asset_example',
                amount: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'userUniversalTransfer')
                .mockRejectedValueOnce(mockError);
            await expect(client.userUniversalTransfer(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
