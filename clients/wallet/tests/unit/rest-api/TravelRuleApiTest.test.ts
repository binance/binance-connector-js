/**
 * Binance Wallet REST API
 *
 * OpenAPI Specification for the Binance Wallet REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { TravelRuleApi } from '../../../src/rest-api';
import {
    BrokerWithdrawRequest,
    DepositHistoryTravelRuleRequest,
    SubmitDepositQuestionnaireRequest,
    SubmitDepositQuestionnaireTravelRuleRequest,
    WithdrawHistoryV1Request,
    WithdrawHistoryV2Request,
    WithdrawTravelRuleRequest,
} from '../../../src/rest-api';
import type {
    BrokerWithdrawResponse,
    DepositHistoryTravelRuleResponse,
    OnboardedVaspListResponse,
    SubmitDepositQuestionnaireResponse,
    SubmitDepositQuestionnaireTravelRuleResponse,
    WithdrawHistoryV1Response,
    WithdrawHistoryV2Response,
    WithdrawTravelRuleResponse,
} from '../../../src/rest-api/types';

describe('TravelRuleApi', () => {
    let client: TravelRuleApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new TravelRuleApi(config);
    });

    describe('brokerWithdraw()', () => {
        it('should execute brokerWithdraw() successfully with required parameters only', async () => {
            const params: BrokerWithdrawRequest = {
                subAccountId: '1',
                address: 'address_example',
                coin: 'coin_example',
                amount: 1,
                withdrawOrderId: '1',
                questionnaire: 'questionnaire_example',
                originatorPii: 'originatorPii_example',
                signature: 'signature_example',
            };

            mockResponse = { trId: 123456, accpted: true, info: 'Withdraw request accepted' };

            const spy = jest.spyOn(client, 'brokerWithdraw').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<BrokerWithdrawResponse>)
            );
            const response = await client.brokerWithdraw(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute brokerWithdraw() successfully with optional parameters', async () => {
            const params: BrokerWithdrawRequest = {
                subAccountId: '1',
                address: 'address_example',
                coin: 'coin_example',
                amount: 1,
                withdrawOrderId: '1',
                questionnaire: 'questionnaire_example',
                originatorPii: 'originatorPii_example',
                signature: 'signature_example',
                addressTag: 'addressTag_example',
                network: 'network_example',
                addressName: 'addressName_example',
                transactionFeeFlag: false,
                walletType: 0,
            };

            mockResponse = { trId: 123456, accpted: true, info: 'Withdraw request accepted' };

            const spy = jest.spyOn(client, 'brokerWithdraw').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<BrokerWithdrawResponse>)
            );
            const response = await client.brokerWithdraw(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when subAccountId is missing', async () => {
            const _params: BrokerWithdrawRequest = {
                subAccountId: '1',
                address: 'address_example',
                coin: 'coin_example',
                amount: 1,
                withdrawOrderId: '1',
                questionnaire: 'questionnaire_example',
                originatorPii: 'originatorPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.subAccountId;

            await expect(client.brokerWithdraw(params)).rejects.toThrow(
                'Required parameter subAccountId was null or undefined when calling brokerWithdraw.'
            );
        });

        it('should throw RequiredError when address is missing', async () => {
            const _params: BrokerWithdrawRequest = {
                subAccountId: '1',
                address: 'address_example',
                coin: 'coin_example',
                amount: 1,
                withdrawOrderId: '1',
                questionnaire: 'questionnaire_example',
                originatorPii: 'originatorPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.address;

            await expect(client.brokerWithdraw(params)).rejects.toThrow(
                'Required parameter address was null or undefined when calling brokerWithdraw.'
            );
        });

        it('should throw RequiredError when coin is missing', async () => {
            const _params: BrokerWithdrawRequest = {
                subAccountId: '1',
                address: 'address_example',
                coin: 'coin_example',
                amount: 1,
                withdrawOrderId: '1',
                questionnaire: 'questionnaire_example',
                originatorPii: 'originatorPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.coin;

            await expect(client.brokerWithdraw(params)).rejects.toThrow(
                'Required parameter coin was null or undefined when calling brokerWithdraw.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: BrokerWithdrawRequest = {
                subAccountId: '1',
                address: 'address_example',
                coin: 'coin_example',
                amount: 1,
                withdrawOrderId: '1',
                questionnaire: 'questionnaire_example',
                originatorPii: 'originatorPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.brokerWithdraw(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling brokerWithdraw.'
            );
        });

        it('should throw RequiredError when withdrawOrderId is missing', async () => {
            const _params: BrokerWithdrawRequest = {
                subAccountId: '1',
                address: 'address_example',
                coin: 'coin_example',
                amount: 1,
                withdrawOrderId: '1',
                questionnaire: 'questionnaire_example',
                originatorPii: 'originatorPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.withdrawOrderId;

            await expect(client.brokerWithdraw(params)).rejects.toThrow(
                'Required parameter withdrawOrderId was null or undefined when calling brokerWithdraw.'
            );
        });

        it('should throw RequiredError when questionnaire is missing', async () => {
            const _params: BrokerWithdrawRequest = {
                subAccountId: '1',
                address: 'address_example',
                coin: 'coin_example',
                amount: 1,
                withdrawOrderId: '1',
                questionnaire: 'questionnaire_example',
                originatorPii: 'originatorPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.questionnaire;

            await expect(client.brokerWithdraw(params)).rejects.toThrow(
                'Required parameter questionnaire was null or undefined when calling brokerWithdraw.'
            );
        });

        it('should throw RequiredError when originatorPii is missing', async () => {
            const _params: BrokerWithdrawRequest = {
                subAccountId: '1',
                address: 'address_example',
                coin: 'coin_example',
                amount: 1,
                withdrawOrderId: '1',
                questionnaire: 'questionnaire_example',
                originatorPii: 'originatorPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.originatorPii;

            await expect(client.brokerWithdraw(params)).rejects.toThrow(
                'Required parameter originatorPii was null or undefined when calling brokerWithdraw.'
            );
        });

        it('should throw RequiredError when signature is missing', async () => {
            const _params: BrokerWithdrawRequest = {
                subAccountId: '1',
                address: 'address_example',
                coin: 'coin_example',
                amount: 1,
                withdrawOrderId: '1',
                questionnaire: 'questionnaire_example',
                originatorPii: 'originatorPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.signature;

            await expect(client.brokerWithdraw(params)).rejects.toThrow(
                'Required parameter signature was null or undefined when calling brokerWithdraw.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: BrokerWithdrawRequest = {
                subAccountId: '1',
                address: 'address_example',
                coin: 'coin_example',
                amount: 1,
                withdrawOrderId: '1',
                questionnaire: 'questionnaire_example',
                originatorPii: 'originatorPii_example',
                signature: 'signature_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'brokerWithdraw').mockRejectedValueOnce(mockError);
            await expect(client.brokerWithdraw(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('depositHistoryTravelRule()', () => {
        it('should execute depositHistoryTravelRule() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    trId: 123451123,
                    tranId: 17644346245865,
                    amount: '0.001',
                    coin: 'BNB',
                    network: 'BNB',
                    depositStatus: 0,
                    travelRuleStatus: 1,
                    address: 'bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23',
                    addressTag: '101764890',
                    txId: '98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC',
                    insertTime: 1661493146000,
                    transferType: 0,
                    confirmTimes: '1/1',
                    unlockConfirm: 0,
                    walletType: 0,
                    requireQuestionnaire: true,
                    questionnaire: null,
                },
                {
                    trId: 2451123,
                    tranId: 4544346245865,
                    amount: '0.50000000',
                    coin: 'IOTA',
                    network: 'IOTA',
                    depositStatus: 0,
                    travelRuleStatus: 0,
                    address:
                        'SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW',
                    addressTag: '',
                    txId: 'ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999',
                    insertTime: 1599620082000,
                    transferType: 0,
                    confirmTimes: '1/1',
                    unlockConfirm: 0,
                    walletType: 0,
                    requireQuestionnaire: false,
                    questionnaire: '{"question1":"answer1","question2":"answer2"}',
                },
            ];

            const spy = jest.spyOn(client, 'depositHistoryTravelRule').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepositHistoryTravelRuleResponse>)
            );
            const response = await client.depositHistoryTravelRule();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute depositHistoryTravelRule() successfully with optional parameters', async () => {
            const params: DepositHistoryTravelRuleRequest = {
                trId: '1',
                txId: '1',
                tranId: '1',
                network: 'network_example',
                coin: 'coin_example',
                travelRuleStatus: 789,
                pendingQuestionnaire: true,
                startTime: 1623319461670,
                endTime: 1641782889000,
                offset: 0,
                limit: 7,
            };

            mockResponse = [
                {
                    trId: 123451123,
                    tranId: 17644346245865,
                    amount: '0.001',
                    coin: 'BNB',
                    network: 'BNB',
                    depositStatus: 0,
                    travelRuleStatus: 1,
                    address: 'bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23',
                    addressTag: '101764890',
                    txId: '98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC',
                    insertTime: 1661493146000,
                    transferType: 0,
                    confirmTimes: '1/1',
                    unlockConfirm: 0,
                    walletType: 0,
                    requireQuestionnaire: true,
                    questionnaire: null,
                },
                {
                    trId: 2451123,
                    tranId: 4544346245865,
                    amount: '0.50000000',
                    coin: 'IOTA',
                    network: 'IOTA',
                    depositStatus: 0,
                    travelRuleStatus: 0,
                    address:
                        'SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW',
                    addressTag: '',
                    txId: 'ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999',
                    insertTime: 1599620082000,
                    transferType: 0,
                    confirmTimes: '1/1',
                    unlockConfirm: 0,
                    walletType: 0,
                    requireQuestionnaire: false,
                    questionnaire: '{"question1":"answer1","question2":"answer2"}',
                },
            ];

            const spy = jest.spyOn(client, 'depositHistoryTravelRule').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepositHistoryTravelRuleResponse>)
            );
            const response = await client.depositHistoryTravelRule(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'depositHistoryTravelRule')
                .mockRejectedValueOnce(mockError);
            await expect(client.depositHistoryTravelRule()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('onboardedVaspList()', () => {
        it('should execute onboardedVaspList() successfully with required parameters only', async () => {
            mockResponse = [
                { vaspName: 'Binance', vaspCode: 'BINANCE' },
                { vaspName: 'HashKeyGlobal', vaspCode: 'NVBH3Z_nNEHjvqbUfkaL' },
            ];

            const spy = jest.spyOn(client, 'onboardedVaspList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OnboardedVaspListResponse>)
            );
            const response = await client.onboardedVaspList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'onboardedVaspList').mockRejectedValueOnce(mockError);
            await expect(client.onboardedVaspList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('submitDepositQuestionnaire()', () => {
        it('should execute submitDepositQuestionnaire() successfully with required parameters only', async () => {
            const params: SubmitDepositQuestionnaireRequest = {
                subAccountId: '1',
                depositId: '1',
                questionnaire: 'questionnaire_example',
                beneficiaryPii: 'beneficiaryPii_example',
                signature: 'signature_example',
            };

            mockResponse = {
                trId: 765127651,
                accepted: true,
                info: 'Deposit questionnaire accepted.',
            };

            const spy = jest.spyOn(client, 'submitDepositQuestionnaire').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubmitDepositQuestionnaireResponse>)
            );
            const response = await client.submitDepositQuestionnaire(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute submitDepositQuestionnaire() successfully with optional parameters', async () => {
            const params: SubmitDepositQuestionnaireRequest = {
                subAccountId: '1',
                depositId: '1',
                questionnaire: 'questionnaire_example',
                beneficiaryPii: 'beneficiaryPii_example',
                signature: 'signature_example',
                network: 'network_example',
                coin: 'coin_example',
                amount: 1,
                address: 'address_example',
                addressTag: 'addressTag_example',
            };

            mockResponse = {
                trId: 765127651,
                accepted: true,
                info: 'Deposit questionnaire accepted.',
            };

            const spy = jest.spyOn(client, 'submitDepositQuestionnaire').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubmitDepositQuestionnaireResponse>)
            );
            const response = await client.submitDepositQuestionnaire(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when subAccountId is missing', async () => {
            const _params: SubmitDepositQuestionnaireRequest = {
                subAccountId: '1',
                depositId: '1',
                questionnaire: 'questionnaire_example',
                beneficiaryPii: 'beneficiaryPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.subAccountId;

            await expect(client.submitDepositQuestionnaire(params)).rejects.toThrow(
                'Required parameter subAccountId was null or undefined when calling submitDepositQuestionnaire.'
            );
        });

        it('should throw RequiredError when depositId is missing', async () => {
            const _params: SubmitDepositQuestionnaireRequest = {
                subAccountId: '1',
                depositId: '1',
                questionnaire: 'questionnaire_example',
                beneficiaryPii: 'beneficiaryPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.depositId;

            await expect(client.submitDepositQuestionnaire(params)).rejects.toThrow(
                'Required parameter depositId was null or undefined when calling submitDepositQuestionnaire.'
            );
        });

        it('should throw RequiredError when questionnaire is missing', async () => {
            const _params: SubmitDepositQuestionnaireRequest = {
                subAccountId: '1',
                depositId: '1',
                questionnaire: 'questionnaire_example',
                beneficiaryPii: 'beneficiaryPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.questionnaire;

            await expect(client.submitDepositQuestionnaire(params)).rejects.toThrow(
                'Required parameter questionnaire was null or undefined when calling submitDepositQuestionnaire.'
            );
        });

        it('should throw RequiredError when beneficiaryPii is missing', async () => {
            const _params: SubmitDepositQuestionnaireRequest = {
                subAccountId: '1',
                depositId: '1',
                questionnaire: 'questionnaire_example',
                beneficiaryPii: 'beneficiaryPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.beneficiaryPii;

            await expect(client.submitDepositQuestionnaire(params)).rejects.toThrow(
                'Required parameter beneficiaryPii was null or undefined when calling submitDepositQuestionnaire.'
            );
        });

        it('should throw RequiredError when signature is missing', async () => {
            const _params: SubmitDepositQuestionnaireRequest = {
                subAccountId: '1',
                depositId: '1',
                questionnaire: 'questionnaire_example',
                beneficiaryPii: 'beneficiaryPii_example',
                signature: 'signature_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.signature;

            await expect(client.submitDepositQuestionnaire(params)).rejects.toThrow(
                'Required parameter signature was null or undefined when calling submitDepositQuestionnaire.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SubmitDepositQuestionnaireRequest = {
                subAccountId: '1',
                depositId: '1',
                questionnaire: 'questionnaire_example',
                beneficiaryPii: 'beneficiaryPii_example',
                signature: 'signature_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'submitDepositQuestionnaire')
                .mockRejectedValueOnce(mockError);
            await expect(client.submitDepositQuestionnaire(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('submitDepositQuestionnaireTravelRule()', () => {
        it('should execute submitDepositQuestionnaireTravelRule() successfully with required parameters only', async () => {
            const params: SubmitDepositQuestionnaireTravelRuleRequest = {
                tranId: 1,
                questionnaire: 'questionnaire_example',
            };

            mockResponse = {
                trId: 765127651,
                accepted: true,
                info: 'Deposit questionnaire accepted.',
            };

            const spy = jest.spyOn(client, 'submitDepositQuestionnaireTravelRule').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubmitDepositQuestionnaireTravelRuleResponse>)
            );
            const response = await client.submitDepositQuestionnaireTravelRule(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute submitDepositQuestionnaireTravelRule() successfully with optional parameters', async () => {
            const params: SubmitDepositQuestionnaireTravelRuleRequest = {
                tranId: 1,
                questionnaire: 'questionnaire_example',
            };

            mockResponse = {
                trId: 765127651,
                accepted: true,
                info: 'Deposit questionnaire accepted.',
            };

            const spy = jest.spyOn(client, 'submitDepositQuestionnaireTravelRule').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubmitDepositQuestionnaireTravelRuleResponse>)
            );
            const response = await client.submitDepositQuestionnaireTravelRule(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when tranId is missing', async () => {
            const _params: SubmitDepositQuestionnaireTravelRuleRequest = {
                tranId: 1,
                questionnaire: 'questionnaire_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.tranId;

            await expect(client.submitDepositQuestionnaireTravelRule(params)).rejects.toThrow(
                'Required parameter tranId was null or undefined when calling submitDepositQuestionnaireTravelRule.'
            );
        });

        it('should throw RequiredError when questionnaire is missing', async () => {
            const _params: SubmitDepositQuestionnaireTravelRuleRequest = {
                tranId: 1,
                questionnaire: 'questionnaire_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.questionnaire;

            await expect(client.submitDepositQuestionnaireTravelRule(params)).rejects.toThrow(
                'Required parameter questionnaire was null or undefined when calling submitDepositQuestionnaireTravelRule.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SubmitDepositQuestionnaireTravelRuleRequest = {
                tranId: 1,
                questionnaire: 'questionnaire_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'submitDepositQuestionnaireTravelRule')
                .mockRejectedValueOnce(mockError);
            await expect(client.submitDepositQuestionnaireTravelRule(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('withdrawHistoryV1()', () => {
        it('should execute withdrawHistoryV1() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    id: 'b6ae22b3aa844210a7041aee7589627c',
                    trId: 1234456,
                    amount: '8.91000000',
                    transactionFee: '0.004',
                    coin: 'USDT',
                    withdrawalStatus: 6,
                    travelRuleStatus: 0,
                    address: '0x94df8b352de7f46f64b01d3666bf6e936e44ce60',
                    addressTag: '1231212',
                    txId: '0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268',
                    applyTime: '2019-10-12 11:12:02',
                    network: 'ETH',
                    transferType: 0,
                    withdrawOrderId: 'WITHDRAWtest123',
                    info: 'The address is not valid. Please confirm with the recipient',
                    confirmNo: 3,
                    walletType: 1,
                    txKey: '',
                    questionnaire: '{"question1":"answer1","question2":"answer2"}',
                    completeTime: '2023-03-23 16:52:41',
                },
                {
                    id: '156ec387f49b41df8724fa744fa82719',
                    trId: 2231556234,
                    amount: '0.00150000',
                    transactionFee: '0.004',
                    coin: 'BTC',
                    withdrawalStatus: 6,
                    travelRuleStatus: 0,
                    address: '1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB',
                    txId: '60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354',
                    applyTime: '2019-09-24 12:43:45',
                    network: 'BTC',
                    transferType: 0,
                    info: '',
                    confirmNo: 2,
                    walletType: 1,
                    txKey: '',
                    questionnaire: '{"question1":"answer1","question2":"answer2"}',
                    completeTime: '2023-03-23 16:52:41',
                },
            ];

            const spy = jest.spyOn(client, 'withdrawHistoryV1').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<WithdrawHistoryV1Response>)
            );
            const response = await client.withdrawHistoryV1();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute withdrawHistoryV1() successfully with optional parameters', async () => {
            const params: WithdrawHistoryV1Request = {
                trId: '1',
                txId: '1',
                withdrawOrderId: '1',
                network: 'network_example',
                coin: 'coin_example',
                travelRuleStatus: 789,
                offset: 0,
                limit: 7,
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    id: 'b6ae22b3aa844210a7041aee7589627c',
                    trId: 1234456,
                    amount: '8.91000000',
                    transactionFee: '0.004',
                    coin: 'USDT',
                    withdrawalStatus: 6,
                    travelRuleStatus: 0,
                    address: '0x94df8b352de7f46f64b01d3666bf6e936e44ce60',
                    addressTag: '1231212',
                    txId: '0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268',
                    applyTime: '2019-10-12 11:12:02',
                    network: 'ETH',
                    transferType: 0,
                    withdrawOrderId: 'WITHDRAWtest123',
                    info: 'The address is not valid. Please confirm with the recipient',
                    confirmNo: 3,
                    walletType: 1,
                    txKey: '',
                    questionnaire: '{"question1":"answer1","question2":"answer2"}',
                    completeTime: '2023-03-23 16:52:41',
                },
                {
                    id: '156ec387f49b41df8724fa744fa82719',
                    trId: 2231556234,
                    amount: '0.00150000',
                    transactionFee: '0.004',
                    coin: 'BTC',
                    withdrawalStatus: 6,
                    travelRuleStatus: 0,
                    address: '1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB',
                    txId: '60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354',
                    applyTime: '2019-09-24 12:43:45',
                    network: 'BTC',
                    transferType: 0,
                    info: '',
                    confirmNo: 2,
                    walletType: 1,
                    txKey: '',
                    questionnaire: '{"question1":"answer1","question2":"answer2"}',
                    completeTime: '2023-03-23 16:52:41',
                },
            ];

            const spy = jest.spyOn(client, 'withdrawHistoryV1').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<WithdrawHistoryV1Response>)
            );
            const response = await client.withdrawHistoryV1(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'withdrawHistoryV1').mockRejectedValueOnce(mockError);
            await expect(client.withdrawHistoryV1()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('withdrawHistoryV2()', () => {
        it('should execute withdrawHistoryV2() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    id: 'b6ae22b3aa844210a7041aee7589627c',
                    trId: 1234456,
                    amount: '8.91000000',
                    transactionFee: '0.004',
                    coin: 'USDT',
                    withdrawalStatus: 6,
                    travelRuleStatus: 0,
                    address: '0x94df8b352de7f46f64b01d3666bf6e936e44ce60',
                    addressTag: '1231212',
                    txId: '0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268',
                    applyTime: '2019-10-12 11:12:02',
                    network: 'ETH',
                    transferType: 0,
                    withdrawOrderId: 'WITHDRAWtest123',
                    info: 'The address is not valid. Please confirm with the recipient',
                    confirmNo: 3,
                    walletType: 1,
                    txKey: '',
                    questionnaire: '{"question1":"answer1","question2":"answer2"}',
                    completeTime: '2023-03-23 16:52:41',
                },
                {
                    id: '156ec387f49b41df8724fa744fa82719',
                    trId: 2231556234,
                    amount: '0.00150000',
                    transactionFee: '0.004',
                    coin: 'BTC',
                    withdrawalStatus: 6,
                    travelRuleStatus: 0,
                    address: '1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB',
                    txId: '60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354',
                    applyTime: '2019-09-24 12:43:45',
                    network: 'BTC',
                    transferType: 0,
                    info: '',
                    confirmNo: 2,
                    walletType: 1,
                    txKey: '',
                    questionnaire: '{"question1":"answer1","question2":"answer2"}',
                    completeTime: '2023-03-23 16:52:41',
                },
            ];

            const spy = jest.spyOn(client, 'withdrawHistoryV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<WithdrawHistoryV2Response>)
            );
            const response = await client.withdrawHistoryV2();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute withdrawHistoryV2() successfully with optional parameters', async () => {
            const params: WithdrawHistoryV2Request = {
                trId: '1',
                txId: '1',
                withdrawOrderId: '1',
                network: 'network_example',
                coin: 'coin_example',
                travelRuleStatus: 789,
                offset: 0,
                limit: 7,
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    id: 'b6ae22b3aa844210a7041aee7589627c',
                    trId: 1234456,
                    amount: '8.91000000',
                    transactionFee: '0.004',
                    coin: 'USDT',
                    withdrawalStatus: 6,
                    travelRuleStatus: 0,
                    address: '0x94df8b352de7f46f64b01d3666bf6e936e44ce60',
                    addressTag: '1231212',
                    txId: '0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268',
                    applyTime: '2019-10-12 11:12:02',
                    network: 'ETH',
                    transferType: 0,
                    withdrawOrderId: 'WITHDRAWtest123',
                    info: 'The address is not valid. Please confirm with the recipient',
                    confirmNo: 3,
                    walletType: 1,
                    txKey: '',
                    questionnaire: '{"question1":"answer1","question2":"answer2"}',
                    completeTime: '2023-03-23 16:52:41',
                },
                {
                    id: '156ec387f49b41df8724fa744fa82719',
                    trId: 2231556234,
                    amount: '0.00150000',
                    transactionFee: '0.004',
                    coin: 'BTC',
                    withdrawalStatus: 6,
                    travelRuleStatus: 0,
                    address: '1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB',
                    txId: '60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354',
                    applyTime: '2019-09-24 12:43:45',
                    network: 'BTC',
                    transferType: 0,
                    info: '',
                    confirmNo: 2,
                    walletType: 1,
                    txKey: '',
                    questionnaire: '{"question1":"answer1","question2":"answer2"}',
                    completeTime: '2023-03-23 16:52:41',
                },
            ];

            const spy = jest.spyOn(client, 'withdrawHistoryV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<WithdrawHistoryV2Response>)
            );
            const response = await client.withdrawHistoryV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'withdrawHistoryV2').mockRejectedValueOnce(mockError);
            await expect(client.withdrawHistoryV2()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('withdrawTravelRule()', () => {
        it('should execute withdrawTravelRule() successfully with required parameters only', async () => {
            const params: WithdrawTravelRuleRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1,
                questionnaire: 'questionnaire_example',
            };

            mockResponse = { trId: 123456, accpted: true, info: 'Withdraw request accepted' };

            const spy = jest.spyOn(client, 'withdrawTravelRule').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<WithdrawTravelRuleResponse>)
            );
            const response = await client.withdrawTravelRule(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute withdrawTravelRule() successfully with optional parameters', async () => {
            const params: WithdrawTravelRuleRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1,
                questionnaire: 'questionnaire_example',
                withdrawOrderId: '1',
                network: 'network_example',
                addressTag: 'addressTag_example',
                transactionFeeFlag: false,
                name: 'name_example',
                walletType: 0,
                recvWindow: 5000,
            };

            mockResponse = { trId: 123456, accpted: true, info: 'Withdraw request accepted' };

            const spy = jest.spyOn(client, 'withdrawTravelRule').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<WithdrawTravelRuleResponse>)
            );
            const response = await client.withdrawTravelRule(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when coin is missing', async () => {
            const _params: WithdrawTravelRuleRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1,
                questionnaire: 'questionnaire_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.coin;

            await expect(client.withdrawTravelRule(params)).rejects.toThrow(
                'Required parameter coin was null or undefined when calling withdrawTravelRule.'
            );
        });

        it('should throw RequiredError when address is missing', async () => {
            const _params: WithdrawTravelRuleRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1,
                questionnaire: 'questionnaire_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.address;

            await expect(client.withdrawTravelRule(params)).rejects.toThrow(
                'Required parameter address was null or undefined when calling withdrawTravelRule.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: WithdrawTravelRuleRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1,
                questionnaire: 'questionnaire_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.withdrawTravelRule(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling withdrawTravelRule.'
            );
        });

        it('should throw RequiredError when questionnaire is missing', async () => {
            const _params: WithdrawTravelRuleRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1,
                questionnaire: 'questionnaire_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.questionnaire;

            await expect(client.withdrawTravelRule(params)).rejects.toThrow(
                'Required parameter questionnaire was null or undefined when calling withdrawTravelRule.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: WithdrawTravelRuleRequest = {
                coin: 'coin_example',
                address: 'address_example',
                amount: 1,
                questionnaire: 'questionnaire_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'withdrawTravelRule').mockRejectedValueOnce(mockError);
            await expect(client.withdrawTravelRule(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
