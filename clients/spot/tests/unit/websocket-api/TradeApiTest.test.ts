/* eslint-disable @typescript-eslint/no-unused-vars */

/**
 * Binance Spot WebSocket API
 *
 * OpenAPI Specifications for the Binance Spot WebSocket API
 *
 * API documents:
 * - [Github web-socket-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-api.md)
 * - [General API information for web-socket-api on website](https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/general-api-information)
 *
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import WebSocketClient from 'ws';
import { EventEmitter } from 'events';
import { jest, expect, beforeEach, afterEach, describe, it } from '@jest/globals';
import { ConfigurationWebsocketAPI, WebsocketAPIBase, randomString } from '@binance/common';

import { TradeApi } from '../../../src/websocket-api';
import {
    OpenOrdersCancelAllRequest,
    OrderAmendKeepPriorityRequest,
    OrderCancelRequest,
    OrderCancelReplaceRequest,
    OrderListCancelRequest,
    OrderListPlaceRequest,
    OrderListPlaceOcoRequest,
    OrderListPlaceOtoRequest,
    OrderListPlaceOtocoRequest,
    OrderPlaceRequest,
    OrderStatusRequest,
    SorOrderPlaceRequest,
} from '../../../src/websocket-api';

jest.mock('ws');

describe('TradeApi', () => {
    let websocketBase: WebsocketAPIBase;
    let websocketAPIClient: TradeApi;
    let mockWs: jest.Mocked<WebSocketClient> & EventEmitter;
    let mockResponse: {
        id?: string;
        status?: number;
        result?: object | null;
        response?: object | null;
        error?: {
            code?: number;
            msg?: string;
        };
        rateLimits?: object[];
    } = {};

    describe('openOrderListsStatus()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute openOrderListsStatus() successfully', async () => {
            mockResponse = {
                id: '3a4437e2-41a3-4c19-897c-9cadc5dce8b6',
                status: 200,
                result: [
                    {
                        orderListId: 0,
                        contingencyType: 'OCO',
                        listStatusType: 'EXEC_STARTED',
                        listOrderStatus: 'EXECUTING',
                        listClientOrderId: '08985fedd9ea2cf6b28996',
                        transactionTime: 1660801713793,
                        symbol: 'BTCUSDT',
                        orders: [
                            {
                                symbol: 'BTCUSDT',
                                orderId: 4,
                                clientOrderId: 'CUhLgTXnX5n2c0gWiLpV4d',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 5,
                                clientOrderId: '1ZqG7bBuYwaF4SU8CwnwHm',
                            },
                        ],
                    },
                ],
                rateLimits: [
                    {
                        rateLimitType: 'REQUEST_WEIGHT',
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 6000,
                        count: 6,
                    },
                ],
            };
            mockResponse.id = randomString();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.openOrderListsStatus({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/openOrderLists.status'.slice(1),
                        expect.any(Object),
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.openOrderListsStatus({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.openOrderListsStatus();
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('openOrdersCancelAll()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute openOrdersCancelAll() successfully', async () => {
            mockResponse = {
                id: '778f938f-9041-4b88-9914-efbf64eeacc8',
                status: 200,
                result: [
                    {
                        symbol: 'BTCUSDT',
                        origClientOrderId: '4d96324ff9d44481926157',
                        orderId: 12569099453,
                        orderListId: -1,
                        clientOrderId: '91fe37ce9e69c90d6358c0',
                        transactTime: 1684804350068,
                        price: '23416.10000000',
                        origQty: '0.00847000',
                        executedQty: '0.00001000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.23416100',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'SELL',
                        stopPrice: '0.00000000',
                        trailingDelta: 0,
                        trailingTime: -1,
                        icebergQty: '0.00000000',
                        strategyId: 37463720,
                        strategyType: 1000000,
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        orderListId: 19431,
                        contingencyType: 'OCO',
                        listStatusType: 'ALL_DONE',
                        listOrderStatus: 'ALL_DONE',
                        listClientOrderId: 'iuVNVJYYrByz6C4yGOPPK0',
                        transactionTime: 1660803702431,
                        symbol: 'BTCUSDT',
                        orders: [
                            {
                                symbol: 'BTCUSDT',
                                orderId: 12569099453,
                                clientOrderId: 'bX5wROblo6YeDwa9iTLeyY',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 12569099454,
                                clientOrderId: 'Tnu2IP0J5Y4mxw3IATBfmW',
                            },
                        ],
                        orderReports: [
                            {
                                symbol: 'BTCUSDT',
                                origClientOrderId: 'bX5wROblo6YeDwa9iTLeyY',
                                orderId: 12569099453,
                                orderListId: 19431,
                                clientOrderId: 'OFFXQtxVFZ6Nbcg4PgE2DA',
                                transactTime: 1684804350068,
                                price: '23450.50000000',
                                origQty: '0.00850000',
                                executedQty: '0.00000000',
                                origQuoteOrderQty: '0.000000',
                                cummulativeQuoteQty: '0.00000000',
                                status: 'CANCELED',
                                timeInForce: 'GTC',
                                type: 'STOP_LOSS_LIMIT',
                                side: 'BUY',
                                stopPrice: '23430.00000000',
                                selfTradePreventionMode: 'NONE',
                            },
                            {
                                symbol: 'BTCUSDT',
                                origClientOrderId: 'Tnu2IP0J5Y4mxw3IATBfmW',
                                orderId: 12569099454,
                                orderListId: 19431,
                                clientOrderId: 'OFFXQtxVFZ6Nbcg4PgE2DA',
                                transactTime: 1684804350068,
                                price: '23400.00000000',
                                origQty: '0.00850000',
                                executedQty: '0.00000000',
                                origQuoteOrderQty: '0.000000',
                                cummulativeQuoteQty: '0.00000000',
                                status: 'CANCELED',
                                timeInForce: 'GTC',
                                type: 'LIMIT_MAKER',
                                side: 'BUY',
                                selfTradePreventionMode: 'NONE',
                            },
                        ],
                    },
                ],
                rateLimits: [
                    {
                        rateLimitType: 'REQUEST_WEIGHT',
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 6000,
                        count: 1,
                    },
                ],
            };
            mockResponse.id = randomString();

            const params: OpenOrdersCancelAllRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.openOrdersCancelAll({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/openOrders.cancelAll'.slice(1),
                        params,
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OpenOrdersCancelAllRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.openOrdersCancelAll({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OpenOrdersCancelAllRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.openOrdersCancelAll(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('openOrdersStatus()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute openOrdersStatus() successfully', async () => {
            mockResponse = {
                id: '55f07876-4f6f-4c47-87dc-43e5fff3f2e7',
                status: 200,
                result: [
                    {
                        symbol: 'BTCUSDT',
                        orderId: 12569099453,
                        orderListId: -1,
                        clientOrderId: '4d96324ff9d44481926157',
                        price: '23416.10000000',
                        origQty: '0.00847000',
                        executedQty: '0.00720000',
                        origQuoteOrderQty: '0.00000000',
                        cummulativeQuoteQty: '172.43931000',
                        status: 'PARTIALLY_FILLED',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'SELL',
                        stopPrice: '0.00000000',
                        icebergQty: '0.00000000',
                        time: 1660801715639,
                        updateTime: 1660801717945,
                        isWorking: true,
                        workingTime: 1660801715639,
                        selfTradePreventionMode: 'NONE',
                    },
                ],
                rateLimits: [
                    {
                        rateLimitType: 'REQUEST_WEIGHT',
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 6000,
                        count: 6,
                    },
                ],
            };
            mockResponse.id = randomString();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.openOrdersStatus({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/openOrders.status'.slice(1),
                        expect.any(Object),
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.openOrdersStatus({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.openOrdersStatus();
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderAmendKeepPriority()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderAmendKeepPriority() successfully', async () => {
            mockResponse = {
                id: '56374b46-3061-486b-a311-89ee972eb648',
                status: 200,
                result: {
                    transactTime: 1741924229819,
                    executionId: 60,
                    amendedOrder: {
                        symbol: 'BTUCSDT',
                        orderId: 23,
                        orderListId: 4,
                        origClientOrderId: 'my_pending_order',
                        clientOrderId: 'xbxXh5SSwaHS7oUEOCI88B',
                        price: '1.00000000',
                        qty: '5.00000000',
                        executedQty: '0.00000000',
                        preventedQty: '0.00000000',
                        quoteOrderQty: '0.00000000',
                        cumulativeQuoteQty: '0.00000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'BUY',
                        workingTime: 1741924204920,
                        selfTradePreventionMode: 'NONE',
                    },
                    listStatus: {
                        orderListId: 4,
                        contingencyType: 'OTO',
                        listOrderStatus: 'EXECUTING',
                        listClientOrderId: '8nOGLLawudj1QoOiwbroRH',
                        symbol: 'BTCUSDT',
                        orders: [
                            {
                                symbol: 'BTCUSDT',
                                orderId: 22,
                                clientOrderId: 'g04EWsjaackzedjC9wRkWD',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 23,
                                clientOrderId: 'xbxXh5SSwaHS7oUEOCI88B',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 22,
                                clientOrderId: 'g04EWsjaackzedjC9wRkWD',
                            },
                            {
                                symbol: 'BTCUSDT',
                                orderId: 23,
                                clientOrderId: 'xbxXh5SSwaHS7oUEOCI88B',
                            },
                        ],
                    },
                },
                rateLimits: [
                    {
                        rateLimitType: 'REQUEST_WEIGHT',
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 6000,
                        count: 1,
                    },
                ],
            };
            mockResponse.id = randomString();

            const params: OrderAmendKeepPriorityRequest = {
                symbol: 'BNBUSDT',
                newQty: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderAmendKeepPriority({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/order.amend.keepPriority'.slice(1),
                        params,
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OrderAmendKeepPriorityRequest = {
                symbol: 'BNBUSDT',
                newQty: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderAmendKeepPriority({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OrderAmendKeepPriorityRequest = {
                symbol: 'BNBUSDT',
                newQty: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderAmendKeepPriority(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderCancel()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderCancel() successfully', async () => {
            mockResponse = {
                id: '16eaf097-bbec-44b9-96ff-e97e6e875870',
                status: 200,
                result: {
                    symbol: 'BTCUSDT',
                    origClientOrderId: '4d96324ff9d44481926157',
                    orderId: 12569099453,
                    orderListId: 19431,
                    clientOrderId: '91fe37ce9e69c90d6358c0',
                    transactTime: 1684804350068,
                    price: '23416.10000000',
                    origQty: '0.00847000',
                    executedQty: '0.00001000',
                    origQuoteOrderQty: '0.000000',
                    cummulativeQuoteQty: '0.23416100',
                    status: 'CANCELED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'SELL',
                    stopPrice: '0.00000000',
                    trailingDelta: 0,
                    icebergQty: '0.00000000',
                    strategyId: 37463720,
                    strategyType: 1000000,
                    selfTradePreventionMode: 'NONE',
                    contingencyType: 'OCO',
                    listStatusType: 'ALL_DONE',
                    listOrderStatus: 'ALL_DONE',
                    listClientOrderId: 'iuVNVJYYrByz6C4yGOPPK0',
                    transactionTime: 1660803702431,
                    orders: [
                        {
                            symbol: 'BTCUSDT',
                            orderId: 12569099453,
                            clientOrderId: 'bX5wROblo6YeDwa9iTLeyY',
                        },
                        {
                            symbol: 'BTCUSDT',
                            orderId: 12569099454,
                            clientOrderId: 'Tnu2IP0J5Y4mxw3IATBfmW',
                        },
                        {
                            symbol: 'BTCUSDT',
                            orderId: 12569099453,
                            clientOrderId: 'bX5wROblo6YeDwa9iTLeyY',
                        },
                        {
                            symbol: 'BTCUSDT',
                            orderId: 12569099454,
                            clientOrderId: 'Tnu2IP0J5Y4mxw3IATBfmW',
                        },
                    ],
                    orderReports: [
                        {
                            symbol: 'BTCUSDT',
                            origClientOrderId: 'bX5wROblo6YeDwa9iTLeyY',
                            orderId: 12569099453,
                            orderListId: 19431,
                            clientOrderId: 'OFFXQtxVFZ6Nbcg4PgE2DA',
                            transactTime: 1684804350068,
                            price: '23450.50000000',
                            origQty: '0.00850000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'STOP_LOSS_LIMIT',
                            side: 'BUY',
                            stopPrice: '23430.00000000',
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'BTCUSDT',
                            origClientOrderId: 'Tnu2IP0J5Y4mxw3IATBfmW',
                            orderId: 12569099454,
                            orderListId: 19431,
                            clientOrderId: 'OFFXQtxVFZ6Nbcg4PgE2DA',
                            transactTime: 1684804350068,
                            price: '23400.00000000',
                            origQty: '0.00850000',
                            executedQty: '0.00000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'BUY',
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'BTCUSDT',
                            origClientOrderId: 'bX5wROblo6YeDwa9iTLeyY',
                            orderId: 12569099453,
                            orderListId: 19431,
                            clientOrderId: 'OFFXQtxVFZ6Nbcg4PgE2DA',
                            transactTime: 1684804350068,
                            price: '23450.50000000',
                            origQty: '0.00850000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'STOP_LOSS_LIMIT',
                            side: 'BUY',
                            stopPrice: '23430.00000000',
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'BTCUSDT',
                            origClientOrderId: 'Tnu2IP0J5Y4mxw3IATBfmW',
                            orderId: 12569099454,
                            orderListId: 19431,
                            clientOrderId: 'OFFXQtxVFZ6Nbcg4PgE2DA',
                            transactTime: 1684804350068,
                            price: '23400.00000000',
                            origQty: '0.00850000',
                            executedQty: '0.00000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'BUY',
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                },
                rateLimits: [
                    {
                        rateLimitType: 'REQUEST_WEIGHT',
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 6000,
                        count: 1,
                    },
                ],
            };
            mockResponse.id = randomString();

            const params: OrderCancelRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderCancel({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/order.cancel'.slice(1), params, {
                        isSigned: true,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OrderCancelRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderCancel({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OrderCancelRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderCancel(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderCancelReplace()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderCancelReplace() successfully', async () => {
            mockResponse = {
                id: '99de1036-b5e2-4e0f-9b5c-13d751c93a1a',
                status: 200,
                result: {
                    cancelResult: 'SUCCESS',
                    newOrderResult: 'SUCCESS',
                    cancelResponse: {
                        symbol: 'BTCUSDT',
                        origClientOrderId: '4d96324ff9d44481926157',
                        orderId: 125690984230,
                        orderListId: -1,
                        clientOrderId: '91fe37ce9e69c90d6358c0',
                        transactTime: 1684804350068,
                        price: '23450.00000000',
                        origQty: '0.00847000',
                        executedQty: '0.00001000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.23450000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'SELL',
                        selfTradePreventionMode: 'NONE',
                    },
                    newOrderResponse: {
                        symbol: 'BTCUSDT',
                        orderId: 12569099453,
                        orderListId: -1,
                        clientOrderId: 'bX5wROblo6YeDwa9iTLeyY',
                        transactTime: 1660813156959,
                        price: '23416.10000000',
                        origQty: '0.00847000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'SELL',
                        selfTradePreventionMode: 'NONE',
                    },
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 1,
                    },
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'DAY',
                        intervalNum: 1,
                        limit: 160000,
                        count: 1,
                    },
                    {
                        rateLimitType: 'REQUEST_WEIGHT',
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 6000,
                        count: 1,
                    },
                ],
            };
            mockResponse.id = randomString();

            const params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderCancelReplace({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/order.cancelReplace'.slice(1),
                        params,
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderCancelReplace({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderCancelReplace(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderListCancel()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderListCancel() successfully', async () => {
            mockResponse = {
                id: 'c5899911-d3f4-47ae-8835-97da553d27d0',
                status: 200,
                result: {
                    orderListId: 1274512,
                    contingencyType: 'OCO',
                    listStatusType: 'ALL_DONE',
                    listOrderStatus: 'ALL_DONE',
                    listClientOrderId: '6023531d7edaad348f5aff',
                    transactionTime: 1660801720215,
                    symbol: 'BTCUSDT',
                    orders: [
                        {
                            symbol: 'BTCUSDT',
                            orderId: 12569138901,
                            clientOrderId: 'BqtFCj5odMoWtSqGk2X9tU',
                        },
                        {
                            symbol: 'BTCUSDT',
                            orderId: 12569138902,
                            clientOrderId: 'jLnZpj5enfMXTuhKB1d0us',
                        },
                    ],
                    orderReports: [
                        {
                            symbol: 'BTCUSDT',
                            orderId: 12569138901,
                            orderListId: 1274512,
                            clientOrderId: 'BqtFCj5odMoWtSqGk2X9tU',
                            transactTime: 1660801720215,
                            price: '23410.00000000',
                            origQty: '0.00650000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'STOP_LOSS_LIMIT',
                            side: 'SELL',
                            stopPrice: '23405.00000000',
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'BTCUSDT',
                            orderId: 12569138902,
                            orderListId: 1274512,
                            clientOrderId: 'jLnZpj5enfMXTuhKB1d0us',
                            transactTime: 1660801720215,
                            price: '23420.00000000',
                            origQty: '0.00650000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'SELL',
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                },
                rateLimits: [
                    {
                        rateLimitType: 'REQUEST_WEIGHT',
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 6000,
                        count: 1,
                    },
                ],
            };
            mockResponse.id = randomString();

            const params: OrderListCancelRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderListCancel({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/orderList.cancel'.slice(1), params, {
                        isSigned: true,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OrderListCancelRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderListCancel({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OrderListCancelRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderListCancel(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderListPlace()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderListPlace() successfully', async () => {
            mockResponse = {
                id: '57833dc0-e3f2-43fb-ba20-46480973b0aa',
                status: 200,
                result: {
                    orderListId: 1274512,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: '08985fedd9ea2cf6b28996',
                    transactionTime: 1660801713793,
                    symbol: 'BTCUSDT',
                    orders: [
                        {
                            symbol: 'BTCUSDT',
                            orderId: 12569138901,
                            clientOrderId: 'BqtFCj5odMoWtSqGk2X9tU',
                        },
                        {
                            symbol: 'BTCUSDT',
                            orderId: 12569138902,
                            clientOrderId: 'jLnZpj5enfMXTuhKB1d0us',
                        },
                    ],
                    orderReports: [
                        {
                            symbol: 'BTCUSDT',
                            orderId: 12569138901,
                            orderListId: 1274512,
                            clientOrderId: 'BqtFCj5odMoWtSqGk2X9tU',
                            transactTime: 1660801713793,
                            price: '23410.00000000',
                            origQty: '0.00650000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'STOP_LOSS_LIMIT',
                            side: 'SELL',
                            stopPrice: '23405.00000000',
                            workingTime: -1,
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'BTCUSDT',
                            orderId: 12569138902,
                            orderListId: 1274512,
                            clientOrderId: 'jLnZpj5enfMXTuhKB1d0us',
                            transactTime: 1660801713793,
                            price: '23420.00000000',
                            origQty: '0.00650000',
                            executedQty: '0.00000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'SELL',
                            workingTime: 1660801713793,
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 2,
                    },
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'DAY',
                        intervalNum: 1,
                        limit: 160000,
                        count: 2,
                    },
                    {
                        rateLimitType: 'REQUEST_WEIGHT',
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 6000,
                        count: 1,
                    },
                ],
            };
            mockResponse.id = randomString();

            const params: OrderListPlaceRequest = {
                symbol: 'BNBUSDT',
                price: 1.0,
                quantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderListPlace({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/orderList.place'.slice(1), params, {
                        isSigned: true,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OrderListPlaceRequest = {
                symbol: 'BNBUSDT',
                price: 1.0,
                quantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderListPlace({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OrderListPlaceRequest = {
                symbol: 'BNBUSDT',
                price: 1.0,
                quantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderListPlace(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderListPlaceOco()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderListPlaceOco() successfully', async () => {
            mockResponse = {
                id: '56374a46-3261-486b-a211-99ed972eb648',
                status: 200,
                result: {
                    orderListId: 2,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'cKPMnDCbcLQILtDYM4f4fX',
                    transactionTime: 1711062760648,
                    symbol: 'LTCBNB',
                    orders: [
                        { symbol: 'LTCBNB', orderId: 2, clientOrderId: '0m6I4wfxvTUrOBSMUl0OPU' },
                        { symbol: 'LTCBNB', orderId: 3, clientOrderId: 'Z2IMlR79XNY5LU0tOxrWyW' },
                    ],
                    orderReports: [
                        {
                            symbol: 'LTCBNB',
                            orderId: 2,
                            orderListId: 2,
                            clientOrderId: '0m6I4wfxvTUrOBSMUl0OPU',
                            transactTime: 1711062760648,
                            price: '1.50000000',
                            origQty: '1.000000',
                            executedQty: '0.000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'STOP_LOSS_LIMIT',
                            side: 'BUY',
                            stopPrice: '1.50000001',
                            workingTime: -1,
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'LTCBNB',
                            orderId: 3,
                            orderListId: 2,
                            clientOrderId: 'Z2IMlR79XNY5LU0tOxrWyW',
                            transactTime: 1711062760648,
                            price: '1.49999999',
                            origQty: '1.000000',
                            executedQty: '0.000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.00000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'BUY',
                            workingTime: 1711062760648,
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 2,
                    },
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'DAY',
                        intervalNum: 1,
                        limit: 160000,
                        count: 2,
                    },
                    {
                        rateLimitType: 'REQUEST_WEIGHT',
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 6000,
                        count: 1,
                    },
                ],
            };
            mockResponse.id = randomString();

            const params: OrderListPlaceOcoRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderListPlaceOco({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/orderList.place.oco'.slice(1),
                        params,
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OrderListPlaceOcoRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderListPlaceOco({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OrderListPlaceOcoRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderListPlaceOco(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderListPlaceOto()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderListPlaceOto() successfully', async () => {
            mockResponse = {
                id: '1712544395950',
                status: 200,
                result: {
                    orderListId: 626,
                    contingencyType: 'OTO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'KA4EBjGnzvSwSCQsDdTrlf',
                    transactionTime: 1712544395981,
                    symbol: '1712544378871',
                    orders: [
                        { symbol: 'LTCBNB', orderId: 13, clientOrderId: 'YiAUtM9yJjl1a2jXHSp9Ny' },
                        { symbol: 'LTCBNB', orderId: 14, clientOrderId: '9MxJSE1TYkmyx5lbGLve7R' },
                    ],
                    orderReports: [
                        {
                            symbol: 'LTCBNB',
                            orderId: 13,
                            orderListId: 626,
                            clientOrderId: 'YiAUtM9yJjl1a2jXHSp9Ny',
                            transactTime: 1712544395981,
                            price: '1.000000',
                            origQty: '1.000000',
                            executedQty: '0.000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT',
                            side: 'SELL',
                            workingTime: 1712544395981,
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'LTCBNB',
                            orderId: 14,
                            orderListId: 626,
                            clientOrderId: '9MxJSE1TYkmyx5lbGLve7R',
                            transactTime: 1712544395981,
                            price: '0.000000',
                            origQty: '1.000000',
                            executedQty: '0.000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'PENDING_NEW',
                            timeInForce: 'GTC',
                            type: 'MARKET',
                            side: 'BUY',
                            workingTime: -1,
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 10000000,
                        count: 10,
                    },
                    {
                        rateLimitType: 'REQUEST_WEIGHT',
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 1000,
                        count: 38,
                    },
                ],
            };
            mockResponse.id = randomString();

            const params: OrderListPlaceOtoRequest = {
                symbol: 'BNBUSDT',
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingQuantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderListPlaceOto({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/orderList.place.oto'.slice(1),
                        params,
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OrderListPlaceOtoRequest = {
                symbol: 'BNBUSDT',
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingQuantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderListPlaceOto({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OrderListPlaceOtoRequest = {
                symbol: 'BNBUSDT',
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingQuantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderListPlaceOto(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderListPlaceOtoco()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderListPlaceOtoco() successfully', async () => {
            mockResponse = {
                id: '1712544408508',
                status: 200,
                result: {
                    orderListId: 629,
                    contingencyType: 'OTO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'GaeJHjZPasPItFj4x7Mqm6',
                    transactionTime: 1712544408537,
                    symbol: '1712544378871',
                    orders: [
                        {
                            symbol: '1712544378871',
                            orderId: 23,
                            clientOrderId: 'OVQOpKwfmPCfaBTD0n7e7H',
                        },
                        {
                            symbol: '1712544378871',
                            orderId: 24,
                            clientOrderId: 'YcCPKCDMQIjNvLtNswt82X',
                        },
                        {
                            symbol: '1712544378871',
                            orderId: 25,
                            clientOrderId: 'ilpIoShcFZ1ZGgSASKxMPt',
                        },
                    ],
                    orderReports: [
                        {
                            symbol: 'LTCBNB',
                            orderId: 23,
                            orderListId: 629,
                            clientOrderId: 'OVQOpKwfmPCfaBTD0n7e7H',
                            transactTime: 1712544408537,
                            price: '1.500000',
                            origQty: '1.000000',
                            executedQty: '0.000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT',
                            side: 'BUY',
                            workingTime: 1712544408537,
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'LTCBNB',
                            orderId: 24,
                            orderListId: 629,
                            clientOrderId: 'YcCPKCDMQIjNvLtNswt82X',
                            transactTime: 1712544408537,
                            price: '0.000000',
                            origQty: '5.000000',
                            executedQty: '0.000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'PENDING_NEW',
                            timeInForce: 'GTC',
                            type: 'STOP_LOSS',
                            side: 'SELL',
                            stopPrice: '0.500000',
                            workingTime: -1,
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'LTCBNB',
                            orderId: 25,
                            orderListId: 629,
                            clientOrderId: 'ilpIoShcFZ1ZGgSASKxMPt',
                            transactTime: 1712544408537,
                            price: '5.000000',
                            origQty: '5.000000',
                            executedQty: '0.000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'PENDING_NEW',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'SELL',
                            workingTime: -1,
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 10000000,
                        count: 18,
                    },
                    {
                        rateLimitType: 'REQUEST_WEIGHT',
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 1000,
                        count: 65,
                    },
                ],
            };
            mockResponse.id = randomString();

            const params: OrderListPlaceOtocoRequest = {
                symbol: 'BNBUSDT',
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingQuantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderListPlaceOtoco({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/orderList.place.otoco'.slice(1),
                        params,
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OrderListPlaceOtocoRequest = {
                symbol: 'BNBUSDT',
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingQuantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderListPlaceOtoco({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OrderListPlaceOtocoRequest = {
                symbol: 'BNBUSDT',
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingQuantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderListPlaceOtoco(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderListStatus()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderListStatus() successfully', async () => {
            mockResponse = {
                id: 'b53fd5ff-82c7-4a04-bd64-5f9dc42c2100',
                status: 200,
                result: {
                    orderListId: 1274512,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: '08985fedd9ea2cf6b28996',
                    transactionTime: 1660801713793,
                    symbol: 'BTCUSDT',
                    orders: [
                        {
                            symbol: 'BTCUSDT',
                            orderId: 12569138901,
                            clientOrderId: 'BqtFCj5odMoWtSqGk2X9tU',
                        },
                        {
                            symbol: 'BTCUSDT',
                            orderId: 12569138902,
                            clientOrderId: 'jLnZpj5enfMXTuhKB1d0us',
                        },
                    ],
                },
                rateLimits: [
                    {
                        rateLimitType: 'REQUEST_WEIGHT',
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 6000,
                        count: 4,
                    },
                ],
            };
            mockResponse.id = randomString();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderListStatus({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/orderList.status'.slice(1),
                        expect.any(Object),
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderListStatus({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderListStatus();
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderPlace()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderPlace() successfully', async () => {
            mockResponse = {
                id: '56374a46-3061-486b-a311-99ee972eb648',
                status: 200,
                result: {
                    symbol: 'BTCUSDT',
                    orderId: 12569099453,
                    orderListId: -1,
                    clientOrderId: '4d96324ff9d44481926157ec08158a40',
                    transactTime: 1660801715793,
                    price: '23416.10000000',
                    origQty: '0.00847000',
                    executedQty: '0.00847000',
                    origQuoteOrderQty: '0.000000',
                    cummulativeQuoteQty: '198.33521500',
                    status: 'FILLED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'SELL',
                    workingTime: 1660801715793,
                    selfTradePreventionMode: 'NONE',
                    fills: [
                        {
                            price: '23416.10000000',
                            qty: '0.00635000',
                            commission: '0.000000',
                            commissionAsset: 'BNB',
                            tradeId: 1650422481,
                        },
                        {
                            price: '23416.50000000',
                            qty: '0.00212000',
                            commission: '0.000000',
                            commissionAsset: 'BNB',
                            tradeId: 1650422482,
                        },
                        {
                            price: '23416.10000000',
                            qty: '0.00635000',
                            commission: '0.000000',
                            commissionAsset: 'BNB',
                            tradeId: 1650422481,
                        },
                        {
                            price: '23416.50000000',
                            qty: '0.00212000',
                            commission: '0.000000',
                            commissionAsset: 'BNB',
                            tradeId: 1650422482,
                        },
                    ],
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 1,
                    },
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'DAY',
                        intervalNum: 1,
                        limit: 160000,
                        count: 1,
                    },
                    {
                        rateLimitType: 'REQUEST_WEIGHT',
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 6000,
                        count: 1,
                    },
                ],
            };
            mockResponse.id = randomString();

            const params: OrderPlaceRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderPlace({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/order.place'.slice(1), params, {
                        isSigned: true,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OrderPlaceRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderPlace({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OrderPlaceRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderPlace(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderStatus()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderStatus() successfully', async () => {
            mockResponse = {
                id: 'aa62318a-5a97-4f3b-bdc7-640bbe33b291',
                status: 200,
                result: {
                    symbol: 'BTCUSDT',
                    orderId: 12569099453,
                    orderListId: -1,
                    clientOrderId: '4d96324ff9d44481926157',
                    price: '23416.10000000',
                    origQty: '0.00847000',
                    executedQty: '0.00847000',
                    cummulativeQuoteQty: '198.33521500',
                    status: 'FILLED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'SELL',
                    stopPrice: '0.00000000',
                    trailingDelta: 10,
                    trailingTime: -1,
                    icebergQty: '0.00000000',
                    time: 1660801715639,
                    updateTime: 1660801717945,
                    isWorking: true,
                    workingTime: 1660801715639,
                    origQuoteOrderQty: '0.00000000',
                    strategyId: 37463720,
                    strategyType: 1000000,
                    selfTradePreventionMode: 'NONE',
                    preventedMatchId: 0,
                    preventedQuantity: '1.200000',
                },
                rateLimits: [
                    {
                        rateLimitType: 'REQUEST_WEIGHT',
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 6000,
                        count: 4,
                    },
                ],
            };
            mockResponse.id = randomString();

            const params: OrderStatusRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderStatus({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/order.status'.slice(1), params, {
                        isSigned: true,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: OrderStatusRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderStatus({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: OrderStatusRequest = {
                symbol: 'BNBUSDT',
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderStatus(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('orderTest()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute orderTest() successfully', async () => {
            mockResponse = {
                id: '6ffebe91-01d9-43ac-be99-57cf062e0e30',
                status: 200,
                result: {
                    standardCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                    taxCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                    discount: {
                        enabledForAccount: true,
                        enabledForSymbol: true,
                        discountAsset: 'BNB',
                        discount: '0.25000000',
                    },
                },
                rateLimits: [
                    {
                        rateLimitType: 'REQUEST_WEIGHT',
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 6000,
                        count: 1,
                    },
                ],
            };
            mockResponse.id = randomString();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.orderTest({ id: mockResponse?.id });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/order.test'.slice(1),
                        expect.any(Object),
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.orderTest({ id: mockResponse?.id });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.orderTest();
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('sorOrderPlace()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute sorOrderPlace() successfully', async () => {
            mockResponse = {
                id: '3a4437e2-41a3-4c19-897c-9cadc5dce8b6',
                status: 200,
                result: [
                    {
                        symbol: 'BTCUSDT',
                        orderId: 2,
                        orderListId: -1,
                        clientOrderId: 'sBI1KM6nNtOfj5tccZSKly',
                        transactTime: 1689149087774,
                        price: '31000.00000000',
                        origQty: '0.50000000',
                        executedQty: '0.50000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '14000.00000000',
                        status: 'FILLED',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'BUY',
                        workingTime: 1689149087774,
                        fills: [
                            {
                                matchType: 'ONE_PARTY_TRADE_REPORT',
                                price: '28000.00000000',
                                qty: '0.50000000',
                                commission: '0.00000000',
                                commissionAsset: 'BTC',
                                tradeId: -1,
                                allocId: 0,
                            },
                        ],
                        workingFloor: 'SOR',
                        selfTradePreventionMode: 'NONE',
                        usedSor: true,
                    },
                ],
                rateLimits: [
                    {
                        rateLimitType: 'REQUEST_WEIGHT',
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 6000,
                        count: 1,
                    },
                ],
            };
            mockResponse.id = randomString();

            const params: SorOrderPlaceRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.sorOrderPlace({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith('/sor.order.place'.slice(1), params, {
                        isSigned: true,
                        withApiKey: false,
                    });
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            const params: SorOrderPlaceRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.sorOrderPlace({
                        id: mockResponse?.id,
                        ...params,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            const params: SorOrderPlaceRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.sorOrderPlace(params);
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });

    describe('sorOrderTest()', () => {
        beforeEach(async () => {
            mockWs = Object.assign(new EventEmitter(), {
                close: jest.fn(),
                ping: jest.fn(),
                pong: jest.fn(),
                send: jest.fn(),
                readyState: WebSocketClient.OPEN,
                OPEN: WebSocket.OPEN,
                CLOSED: WebSocket.CLOSED,
            }) as unknown as jest.Mocked<WebSocketClient> & EventEmitter;

            (WebSocketClient as jest.MockedClass<typeof WebSocketClient>).mockImplementation(
                () => mockWs
            );

            const config = new ConfigurationWebsocketAPI({
                apiKey: 'test-api-key',
                apiSecret: 'test-api-secret',
                wsURL: 'ws://localhost:3000',
                timeout: 1000,
            });

            websocketBase = new WebsocketAPIBase(config);
            websocketBase.connect();
        });

        afterEach(async () => {
            if (websocketBase) {
                await websocketBase.disconnect();
            }
            jest.clearAllMocks();
            jest.clearAllTimers();
        });

        it('should execute sorOrderTest() successfully', async () => {
            mockResponse = {
                id: '3a4437e2-41a3-4c19-897c-9cadc5dce8b6',
                status: 200,
                result: {
                    standardCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                    taxCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                    discount: {
                        enabledForAccount: true,
                        enabledForSymbol: true,
                        discountAsset: 'BNB',
                        discount: '0.25',
                    },
                },
                rateLimits: [
                    {
                        rateLimitType: 'REQUEST_WEIGHT',
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 6000,
                        count: 1,
                    },
                ],
            };
            mockResponse.id = randomString();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const sendMsgSpy = jest.spyOn(conn, 'sendMessage');
                    const responsePromise = websocketAPIClient.sorOrderTest({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    const response = await responsePromise;
                    expect(response.data).toEqual(mockResponse.result);
                    expect(response.rateLimits).toEqual(mockResponse.rateLimits);
                    expect(sendMsgSpy).toHaveBeenCalledWith(
                        '/sor.order.test'.slice(1),
                        expect.any(Object),
                        { isSigned: true, withApiKey: false }
                    );
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle server error responses gracefully', async () => {
            mockResponse = {
                id: randomString(),
                status: 400,
                error: {
                    code: -2010,
                    msg: 'Account has insufficient balance for requested action.',
                },
                rateLimits: [
                    {
                        rateLimitType: 'ORDERS',
                        interval: 'SECOND',
                        intervalNum: 10,
                        limit: 50,
                        count: 13,
                    },
                ],
            };

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(conn);
                    const responsePromise = websocketAPIClient.sorOrderTest({
                        id: mockResponse?.id,
                    });
                    mockWs.emit('message', JSON.stringify(mockResponse));
                    await expect(responsePromise).rejects.toMatchObject(mockResponse.error!);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        });

        it('should handle request timeout gracefully', async () => {
            jest.useRealTimers();

            let resolveTest: (value: unknown) => void;
            const testComplete = new Promise((resolve) => {
                resolveTest = resolve;
            });

            websocketBase.on('open', async (conn: WebsocketAPIBase) => {
                try {
                    websocketAPIClient = new TradeApi(websocketBase);
                    const responsePromise = websocketAPIClient.sorOrderTest();
                    await expect(responsePromise).rejects.toThrow(/^Request timeout for id:/);
                    resolveTest(true);
                } catch (error) {
                    resolveTest(error);
                }
            });
            mockWs.emit('open');

            const result = await testComplete;
            if (result instanceof Error) {
                throw result;
            }
        }, 10000);
    });
});
