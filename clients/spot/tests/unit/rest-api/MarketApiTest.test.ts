/**
 * Binance Public Spot REST API
 *
 * OpenAPI Specifications for the Binance Public Spot REST API
 *
 * API documents:
 * - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)
 * - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)
 *
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import {
    MarketApi,
    KlinesIntervalEnum,
    TickerWindowSizeEnum,
    TickerTypeEnum,
    Ticker24hrTypeEnum,
    TickerTradingDayTypeEnum,
    UiKlinesIntervalEnum,
} from '../../../src/rest-api';
import {
    AggTradesRequest,
    AvgPriceRequest,
    DepthRequest,
    GetTradesRequest,
    HistoricalTradesRequest,
    KlinesRequest,
    TickerRequest,
    Ticker24hrRequest,
    TickerBookTickerRequest,
    TickerPriceRequest,
    TickerTradingDayRequest,
    UiKlinesRequest,
} from '../../../src/rest-api';
import type {
    AggTradesResponse,
    AvgPriceResponse,
    DepthResponse,
    GetTradesResponse,
    HistoricalTradesResponse,
    KlinesResponse,
    Ticker24hrResponse,
    TickerBookTickerResponse,
    TickerPriceResponse,
    TickerResponse,
    TickerTradingDayResponse,
    UiKlinesResponse,
} from '../../../src/rest-api/types';

describe('MarketApi', () => {
    let client: MarketApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new MarketApi(config);
    });

    describe('aggTrades()', () => {
        it('should execute aggTrades() successfully with required parameters only', async () => {
            const params: AggTradesRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = [
                {
                    a: 26129,
                    p: '0.01633102',
                    q: '4.70443515',
                    f: 27781,
                    l: 27781,
                    T: 1498793709153,
                    m: true,
                    M: true,
                },
            ];

            const spy = jest.spyOn(client, 'aggTrades').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AggTradesResponse>)
            );
            const response = await client.aggTrades(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute aggTrades() successfully with optional parameters', async () => {
            const params: AggTradesRequest = {
                symbol: 'BNBUSDT',
                fromId: 1,
                startTime: 1735693200000,
                endTime: 1735693200000,
                limit: 500,
            };

            mockResponse = [
                {
                    a: 26129,
                    p: '0.01633102',
                    q: '4.70443515',
                    f: 27781,
                    l: 27781,
                    T: 1498793709153,
                    m: true,
                    M: true,
                },
            ];

            const spy = jest.spyOn(client, 'aggTrades').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AggTradesResponse>)
            );
            const response = await client.aggTrades(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: AggTradesRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.aggTrades(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling aggTrades.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AggTradesRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'aggTrades').mockRejectedValueOnce(mockError);
            await expect(client.aggTrades(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('avgPrice()', () => {
        it('should execute avgPrice() successfully with required parameters only', async () => {
            const params: AvgPriceRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = { mins: 5, price: '9.35751834', closeTime: 1694061154503 };

            const spy = jest.spyOn(client, 'avgPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AvgPriceResponse>)
            );
            const response = await client.avgPrice(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute avgPrice() successfully with optional parameters', async () => {
            const params: AvgPriceRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = { mins: 5, price: '9.35751834', closeTime: 1694061154503 };

            const spy = jest.spyOn(client, 'avgPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AvgPriceResponse>)
            );
            const response = await client.avgPrice(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: AvgPriceRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.avgPrice(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling avgPrice.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AvgPriceRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'avgPrice').mockRejectedValueOnce(mockError);
            await expect(client.avgPrice(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('depth()', () => {
        it('should execute depth() successfully with required parameters only', async () => {
            const params: DepthRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = {
                lastUpdateId: 1027024,
                bids: [['4.00000000', '431.00000000']],
                asks: [['4.00000200', '12.00000000']],
            };

            const spy = jest.spyOn(client, 'depth').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepthResponse>)
            );
            const response = await client.depth(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute depth() successfully with optional parameters', async () => {
            const params: DepthRequest = {
                symbol: 'BNBUSDT',
                limit: 500,
            };

            mockResponse = {
                lastUpdateId: 1027024,
                bids: [['4.00000000', '431.00000000']],
                asks: [['4.00000200', '12.00000000']],
            };

            const spy = jest.spyOn(client, 'depth').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepthResponse>)
            );
            const response = await client.depth(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: DepthRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.depth(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling depth.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DepthRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'depth').mockRejectedValueOnce(mockError);
            await expect(client.depth(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getTrades()', () => {
        it('should execute getTrades() successfully with required parameters only', async () => {
            const params: GetTradesRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = [
                {
                    id: 28457,
                    price: '4.00000100',
                    qty: '12.00000000',
                    quoteQty: '48.000012',
                    time: 1499865549590,
                    isBuyerMaker: true,
                    isBestMatch: true,
                },
            ];

            const spy = jest.spyOn(client, 'getTrades').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetTradesResponse>)
            );
            const response = await client.getTrades(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getTrades() successfully with optional parameters', async () => {
            const params: GetTradesRequest = {
                symbol: 'BNBUSDT',
                limit: 500,
            };

            mockResponse = [
                {
                    id: 28457,
                    price: '4.00000100',
                    qty: '12.00000000',
                    quoteQty: '48.000012',
                    time: 1499865549590,
                    isBuyerMaker: true,
                    isBestMatch: true,
                },
            ];

            const spy = jest.spyOn(client, 'getTrades').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetTradesResponse>)
            );
            const response = await client.getTrades(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: GetTradesRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.getTrades(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling getTrades.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetTradesRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getTrades').mockRejectedValueOnce(mockError);
            await expect(client.getTrades(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('historicalTrades()', () => {
        it('should execute historicalTrades() successfully with required parameters only', async () => {
            const params: HistoricalTradesRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = [
                {
                    id: 28457,
                    price: '4.00000100',
                    qty: '12.00000000',
                    quoteQty: '48.000012',
                    time: 1499865549590,
                    isBuyerMaker: true,
                    isBestMatch: true,
                },
            ];

            const spy = jest.spyOn(client, 'historicalTrades').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<HistoricalTradesResponse>)
            );
            const response = await client.historicalTrades(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute historicalTrades() successfully with optional parameters', async () => {
            const params: HistoricalTradesRequest = {
                symbol: 'BNBUSDT',
                limit: 500,
                fromId: 1,
            };

            mockResponse = [
                {
                    id: 28457,
                    price: '4.00000100',
                    qty: '12.00000000',
                    quoteQty: '48.000012',
                    time: 1499865549590,
                    isBuyerMaker: true,
                    isBestMatch: true,
                },
            ];

            const spy = jest.spyOn(client, 'historicalTrades').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<HistoricalTradesResponse>)
            );
            const response = await client.historicalTrades(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: HistoricalTradesRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.historicalTrades(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling historicalTrades.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: HistoricalTradesRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'historicalTrades').mockRejectedValueOnce(mockError);
            await expect(client.historicalTrades(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('klines()', () => {
        it('should execute klines() successfully with required parameters only', async () => {
            const params: KlinesRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = [
                [
                    1499040000000,
                    '0.01634790',
                    '0.80000000',
                    '0.01575800',
                    '0.01577100',
                    '148976.11427815',
                    1499644799999,
                    '2434.19055334',
                    308,
                    '1756.87402397',
                    '28.46694368',
                    '0',
                ],
            ];

            const spy = jest.spyOn(client, 'klines').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<KlinesResponse>)
            );
            const response = await client.klines(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute klines() successfully with optional parameters', async () => {
            const params: KlinesRequest = {
                symbol: 'BNBUSDT',
                interval: KlinesIntervalEnum.INTERVAL_1s,
                startTime: 1735693200000,
                endTime: 1735693200000,
                timeZone: 'timeZone_example',
                limit: 500,
            };

            mockResponse = [
                [
                    1499040000000,
                    '0.01634790',
                    '0.80000000',
                    '0.01575800',
                    '0.01577100',
                    '148976.11427815',
                    1499644799999,
                    '2434.19055334',
                    308,
                    '1756.87402397',
                    '28.46694368',
                    '0',
                ],
            ];

            const spy = jest.spyOn(client, 'klines').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<KlinesResponse>)
            );
            const response = await client.klines(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: KlinesRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.klines(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling klines.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: KlinesRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'klines').mockRejectedValueOnce(mockError);
            await expect(client.klines(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('ticker()', () => {
        it('should execute ticker() successfully with required parameters only', async () => {
            const params: TickerRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = {
                symbol: 'LTCBTC',
                openPrice: '0.10000000',
                highPrice: '2.00000000',
                lowPrice: '0.10000000',
                lastPrice: '2.00000000',
                volume: '39.00000000',
                quoteVolume: '13.40000000',
                openTime: 1656986580000,
                closeTime: 1657001016795,
                firstId: 0,
                lastId: 34,
                count: 35,
            };

            const spy = jest.spyOn(client, 'ticker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TickerResponse>)
            );
            const response = await client.ticker(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute ticker() successfully with optional parameters', async () => {
            const params: TickerRequest = {
                symbol: 'BNBUSDT',
                symbols: ['null'],
                windowSize: TickerWindowSizeEnum.WINDOW_SIZE_1m,
                type: TickerTypeEnum.FULL,
            };

            mockResponse = {
                symbol: 'LTCBTC',
                openPrice: '0.10000000',
                highPrice: '2.00000000',
                lowPrice: '0.10000000',
                lastPrice: '2.00000000',
                volume: '39.00000000',
                quoteVolume: '13.40000000',
                openTime: 1656986580000,
                closeTime: 1657001016795,
                firstId: 0,
                lastId: 34,
                count: 35,
            };

            const spy = jest.spyOn(client, 'ticker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TickerResponse>)
            );
            const response = await client.ticker(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: TickerRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.ticker(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling ticker.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TickerRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'ticker').mockRejectedValueOnce(mockError);
            await expect(client.ticker(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('ticker24hr()', () => {
        it('should execute ticker24hr() successfully with required parameters only', async () => {
            const params: Ticker24hrRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = {
                symbol: 'BNBBTC',
                openPrice: '99.00000000',
                highPrice: '100.00000000',
                lowPrice: '0.10000000',
                lastPrice: '4.00000200',
                volume: '8913.30000000',
                quoteVolume: '15.30000000',
                openTime: 1499783499040,
                closeTime: 1499869899040,
                firstId: 28385,
                lastId: 28460,
                count: 76,
            };

            const spy = jest.spyOn(client, 'ticker24hr').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<Ticker24hrResponse>)
            );
            const response = await client.ticker24hr(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute ticker24hr() successfully with optional parameters', async () => {
            const params: Ticker24hrRequest = {
                symbol: 'BNBUSDT',
                symbols: ['null'],
                type: Ticker24hrTypeEnum.FULL,
            };

            mockResponse = {
                symbol: 'BNBBTC',
                openPrice: '99.00000000',
                highPrice: '100.00000000',
                lowPrice: '0.10000000',
                lastPrice: '4.00000200',
                volume: '8913.30000000',
                quoteVolume: '15.30000000',
                openTime: 1499783499040,
                closeTime: 1499869899040,
                firstId: 28385,
                lastId: 28460,
                count: 76,
            };

            const spy = jest.spyOn(client, 'ticker24hr').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<Ticker24hrResponse>)
            );
            const response = await client.ticker24hr(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: Ticker24hrRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.ticker24hr(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling ticker24hr.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: Ticker24hrRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'ticker24hr').mockRejectedValueOnce(mockError);
            await expect(client.ticker24hr(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('tickerBookTicker()', () => {
        it('should execute tickerBookTicker() successfully with required parameters only', async () => {
            const params: TickerBookTickerRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = {
                symbol: 'LTCBTC',
                bidPrice: '4.00000000',
                bidQty: '431.00000000',
                askPrice: '4.00000200',
                askQty: '9.00000000',
            };

            const spy = jest.spyOn(client, 'tickerBookTicker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TickerBookTickerResponse>)
            );
            const response = await client.tickerBookTicker(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute tickerBookTicker() successfully with optional parameters', async () => {
            const params: TickerBookTickerRequest = {
                symbol: 'BNBUSDT',
                symbols: ['null'],
            };

            mockResponse = {
                symbol: 'LTCBTC',
                bidPrice: '4.00000000',
                bidQty: '431.00000000',
                askPrice: '4.00000200',
                askQty: '9.00000000',
            };

            const spy = jest.spyOn(client, 'tickerBookTicker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TickerBookTickerResponse>)
            );
            const response = await client.tickerBookTicker(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: TickerBookTickerRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.tickerBookTicker(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling tickerBookTicker.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TickerBookTickerRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'tickerBookTicker').mockRejectedValueOnce(mockError);
            await expect(client.tickerBookTicker(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('tickerPrice()', () => {
        it('should execute tickerPrice() successfully with required parameters only', async () => {
            const params: TickerPriceRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = { symbol: 'LTCBTC', price: '4.00000200' };

            const spy = jest.spyOn(client, 'tickerPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TickerPriceResponse>)
            );
            const response = await client.tickerPrice(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute tickerPrice() successfully with optional parameters', async () => {
            const params: TickerPriceRequest = {
                symbol: 'BNBUSDT',
                symbols: ['null'],
            };

            mockResponse = { symbol: 'LTCBTC', price: '4.00000200' };

            const spy = jest.spyOn(client, 'tickerPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TickerPriceResponse>)
            );
            const response = await client.tickerPrice(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: TickerPriceRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.tickerPrice(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling tickerPrice.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TickerPriceRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'tickerPrice').mockRejectedValueOnce(mockError);
            await expect(client.tickerPrice(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('tickerTradingDay()', () => {
        it('should execute tickerTradingDay() successfully with required parameters only', async () => {
            const params: TickerTradingDayRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                openPrice: '26304.80000000',
                highPrice: '26397.46000000',
                lowPrice: '26088.34000000',
                lastPrice: '26221.67000000',
                volume: '18495.35066000',
                quoteVolume: '485217905.04210480',
                openTime: 1695686400000,
                closeTime: 1695772799999,
                firstId: 3220151555,
                lastId: 3220849281,
                count: 697727,
            };

            const spy = jest.spyOn(client, 'tickerTradingDay').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TickerTradingDayResponse>)
            );
            const response = await client.tickerTradingDay(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute tickerTradingDay() successfully with optional parameters', async () => {
            const params: TickerTradingDayRequest = {
                symbol: 'BNBUSDT',
                symbols: ['null'],
                timeZone: 'timeZone_example',
                type: TickerTradingDayTypeEnum.FULL,
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                openPrice: '26304.80000000',
                highPrice: '26397.46000000',
                lowPrice: '26088.34000000',
                lastPrice: '26221.67000000',
                volume: '18495.35066000',
                quoteVolume: '485217905.04210480',
                openTime: 1695686400000,
                closeTime: 1695772799999,
                firstId: 3220151555,
                lastId: 3220849281,
                count: 697727,
            };

            const spy = jest.spyOn(client, 'tickerTradingDay').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TickerTradingDayResponse>)
            );
            const response = await client.tickerTradingDay(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: TickerTradingDayRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.tickerTradingDay(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling tickerTradingDay.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TickerTradingDayRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'tickerTradingDay').mockRejectedValueOnce(mockError);
            await expect(client.tickerTradingDay(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('uiKlines()', () => {
        it('should execute uiKlines() successfully with required parameters only', async () => {
            const params: UiKlinesRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = [
                [
                    1499040000000,
                    '0.01634790',
                    '0.80000000',
                    '0.01575800',
                    '0.01577100',
                    '148976.11427815',
                    1499644799999,
                    '2434.19055334',
                    308,
                    '1756.87402397',
                    '28.46694368',
                    '0',
                ],
            ];

            const spy = jest.spyOn(client, 'uiKlines').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UiKlinesResponse>)
            );
            const response = await client.uiKlines(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute uiKlines() successfully with optional parameters', async () => {
            const params: UiKlinesRequest = {
                symbol: 'BNBUSDT',
                interval: UiKlinesIntervalEnum.INTERVAL_1s,
                startTime: 1735693200000,
                endTime: 1735693200000,
                timeZone: 'timeZone_example',
                limit: 500,
            };

            mockResponse = [
                [
                    1499040000000,
                    '0.01634790',
                    '0.80000000',
                    '0.01575800',
                    '0.01577100',
                    '148976.11427815',
                    1499644799999,
                    '2434.19055334',
                    308,
                    '1756.87402397',
                    '28.46694368',
                    '0',
                ],
            ];

            const spy = jest.spyOn(client, 'uiKlines').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UiKlinesResponse>)
            );
            const response = await client.uiKlines(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: UiKlinesRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.uiKlines(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling uiKlines.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: UiKlinesRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'uiKlines').mockRejectedValueOnce(mockError);
            await expect(client.uiKlines(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
