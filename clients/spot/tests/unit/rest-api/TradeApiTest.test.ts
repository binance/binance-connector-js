/**
 * Binance Spot REST API
 *
 * OpenAPI Specifications for the Binance Spot REST API
 *
 * API documents:
 * - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)
 * - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)
 *
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import {
    TradeApi,
    DeleteOrderCancelRestrictionsEnum,
    NewOrderSideEnum,
    NewOrderTypeEnum,
    NewOrderTimeInForceEnum,
    NewOrderNewOrderRespTypeEnum,
    NewOrderSelfTradePreventionModeEnum,
    OrderCancelReplaceSideEnum,
    OrderCancelReplaceTypeEnum,
    OrderCancelReplaceCancelReplaceModeEnum,
    OrderCancelReplaceTimeInForceEnum,
    OrderCancelReplaceNewOrderRespTypeEnum,
    OrderCancelReplaceSelfTradePreventionModeEnum,
    OrderCancelReplaceCancelRestrictionsEnum,
    OrderCancelReplaceOrderRateLimitExceededModeEnum,
    OrderListOcoSideEnum,
    OrderListOcoAboveTypeEnum,
    OrderListOcoBelowTypeEnum,
    OrderListOcoBelowTimeInForceEnum,
    OrderListOcoNewOrderRespTypeEnum,
    OrderListOcoSelfTradePreventionModeEnum,
    OrderListOtoWorkingTypeEnum,
    OrderListOtoWorkingSideEnum,
    OrderListOtoPendingTypeEnum,
    OrderListOtoPendingSideEnum,
    OrderListOtoNewOrderRespTypeEnum,
    OrderListOtoSelfTradePreventionModeEnum,
    OrderListOtoWorkingTimeInForceEnum,
    OrderListOtoPendingTimeInForceEnum,
    OrderListOtocoWorkingTypeEnum,
    OrderListOtocoWorkingSideEnum,
    OrderListOtocoPendingSideEnum,
    OrderListOtocoPendingAboveTypeEnum,
    OrderListOtocoNewOrderRespTypeEnum,
    OrderListOtocoSelfTradePreventionModeEnum,
    OrderListOtocoWorkingTimeInForceEnum,
    OrderListOtocoPendingAboveTimeInForceEnum,
    OrderListOtocoPendingBelowTypeEnum,
    OrderListOtocoPendingBelowTimeInForceEnum,
    OrderOcoSideEnum,
    OrderOcoStopLimitTimeInForceEnum,
    OrderOcoNewOrderRespTypeEnum,
    OrderOcoSelfTradePreventionModeEnum,
    OrderTestSideEnum,
    OrderTestTypeEnum,
    OrderTestTimeInForceEnum,
    OrderTestNewOrderRespTypeEnum,
    OrderTestSelfTradePreventionModeEnum,
    SorOrderSideEnum,
    SorOrderTypeEnum,
    SorOrderTimeInForceEnum,
    SorOrderNewOrderRespTypeEnum,
    SorOrderSelfTradePreventionModeEnum,
    SorOrderTestSideEnum,
    SorOrderTestTypeEnum,
    SorOrderTestTimeInForceEnum,
    SorOrderTestNewOrderRespTypeEnum,
    SorOrderTestSelfTradePreventionModeEnum,
} from '../../../src/rest-api';
import {
    DeleteOpenOrdersRequest,
    DeleteOrderRequest,
    DeleteOrderListRequest,
    NewOrderRequest,
    OrderAmendKeepPriorityRequest,
    OrderCancelReplaceRequest,
    OrderListOcoRequest,
    OrderListOtoRequest,
    OrderListOtocoRequest,
    OrderOcoRequest,
    OrderTestRequest,
    SorOrderRequest,
    SorOrderTestRequest,
} from '../../../src/rest-api';
import type {
    DeleteOpenOrdersResponse,
    DeleteOrderListResponse,
    DeleteOrderResponse,
    NewOrderResponse,
    OrderAmendKeepPriorityResponse,
    OrderCancelReplaceResponse,
    OrderListOcoResponse,
    OrderListOtoResponse,
    OrderListOtocoResponse,
    OrderOcoResponse,
    OrderTestResponse,
    SorOrderResponse,
    SorOrderTestResponse,
} from '../../../src/rest-api/types';

describe('TradeApi', () => {
    let client: TradeApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new TradeApi(config);
    });

    describe('deleteOpenOrders()', () => {
        it('should execute deleteOpenOrders() successfully with required parameters only', async () => {
            const params: DeleteOpenOrdersRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    origClientOrderId: 'E6APeyTJvkMvLMYMqu1KQ4',
                    orderId: 11,
                    orderListId: -1,
                    clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                    transactTime: 1684804350068,
                    price: '0.089853',
                    origQty: '0.178622',
                    executedQty: '0.000000',
                    origQuoteOrderQty: '0.000000',
                    cummulativeQuoteQty: '0.000000',
                    status: 'CANCELED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    selfTradePreventionMode: 'NONE',
                },
                {
                    symbol: 'BTCUSDT',
                    origClientOrderId: 'A3EF2HCwxgZPFMrfwbgrhv',
                    orderId: 13,
                    orderListId: -1,
                    clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                    transactTime: 1684804350069,
                    price: '0.090430',
                    origQty: '0.178622',
                    executedQty: '0.000000',
                    origQuoteOrderQty: '0.000000',
                    cummulativeQuoteQty: '0.000000',
                    status: 'CANCELED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    selfTradePreventionMode: 'NONE',
                },
                {
                    orderListId: 1929,
                    contingencyType: 'OCO',
                    listStatusType: 'ALL_DONE',
                    listOrderStatus: 'ALL_DONE',
                    listClientOrderId: '2inzWQdDvZLHbbAmAozX2N',
                    transactionTime: 1585230948299,
                    symbol: 'BTCUSDT',
                    orders: [
                        { symbol: 'BTCUSDT', orderId: 20, clientOrderId: 'CwOOIPHSmYywx6jZX77TdL' },
                        { symbol: 'BTCUSDT', orderId: 21, clientOrderId: '461cPg51vQjV3zIMOXNz39' },
                    ],
                    orderReports: [
                        {
                            symbol: 'BTCUSDT',
                            origClientOrderId: 'CwOOIPHSmYywx6jZX77TdL',
                            orderId: 20,
                            orderListId: 1929,
                            clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                            transactTime: 1688005070874,
                            price: '0.668611',
                            origQty: '0.690354',
                            executedQty: '0.000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'STOP_LOSS_LIMIT',
                            side: 'BUY',
                            stopPrice: '0.378131',
                            icebergQty: '0.017083',
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'BTCUSDT',
                            origClientOrderId: '461cPg51vQjV3zIMOXNz39',
                            orderId: 21,
                            orderListId: 1929,
                            clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                            transactTime: 1688005070874,
                            price: '0.008791',
                            origQty: '0.690354',
                            executedQty: '0.000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'BUY',
                            icebergQty: '0.639962',
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'deleteOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DeleteOpenOrdersResponse>)
            );
            const response = await client.deleteOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute deleteOpenOrders() successfully with optional parameters', async () => {
            const params: DeleteOpenOrdersRequest = {
                symbol: 'BNBUSDT',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    origClientOrderId: 'E6APeyTJvkMvLMYMqu1KQ4',
                    orderId: 11,
                    orderListId: -1,
                    clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                    transactTime: 1684804350068,
                    price: '0.089853',
                    origQty: '0.178622',
                    executedQty: '0.000000',
                    origQuoteOrderQty: '0.000000',
                    cummulativeQuoteQty: '0.000000',
                    status: 'CANCELED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    selfTradePreventionMode: 'NONE',
                },
                {
                    symbol: 'BTCUSDT',
                    origClientOrderId: 'A3EF2HCwxgZPFMrfwbgrhv',
                    orderId: 13,
                    orderListId: -1,
                    clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                    transactTime: 1684804350069,
                    price: '0.090430',
                    origQty: '0.178622',
                    executedQty: '0.000000',
                    origQuoteOrderQty: '0.000000',
                    cummulativeQuoteQty: '0.000000',
                    status: 'CANCELED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    selfTradePreventionMode: 'NONE',
                },
                {
                    orderListId: 1929,
                    contingencyType: 'OCO',
                    listStatusType: 'ALL_DONE',
                    listOrderStatus: 'ALL_DONE',
                    listClientOrderId: '2inzWQdDvZLHbbAmAozX2N',
                    transactionTime: 1585230948299,
                    symbol: 'BTCUSDT',
                    orders: [
                        { symbol: 'BTCUSDT', orderId: 20, clientOrderId: 'CwOOIPHSmYywx6jZX77TdL' },
                        { symbol: 'BTCUSDT', orderId: 21, clientOrderId: '461cPg51vQjV3zIMOXNz39' },
                    ],
                    orderReports: [
                        {
                            symbol: 'BTCUSDT',
                            origClientOrderId: 'CwOOIPHSmYywx6jZX77TdL',
                            orderId: 20,
                            orderListId: 1929,
                            clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                            transactTime: 1688005070874,
                            price: '0.668611',
                            origQty: '0.690354',
                            executedQty: '0.000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'STOP_LOSS_LIMIT',
                            side: 'BUY',
                            stopPrice: '0.378131',
                            icebergQty: '0.017083',
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'BTCUSDT',
                            origClientOrderId: '461cPg51vQjV3zIMOXNz39',
                            orderId: 21,
                            orderListId: 1929,
                            clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                            transactTime: 1688005070874,
                            price: '0.008791',
                            origQty: '0.690354',
                            executedQty: '0.000000',
                            origQuoteOrderQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'BUY',
                            icebergQty: '0.639962',
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'deleteOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DeleteOpenOrdersResponse>)
            );
            const response = await client.deleteOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: DeleteOpenOrdersRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.deleteOpenOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling deleteOpenOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DeleteOpenOrdersRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'deleteOpenOrders').mockRejectedValueOnce(mockError);
            await expect(client.deleteOpenOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('deleteOrder()', () => {
        it('should execute deleteOrder() successfully with required parameters only', async () => {
            const params: DeleteOrderRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = {
                symbol: 'LTCBTC',
                origClientOrderId: 'myOrder1',
                orderId: 4,
                orderListId: -1,
                clientOrderId: 'cancelMyOrder1',
                transactTime: 1684804350068,
                price: '2.00000000',
                origQty: '1.00000000',
                executedQty: '0.00000000',
                origQuoteOrderQty: '0.000000',
                cummulativeQuoteQty: '0.00000000',
                status: 'CANCELED',
                timeInForce: 'GTC',
                type: 'LIMIT',
                side: 'BUY',
                selfTradePreventionMode: 'NONE',
            };

            const spy = jest.spyOn(client, 'deleteOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DeleteOrderResponse>)
            );
            const response = await client.deleteOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute deleteOrder() successfully with optional parameters', async () => {
            const params: DeleteOrderRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
                origClientOrderId: 'origClientOrderId_example',
                newClientOrderId: 'newClientOrderId_example',
                cancelRestrictions: DeleteOrderCancelRestrictionsEnum.ONLY_NEW,
                recvWindow: 5000,
            };

            mockResponse = {
                symbol: 'LTCBTC',
                origClientOrderId: 'myOrder1',
                orderId: 4,
                orderListId: -1,
                clientOrderId: 'cancelMyOrder1',
                transactTime: 1684804350068,
                price: '2.00000000',
                origQty: '1.00000000',
                executedQty: '0.00000000',
                origQuoteOrderQty: '0.000000',
                cummulativeQuoteQty: '0.00000000',
                status: 'CANCELED',
                timeInForce: 'GTC',
                type: 'LIMIT',
                side: 'BUY',
                selfTradePreventionMode: 'NONE',
            };

            const spy = jest.spyOn(client, 'deleteOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DeleteOrderResponse>)
            );
            const response = await client.deleteOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: DeleteOrderRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.deleteOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling deleteOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DeleteOrderRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'deleteOrder').mockRejectedValueOnce(mockError);
            await expect(client.deleteOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('deleteOrderList()', () => {
        it('should execute deleteOrderList() successfully with required parameters only', async () => {
            const params: DeleteOrderListRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = {
                orderListId: 0,
                contingencyType: 'OCO',
                listStatusType: 'ALL_DONE',
                listOrderStatus: 'ALL_DONE',
                listClientOrderId: 'C3wyj4WVEktd7u9aVBRXcN',
                transactionTime: 1574040868128,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'TXOvglzXuaubXAaENpaRCB' },
                    { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'pO9ufTiFGg3nw2fOdgeOXa' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        origClientOrderId: 'TXOvglzXuaubXAaENpaRCB',
                        orderId: 3,
                        orderListId: 0,
                        clientOrderId: 'unfWT8ig8i0uj6lPuYLez6',
                        transactTime: 1688005070874,
                        price: '3.00000000',
                        origQty: '10.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'SELL',
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        origClientOrderId: 'pO9ufTiFGg3nw2fOdgeOXa',
                        orderId: 2,
                        orderListId: 0,
                        clientOrderId: 'unfWT8ig8i0uj6lPuYLez6',
                        transactTime: 1688005070874,
                        price: '1.00000000',
                        origQty: '10.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'STOP_LOSS_LIMIT',
                        side: 'SELL',
                        stopPrice: '1.00000000',
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'deleteOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DeleteOrderListResponse>)
            );
            const response = await client.deleteOrderList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute deleteOrderList() successfully with optional parameters', async () => {
            const params: DeleteOrderListRequest = {
                symbol: 'BNBUSDT',
                orderListId: 1,
                listClientOrderId: 'listClientOrderId_example',
                newClientOrderId: 'newClientOrderId_example',
                recvWindow: 5000,
            };

            mockResponse = {
                orderListId: 0,
                contingencyType: 'OCO',
                listStatusType: 'ALL_DONE',
                listOrderStatus: 'ALL_DONE',
                listClientOrderId: 'C3wyj4WVEktd7u9aVBRXcN',
                transactionTime: 1574040868128,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'TXOvglzXuaubXAaENpaRCB' },
                    { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'pO9ufTiFGg3nw2fOdgeOXa' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        origClientOrderId: 'TXOvglzXuaubXAaENpaRCB',
                        orderId: 3,
                        orderListId: 0,
                        clientOrderId: 'unfWT8ig8i0uj6lPuYLez6',
                        transactTime: 1688005070874,
                        price: '3.00000000',
                        origQty: '10.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'SELL',
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        origClientOrderId: 'pO9ufTiFGg3nw2fOdgeOXa',
                        orderId: 2,
                        orderListId: 0,
                        clientOrderId: 'unfWT8ig8i0uj6lPuYLez6',
                        transactTime: 1688005070874,
                        price: '1.00000000',
                        origQty: '10.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'STOP_LOSS_LIMIT',
                        side: 'SELL',
                        stopPrice: '1.00000000',
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'deleteOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DeleteOrderListResponse>)
            );
            const response = await client.deleteOrderList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: DeleteOrderListRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.deleteOrderList(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling deleteOrderList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DeleteOrderListRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'deleteOrderList').mockRejectedValueOnce(mockError);
            await expect(client.deleteOrderList(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('newOrder()', () => {
        it('should execute newOrder() successfully with required parameters only', async () => {
            const params: NewOrderRequest = {
                symbol: 'BNBUSDT',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.MARKET,
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                orderId: 28,
                orderListId: -1,
                clientOrderId: '6gCrw2kRUAF9CvJDGP16IP',
                transactTime: 1507725176595,
                price: '0.00000000',
                origQty: '10.00000000',
                executedQty: '10.00000000',
                origQuoteOrderQty: '0.000000',
                cummulativeQuoteQty: '10.00000000',
                status: 'FILLED',
                timeInForce: 'GTC',
                type: 'MARKET',
                side: 'SELL',
                workingTime: 1507725176595,
                selfTradePreventionMode: 'NONE',
                fills: [
                    {
                        price: '3995.00000000',
                        qty: '1.00000000',
                        commission: '3.99500000',
                        commissionAsset: 'USDT',
                        tradeId: 60,
                    },
                    {
                        price: '3997.00000000',
                        qty: '1.00000000',
                        commission: '3.99700000',
                        commissionAsset: 'USDT',
                        tradeId: 59,
                    },
                    {
                        price: '3998.00000000',
                        qty: '2.00000000',
                        commission: '7.99600000',
                        commissionAsset: 'USDT',
                        tradeId: 58,
                    },
                    {
                        price: '3999.00000000',
                        qty: '5.00000000',
                        commission: '19.99500000',
                        commissionAsset: 'USDT',
                        tradeId: 57,
                    },
                    {
                        price: '4000.00000000',
                        qty: '1.00000000',
                        commission: '4.00000000',
                        commissionAsset: 'USDT',
                        tradeId: 56,
                    },
                    {
                        price: '3995.00000000',
                        qty: '1.00000000',
                        commission: '3.99500000',
                        commissionAsset: 'USDT',
                        tradeId: 60,
                    },
                    {
                        price: '3997.00000000',
                        qty: '1.00000000',
                        commission: '3.99700000',
                        commissionAsset: 'USDT',
                        tradeId: 59,
                    },
                    {
                        price: '3998.00000000',
                        qty: '2.00000000',
                        commission: '7.99600000',
                        commissionAsset: 'USDT',
                        tradeId: 58,
                    },
                    {
                        price: '3999.00000000',
                        qty: '5.00000000',
                        commission: '19.99500000',
                        commissionAsset: 'USDT',
                        tradeId: 57,
                    },
                    {
                        price: '4000.00000000',
                        qty: '1.00000000',
                        commission: '4.00000000',
                        commissionAsset: 'USDT',
                        tradeId: 56,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'newOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewOrderResponse>)
            );
            const response = await client.newOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute newOrder() successfully with optional parameters', async () => {
            const params: NewOrderRequest = {
                symbol: 'BNBUSDT',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.MARKET,
                timeInForce: NewOrderTimeInForceEnum.GTC,
                quantity: 1.0,
                quoteOrderQty: 1.0,
                price: 400.0,
                newClientOrderId: 'newClientOrderId_example',
                strategyId: 1,
                strategyType: 1,
                stopPrice: 1.0,
                trailingDelta: 1,
                icebergQty: 1.0,
                newOrderRespType: NewOrderNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: NewOrderSelfTradePreventionModeEnum.NONE,
                recvWindow: 5000,
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                orderId: 28,
                orderListId: -1,
                clientOrderId: '6gCrw2kRUAF9CvJDGP16IP',
                transactTime: 1507725176595,
                price: '0.00000000',
                origQty: '10.00000000',
                executedQty: '10.00000000',
                origQuoteOrderQty: '0.000000',
                cummulativeQuoteQty: '10.00000000',
                status: 'FILLED',
                timeInForce: 'GTC',
                type: 'MARKET',
                side: 'SELL',
                workingTime: 1507725176595,
                selfTradePreventionMode: 'NONE',
                fills: [
                    {
                        price: '3995.00000000',
                        qty: '1.00000000',
                        commission: '3.99500000',
                        commissionAsset: 'USDT',
                        tradeId: 60,
                    },
                    {
                        price: '3997.00000000',
                        qty: '1.00000000',
                        commission: '3.99700000',
                        commissionAsset: 'USDT',
                        tradeId: 59,
                    },
                    {
                        price: '3998.00000000',
                        qty: '2.00000000',
                        commission: '7.99600000',
                        commissionAsset: 'USDT',
                        tradeId: 58,
                    },
                    {
                        price: '3999.00000000',
                        qty: '5.00000000',
                        commission: '19.99500000',
                        commissionAsset: 'USDT',
                        tradeId: 57,
                    },
                    {
                        price: '4000.00000000',
                        qty: '1.00000000',
                        commission: '4.00000000',
                        commissionAsset: 'USDT',
                        tradeId: 56,
                    },
                    {
                        price: '3995.00000000',
                        qty: '1.00000000',
                        commission: '3.99500000',
                        commissionAsset: 'USDT',
                        tradeId: 60,
                    },
                    {
                        price: '3997.00000000',
                        qty: '1.00000000',
                        commission: '3.99700000',
                        commissionAsset: 'USDT',
                        tradeId: 59,
                    },
                    {
                        price: '3998.00000000',
                        qty: '2.00000000',
                        commission: '7.99600000',
                        commissionAsset: 'USDT',
                        tradeId: 58,
                    },
                    {
                        price: '3999.00000000',
                        qty: '5.00000000',
                        commission: '19.99500000',
                        commissionAsset: 'USDT',
                        tradeId: 57,
                    },
                    {
                        price: '4000.00000000',
                        qty: '1.00000000',
                        commission: '4.00000000',
                        commissionAsset: 'USDT',
                        tradeId: 56,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'newOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewOrderResponse>)
            );
            const response = await client.newOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: NewOrderRequest = {
                symbol: 'BNBUSDT',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.MARKET,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.newOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling newOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: NewOrderRequest = {
                symbol: 'BNBUSDT',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.MARKET,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.newOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling newOrder.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: NewOrderRequest = {
                symbol: 'BNBUSDT',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.MARKET,
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.newOrder(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling newOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: NewOrderRequest = {
                symbol: 'BNBUSDT',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.MARKET,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'newOrder').mockRejectedValueOnce(mockError);
            await expect(client.newOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderAmendKeepPriority()', () => {
        it('should execute orderAmendKeepPriority() successfully with required parameters only', async () => {
            const params: OrderAmendKeepPriorityRequest = {
                symbol: 'BNBUSDT',
                newQty: 1.0,
            };

            mockResponse = {
                transactTime: 1741669661670,
                executionId: 22,
                amendedOrder: {
                    symbol: 'BTCUSDT',
                    orderId: 9,
                    orderListId: 1,
                    origClientOrderId: 'W0fJ9fiLKHOJutovPK3oJp',
                    clientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi',
                    price: '0.00000000',
                    qty: '4.00000000',
                    executedQty: '0.00000000',
                    preventedQty: '0.00000000',
                    quoteOrderQty: '0.00000000',
                    cumulativeQuoteQty: '0.00000000',
                    status: 'PENDING_NEW',
                    timeInForce: 'GTC',
                    type: 'MARKET',
                    side: 'BUY',
                    workingTime: 1741926410242,
                    selfTradePreventionMode: 'NONE',
                },
                listStatus: {
                    orderListId: 1,
                    contingencyType: 'OTO',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'AT7FTxZXylVSwRoZs52mt3',
                    symbol: 'BTCUSDT',
                    orders: [
                        { symbol: 'BTCUSDT', orderId: 9, clientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi' },
                        { symbol: 'BTCUSDT', orderId: 8, clientOrderId: 'GkwwHZUUbFtZOoH1YsZk9Q' },
                        { symbol: 'BTCUSDT', orderId: 9, clientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi' },
                        { symbol: 'BTCUSDT', orderId: 8, clientOrderId: 'GkwwHZUUbFtZOoH1YsZk9Q' },
                    ],
                },
            };

            const spy = jest.spyOn(client, 'orderAmendKeepPriority').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderAmendKeepPriorityResponse>)
            );
            const response = await client.orderAmendKeepPriority(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderAmendKeepPriority() successfully with optional parameters', async () => {
            const params: OrderAmendKeepPriorityRequest = {
                symbol: 'BNBUSDT',
                newQty: 1.0,
                orderId: 1,
                origClientOrderId: 'origClientOrderId_example',
                newClientOrderId: 'newClientOrderId_example',
                recvWindow: 5000,
            };

            mockResponse = {
                transactTime: 1741669661670,
                executionId: 22,
                amendedOrder: {
                    symbol: 'BTCUSDT',
                    orderId: 9,
                    orderListId: 1,
                    origClientOrderId: 'W0fJ9fiLKHOJutovPK3oJp',
                    clientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi',
                    price: '0.00000000',
                    qty: '4.00000000',
                    executedQty: '0.00000000',
                    preventedQty: '0.00000000',
                    quoteOrderQty: '0.00000000',
                    cumulativeQuoteQty: '0.00000000',
                    status: 'PENDING_NEW',
                    timeInForce: 'GTC',
                    type: 'MARKET',
                    side: 'BUY',
                    workingTime: 1741926410242,
                    selfTradePreventionMode: 'NONE',
                },
                listStatus: {
                    orderListId: 1,
                    contingencyType: 'OTO',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'AT7FTxZXylVSwRoZs52mt3',
                    symbol: 'BTCUSDT',
                    orders: [
                        { symbol: 'BTCUSDT', orderId: 9, clientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi' },
                        { symbol: 'BTCUSDT', orderId: 8, clientOrderId: 'GkwwHZUUbFtZOoH1YsZk9Q' },
                        { symbol: 'BTCUSDT', orderId: 9, clientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi' },
                        { symbol: 'BTCUSDT', orderId: 8, clientOrderId: 'GkwwHZUUbFtZOoH1YsZk9Q' },
                    ],
                },
            };

            const spy = jest.spyOn(client, 'orderAmendKeepPriority').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderAmendKeepPriorityResponse>)
            );
            const response = await client.orderAmendKeepPriority(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderAmendKeepPriorityRequest = {
                symbol: 'BNBUSDT',
                newQty: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderAmendKeepPriority(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderAmendKeepPriority.'
            );
        });

        it('should throw RequiredError when newQty is missing', async () => {
            const _params: OrderAmendKeepPriorityRequest = {
                symbol: 'BNBUSDT',
                newQty: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.newQty;

            await expect(client.orderAmendKeepPriority(params)).rejects.toThrow(
                'Required parameter newQty was null or undefined when calling orderAmendKeepPriority.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderAmendKeepPriorityRequest = {
                symbol: 'BNBUSDT',
                newQty: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'orderAmendKeepPriority')
                .mockRejectedValueOnce(mockError);
            await expect(client.orderAmendKeepPriority(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderCancelReplace()', () => {
        it('should execute orderCancelReplace() successfully with required parameters only', async () => {
            const params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
                side: OrderCancelReplaceSideEnum.BUY,
                type: OrderCancelReplaceTypeEnum.MARKET,
                cancelReplaceMode: OrderCancelReplaceCancelReplaceModeEnum.STOP_ON_FAILURE,
            };

            mockResponse = {
                cancelResult: 'SUCCESS',
                newOrderResult: 'SUCCESS',
                cancelResponse: {
                    symbol: 'BTCUSDT',
                    origClientOrderId: 'DnLo3vTAQcjha43lAZhZ0y',
                    orderId: 9,
                    orderListId: -1,
                    clientOrderId: 'osxN3JXAtJvKvCqGeMWMVR',
                    transactTime: 1684804350068,
                    price: '0.01000000',
                    origQty: '0.000100',
                    executedQty: '0.00000000',
                    origQuoteOrderQty: '0.000000',
                    cummulativeQuoteQty: '0.00000000',
                    status: 'CANCELED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'SELL',
                    selfTradePreventionMode: 'NONE',
                },
                newOrderResponse: {
                    symbol: 'BTCUSDT',
                    orderId: 10,
                    orderListId: -1,
                    clientOrderId: 'wOceeeOzNORyLiQfw7jd8S',
                    transactTime: 1652928801803,
                    price: '0.02000000',
                    origQty: '0.040000',
                    executedQty: '0.00000000',
                    origQuoteOrderQty: '0.000000',
                    cummulativeQuoteQty: '0.00000000',
                    status: 'NEW',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    workingTime: 1669277163808,
                    fills: [],
                    selfTradePreventionMode: 'NONE',
                },
                code: -2021,
                msg: 'Order cancel-replace partially failed.',
                data: {
                    cancelResult: 'SUCCESS',
                    newOrderResult: 'FAILURE',
                    cancelResponse: {
                        code: -2011,
                        msg: 'Unknown order sent.',
                        symbol: 'LTCBNB',
                        origClientOrderId: 'GKt5zzfOxRDSQLveDYCTkc',
                        orderId: 64,
                        orderListId: -1,
                        clientOrderId: 'loehOJF3FjoreUBDmv739R',
                        transactTime: 1715779007228,
                        price: '1.00',
                        origQty: '10.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'SELL',
                        selfTradePreventionMode: 'NONE',
                    },
                    newOrderResponse: {
                        code: -1015,
                        msg: 'Too many new orders; current limit is 1 orders per 10 SECOND.',
                        symbol: 'BTCUSDT',
                        orderId: 11,
                        orderListId: -1,
                        clientOrderId: 'pfojJMg6IMNDKuJqDxvoxN',
                        transactTime: 1648540168818,
                    },
                },
            };

            const spy = jest.spyOn(client, 'orderCancelReplace').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderCancelReplaceResponse>)
            );
            const response = await client.orderCancelReplace(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderCancelReplace() successfully with optional parameters', async () => {
            const params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
                side: OrderCancelReplaceSideEnum.BUY,
                type: OrderCancelReplaceTypeEnum.MARKET,
                cancelReplaceMode: OrderCancelReplaceCancelReplaceModeEnum.STOP_ON_FAILURE,
                timeInForce: OrderCancelReplaceTimeInForceEnum.GTC,
                quantity: 1.0,
                quoteOrderQty: 1.0,
                price: 400.0,
                cancelNewClientOrderId: 'cancelNewClientOrderId_example',
                cancelOrigClientOrderId: 'cancelOrigClientOrderId_example',
                cancelOrderId: 1,
                newClientOrderId: 'newClientOrderId_example',
                strategyId: 1,
                strategyType: 1,
                stopPrice: 1.0,
                trailingDelta: 1,
                icebergQty: 1.0,
                newOrderRespType: OrderCancelReplaceNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: OrderCancelReplaceSelfTradePreventionModeEnum.NONE,
                cancelRestrictions: OrderCancelReplaceCancelRestrictionsEnum.ONLY_NEW,
                orderRateLimitExceededMode:
                    OrderCancelReplaceOrderRateLimitExceededModeEnum.DO_NOTHING,
                recvWindow: 5000,
            };

            mockResponse = {
                cancelResult: 'SUCCESS',
                newOrderResult: 'SUCCESS',
                cancelResponse: {
                    symbol: 'BTCUSDT',
                    origClientOrderId: 'DnLo3vTAQcjha43lAZhZ0y',
                    orderId: 9,
                    orderListId: -1,
                    clientOrderId: 'osxN3JXAtJvKvCqGeMWMVR',
                    transactTime: 1684804350068,
                    price: '0.01000000',
                    origQty: '0.000100',
                    executedQty: '0.00000000',
                    origQuoteOrderQty: '0.000000',
                    cummulativeQuoteQty: '0.00000000',
                    status: 'CANCELED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'SELL',
                    selfTradePreventionMode: 'NONE',
                },
                newOrderResponse: {
                    symbol: 'BTCUSDT',
                    orderId: 10,
                    orderListId: -1,
                    clientOrderId: 'wOceeeOzNORyLiQfw7jd8S',
                    transactTime: 1652928801803,
                    price: '0.02000000',
                    origQty: '0.040000',
                    executedQty: '0.00000000',
                    origQuoteOrderQty: '0.000000',
                    cummulativeQuoteQty: '0.00000000',
                    status: 'NEW',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    workingTime: 1669277163808,
                    fills: [],
                    selfTradePreventionMode: 'NONE',
                },
                code: -2021,
                msg: 'Order cancel-replace partially failed.',
                data: {
                    cancelResult: 'SUCCESS',
                    newOrderResult: 'FAILURE',
                    cancelResponse: {
                        code: -2011,
                        msg: 'Unknown order sent.',
                        symbol: 'LTCBNB',
                        origClientOrderId: 'GKt5zzfOxRDSQLveDYCTkc',
                        orderId: 64,
                        orderListId: -1,
                        clientOrderId: 'loehOJF3FjoreUBDmv739R',
                        transactTime: 1715779007228,
                        price: '1.00',
                        origQty: '10.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'SELL',
                        selfTradePreventionMode: 'NONE',
                    },
                    newOrderResponse: {
                        code: -1015,
                        msg: 'Too many new orders; current limit is 1 orders per 10 SECOND.',
                        symbol: 'BTCUSDT',
                        orderId: 11,
                        orderListId: -1,
                        clientOrderId: 'pfojJMg6IMNDKuJqDxvoxN',
                        transactTime: 1648540168818,
                    },
                },
            };

            const spy = jest.spyOn(client, 'orderCancelReplace').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderCancelReplaceResponse>)
            );
            const response = await client.orderCancelReplace(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
                side: OrderCancelReplaceSideEnum.BUY,
                type: OrderCancelReplaceTypeEnum.MARKET,
                cancelReplaceMode: OrderCancelReplaceCancelReplaceModeEnum.STOP_ON_FAILURE,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderCancelReplace(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderCancelReplace.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
                side: OrderCancelReplaceSideEnum.BUY,
                type: OrderCancelReplaceTypeEnum.MARKET,
                cancelReplaceMode: OrderCancelReplaceCancelReplaceModeEnum.STOP_ON_FAILURE,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.orderCancelReplace(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling orderCancelReplace.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
                side: OrderCancelReplaceSideEnum.BUY,
                type: OrderCancelReplaceTypeEnum.MARKET,
                cancelReplaceMode: OrderCancelReplaceCancelReplaceModeEnum.STOP_ON_FAILURE,
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.orderCancelReplace(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling orderCancelReplace.'
            );
        });

        it('should throw RequiredError when cancelReplaceMode is missing', async () => {
            const _params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
                side: OrderCancelReplaceSideEnum.BUY,
                type: OrderCancelReplaceTypeEnum.MARKET,
                cancelReplaceMode: OrderCancelReplaceCancelReplaceModeEnum.STOP_ON_FAILURE,
            };
            const params = Object.assign({ ..._params });
            delete params?.cancelReplaceMode;

            await expect(client.orderCancelReplace(params)).rejects.toThrow(
                'Required parameter cancelReplaceMode was null or undefined when calling orderCancelReplace.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
                side: OrderCancelReplaceSideEnum.BUY,
                type: OrderCancelReplaceTypeEnum.MARKET,
                cancelReplaceMode: OrderCancelReplaceCancelReplaceModeEnum.STOP_ON_FAILURE,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderCancelReplace').mockRejectedValueOnce(mockError);
            await expect(client.orderCancelReplace(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderListOco()', () => {
        it('should execute orderListOco() successfully with required parameters only', async () => {
            const params: OrderListOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderListOcoSideEnum.BUY,
                quantity: 1.0,
                aboveType: OrderListOcoAboveTypeEnum.STOP_LOSS_LIMIT,
                belowType: OrderListOcoBelowTypeEnum.STOP_LOSS,
            };

            mockResponse = {
                orderListId: 1,
                contingencyType: 'OCO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'lH1YDkuQKWiXVXHPSKYEIp',
                transactionTime: 1710485608839,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 11, clientOrderId: 'NuMp0nVYnciDiFmVqfpBqK' },
                    { symbol: 'LTCBTC', orderId: 10, clientOrderId: '44nZvqpemY7sVYgPYbvPih' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        orderId: 11,
                        orderListId: 1,
                        clientOrderId: 'NuMp0nVYnciDiFmVqfpBqK',
                        transactTime: 1710485608839,
                        price: '3.00000000',
                        origQty: '5.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'SELL',
                        workingTime: 1710485608839,
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 10,
                        orderListId: 1,
                        clientOrderId: '44nZvqpemY7sVYgPYbvPih',
                        transactTime: 1710485608839,
                        price: '1.00000000',
                        origQty: '5.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'STOP_LOSS_LIMIT',
                        side: 'SELL',
                        stopPrice: '1.00000000',
                        workingTime: -1,
                        icebergQty: '1.00000000',
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'orderListOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderListOcoResponse>)
            );
            const response = await client.orderListOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderListOco() successfully with optional parameters', async () => {
            const params: OrderListOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderListOcoSideEnum.BUY,
                quantity: 1.0,
                aboveType: OrderListOcoAboveTypeEnum.STOP_LOSS_LIMIT,
                belowType: OrderListOcoBelowTypeEnum.STOP_LOSS,
                listClientOrderId: 'listClientOrderId_example',
                aboveClientOrderId: 'aboveClientOrderId_example',
                aboveIcebergQty: 1,
                abovePrice: 1.0,
                aboveStopPrice: 1.0,
                aboveTrailingDelta: 1,
                aboveTimeInForce: 1.0,
                aboveStrategyId: 1,
                aboveStrategyType: 1,
                belowClientOrderId: 'belowClientOrderId_example',
                belowIcebergQty: 1,
                belowPrice: 1.0,
                belowStopPrice: 1.0,
                belowTrailingDelta: 1,
                belowTimeInForce: OrderListOcoBelowTimeInForceEnum.belowType,
                belowStrategyId: 1,
                belowStrategyType: 1,
                newOrderRespType: OrderListOcoNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: OrderListOcoSelfTradePreventionModeEnum.NONE,
                recvWindow: 5000,
            };

            mockResponse = {
                orderListId: 1,
                contingencyType: 'OCO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'lH1YDkuQKWiXVXHPSKYEIp',
                transactionTime: 1710485608839,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 11, clientOrderId: 'NuMp0nVYnciDiFmVqfpBqK' },
                    { symbol: 'LTCBTC', orderId: 10, clientOrderId: '44nZvqpemY7sVYgPYbvPih' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        orderId: 11,
                        orderListId: 1,
                        clientOrderId: 'NuMp0nVYnciDiFmVqfpBqK',
                        transactTime: 1710485608839,
                        price: '3.00000000',
                        origQty: '5.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'SELL',
                        workingTime: 1710485608839,
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 10,
                        orderListId: 1,
                        clientOrderId: '44nZvqpemY7sVYgPYbvPih',
                        transactTime: 1710485608839,
                        price: '1.00000000',
                        origQty: '5.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'STOP_LOSS_LIMIT',
                        side: 'SELL',
                        stopPrice: '1.00000000',
                        workingTime: -1,
                        icebergQty: '1.00000000',
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'orderListOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderListOcoResponse>)
            );
            const response = await client.orderListOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderListOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderListOcoSideEnum.BUY,
                quantity: 1.0,
                aboveType: OrderListOcoAboveTypeEnum.STOP_LOSS_LIMIT,
                belowType: OrderListOcoBelowTypeEnum.STOP_LOSS,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderListOco(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderListOco.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: OrderListOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderListOcoSideEnum.BUY,
                quantity: 1.0,
                aboveType: OrderListOcoAboveTypeEnum.STOP_LOSS_LIMIT,
                belowType: OrderListOcoBelowTypeEnum.STOP_LOSS,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.orderListOco(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling orderListOco.'
            );
        });

        it('should throw RequiredError when quantity is missing', async () => {
            const _params: OrderListOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderListOcoSideEnum.BUY,
                quantity: 1.0,
                aboveType: OrderListOcoAboveTypeEnum.STOP_LOSS_LIMIT,
                belowType: OrderListOcoBelowTypeEnum.STOP_LOSS,
            };
            const params = Object.assign({ ..._params });
            delete params?.quantity;

            await expect(client.orderListOco(params)).rejects.toThrow(
                'Required parameter quantity was null or undefined when calling orderListOco.'
            );
        });

        it('should throw RequiredError when aboveType is missing', async () => {
            const _params: OrderListOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderListOcoSideEnum.BUY,
                quantity: 1.0,
                aboveType: OrderListOcoAboveTypeEnum.STOP_LOSS_LIMIT,
                belowType: OrderListOcoBelowTypeEnum.STOP_LOSS,
            };
            const params = Object.assign({ ..._params });
            delete params?.aboveType;

            await expect(client.orderListOco(params)).rejects.toThrow(
                'Required parameter aboveType was null or undefined when calling orderListOco.'
            );
        });

        it('should throw RequiredError when belowType is missing', async () => {
            const _params: OrderListOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderListOcoSideEnum.BUY,
                quantity: 1.0,
                aboveType: OrderListOcoAboveTypeEnum.STOP_LOSS_LIMIT,
                belowType: OrderListOcoBelowTypeEnum.STOP_LOSS,
            };
            const params = Object.assign({ ..._params });
            delete params?.belowType;

            await expect(client.orderListOco(params)).rejects.toThrow(
                'Required parameter belowType was null or undefined when calling orderListOco.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderListOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderListOcoSideEnum.BUY,
                quantity: 1.0,
                aboveType: OrderListOcoAboveTypeEnum.STOP_LOSS_LIMIT,
                belowType: OrderListOcoBelowTypeEnum.STOP_LOSS,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderListOco').mockRejectedValueOnce(mockError);
            await expect(client.orderListOco(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderListOto()', () => {
        it('should execute orderListOto() successfully with required parameters only', async () => {
            const params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };

            mockResponse = {
                orderListId: 0,
                contingencyType: 'OTO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'yl2ERtcar1o25zcWtqVBTC',
                transactionTime: 1712289389158,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'arLFo0zGJVDE69cvGBaU0d' },
                    { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'Bq17mn9fP6vyCn75Jw1xya' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        orderId: 5,
                        orderListId: 0,
                        clientOrderId: 'arLFo0zGJVDE69cvGBaU0d',
                        transactTime: 1712289389158,
                        price: '0.00000000',
                        origQty: '5.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'PENDING_NEW',
                        timeInForce: 'GTC',
                        type: 'MARKET',
                        side: 'BUY',
                        workingTime: -1,
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 4,
                        orderListId: 0,
                        clientOrderId: 'Bq17mn9fP6vyCn75Jw1xya',
                        transactTime: 1712289389158,
                        price: '1.00000000',
                        origQty: '1.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'SELL',
                        workingTime: 1712289389158,
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'orderListOto').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderListOtoResponse>)
            );
            const response = await client.orderListOto(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderListOto() successfully with optional parameters', async () => {
            const params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                listClientOrderId: 'listClientOrderId_example',
                newOrderRespType: OrderListOtoNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: OrderListOtoSelfTradePreventionModeEnum.NONE,
                workingClientOrderId: 'workingClientOrderId_example',
                workingIcebergQty: 1.0,
                workingTimeInForce: OrderListOtoWorkingTimeInForceEnum.GTC,
                workingStrategyId: 1,
                workingStrategyType: 1,
                pendingClientOrderId: 'pendingClientOrderId_example',
                pendingPrice: 1.0,
                pendingStopPrice: 1.0,
                pendingTrailingDelta: 1.0,
                pendingIcebergQty: 1.0,
                pendingTimeInForce: OrderListOtoPendingTimeInForceEnum.GTC,
                pendingStrategyId: 1,
                pendingStrategyType: 1,
                recvWindow: 5000,
            };

            mockResponse = {
                orderListId: 0,
                contingencyType: 'OTO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'yl2ERtcar1o25zcWtqVBTC',
                transactionTime: 1712289389158,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'arLFo0zGJVDE69cvGBaU0d' },
                    { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'Bq17mn9fP6vyCn75Jw1xya' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        orderId: 5,
                        orderListId: 0,
                        clientOrderId: 'arLFo0zGJVDE69cvGBaU0d',
                        transactTime: 1712289389158,
                        price: '0.00000000',
                        origQty: '5.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'PENDING_NEW',
                        timeInForce: 'GTC',
                        type: 'MARKET',
                        side: 'BUY',
                        workingTime: -1,
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 4,
                        orderListId: 0,
                        clientOrderId: 'Bq17mn9fP6vyCn75Jw1xya',
                        transactTime: 1712289389158,
                        price: '1.00000000',
                        origQty: '1.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'SELL',
                        workingTime: 1712289389158,
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'orderListOto').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderListOtoResponse>)
            );
            const response = await client.orderListOto(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderListOto(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderListOto.'
            );
        });

        it('should throw RequiredError when workingType is missing', async () => {
            const _params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingType;

            await expect(client.orderListOto(params)).rejects.toThrow(
                'Required parameter workingType was null or undefined when calling orderListOto.'
            );
        });

        it('should throw RequiredError when workingSide is missing', async () => {
            const _params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingSide;

            await expect(client.orderListOto(params)).rejects.toThrow(
                'Required parameter workingSide was null or undefined when calling orderListOto.'
            );
        });

        it('should throw RequiredError when workingPrice is missing', async () => {
            const _params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingPrice;

            await expect(client.orderListOto(params)).rejects.toThrow(
                'Required parameter workingPrice was null or undefined when calling orderListOto.'
            );
        });

        it('should throw RequiredError when workingQuantity is missing', async () => {
            const _params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingQuantity;

            await expect(client.orderListOto(params)).rejects.toThrow(
                'Required parameter workingQuantity was null or undefined when calling orderListOto.'
            );
        });

        it('should throw RequiredError when pendingType is missing', async () => {
            const _params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingType;

            await expect(client.orderListOto(params)).rejects.toThrow(
                'Required parameter pendingType was null or undefined when calling orderListOto.'
            );
        });

        it('should throw RequiredError when pendingSide is missing', async () => {
            const _params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingSide;

            await expect(client.orderListOto(params)).rejects.toThrow(
                'Required parameter pendingSide was null or undefined when calling orderListOto.'
            );
        });

        it('should throw RequiredError when pendingQuantity is missing', async () => {
            const _params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingQuantity;

            await expect(client.orderListOto(params)).rejects.toThrow(
                'Required parameter pendingQuantity was null or undefined when calling orderListOto.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderListOto').mockRejectedValueOnce(mockError);
            await expect(client.orderListOto(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderListOtoco()', () => {
        it('should execute orderListOtoco() successfully with required parameters only', async () => {
            const params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };

            mockResponse = {
                orderListId: 1,
                contingencyType: 'OTO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'RumwQpBaDctlUu5jyG5rs0',
                transactionTime: 1712291372842,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 8, clientOrderId: 'r4JMv9cwAYYUwwBZfbussx' },
                    { symbol: 'LTCBTC', orderId: 7, clientOrderId: '6pcQbFIzTXGZQ1e2MkGDq4' },
                    { symbol: 'LTCBTC', orderId: 6, clientOrderId: 'fM9Y4m23IFJVCQmIrlUmMK' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        orderId: 8,
                        orderListId: 1,
                        clientOrderId: 'r4JMv9cwAYYUwwBZfbussx',
                        transactTime: 1712291372842,
                        price: '3.00000000',
                        origQty: '5.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'PENDING_NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'BUY',
                        workingTime: -1,
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 7,
                        orderListId: 1,
                        clientOrderId: '6pcQbFIzTXGZQ1e2MkGDq4',
                        transactTime: 1712291372842,
                        price: '1.00000000',
                        origQty: '5.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'PENDING_NEW',
                        timeInForce: 'IOC',
                        type: 'STOP_LOSS_LIMIT',
                        side: 'BUY',
                        stopPrice: '6.00000000',
                        workingTime: -1,
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 6,
                        orderListId: 1,
                        clientOrderId: 'fM9Y4m23IFJVCQmIrlUmMK',
                        transactTime: 1712291372842,
                        price: '1.00000000',
                        origQty: '1.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'SELL',
                        workingTime: 1712291372842,
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'orderListOtoco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderListOtocoResponse>)
            );
            const response = await client.orderListOtoco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderListOtoco() successfully with optional parameters', async () => {
            const params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
                listClientOrderId: 'listClientOrderId_example',
                newOrderRespType: OrderListOtocoNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: OrderListOtocoSelfTradePreventionModeEnum.NONE,
                workingClientOrderId: 'workingClientOrderId_example',
                workingIcebergQty: 1.0,
                workingTimeInForce: OrderListOtocoWorkingTimeInForceEnum.GTC,
                workingStrategyId: 1,
                workingStrategyType: 1,
                pendingAboveClientOrderId: 'pendingAboveClientOrderId_example',
                pendingAbovePrice: 1.0,
                pendingAboveStopPrice: 1.0,
                pendingAboveTrailingDelta: 1.0,
                pendingAboveIcebergQty: 1.0,
                pendingAboveTimeInForce: OrderListOtocoPendingAboveTimeInForceEnum.GTC,
                pendingAboveStrategyId: 1,
                pendingAboveStrategyType: 1,
                pendingBelowType: OrderListOtocoPendingBelowTypeEnum.STOP_LOSS,
                pendingBelowClientOrderId: 'pendingBelowClientOrderId_example',
                pendingBelowPrice: 1.0,
                pendingBelowStopPrice: 1.0,
                pendingBelowTrailingDelta: 1.0,
                pendingBelowIcebergQty: 1.0,
                pendingBelowTimeInForce: OrderListOtocoPendingBelowTimeInForceEnum.GTC,
                pendingBelowStrategyId: 1,
                pendingBelowStrategyType: 1,
                recvWindow: 5000,
            };

            mockResponse = {
                orderListId: 1,
                contingencyType: 'OTO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'RumwQpBaDctlUu5jyG5rs0',
                transactionTime: 1712291372842,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 8, clientOrderId: 'r4JMv9cwAYYUwwBZfbussx' },
                    { symbol: 'LTCBTC', orderId: 7, clientOrderId: '6pcQbFIzTXGZQ1e2MkGDq4' },
                    { symbol: 'LTCBTC', orderId: 6, clientOrderId: 'fM9Y4m23IFJVCQmIrlUmMK' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        orderId: 8,
                        orderListId: 1,
                        clientOrderId: 'r4JMv9cwAYYUwwBZfbussx',
                        transactTime: 1712291372842,
                        price: '3.00000000',
                        origQty: '5.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'PENDING_NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'BUY',
                        workingTime: -1,
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 7,
                        orderListId: 1,
                        clientOrderId: '6pcQbFIzTXGZQ1e2MkGDq4',
                        transactTime: 1712291372842,
                        price: '1.00000000',
                        origQty: '5.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'PENDING_NEW',
                        timeInForce: 'IOC',
                        type: 'STOP_LOSS_LIMIT',
                        side: 'BUY',
                        stopPrice: '6.00000000',
                        workingTime: -1,
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 6,
                        orderListId: 1,
                        clientOrderId: 'fM9Y4m23IFJVCQmIrlUmMK',
                        transactTime: 1712291372842,
                        price: '1.00000000',
                        origQty: '1.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'SELL',
                        workingTime: 1712291372842,
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'orderListOtoco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderListOtocoResponse>)
            );
            const response = await client.orderListOtoco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderListOtoco(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderListOtoco.'
            );
        });

        it('should throw RequiredError when workingType is missing', async () => {
            const _params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingType;

            await expect(client.orderListOtoco(params)).rejects.toThrow(
                'Required parameter workingType was null or undefined when calling orderListOtoco.'
            );
        });

        it('should throw RequiredError when workingSide is missing', async () => {
            const _params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingSide;

            await expect(client.orderListOtoco(params)).rejects.toThrow(
                'Required parameter workingSide was null or undefined when calling orderListOtoco.'
            );
        });

        it('should throw RequiredError when workingPrice is missing', async () => {
            const _params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingPrice;

            await expect(client.orderListOtoco(params)).rejects.toThrow(
                'Required parameter workingPrice was null or undefined when calling orderListOtoco.'
            );
        });

        it('should throw RequiredError when workingQuantity is missing', async () => {
            const _params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingQuantity;

            await expect(client.orderListOtoco(params)).rejects.toThrow(
                'Required parameter workingQuantity was null or undefined when calling orderListOtoco.'
            );
        });

        it('should throw RequiredError when pendingSide is missing', async () => {
            const _params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingSide;

            await expect(client.orderListOtoco(params)).rejects.toThrow(
                'Required parameter pendingSide was null or undefined when calling orderListOtoco.'
            );
        });

        it('should throw RequiredError when pendingQuantity is missing', async () => {
            const _params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingQuantity;

            await expect(client.orderListOtoco(params)).rejects.toThrow(
                'Required parameter pendingQuantity was null or undefined when calling orderListOtoco.'
            );
        });

        it('should throw RequiredError when pendingAboveType is missing', async () => {
            const _params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingAboveType;

            await expect(client.orderListOtoco(params)).rejects.toThrow(
                'Required parameter pendingAboveType was null or undefined when calling orderListOtoco.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingQuantity: 1.0,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderListOtoco').mockRejectedValueOnce(mockError);
            await expect(client.orderListOtoco(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderOco()', () => {
        it('should execute orderOco() successfully with required parameters only', async () => {
            const params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderOcoSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
            };

            mockResponse = {
                orderListId: 0,
                contingencyType: 'OCO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'JYVpp3F0f5CAG15DhtrqLp',
                transactionTime: 1563417480525,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'xTXKaGYd4bluPVp78IVRvl' },
                    { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'Kk7sqHb9J6mJWTMDVW7Vos' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        orderId: 3,
                        orderListId: 0,
                        clientOrderId: 'xTXKaGYd4bluPVp78IVRvl',
                        transactTime: 1563417480525,
                        price: '0.036435',
                        origQty: '0.624363',
                        executedQty: '0.000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'BUY',
                        workingTime: 1563417480525,
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 2,
                        orderListId: 0,
                        clientOrderId: 'Kk7sqHb9J6mJWTMDVW7Vos',
                        transactTime: 1563417480525,
                        price: '0.000000',
                        origQty: '0.624363',
                        executedQty: '0.000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'STOP_LOSS',
                        side: 'BUY',
                        stopPrice: '0.960664',
                        workingTime: -1,
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'orderOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderOcoResponse>)
            );
            const response = await client.orderOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderOco() successfully with optional parameters', async () => {
            const params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderOcoSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
                listClientOrderId: 'listClientOrderId_example',
                limitClientOrderId: 'limitClientOrderId_example',
                limitStrategyId: 1,
                limitStrategyType: 1,
                limitIcebergQty: 1.0,
                trailingDelta: 1,
                stopClientOrderId: 'stopClientOrderId_example',
                stopStrategyId: 1,
                stopStrategyType: 1,
                stopLimitPrice: 1.0,
                stopIcebergQty: 1.0,
                stopLimitTimeInForce: OrderOcoStopLimitTimeInForceEnum.GTC,
                newOrderRespType: OrderOcoNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: OrderOcoSelfTradePreventionModeEnum.NONE,
                recvWindow: 5000,
            };

            mockResponse = {
                orderListId: 0,
                contingencyType: 'OCO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'JYVpp3F0f5CAG15DhtrqLp',
                transactionTime: 1563417480525,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'xTXKaGYd4bluPVp78IVRvl' },
                    { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'Kk7sqHb9J6mJWTMDVW7Vos' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        orderId: 3,
                        orderListId: 0,
                        clientOrderId: 'xTXKaGYd4bluPVp78IVRvl',
                        transactTime: 1563417480525,
                        price: '0.036435',
                        origQty: '0.624363',
                        executedQty: '0.000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'BUY',
                        workingTime: 1563417480525,
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 2,
                        orderListId: 0,
                        clientOrderId: 'Kk7sqHb9J6mJWTMDVW7Vos',
                        transactTime: 1563417480525,
                        price: '0.000000',
                        origQty: '0.624363',
                        executedQty: '0.000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'STOP_LOSS',
                        side: 'BUY',
                        stopPrice: '0.960664',
                        workingTime: -1,
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'orderOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderOcoResponse>)
            );
            const response = await client.orderOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderOcoSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderOco(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderOco.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderOcoSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.orderOco(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling orderOco.'
            );
        });

        it('should throw RequiredError when quantity is missing', async () => {
            const _params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderOcoSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.quantity;

            await expect(client.orderOco(params)).rejects.toThrow(
                'Required parameter quantity was null or undefined when calling orderOco.'
            );
        });

        it('should throw RequiredError when price is missing', async () => {
            const _params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderOcoSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.price;

            await expect(client.orderOco(params)).rejects.toThrow(
                'Required parameter price was null or undefined when calling orderOco.'
            );
        });

        it('should throw RequiredError when stopPrice is missing', async () => {
            const _params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderOcoSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.stopPrice;

            await expect(client.orderOco(params)).rejects.toThrow(
                'Required parameter stopPrice was null or undefined when calling orderOco.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                side: OrderOcoSideEnum.BUY,
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderOco').mockRejectedValueOnce(mockError);
            await expect(client.orderOco(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderTest()', () => {
        it('should execute orderTest() successfully with required parameters only', async () => {
            const params: OrderTestRequest = {
                symbol: 'BNBUSDT',
                side: OrderTestSideEnum.BUY,
                type: OrderTestTypeEnum.MARKET,
            };

            mockResponse = {
                standardCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                taxCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                discount: {
                    enabledForAccount: true,
                    enabledForSymbol: true,
                    discountAsset: 'BNB',
                    discount: '0.25000000',
                },
            };

            const spy = jest.spyOn(client, 'orderTest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderTestResponse>)
            );
            const response = await client.orderTest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderTest() successfully with optional parameters', async () => {
            const params: OrderTestRequest = {
                symbol: 'BNBUSDT',
                side: OrderTestSideEnum.BUY,
                type: OrderTestTypeEnum.MARKET,
                computeCommissionRates: false,
                timeInForce: OrderTestTimeInForceEnum.GTC,
                quantity: 1.0,
                quoteOrderQty: 1.0,
                price: 400.0,
                newClientOrderId: 'newClientOrderId_example',
                strategyId: 1,
                strategyType: 1,
                stopPrice: 1.0,
                trailingDelta: 1,
                icebergQty: 1.0,
                newOrderRespType: OrderTestNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: OrderTestSelfTradePreventionModeEnum.NONE,
                recvWindow: 5000,
            };

            mockResponse = {
                standardCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                taxCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                discount: {
                    enabledForAccount: true,
                    enabledForSymbol: true,
                    discountAsset: 'BNB',
                    discount: '0.25000000',
                },
            };

            const spy = jest.spyOn(client, 'orderTest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderTestResponse>)
            );
            const response = await client.orderTest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderTestRequest = {
                symbol: 'BNBUSDT',
                side: OrderTestSideEnum.BUY,
                type: OrderTestTypeEnum.MARKET,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderTest(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderTest.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: OrderTestRequest = {
                symbol: 'BNBUSDT',
                side: OrderTestSideEnum.BUY,
                type: OrderTestTypeEnum.MARKET,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.orderTest(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling orderTest.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: OrderTestRequest = {
                symbol: 'BNBUSDT',
                side: OrderTestSideEnum.BUY,
                type: OrderTestTypeEnum.MARKET,
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.orderTest(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling orderTest.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderTestRequest = {
                symbol: 'BNBUSDT',
                side: OrderTestSideEnum.BUY,
                type: OrderTestTypeEnum.MARKET,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderTest').mockRejectedValueOnce(mockError);
            await expect(client.orderTest(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('sorOrder()', () => {
        it('should execute sorOrder() successfully with required parameters only', async () => {
            const params: SorOrderRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderSideEnum.BUY,
                type: SorOrderTypeEnum.MARKET,
                quantity: 1.0,
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                orderId: 2,
                orderListId: -1,
                clientOrderId: 'sBI1KM6nNtOfj5tccZSKly',
                transactTime: 1689149087774,
                price: '31000.00000000',
                origQty: '0.50000000',
                executedQty: '0.50000000',
                origQuoteOrderQty: '0.000000',
                cummulativeQuoteQty: '14000.00000000',
                status: 'FILLED',
                timeInForce: 'GTC',
                type: 'LIMIT',
                side: 'BUY',
                workingTime: 1689149087774,
                fills: [
                    {
                        matchType: 'ONE_PARTY_TRADE_REPORT',
                        price: '28000.00000000',
                        qty: '0.50000000',
                        commission: '0.00000000',
                        commissionAsset: 'BTC',
                        tradeId: -1,
                        allocId: 0,
                    },
                ],
                workingFloor: 'SOR',
                selfTradePreventionMode: 'NONE',
                usedSor: true,
            };

            const spy = jest.spyOn(client, 'sorOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SorOrderResponse>)
            );
            const response = await client.sorOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute sorOrder() successfully with optional parameters', async () => {
            const params: SorOrderRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderSideEnum.BUY,
                type: SorOrderTypeEnum.MARKET,
                quantity: 1.0,
                timeInForce: SorOrderTimeInForceEnum.GTC,
                price: 400.0,
                newClientOrderId: 'newClientOrderId_example',
                strategyId: 1,
                strategyType: 1,
                icebergQty: 1.0,
                newOrderRespType: SorOrderNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: SorOrderSelfTradePreventionModeEnum.NONE,
                recvWindow: 5000,
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                orderId: 2,
                orderListId: -1,
                clientOrderId: 'sBI1KM6nNtOfj5tccZSKly',
                transactTime: 1689149087774,
                price: '31000.00000000',
                origQty: '0.50000000',
                executedQty: '0.50000000',
                origQuoteOrderQty: '0.000000',
                cummulativeQuoteQty: '14000.00000000',
                status: 'FILLED',
                timeInForce: 'GTC',
                type: 'LIMIT',
                side: 'BUY',
                workingTime: 1689149087774,
                fills: [
                    {
                        matchType: 'ONE_PARTY_TRADE_REPORT',
                        price: '28000.00000000',
                        qty: '0.50000000',
                        commission: '0.00000000',
                        commissionAsset: 'BTC',
                        tradeId: -1,
                        allocId: 0,
                    },
                ],
                workingFloor: 'SOR',
                selfTradePreventionMode: 'NONE',
                usedSor: true,
            };

            const spy = jest.spyOn(client, 'sorOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SorOrderResponse>)
            );
            const response = await client.sorOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: SorOrderRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderSideEnum.BUY,
                type: SorOrderTypeEnum.MARKET,
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.sorOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling sorOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: SorOrderRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderSideEnum.BUY,
                type: SorOrderTypeEnum.MARKET,
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.sorOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling sorOrder.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: SorOrderRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderSideEnum.BUY,
                type: SorOrderTypeEnum.MARKET,
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.sorOrder(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling sorOrder.'
            );
        });

        it('should throw RequiredError when quantity is missing', async () => {
            const _params: SorOrderRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderSideEnum.BUY,
                type: SorOrderTypeEnum.MARKET,
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.quantity;

            await expect(client.sorOrder(params)).rejects.toThrow(
                'Required parameter quantity was null or undefined when calling sorOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SorOrderRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderSideEnum.BUY,
                type: SorOrderTypeEnum.MARKET,
                quantity: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'sorOrder').mockRejectedValueOnce(mockError);
            await expect(client.sorOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('sorOrderTest()', () => {
        it('should execute sorOrderTest() successfully with required parameters only', async () => {
            const params: SorOrderTestRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderTestSideEnum.BUY,
                type: SorOrderTestTypeEnum.MARKET,
                quantity: 1.0,
            };

            mockResponse = {
                standardCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                taxCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                discount: {
                    enabledForAccount: true,
                    enabledForSymbol: true,
                    discountAsset: 'BNB',
                    discount: '0.25000000',
                },
            };

            const spy = jest.spyOn(client, 'sorOrderTest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SorOrderTestResponse>)
            );
            const response = await client.sorOrderTest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute sorOrderTest() successfully with optional parameters', async () => {
            const params: SorOrderTestRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderTestSideEnum.BUY,
                type: SorOrderTestTypeEnum.MARKET,
                quantity: 1.0,
                computeCommissionRates: false,
                timeInForce: SorOrderTestTimeInForceEnum.GTC,
                price: 400.0,
                newClientOrderId: 'newClientOrderId_example',
                strategyId: 1,
                strategyType: 1,
                icebergQty: 1.0,
                newOrderRespType: SorOrderTestNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: SorOrderTestSelfTradePreventionModeEnum.NONE,
                recvWindow: 5000,
            };

            mockResponse = {
                standardCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                taxCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                discount: {
                    enabledForAccount: true,
                    enabledForSymbol: true,
                    discountAsset: 'BNB',
                    discount: '0.25000000',
                },
            };

            const spy = jest.spyOn(client, 'sorOrderTest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SorOrderTestResponse>)
            );
            const response = await client.sorOrderTest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: SorOrderTestRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderTestSideEnum.BUY,
                type: SorOrderTestTypeEnum.MARKET,
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.sorOrderTest(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling sorOrderTest.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: SorOrderTestRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderTestSideEnum.BUY,
                type: SorOrderTestTypeEnum.MARKET,
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.sorOrderTest(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling sorOrderTest.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: SorOrderTestRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderTestSideEnum.BUY,
                type: SorOrderTestTypeEnum.MARKET,
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.sorOrderTest(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling sorOrderTest.'
            );
        });

        it('should throw RequiredError when quantity is missing', async () => {
            const _params: SorOrderTestRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderTestSideEnum.BUY,
                type: SorOrderTestTypeEnum.MARKET,
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.quantity;

            await expect(client.sorOrderTest(params)).rejects.toThrow(
                'Required parameter quantity was null or undefined when calling sorOrderTest.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SorOrderTestRequest = {
                symbol: 'BNBUSDT',
                side: SorOrderTestSideEnum.BUY,
                type: SorOrderTestTypeEnum.MARKET,
                quantity: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'sorOrderTest').mockRejectedValueOnce(mockError);
            await expect(client.sorOrderTest(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
