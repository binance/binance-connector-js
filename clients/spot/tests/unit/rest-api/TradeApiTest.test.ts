/**
 * Binance Spot REST API
 *
 * OpenAPI Specifications for the Binance Spot REST API
 *
 * API documents:
 * - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)
 * - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)
 *
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import {
    TradeApi,
    DeleteOrderCancelRestrictionsEnum,
    NewOrderSideEnum,
    NewOrderTypeEnum,
    NewOrderTimeInForceEnum,
    NewOrderNewOrderRespTypeEnum,
    NewOrderSelfTradePreventionModeEnum,
    OrderCancelReplaceSideEnum,
    OrderCancelReplaceTypeEnum,
    OrderCancelReplaceCancelReplaceModeEnum,
    OrderCancelReplaceTimeInForceEnum,
    OrderCancelReplaceNewOrderRespTypeEnum,
    OrderCancelReplaceSelfTradePreventionModeEnum,
    OrderCancelReplaceCancelRestrictionsEnum,
    OrderCancelReplaceOrderRateLimitExceededModeEnum,
    OrderListOcoSideEnum,
    OrderListOcoAboveTypeEnum,
    OrderListOcoBelowTypeEnum,
    OrderListOcoBelowTimeInForceEnum,
    OrderListOcoNewOrderRespTypeEnum,
    OrderListOcoSelfTradePreventionModeEnum,
    OrderListOtoNewOrderRespTypeEnum,
    OrderListOtoSelfTradePreventionModeEnum,
    OrderListOtoWorkingTypeEnum,
    OrderListOtoWorkingSideEnum,
    OrderListOtoWorkingTimeInForceEnum,
    OrderListOtoPendingTypeEnum,
    OrderListOtoPendingSideEnum,
    OrderListOtoPendingTimeInForceEnum,
    OrderListOtocoNewOrderRespTypeEnum,
    OrderListOtocoSelfTradePreventionModeEnum,
    OrderListOtocoWorkingTypeEnum,
    OrderListOtocoWorkingSideEnum,
    OrderListOtocoWorkingTimeInForceEnum,
    OrderListOtocoPendingSideEnum,
    OrderListOtocoPendingAboveTypeEnum,
    OrderListOtocoPendingAboveTimeInForceEnum,
    OrderListOtocoPendingBelowTypeEnum,
    OrderListOtocoPendingBelowTimeInForceEnum,
    OrderOcoSideEnum,
    OrderOcoStopLimitTimeInForceEnum,
    OrderOcoNewOrderRespTypeEnum,
    OrderOcoSelfTradePreventionModeEnum,
    SorOrderSideEnum,
    SorOrderTypeEnum,
    SorOrderTimeInForceEnum,
    SorOrderNewOrderRespTypeEnum,
    SorOrderSelfTradePreventionModeEnum,
} from '../../../src/rest-api';
import {
    AllOrderListRequest,
    AllOrdersRequest,
    DeleteOpenOrdersRequest,
    DeleteOrderRequest,
    DeleteOrderListRequest,
    GetOpenOrdersRequest,
    GetOrderRequest,
    GetOrderListRequest,
    NewOrderRequest,
    OpenOrderListRequest,
    OrderAmendKeepPriorityRequest,
    OrderCancelReplaceRequest,
    OrderListOcoRequest,
    OrderListOtoRequest,
    OrderListOtocoRequest,
    OrderOcoRequest,
    OrderTestRequest,
    SorOrderRequest,
    SorOrderTestRequest,
} from '../../../src/rest-api';
import type {
    AllOrderListResponse,
    AllOrdersResponse,
    DeleteOpenOrdersResponse,
    DeleteOrderListResponse,
    DeleteOrderResponse,
    GetOpenOrdersResponse,
    GetOrderListResponse,
    GetOrderResponse,
    NewOrderResponse,
    OpenOrderListResponse,
    OrderAmendKeepPriorityResponse,
    OrderCancelReplaceResponse,
    OrderListOcoResponse,
    OrderListOtoResponse,
    OrderListOtocoResponse,
    OrderOcoResponse,
    OrderTestResponse,
    SorOrderResponse,
    SorOrderTestResponse,
} from '../../../src/rest-api/types';

describe('TradeApi', () => {
    let client: TradeApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new TradeApi(config);
    });

    describe('allOrderList()', () => {
        it('should execute allOrderList() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    orderListId: 29,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'amEEAXryFzFwYF1FeRpUoZ',
                    transactionTime: 1565245913483,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'oD7aesZqjEGlZrbtRpy5zB' },
                        { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'Jr1h6xirOxgeJOUuYQS7V3' },
                    ],
                },
                {
                    orderListId: 28,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'hG7hFNxJV6cZy3Ze4AUT4d',
                    transactionTime: 1565245913407,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'j6lFOfbmFMRjTYA7rRJ0LP' },
                        { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'z0KCjOdditiLS5ekAFtK81' },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'allOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AllOrderListResponse>)
            );
            const response = await client.allOrderList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute allOrderList() successfully with optional parameters', async () => {
            const params: AllOrderListRequest = {
                fromId: 1,
                startTime: 1735693200000,
                endTime: 1735693200000,
                limit: 500,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    orderListId: 29,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'amEEAXryFzFwYF1FeRpUoZ',
                    transactionTime: 1565245913483,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'oD7aesZqjEGlZrbtRpy5zB' },
                        { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'Jr1h6xirOxgeJOUuYQS7V3' },
                    ],
                },
                {
                    orderListId: 28,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'hG7hFNxJV6cZy3Ze4AUT4d',
                    transactionTime: 1565245913407,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'j6lFOfbmFMRjTYA7rRJ0LP' },
                        { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'z0KCjOdditiLS5ekAFtK81' },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'allOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AllOrderListResponse>)
            );
            const response = await client.allOrderList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'allOrderList').mockRejectedValueOnce(mockError);
            await expect(client.allOrderList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('allOrders()', () => {
        it('should execute allOrders() successfully with required parameters only', async () => {
            const params: AllOrdersRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = [
                {
                    symbol: 'LTCBTC',
                    orderId: 1,
                    orderListId: -1,
                    clientOrderId: 'myOrder1',
                    price: '0.1',
                    origQty: '1.0',
                    executedQty: '0.0',
                    cummulativeQuoteQty: '0.0',
                    status: 'NEW',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    stopPrice: '0.0',
                    icebergQty: '0.0',
                    time: 1499827319559,
                    updateTime: 1499827319559,
                    isWorking: true,
                    origQuoteOrderQty: '0.000000',
                    workingTime: 1499827319559,
                    selfTradePreventionMode: 'NONE',
                },
            ];

            const spy = jest.spyOn(client, 'allOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AllOrdersResponse>)
            );
            const response = await client.allOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute allOrders() successfully with optional parameters', async () => {
            const params: AllOrdersRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
                startTime: 1735693200000,
                endTime: 1735693200000,
                limit: 500,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'LTCBTC',
                    orderId: 1,
                    orderListId: -1,
                    clientOrderId: 'myOrder1',
                    price: '0.1',
                    origQty: '1.0',
                    executedQty: '0.0',
                    cummulativeQuoteQty: '0.0',
                    status: 'NEW',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    stopPrice: '0.0',
                    icebergQty: '0.0',
                    time: 1499827319559,
                    updateTime: 1499827319559,
                    isWorking: true,
                    origQuoteOrderQty: '0.000000',
                    workingTime: 1499827319559,
                    selfTradePreventionMode: 'NONE',
                },
            ];

            const spy = jest.spyOn(client, 'allOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AllOrdersResponse>)
            );
            const response = await client.allOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: AllOrdersRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.allOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling allOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AllOrdersRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'allOrders').mockRejectedValueOnce(mockError);
            await expect(client.allOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('deleteOpenOrders()', () => {
        it('should execute deleteOpenOrders() successfully with required parameters only', async () => {
            const params: DeleteOpenOrdersRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    origClientOrderId: 'E6APeyTJvkMvLMYMqu1KQ4',
                    orderId: 11,
                    orderListId: -1,
                    clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                    transactTime: 1684804350068,
                    price: '0.089853',
                    origQty: '0.178622',
                    executedQty: '0.000000',
                    cummulativeQuoteQty: '0.000000',
                    status: 'CANCELED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    selfTradePreventionMode: 'NONE',
                },
                {
                    symbol: 'BTCUSDT',
                    origClientOrderId: 'A3EF2HCwxgZPFMrfwbgrhv',
                    orderId: 13,
                    orderListId: -1,
                    clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                    transactTime: 1684804350069,
                    price: '0.090430',
                    origQty: '0.178622',
                    executedQty: '0.000000',
                    cummulativeQuoteQty: '0.000000',
                    status: 'CANCELED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    selfTradePreventionMode: 'NONE',
                },
                {
                    orderListId: 1929,
                    contingencyType: 'OCO',
                    listStatusType: 'ALL_DONE',
                    listOrderStatus: 'ALL_DONE',
                    listClientOrderId: '2inzWQdDvZLHbbAmAozX2N',
                    transactionTime: 1585230948299,
                    symbol: 'BTCUSDT',
                    orders: [
                        { symbol: 'BTCUSDT', orderId: 20, clientOrderId: 'CwOOIPHSmYywx6jZX77TdL' },
                        { symbol: 'BTCUSDT', orderId: 21, clientOrderId: '461cPg51vQjV3zIMOXNz39' },
                    ],
                    orderReports: [
                        {
                            symbol: 'BTCUSDT',
                            origClientOrderId: 'CwOOIPHSmYywx6jZX77TdL',
                            orderId: 20,
                            orderListId: 1929,
                            clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                            transactTime: 1688005070874,
                            price: '0.668611',
                            origQty: '0.690354',
                            executedQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'STOP_LOSS_LIMIT',
                            side: 'BUY',
                            stopPrice: '0.378131',
                            icebergQty: '0.017083',
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'BTCUSDT',
                            origClientOrderId: '461cPg51vQjV3zIMOXNz39',
                            orderId: 21,
                            orderListId: 1929,
                            clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                            transactTime: 1688005070874,
                            price: '0.008791',
                            origQty: '0.690354',
                            executedQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'BUY',
                            icebergQty: '0.639962',
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'deleteOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DeleteOpenOrdersResponse>)
            );
            const response = await client.deleteOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute deleteOpenOrders() successfully with optional parameters', async () => {
            const params: DeleteOpenOrdersRequest = {
                symbol: 'BNBUSDT',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    origClientOrderId: 'E6APeyTJvkMvLMYMqu1KQ4',
                    orderId: 11,
                    orderListId: -1,
                    clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                    transactTime: 1684804350068,
                    price: '0.089853',
                    origQty: '0.178622',
                    executedQty: '0.000000',
                    cummulativeQuoteQty: '0.000000',
                    status: 'CANCELED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    selfTradePreventionMode: 'NONE',
                },
                {
                    symbol: 'BTCUSDT',
                    origClientOrderId: 'A3EF2HCwxgZPFMrfwbgrhv',
                    orderId: 13,
                    orderListId: -1,
                    clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                    transactTime: 1684804350069,
                    price: '0.090430',
                    origQty: '0.178622',
                    executedQty: '0.000000',
                    cummulativeQuoteQty: '0.000000',
                    status: 'CANCELED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    selfTradePreventionMode: 'NONE',
                },
                {
                    orderListId: 1929,
                    contingencyType: 'OCO',
                    listStatusType: 'ALL_DONE',
                    listOrderStatus: 'ALL_DONE',
                    listClientOrderId: '2inzWQdDvZLHbbAmAozX2N',
                    transactionTime: 1585230948299,
                    symbol: 'BTCUSDT',
                    orders: [
                        { symbol: 'BTCUSDT', orderId: 20, clientOrderId: 'CwOOIPHSmYywx6jZX77TdL' },
                        { symbol: 'BTCUSDT', orderId: 21, clientOrderId: '461cPg51vQjV3zIMOXNz39' },
                    ],
                    orderReports: [
                        {
                            symbol: 'BTCUSDT',
                            origClientOrderId: 'CwOOIPHSmYywx6jZX77TdL',
                            orderId: 20,
                            orderListId: 1929,
                            clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                            transactTime: 1688005070874,
                            price: '0.668611',
                            origQty: '0.690354',
                            executedQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'STOP_LOSS_LIMIT',
                            side: 'BUY',
                            stopPrice: '0.378131',
                            icebergQty: '0.017083',
                            selfTradePreventionMode: 'NONE',
                        },
                        {
                            symbol: 'BTCUSDT',
                            origClientOrderId: '461cPg51vQjV3zIMOXNz39',
                            orderId: 21,
                            orderListId: 1929,
                            clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                            transactTime: 1688005070874,
                            price: '0.008791',
                            origQty: '0.690354',
                            executedQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'BUY',
                            icebergQty: '0.639962',
                            selfTradePreventionMode: 'NONE',
                        },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'deleteOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DeleteOpenOrdersResponse>)
            );
            const response = await client.deleteOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: DeleteOpenOrdersRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.deleteOpenOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling deleteOpenOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DeleteOpenOrdersRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'deleteOpenOrders').mockRejectedValueOnce(mockError);
            await expect(client.deleteOpenOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('deleteOrder()', () => {
        it('should execute deleteOrder() successfully with required parameters only', async () => {
            const params: DeleteOrderRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = {
                symbol: 'LTCBTC',
                origClientOrderId: 'myOrder1',
                orderId: 4,
                orderListId: -1,
                clientOrderId: 'cancelMyOrder1',
                transactTime: 1684804350068,
                price: '2.00000000',
                origQty: '1.00000000',
                executedQty: '0.00000000',
                cummulativeQuoteQty: '0.00000000',
                status: 'CANCELED',
                timeInForce: 'GTC',
                type: 'LIMIT',
                side: 'BUY',
                selfTradePreventionMode: 'NONE',
            };

            const spy = jest.spyOn(client, 'deleteOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DeleteOrderResponse>)
            );
            const response = await client.deleteOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute deleteOrder() successfully with optional parameters', async () => {
            const params: DeleteOrderRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
                origClientOrderId: 'origClientOrderId_example',
                newClientOrderId: 'newClientOrderId_example',
                cancelRestrictions: DeleteOrderCancelRestrictionsEnum.ONLY_NEW,
                recvWindow: 5000,
            };

            mockResponse = {
                symbol: 'LTCBTC',
                origClientOrderId: 'myOrder1',
                orderId: 4,
                orderListId: -1,
                clientOrderId: 'cancelMyOrder1',
                transactTime: 1684804350068,
                price: '2.00000000',
                origQty: '1.00000000',
                executedQty: '0.00000000',
                cummulativeQuoteQty: '0.00000000',
                status: 'CANCELED',
                timeInForce: 'GTC',
                type: 'LIMIT',
                side: 'BUY',
                selfTradePreventionMode: 'NONE',
            };

            const spy = jest.spyOn(client, 'deleteOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DeleteOrderResponse>)
            );
            const response = await client.deleteOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: DeleteOrderRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.deleteOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling deleteOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DeleteOrderRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'deleteOrder').mockRejectedValueOnce(mockError);
            await expect(client.deleteOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('deleteOrderList()', () => {
        it('should execute deleteOrderList() successfully with required parameters only', async () => {
            const params: DeleteOrderListRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = {
                orderListId: 0,
                contingencyType: 'OCO',
                listStatusType: 'ALL_DONE',
                listOrderStatus: 'ALL_DONE',
                listClientOrderId: 'C3wyj4WVEktd7u9aVBRXcN',
                transactionTime: 1574040868128,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'pO9ufTiFGg3nw2fOdgeOXa' },
                    { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'TXOvglzXuaubXAaENpaRCB' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        origClientOrderId: 'pO9ufTiFGg3nw2fOdgeOXa',
                        orderId: 2,
                        orderListId: 0,
                        clientOrderId: 'unfWT8ig8i0uj6lPuYLez6',
                        transactTime: 1688005070874,
                        price: '1.00000000',
                        origQty: '10.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'STOP_LOSS_LIMIT',
                        side: 'SELL',
                        stopPrice: '1.00000000',
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        origClientOrderId: 'TXOvglzXuaubXAaENpaRCB',
                        orderId: 3,
                        orderListId: 0,
                        clientOrderId: 'unfWT8ig8i0uj6lPuYLez6',
                        transactTime: 1688005070874,
                        price: '3.00000000',
                        origQty: '10.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'SELL',
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'deleteOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DeleteOrderListResponse>)
            );
            const response = await client.deleteOrderList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute deleteOrderList() successfully with optional parameters', async () => {
            const params: DeleteOrderListRequest = {
                symbol: 'BNBUSDT',
                orderListId: 1,
                listClientOrderId: 'listClientOrderId_example',
                newClientOrderId: 'newClientOrderId_example',
                recvWindow: 5000,
            };

            mockResponse = {
                orderListId: 0,
                contingencyType: 'OCO',
                listStatusType: 'ALL_DONE',
                listOrderStatus: 'ALL_DONE',
                listClientOrderId: 'C3wyj4WVEktd7u9aVBRXcN',
                transactionTime: 1574040868128,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'pO9ufTiFGg3nw2fOdgeOXa' },
                    { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'TXOvglzXuaubXAaENpaRCB' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        origClientOrderId: 'pO9ufTiFGg3nw2fOdgeOXa',
                        orderId: 2,
                        orderListId: 0,
                        clientOrderId: 'unfWT8ig8i0uj6lPuYLez6',
                        transactTime: 1688005070874,
                        price: '1.00000000',
                        origQty: '10.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'STOP_LOSS_LIMIT',
                        side: 'SELL',
                        stopPrice: '1.00000000',
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        origClientOrderId: 'TXOvglzXuaubXAaENpaRCB',
                        orderId: 3,
                        orderListId: 0,
                        clientOrderId: 'unfWT8ig8i0uj6lPuYLez6',
                        transactTime: 1688005070874,
                        price: '3.00000000',
                        origQty: '10.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'SELL',
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'deleteOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DeleteOrderListResponse>)
            );
            const response = await client.deleteOrderList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: DeleteOrderListRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.deleteOrderList(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling deleteOrderList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DeleteOrderListRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'deleteOrderList').mockRejectedValueOnce(mockError);
            await expect(client.deleteOrderList(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getOpenOrders()', () => {
        it('should execute getOpenOrders() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    symbol: 'LTCBTC',
                    orderId: 1,
                    orderListId: -1,
                    clientOrderId: 'myOrder1',
                    price: '0.1',
                    origQty: '1.0',
                    executedQty: '0.0',
                    cummulativeQuoteQty: '0.0',
                    status: 'NEW',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    stopPrice: '0.0',
                    icebergQty: '0.0',
                    time: 1499827319559,
                    updateTime: 1499827319559,
                    isWorking: true,
                    origQuoteOrderQty: '0.000000',
                    workingTime: 1499827319559,
                    selfTradePreventionMode: 'NONE',
                },
            ];

            const spy = jest.spyOn(client, 'getOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOpenOrdersResponse>)
            );
            const response = await client.getOpenOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOpenOrders() successfully with optional parameters', async () => {
            const params: GetOpenOrdersRequest = {
                symbol: 'BNBUSDT',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'LTCBTC',
                    orderId: 1,
                    orderListId: -1,
                    clientOrderId: 'myOrder1',
                    price: '0.1',
                    origQty: '1.0',
                    executedQty: '0.0',
                    cummulativeQuoteQty: '0.0',
                    status: 'NEW',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    stopPrice: '0.0',
                    icebergQty: '0.0',
                    time: 1499827319559,
                    updateTime: 1499827319559,
                    isWorking: true,
                    origQuoteOrderQty: '0.000000',
                    workingTime: 1499827319559,
                    selfTradePreventionMode: 'NONE',
                },
            ];

            const spy = jest.spyOn(client, 'getOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOpenOrdersResponse>)
            );
            const response = await client.getOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getOpenOrders').mockRejectedValueOnce(mockError);
            await expect(client.getOpenOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getOrder()', () => {
        it('should execute getOrder() successfully with required parameters only', async () => {
            const params: GetOrderRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = {
                symbol: 'LTCBTC',
                orderId: 1,
                orderListId: -1,
                clientOrderId: 'myOrder1',
                price: '0.1',
                origQty: '1.0',
                executedQty: '0.0',
                cummulativeQuoteQty: '0.0',
                status: 'NEW',
                timeInForce: 'GTC',
                type: 'LIMIT',
                side: 'BUY',
                stopPrice: '0.0',
                icebergQty: '0.0',
                time: 1499827319559,
                updateTime: 1499827319559,
                isWorking: true,
                workingTime: 1499827319559,
                origQuoteOrderQty: '0.000000',
                selfTradePreventionMode: 'NONE',
            };

            const spy = jest.spyOn(client, 'getOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOrderResponse>)
            );
            const response = await client.getOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOrder() successfully with optional parameters', async () => {
            const params: GetOrderRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
                origClientOrderId: 'origClientOrderId_example',
                recvWindow: 5000,
            };

            mockResponse = {
                symbol: 'LTCBTC',
                orderId: 1,
                orderListId: -1,
                clientOrderId: 'myOrder1',
                price: '0.1',
                origQty: '1.0',
                executedQty: '0.0',
                cummulativeQuoteQty: '0.0',
                status: 'NEW',
                timeInForce: 'GTC',
                type: 'LIMIT',
                side: 'BUY',
                stopPrice: '0.0',
                icebergQty: '0.0',
                time: 1499827319559,
                updateTime: 1499827319559,
                isWorking: true,
                workingTime: 1499827319559,
                origQuoteOrderQty: '0.000000',
                selfTradePreventionMode: 'NONE',
            };

            const spy = jest.spyOn(client, 'getOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOrderResponse>)
            );
            const response = await client.getOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: GetOrderRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.getOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling getOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetOrderRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getOrder').mockRejectedValueOnce(mockError);
            await expect(client.getOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getOrderList()', () => {
        it('should execute getOrderList() successfully with required parameters only', async () => {
            mockResponse = {
                orderListId: 27,
                contingencyType: 'OCO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'h2USkA5YQpaXHPIrkd96xE',
                transactionTime: 1565245656253,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'qD1gy3kc3Gx0rihm9Y3xwS' },
                    { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'ARzZ9I00CPM8i3NhmU9Ega' },
                ],
            };

            const spy = jest.spyOn(client, 'getOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOrderListResponse>)
            );
            const response = await client.getOrderList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOrderList() successfully with optional parameters', async () => {
            const params: GetOrderListRequest = {
                orderListId: 1,
                origClientOrderId: 'origClientOrderId_example',
                recvWindow: 5000,
            };

            mockResponse = {
                orderListId: 27,
                contingencyType: 'OCO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'h2USkA5YQpaXHPIrkd96xE',
                transactionTime: 1565245656253,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'qD1gy3kc3Gx0rihm9Y3xwS' },
                    { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'ARzZ9I00CPM8i3NhmU9Ega' },
                ],
            };

            const spy = jest.spyOn(client, 'getOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOrderListResponse>)
            );
            const response = await client.getOrderList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getOrderList').mockRejectedValueOnce(mockError);
            await expect(client.getOrderList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('newOrder()', () => {
        it('should execute newOrder() successfully with required parameters only', async () => {
            const params: NewOrderRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                orderId: 28,
                orderListId: -1,
                clientOrderId: '6gCrw2kRUAF9CvJDGP16IP',
                transactTime: 1507725176595,
                price: '0.00000000',
                origQty: '10.00000000',
                executedQty: '10.00000000',
                origQuoteOrderQty: '0.000000',
                cummulativeQuoteQty: '10.00000000',
                status: 'FILLED',
                timeInForce: 'GTC',
                type: 'MARKET',
                side: 'SELL',
                workingTime: 1507725176595,
                selfTradePreventionMode: 'NONE',
                fills: [
                    {
                        price: '4000.00000000',
                        qty: '1.00000000',
                        commission: '4.00000000',
                        commissionAsset: 'USDT',
                        tradeId: 56,
                    },
                    {
                        price: '3999.00000000',
                        qty: '5.00000000',
                        commission: '19.99500000',
                        commissionAsset: 'USDT',
                        tradeId: 57,
                    },
                    {
                        price: '3998.00000000',
                        qty: '2.00000000',
                        commission: '7.99600000',
                        commissionAsset: 'USDT',
                        tradeId: 58,
                    },
                    {
                        price: '3997.00000000',
                        qty: '1.00000000',
                        commission: '3.99700000',
                        commissionAsset: 'USDT',
                        tradeId: 59,
                    },
                    {
                        price: '3995.00000000',
                        qty: '1.00000000',
                        commission: '3.99500000',
                        commissionAsset: 'USDT',
                        tradeId: 60,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'newOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewOrderResponse>)
            );
            const response = await client.newOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute newOrder() successfully with optional parameters', async () => {
            const params: NewOrderRequest = {
                symbol: 'BNBUSDT',
                side: NewOrderSideEnum.BUY,
                type: NewOrderTypeEnum.MARKET,
                timeInForce: NewOrderTimeInForceEnum.GTC,
                quantity: 1.0,
                quoteOrderQty: 1.0,
                price: 400.0,
                newClientOrderId: 'newClientOrderId_example',
                strategyId: 1,
                strategyType: 1,
                stopPrice: 1.0,
                trailingDelta: 1,
                icebergQty: 1.0,
                newOrderRespType: NewOrderNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: NewOrderSelfTradePreventionModeEnum.NONE,
                recvWindow: 5000,
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                orderId: 28,
                orderListId: -1,
                clientOrderId: '6gCrw2kRUAF9CvJDGP16IP',
                transactTime: 1507725176595,
                price: '0.00000000',
                origQty: '10.00000000',
                executedQty: '10.00000000',
                origQuoteOrderQty: '0.000000',
                cummulativeQuoteQty: '10.00000000',
                status: 'FILLED',
                timeInForce: 'GTC',
                type: 'MARKET',
                side: 'SELL',
                workingTime: 1507725176595,
                selfTradePreventionMode: 'NONE',
                fills: [
                    {
                        price: '4000.00000000',
                        qty: '1.00000000',
                        commission: '4.00000000',
                        commissionAsset: 'USDT',
                        tradeId: 56,
                    },
                    {
                        price: '3999.00000000',
                        qty: '5.00000000',
                        commission: '19.99500000',
                        commissionAsset: 'USDT',
                        tradeId: 57,
                    },
                    {
                        price: '3998.00000000',
                        qty: '2.00000000',
                        commission: '7.99600000',
                        commissionAsset: 'USDT',
                        tradeId: 58,
                    },
                    {
                        price: '3997.00000000',
                        qty: '1.00000000',
                        commission: '3.99700000',
                        commissionAsset: 'USDT',
                        tradeId: 59,
                    },
                    {
                        price: '3995.00000000',
                        qty: '1.00000000',
                        commission: '3.99500000',
                        commissionAsset: 'USDT',
                        tradeId: 60,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'newOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewOrderResponse>)
            );
            const response = await client.newOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: NewOrderRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.newOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling newOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: NewOrderRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'newOrder').mockRejectedValueOnce(mockError);
            await expect(client.newOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('openOrderList()', () => {
        it('should execute openOrderList() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    orderListId: 31,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'wuB13fmulKj3YjdqWEcsnp',
                    transactionTime: 1565246080644,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'r3EH2N76dHfLoSZWIUw1bT' },
                        { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'Cv1SnyPD3qhqpbjpYEHbd2' },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'openOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenOrderListResponse>)
            );
            const response = await client.openOrderList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute openOrderList() successfully with optional parameters', async () => {
            const params: OpenOrderListRequest = {
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    orderListId: 31,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'wuB13fmulKj3YjdqWEcsnp',
                    transactionTime: 1565246080644,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'r3EH2N76dHfLoSZWIUw1bT' },
                        { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'Cv1SnyPD3qhqpbjpYEHbd2' },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'openOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenOrderListResponse>)
            );
            const response = await client.openOrderList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'openOrderList').mockRejectedValueOnce(mockError);
            await expect(client.openOrderList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderAmendKeepPriority()', () => {
        it('should execute orderAmendKeepPriority() successfully with required parameters only', async () => {
            const params: OrderAmendKeepPriorityRequest = {
                symbol: 'BNBUSDT',
                newQty: 1.0,
            };

            mockResponse = {
                transactTime: 1741926410255,
                executionId: 75,
                amendedOrder: {
                    symbol: 'BTCUSDT',
                    orderId: 33,
                    orderListId: -1,
                    origClientOrderId: '5xrgbMyg6z36NzBn2pbT8H',
                    clientOrderId: 'PFaq6hIHxqFENGfdtn4J6Q',
                    price: '6.00000000',
                    qty: '5.00000000',
                    executedQty: '0.00000000',
                    preventedQty: '0.00000000',
                    quoteOrderQty: '0.00000000',
                    cumulativeQuoteQty: '0.00000000',
                    status: 'NEW',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'SELL',
                    workingTime: 1741926410242,
                    selfTradePreventionMode: 'NONE',
                },
            };

            const spy = jest.spyOn(client, 'orderAmendKeepPriority').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderAmendKeepPriorityResponse>)
            );
            const response = await client.orderAmendKeepPriority(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderAmendKeepPriority() successfully with optional parameters', async () => {
            const params: OrderAmendKeepPriorityRequest = {
                symbol: 'BNBUSDT',
                newQty: 1.0,
                orderId: 1,
                origClientOrderId: 'origClientOrderId_example',
                newClientOrderId: 'newClientOrderId_example',
                recvWindow: 5000,
            };

            mockResponse = {
                transactTime: 1741926410255,
                executionId: 75,
                amendedOrder: {
                    symbol: 'BTCUSDT',
                    orderId: 33,
                    orderListId: -1,
                    origClientOrderId: '5xrgbMyg6z36NzBn2pbT8H',
                    clientOrderId: 'PFaq6hIHxqFENGfdtn4J6Q',
                    price: '6.00000000',
                    qty: '5.00000000',
                    executedQty: '0.00000000',
                    preventedQty: '0.00000000',
                    quoteOrderQty: '0.00000000',
                    cumulativeQuoteQty: '0.00000000',
                    status: 'NEW',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'SELL',
                    workingTime: 1741926410242,
                    selfTradePreventionMode: 'NONE',
                },
            };

            const spy = jest.spyOn(client, 'orderAmendKeepPriority').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderAmendKeepPriorityResponse>)
            );
            const response = await client.orderAmendKeepPriority(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderAmendKeepPriorityRequest = {
                symbol: 'BNBUSDT',
                newQty: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderAmendKeepPriority(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderAmendKeepPriority.'
            );
        });

        it('should throw RequiredError when newQty is missing', async () => {
            const _params: OrderAmendKeepPriorityRequest = {
                symbol: 'BNBUSDT',
                newQty: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.newQty;

            await expect(client.orderAmendKeepPriority(params)).rejects.toThrow(
                'Required parameter newQty was null or undefined when calling orderAmendKeepPriority.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderAmendKeepPriorityRequest = {
                symbol: 'BNBUSDT',
                newQty: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'orderAmendKeepPriority')
                .mockRejectedValueOnce(mockError);
            await expect(client.orderAmendKeepPriority(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderCancelReplace()', () => {
        it('should execute orderCancelReplace() successfully with required parameters only', async () => {
            const params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = {
                code: -2021,
                msg: 'Order cancel-replace partially failed.',
                data: {
                    cancelResult: 'SUCCESS',
                    newOrderResult: 'FAILURE',
                    cancelResponse: {
                        symbol: 'LTCBNB',
                        origClientOrderId: 'GKt5zzfOxRDSQLveDYCTkc',
                        orderId: 64,
                        orderListId: -1,
                        clientOrderId: 'loehOJF3FjoreUBDmv739R',
                        transactTime: 1715779007228,
                        price: '1.00',
                        origQty: '10.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'SELL',
                        selfTradePreventionMode: 'NONE',
                    },
                    newOrderResponse: {
                        code: -1015,
                        msg: 'Too many new orders; current limit is 1 orders per 10 SECOND.',
                    },
                },
            };

            const spy = jest.spyOn(client, 'orderCancelReplace').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderCancelReplaceResponse>)
            );
            const response = await client.orderCancelReplace(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderCancelReplace() successfully with optional parameters', async () => {
            const params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
                side: OrderCancelReplaceSideEnum.BUY,
                type: OrderCancelReplaceTypeEnum.MARKET,
                cancelReplaceMode: OrderCancelReplaceCancelReplaceModeEnum.STOP_ON_FAILURE,
                timeInForce: OrderCancelReplaceTimeInForceEnum.GTC,
                quantity: 1.0,
                quoteOrderQty: 1.0,
                price: 400.0,
                cancelNewClientOrderId: 'cancelNewClientOrderId_example',
                cancelOrigClientOrderId: 'cancelOrigClientOrderId_example',
                cancelOrderId: 1,
                newClientOrderId: 'newClientOrderId_example',
                strategyId: 1,
                strategyType: 1,
                stopPrice: 1.0,
                trailingDelta: 1,
                icebergQty: 1.0,
                newOrderRespType: OrderCancelReplaceNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: OrderCancelReplaceSelfTradePreventionModeEnum.NONE,
                cancelRestrictions: OrderCancelReplaceCancelRestrictionsEnum.ONLY_NEW,
                orderRateLimitExceededMode:
                    OrderCancelReplaceOrderRateLimitExceededModeEnum.DO_NOTHING,
                recvWindow: 5000,
            };

            mockResponse = {
                code: -2021,
                msg: 'Order cancel-replace partially failed.',
                data: {
                    cancelResult: 'SUCCESS',
                    newOrderResult: 'FAILURE',
                    cancelResponse: {
                        symbol: 'LTCBNB',
                        origClientOrderId: 'GKt5zzfOxRDSQLveDYCTkc',
                        orderId: 64,
                        orderListId: -1,
                        clientOrderId: 'loehOJF3FjoreUBDmv739R',
                        transactTime: 1715779007228,
                        price: '1.00',
                        origQty: '10.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'SELL',
                        selfTradePreventionMode: 'NONE',
                    },
                    newOrderResponse: {
                        code: -1015,
                        msg: 'Too many new orders; current limit is 1 orders per 10 SECOND.',
                    },
                },
            };

            const spy = jest.spyOn(client, 'orderCancelReplace').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderCancelReplaceResponse>)
            );
            const response = await client.orderCancelReplace(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderCancelReplace(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderCancelReplace.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderCancelReplaceRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderCancelReplace').mockRejectedValueOnce(mockError);
            await expect(client.orderCancelReplace(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderListOco()', () => {
        it('should execute orderListOco() successfully with required parameters only', async () => {
            const params: OrderListOcoRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
            };

            mockResponse = {
                orderListId: 1,
                contingencyType: 'OCO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'lH1YDkuQKWiXVXHPSKYEIp',
                transactionTime: 1710485608839,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 10, clientOrderId: '44nZvqpemY7sVYgPYbvPih' },
                    { symbol: 'LTCBTC', orderId: 11, clientOrderId: 'NuMp0nVYnciDiFmVqfpBqK' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        orderId: 10,
                        orderListId: 1,
                        clientOrderId: '44nZvqpemY7sVYgPYbvPih',
                        transactTime: 1710485608839,
                        price: '1.00000000',
                        origQty: '5.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'STOP_LOSS_LIMIT',
                        side: 'SELL',
                        stopPrice: '1.00000000',
                        workingTime: -1,
                        icebergQty: '1.00000000',
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 11,
                        orderListId: 1,
                        clientOrderId: 'NuMp0nVYnciDiFmVqfpBqK',
                        transactTime: 1710485608839,
                        price: '3.00000000',
                        origQty: '5.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'SELL',
                        workingTime: 1710485608839,
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'orderListOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderListOcoResponse>)
            );
            const response = await client.orderListOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderListOco() successfully with optional parameters', async () => {
            const params: OrderListOcoRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
                listClientOrderId: 'listClientOrderId_example',
                side: OrderListOcoSideEnum.BUY,
                aboveType: OrderListOcoAboveTypeEnum.STOP_LOSS_LIMIT,
                aboveClientOrderId: 'aboveClientOrderId_example',
                aboveIcebergQty: 1,
                abovePrice: 1.0,
                aboveStopPrice: 1.0,
                aboveTrailingDelta: 1,
                aboveTimeInForce: 1.0,
                aboveStrategyId: 1,
                aboveStrategyType: 1,
                belowType: OrderListOcoBelowTypeEnum.STOP_LOSS,
                belowClientOrderId: 'belowClientOrderId_example',
                belowIcebergQty: 1,
                belowPrice: 1.0,
                belowStopPrice: 1.0,
                belowTrailingDelta: 1,
                belowTimeInForce: OrderListOcoBelowTimeInForceEnum.belowType,
                belowStrategyId: 1,
                belowStrategyType: 1,
                newOrderRespType: OrderListOcoNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: OrderListOcoSelfTradePreventionModeEnum.NONE,
                recvWindow: 5000,
            };

            mockResponse = {
                orderListId: 1,
                contingencyType: 'OCO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'lH1YDkuQKWiXVXHPSKYEIp',
                transactionTime: 1710485608839,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 10, clientOrderId: '44nZvqpemY7sVYgPYbvPih' },
                    { symbol: 'LTCBTC', orderId: 11, clientOrderId: 'NuMp0nVYnciDiFmVqfpBqK' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        orderId: 10,
                        orderListId: 1,
                        clientOrderId: '44nZvqpemY7sVYgPYbvPih',
                        transactTime: 1710485608839,
                        price: '1.00000000',
                        origQty: '5.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'STOP_LOSS_LIMIT',
                        side: 'SELL',
                        stopPrice: '1.00000000',
                        workingTime: -1,
                        icebergQty: '1.00000000',
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 11,
                        orderListId: 1,
                        clientOrderId: 'NuMp0nVYnciDiFmVqfpBqK',
                        transactTime: 1710485608839,
                        price: '3.00000000',
                        origQty: '5.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'SELL',
                        workingTime: 1710485608839,
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'orderListOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderListOcoResponse>)
            );
            const response = await client.orderListOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderListOcoRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderListOco(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderListOco.'
            );
        });

        it('should throw RequiredError when quantity is missing', async () => {
            const _params: OrderListOcoRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.quantity;

            await expect(client.orderListOco(params)).rejects.toThrow(
                'Required parameter quantity was null or undefined when calling orderListOco.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderListOcoRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderListOco').mockRejectedValueOnce(mockError);
            await expect(client.orderListOco(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderListOto()', () => {
        it('should execute orderListOto() successfully with required parameters only', async () => {
            const params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingQuantity: 1.0,
            };

            mockResponse = {
                orderListId: 0,
                contingencyType: 'OTO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'yl2ERtcar1o25zcWtqVBTC',
                transactionTime: 1712289389158,
                symbol: 'ABCDEF',
                orders: [
                    { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'Bq17mn9fP6vyCn75Jw1xya' },
                    { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'arLFo0zGJVDE69cvGBaU0d' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        orderId: 4,
                        orderListId: 0,
                        clientOrderId: 'Bq17mn9fP6vyCn75Jw1xya',
                        transactTime: 1712289389158,
                        price: '1.00000000',
                        origQty: '1.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'SELL',
                        workingTime: 1712289389158,
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 5,
                        orderListId: 0,
                        clientOrderId: 'arLFo0zGJVDE69cvGBaU0d',
                        transactTime: 1712289389158,
                        price: '0.00000000',
                        origQty: '5.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'PENDING_NEW',
                        timeInForce: 'GTC',
                        type: 'MARKET',
                        side: 'BUY',
                        workingTime: -1,
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'orderListOto').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderListOtoResponse>)
            );
            const response = await client.orderListOto(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderListOto() successfully with optional parameters', async () => {
            const params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingQuantity: 1.0,
                listClientOrderId: 'listClientOrderId_example',
                newOrderRespType: OrderListOtoNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: OrderListOtoSelfTradePreventionModeEnum.NONE,
                workingType: OrderListOtoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtoWorkingSideEnum.BUY,
                workingClientOrderId: 'workingClientOrderId_example',
                workingIcebergQty: 1.0,
                workingTimeInForce: OrderListOtoWorkingTimeInForceEnum.GTC,
                workingStrategyId: 1,
                workingStrategyType: 1,
                pendingType: OrderListOtoPendingTypeEnum.LIMIT,
                pendingSide: OrderListOtoPendingSideEnum.BUY,
                pendingClientOrderId: 'pendingClientOrderId_example',
                pendingPrice: 1.0,
                pendingStopPrice: 1.0,
                pendingTrailingDelta: 1.0,
                pendingIcebergQty: 1.0,
                pendingTimeInForce: OrderListOtoPendingTimeInForceEnum.GTC,
                pendingStrategyId: 1,
                pendingStrategyType: 1,
                recvWindow: 5000,
            };

            mockResponse = {
                orderListId: 0,
                contingencyType: 'OTO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'yl2ERtcar1o25zcWtqVBTC',
                transactionTime: 1712289389158,
                symbol: 'ABCDEF',
                orders: [
                    { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'Bq17mn9fP6vyCn75Jw1xya' },
                    { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'arLFo0zGJVDE69cvGBaU0d' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        orderId: 4,
                        orderListId: 0,
                        clientOrderId: 'Bq17mn9fP6vyCn75Jw1xya',
                        transactTime: 1712289389158,
                        price: '1.00000000',
                        origQty: '1.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'SELL',
                        workingTime: 1712289389158,
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 5,
                        orderListId: 0,
                        clientOrderId: 'arLFo0zGJVDE69cvGBaU0d',
                        transactTime: 1712289389158,
                        price: '0.00000000',
                        origQty: '5.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'PENDING_NEW',
                        timeInForce: 'GTC',
                        type: 'MARKET',
                        side: 'BUY',
                        workingTime: -1,
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'orderListOto').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderListOtoResponse>)
            );
            const response = await client.orderListOto(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderListOto(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderListOto.'
            );
        });

        it('should throw RequiredError when workingPrice is missing', async () => {
            const _params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingPrice;

            await expect(client.orderListOto(params)).rejects.toThrow(
                'Required parameter workingPrice was null or undefined when calling orderListOto.'
            );
        });

        it('should throw RequiredError when workingQuantity is missing', async () => {
            const _params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingQuantity;

            await expect(client.orderListOto(params)).rejects.toThrow(
                'Required parameter workingQuantity was null or undefined when calling orderListOto.'
            );
        });

        it('should throw RequiredError when pendingQuantity is missing', async () => {
            const _params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingQuantity;

            await expect(client.orderListOto(params)).rejects.toThrow(
                'Required parameter pendingQuantity was null or undefined when calling orderListOto.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderListOtoRequest = {
                symbol: 'BNBUSDT',
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingQuantity: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderListOto').mockRejectedValueOnce(mockError);
            await expect(client.orderListOto(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderListOtoco()', () => {
        it('should execute orderListOtoco() successfully with required parameters only', async () => {
            const params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingQuantity: 1.0,
            };

            mockResponse = {
                orderListId: 1,
                contingencyType: 'OTO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'RumwQpBaDctlUu5jyG5rs0',
                transactionTime: 1712291372842,
                symbol: 'ABCDEF',
                orders: [
                    { symbol: 'LTCBTC', orderId: 6, clientOrderId: 'fM9Y4m23IFJVCQmIrlUmMK' },
                    { symbol: 'LTCBTC', orderId: 7, clientOrderId: '6pcQbFIzTXGZQ1e2MkGDq4' },
                    { symbol: 'LTCBTC', orderId: 8, clientOrderId: 'r4JMv9cwAYYUwwBZfbussx' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        orderId: 6,
                        orderListId: 1,
                        clientOrderId: 'fM9Y4m23IFJVCQmIrlUmMK',
                        transactTime: 1712291372842,
                        price: '1.00000000',
                        origQty: '1.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'SELL',
                        workingTime: 1712291372842,
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 7,
                        orderListId: 1,
                        clientOrderId: '6pcQbFIzTXGZQ1e2MkGDq4',
                        transactTime: 1712291372842,
                        price: '1.00000000',
                        origQty: '5.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'PENDING_NEW',
                        timeInForce: 'IOC',
                        type: 'STOP_LOSS_LIMIT',
                        side: 'BUY',
                        stopPrice: '6.00000000',
                        workingTime: -1,
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 8,
                        orderListId: 1,
                        clientOrderId: 'r4JMv9cwAYYUwwBZfbussx',
                        transactTime: 1712291372842,
                        price: '3.00000000',
                        origQty: '5.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'PENDING_NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'BUY',
                        workingTime: -1,
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'orderListOtoco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderListOtocoResponse>)
            );
            const response = await client.orderListOtoco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderListOtoco() successfully with optional parameters', async () => {
            const params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingQuantity: 1.0,
                listClientOrderId: 'listClientOrderId_example',
                newOrderRespType: OrderListOtocoNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: OrderListOtocoSelfTradePreventionModeEnum.NONE,
                workingType: OrderListOtocoWorkingTypeEnum.LIMIT,
                workingSide: OrderListOtocoWorkingSideEnum.BUY,
                workingClientOrderId: 'workingClientOrderId_example',
                workingIcebergQty: 1.0,
                workingTimeInForce: OrderListOtocoWorkingTimeInForceEnum.GTC,
                workingStrategyId: 1,
                workingStrategyType: 1,
                pendingSide: OrderListOtocoPendingSideEnum.BUY,
                pendingAboveType: OrderListOtocoPendingAboveTypeEnum.STOP_LOSS_LIMIT,
                pendingAboveClientOrderId: 'pendingAboveClientOrderId_example',
                pendingAbovePrice: 1.0,
                pendingAboveStopPrice: 1.0,
                pendingAboveTrailingDelta: 1.0,
                pendingAboveIcebergQty: 1.0,
                pendingAboveTimeInForce: OrderListOtocoPendingAboveTimeInForceEnum.GTC,
                pendingAboveStrategyId: 1,
                pendingAboveStrategyType: 1,
                pendingBelowType: OrderListOtocoPendingBelowTypeEnum.STOP_LOSS,
                pendingBelowClientOrderId: 'pendingBelowClientOrderId_example',
                pendingBelowPrice: 1.0,
                pendingBelowStopPrice: 1.0,
                pendingBelowTrailingDelta: 1.0,
                pendingBelowIcebergQty: 1.0,
                pendingBelowTimeInForce: OrderListOtocoPendingBelowTimeInForceEnum.GTC,
                pendingBelowStrategyId: 1,
                pendingBelowStrategyType: 1,
                recvWindow: 5000,
            };

            mockResponse = {
                orderListId: 1,
                contingencyType: 'OTO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'RumwQpBaDctlUu5jyG5rs0',
                transactionTime: 1712291372842,
                symbol: 'ABCDEF',
                orders: [
                    { symbol: 'LTCBTC', orderId: 6, clientOrderId: 'fM9Y4m23IFJVCQmIrlUmMK' },
                    { symbol: 'LTCBTC', orderId: 7, clientOrderId: '6pcQbFIzTXGZQ1e2MkGDq4' },
                    { symbol: 'LTCBTC', orderId: 8, clientOrderId: 'r4JMv9cwAYYUwwBZfbussx' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        orderId: 6,
                        orderListId: 1,
                        clientOrderId: 'fM9Y4m23IFJVCQmIrlUmMK',
                        transactTime: 1712291372842,
                        price: '1.00000000',
                        origQty: '1.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT',
                        side: 'SELL',
                        workingTime: 1712291372842,
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 7,
                        orderListId: 1,
                        clientOrderId: '6pcQbFIzTXGZQ1e2MkGDq4',
                        transactTime: 1712291372842,
                        price: '1.00000000',
                        origQty: '5.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'PENDING_NEW',
                        timeInForce: 'IOC',
                        type: 'STOP_LOSS_LIMIT',
                        side: 'BUY',
                        stopPrice: '6.00000000',
                        workingTime: -1,
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 8,
                        orderListId: 1,
                        clientOrderId: 'r4JMv9cwAYYUwwBZfbussx',
                        transactTime: 1712291372842,
                        price: '3.00000000',
                        origQty: '5.00000000',
                        executedQty: '0.00000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'PENDING_NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'BUY',
                        workingTime: -1,
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'orderListOtoco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderListOtocoResponse>)
            );
            const response = await client.orderListOtoco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderListOtoco(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderListOtoco.'
            );
        });

        it('should throw RequiredError when workingPrice is missing', async () => {
            const _params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingPrice;

            await expect(client.orderListOtoco(params)).rejects.toThrow(
                'Required parameter workingPrice was null or undefined when calling orderListOtoco.'
            );
        });

        it('should throw RequiredError when workingQuantity is missing', async () => {
            const _params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.workingQuantity;

            await expect(client.orderListOtoco(params)).rejects.toThrow(
                'Required parameter workingQuantity was null or undefined when calling orderListOtoco.'
            );
        });

        it('should throw RequiredError when pendingQuantity is missing', async () => {
            const _params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingQuantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.pendingQuantity;

            await expect(client.orderListOtoco(params)).rejects.toThrow(
                'Required parameter pendingQuantity was null or undefined when calling orderListOtoco.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderListOtocoRequest = {
                symbol: 'BNBUSDT',
                workingPrice: 1.0,
                workingQuantity: 1.0,
                pendingQuantity: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderListOtoco').mockRejectedValueOnce(mockError);
            await expect(client.orderListOtoco(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderOco()', () => {
        it('should execute orderOco() successfully with required parameters only', async () => {
            const params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
            };

            mockResponse = {
                orderListId: 0,
                contingencyType: 'OCO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'JYVpp3F0f5CAG15DhtrqLp',
                transactionTime: 1563417480525,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'Kk7sqHb9J6mJWTMDVW7Vos' },
                    { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'xTXKaGYd4bluPVp78IVRvl' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        orderId: 2,
                        orderListId: 0,
                        clientOrderId: 'Kk7sqHb9J6mJWTMDVW7Vos',
                        transactTime: 1563417480525,
                        price: '0.000000',
                        origQty: '0.624363',
                        executedQty: '0.000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'STOP_LOSS',
                        side: 'BUY',
                        stopPrice: '0.960664',
                        workingTime: -1,
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 3,
                        orderListId: 0,
                        clientOrderId: 'xTXKaGYd4bluPVp78IVRvl',
                        transactTime: 1563417480525,
                        price: '0.036435',
                        origQty: '0.624363',
                        executedQty: '0.000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'BUY',
                        workingTime: 1563417480525,
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'orderOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderOcoResponse>)
            );
            const response = await client.orderOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderOco() successfully with optional parameters', async () => {
            const params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
                listClientOrderId: 'listClientOrderId_example',
                side: OrderOcoSideEnum.BUY,
                limitClientOrderId: 'limitClientOrderId_example',
                limitStrategyId: 1,
                limitStrategyType: 1,
                limitIcebergQty: 1.0,
                trailingDelta: 1,
                stopClientOrderId: 'stopClientOrderId_example',
                stopStrategyId: 1,
                stopStrategyType: 1,
                stopLimitPrice: 1.0,
                stopIcebergQty: 1.0,
                stopLimitTimeInForce: OrderOcoStopLimitTimeInForceEnum.GTC,
                newOrderRespType: OrderOcoNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: OrderOcoSelfTradePreventionModeEnum.NONE,
                recvWindow: 5000,
            };

            mockResponse = {
                orderListId: 0,
                contingencyType: 'OCO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'JYVpp3F0f5CAG15DhtrqLp',
                transactionTime: 1563417480525,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'Kk7sqHb9J6mJWTMDVW7Vos' },
                    { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'xTXKaGYd4bluPVp78IVRvl' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        orderId: 2,
                        orderListId: 0,
                        clientOrderId: 'Kk7sqHb9J6mJWTMDVW7Vos',
                        transactTime: 1563417480525,
                        price: '0.000000',
                        origQty: '0.624363',
                        executedQty: '0.000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'STOP_LOSS',
                        side: 'BUY',
                        stopPrice: '0.960664',
                        workingTime: -1,
                        selfTradePreventionMode: 'NONE',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 3,
                        orderListId: 0,
                        clientOrderId: 'xTXKaGYd4bluPVp78IVRvl',
                        transactTime: 1563417480525,
                        price: '0.036435',
                        origQty: '0.624363',
                        executedQty: '0.000000',
                        origQuoteOrderQty: '0.000000',
                        cummulativeQuoteQty: '0.000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'BUY',
                        workingTime: 1563417480525,
                        selfTradePreventionMode: 'NONE',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'orderOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderOcoResponse>)
            );
            const response = await client.orderOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderOco(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderOco.'
            );
        });

        it('should throw RequiredError when quantity is missing', async () => {
            const _params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.quantity;

            await expect(client.orderOco(params)).rejects.toThrow(
                'Required parameter quantity was null or undefined when calling orderOco.'
            );
        });

        it('should throw RequiredError when price is missing', async () => {
            const _params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.price;

            await expect(client.orderOco(params)).rejects.toThrow(
                'Required parameter price was null or undefined when calling orderOco.'
            );
        });

        it('should throw RequiredError when stopPrice is missing', async () => {
            const _params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.stopPrice;

            await expect(client.orderOco(params)).rejects.toThrow(
                'Required parameter stopPrice was null or undefined when calling orderOco.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderOcoRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
                price: 1.0,
                stopPrice: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderOco').mockRejectedValueOnce(mockError);
            await expect(client.orderOco(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderTest()', () => {
        it('should execute orderTest() successfully with required parameters only', async () => {
            mockResponse = {
                standardCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                taxCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                discount: {
                    enabledForAccount: true,
                    enabledForSymbol: true,
                    discountAsset: 'BNB',
                    discount: '0.25000000',
                },
            };

            const spy = jest.spyOn(client, 'orderTest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderTestResponse>)
            );
            const response = await client.orderTest();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderTest() successfully with optional parameters', async () => {
            const params: OrderTestRequest = {
                computeCommissionRates: false,
            };

            mockResponse = {
                standardCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                taxCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                discount: {
                    enabledForAccount: true,
                    enabledForSymbol: true,
                    discountAsset: 'BNB',
                    discount: '0.25000000',
                },
            };

            const spy = jest.spyOn(client, 'orderTest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderTestResponse>)
            );
            const response = await client.orderTest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderTest').mockRejectedValueOnce(mockError);
            await expect(client.orderTest()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('sorOrder()', () => {
        it('should execute sorOrder() successfully with required parameters only', async () => {
            const params: SorOrderRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                orderId: 2,
                orderListId: -1,
                clientOrderId: 'sBI1KM6nNtOfj5tccZSKly',
                transactTime: 1689149087774,
                price: '31000.00000000',
                origQty: '0.50000000',
                executedQty: '0.50000000',
                origQuoteOrderQty: '0.000000',
                cummulativeQuoteQty: '14000.00000000',
                status: 'FILLED',
                timeInForce: 'GTC',
                type: 'LIMIT',
                side: 'BUY',
                workingTime: 1689149087774,
                fills: [
                    {
                        matchType: 'ONE_PARTY_TRADE_REPORT',
                        price: '28000.00000000',
                        qty: '0.50000000',
                        commission: '0.00000000',
                        commissionAsset: 'BTC',
                        tradeId: -1,
                        allocId: 0,
                    },
                ],
                workingFloor: 'SOR',
                selfTradePreventionMode: 'NONE',
                usedSor: true,
            };

            const spy = jest.spyOn(client, 'sorOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SorOrderResponse>)
            );
            const response = await client.sorOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute sorOrder() successfully with optional parameters', async () => {
            const params: SorOrderRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
                side: SorOrderSideEnum.BUY,
                type: SorOrderTypeEnum.MARKET,
                timeInForce: SorOrderTimeInForceEnum.GTC,
                price: 400.0,
                newClientOrderId: 'newClientOrderId_example',
                strategyId: 1,
                strategyType: 1,
                icebergQty: 1.0,
                newOrderRespType: SorOrderNewOrderRespTypeEnum.ACK,
                selfTradePreventionMode: SorOrderSelfTradePreventionModeEnum.NONE,
                recvWindow: 5000,
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                orderId: 2,
                orderListId: -1,
                clientOrderId: 'sBI1KM6nNtOfj5tccZSKly',
                transactTime: 1689149087774,
                price: '31000.00000000',
                origQty: '0.50000000',
                executedQty: '0.50000000',
                origQuoteOrderQty: '0.000000',
                cummulativeQuoteQty: '14000.00000000',
                status: 'FILLED',
                timeInForce: 'GTC',
                type: 'LIMIT',
                side: 'BUY',
                workingTime: 1689149087774,
                fills: [
                    {
                        matchType: 'ONE_PARTY_TRADE_REPORT',
                        price: '28000.00000000',
                        qty: '0.50000000',
                        commission: '0.00000000',
                        commissionAsset: 'BTC',
                        tradeId: -1,
                        allocId: 0,
                    },
                ],
                workingFloor: 'SOR',
                selfTradePreventionMode: 'NONE',
                usedSor: true,
            };

            const spy = jest.spyOn(client, 'sorOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SorOrderResponse>)
            );
            const response = await client.sorOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: SorOrderRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.sorOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling sorOrder.'
            );
        });

        it('should throw RequiredError when quantity is missing', async () => {
            const _params: SorOrderRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.quantity;

            await expect(client.sorOrder(params)).rejects.toThrow(
                'Required parameter quantity was null or undefined when calling sorOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SorOrderRequest = {
                symbol: 'BNBUSDT',
                quantity: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'sorOrder').mockRejectedValueOnce(mockError);
            await expect(client.sorOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('sorOrderTest()', () => {
        it('should execute sorOrderTest() successfully with required parameters only', async () => {
            mockResponse = {
                standardCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                taxCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                discount: {
                    enabledForAccount: true,
                    enabledForSymbol: true,
                    discountAsset: 'BNB',
                    discount: '0.25000000',
                },
            };

            const spy = jest.spyOn(client, 'sorOrderTest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SorOrderTestResponse>)
            );
            const response = await client.sorOrderTest();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute sorOrderTest() successfully with optional parameters', async () => {
            const params: SorOrderTestRequest = {
                computeCommissionRates: false,
            };

            mockResponse = {
                standardCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                taxCommissionForOrder: { maker: '0.00000112', taker: '0.00000114' },
                discount: {
                    enabledForAccount: true,
                    enabledForSymbol: true,
                    discountAsset: 'BNB',
                    discount: '0.25000000',
                },
            };

            const spy = jest.spyOn(client, 'sorOrderTest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SorOrderTestResponse>)
            );
            const response = await client.sorOrderTest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'sorOrderTest').mockRejectedValueOnce(mockError);
            await expect(client.sorOrderTest()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
