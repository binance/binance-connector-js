/**
 * Binance Spot REST API
 *
 * OpenAPI Specifications for the Binance Spot REST API
 *
 * API documents:
 * - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)
 * - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)
 *
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { GeneralApi, ExchangeInfoSymbolStatusEnum } from '../../../src/rest-api';
import { ExchangeInfoRequest } from '../../../src/rest-api';
import type { ExchangeInfoResponse, TimeResponse } from '../../../src/rest-api/types';

describe('GeneralApi', () => {
    let client: GeneralApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new GeneralApi(config);
    });

    describe('exchangeInfo()', () => {
        it('should execute exchangeInfo() successfully with required parameters only', async () => {
            mockResponse = {
                timezone: 'UTC',
                serverTime: 1565246363776,
                rateLimits: [
                    {
                        rateLimitType: 'RAW_REQUESTS',
                        interval: 'MINUTE',
                        intervalNum: 5,
                        limit: 61000,
                    },
                    { rateLimitType: 'ORDERS', interval: 'DAY', intervalNum: 1, limit: 160000 },
                    {
                        rateLimitType: 'REQUEST_WEIGHT',
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 6000,
                    },
                ],
                exchangeFilters: [
                    { filterType: 'EXCHANGE_MAX_NUM_ICEBERG_ORDERS', maxNumIcebergOrders: 10000 },
                    { filterType: 'EXCHANGE_MAX_NUM_ALGO_ORDERS', maxNumAlgoOrders: 200 },
                    { filterType: 'EXCHANGE_MAX_NUM_ORDERS', maxNumOrders: 1000 },
                    {
                        filterType: 'TRAILING_DELTA',
                        minTrailingAboveDelta: 10,
                        maxTrailingAboveDelta: 2000,
                        minTrailingBelowDelta: 10,
                        maxTrailingBelowDelta: 2000,
                    },
                    { filterType: 'MAX_POSITION', maxPosition: '10.00000000' },
                    { filterType: 'MAX_NUM_ICEBERG_ORDERS', maxNumIcebergOrders: 5 },
                    { filterType: 'MAX_NUM_ALGO_ORDERS', maxNumAlgoOrders: 5 },
                    { filterType: 'MAX_NUM_ORDERS', maxNumOrders: 25 },
                    {
                        filterType: 'MARKET_LOT_SIZE',
                        minQty: '0.00100000',
                        maxQty: '100000.00000000',
                        stepSize: '0.00100000',
                    },
                    { filterType: 'ICEBERG_PARTS', limit: 10 },
                    {
                        filterType: 'NOTIONAL',
                        minNotional: '10.00000000',
                        applyMinToMarket: false,
                        maxNotional: '10000.00000000',
                        applyMaxToMarket: false,
                        avgPriceMins: 5,
                    },
                    {
                        filterType: 'MIN_NOTIONAL',
                        minNotional: '0.00100000',
                        applyToMarket: true,
                        avgPriceMins: 5,
                    },
                    {
                        filterType: 'LOT_SIZE',
                        minQty: '0.00100000',
                        maxQty: '100000.00000000',
                        stepSize: '0.00100000',
                    },
                    {
                        filterType: 'PERCENT_PRICE_BY_SIDE',
                        bidMultiplierUp: '1.2',
                        bidMultiplierDown: '0.2',
                        askMultiplierUp: '5',
                        askMultiplierDown: '0.8',
                        avgPriceMins: 1,
                    },
                    {
                        filterType: 'PERCENT_PRICE',
                        multiplierUp: '1.3000',
                        multiplierDown: '0.7000',
                        avgPriceMins: 5,
                    },
                    {
                        filterType: 'PRICE_FILTER',
                        minPrice: '0.00000100',
                        maxPrice: '100000.00000000',
                        tickSize: '0.00000100',
                    },
                ],
                symbols: [
                    {
                        symbol: 'ETHBTC',
                        status: 'TRADING',
                        baseAsset: 'ETH',
                        baseAssetPrecision: 8,
                        quoteAsset: 'BTC',
                        quotePrecision: 8,
                        quoteAssetPrecision: 8,
                        baseCommissionPrecision: 8,
                        quoteCommissionPrecision: 8,
                        orderTypes: [
                            'LIMIT LIMIT_MAKER MARKET STOP_LOSS STOP_LOSS_LIMIT TAKE_PROFIT TAKE_PROFIT_LIMIT',
                        ],
                        icebergAllowed: true,
                        ocoAllowed: true,
                        otoAllowed: true,
                        quoteOrderQtyMarketAllowed: true,
                        allowTrailingStop: false,
                        cancelReplaceAllowed: false,
                        amendAllowed: false,
                        isSpotTradingAllowed: true,
                        isMarginTradingAllowed: true,
                        filters: [
                            {
                                filterType: 'EXCHANGE_MAX_NUM_ICEBERG_ORDERS',
                                maxNumIcebergOrders: 10000,
                            },
                            { filterType: 'EXCHANGE_MAX_NUM_ALGO_ORDERS', maxNumAlgoOrders: 200 },
                            { filterType: 'EXCHANGE_MAX_NUM_ORDERS', maxNumOrders: 1000 },
                            {
                                filterType: 'TRAILING_DELTA',
                                minTrailingAboveDelta: 10,
                                maxTrailingAboveDelta: 2000,
                                minTrailingBelowDelta: 10,
                                maxTrailingBelowDelta: 2000,
                            },
                            { filterType: 'MAX_POSITION', maxPosition: '10.00000000' },
                            { filterType: 'MAX_NUM_ICEBERG_ORDERS', maxNumIcebergOrders: 5 },
                            { filterType: 'MAX_NUM_ALGO_ORDERS', maxNumAlgoOrders: 5 },
                            { filterType: 'MAX_NUM_ORDERS', maxNumOrders: 25 },
                            {
                                filterType: 'MARKET_LOT_SIZE',
                                minQty: '0.00100000',
                                maxQty: '100000.00000000',
                                stepSize: '0.00100000',
                            },
                            { filterType: 'ICEBERG_PARTS', limit: 10 },
                            {
                                filterType: 'NOTIONAL',
                                minNotional: '10.00000000',
                                applyMinToMarket: false,
                                maxNotional: '10000.00000000',
                                applyMaxToMarket: false,
                                avgPriceMins: 5,
                            },
                            {
                                filterType: 'MIN_NOTIONAL',
                                minNotional: '0.00100000',
                                applyToMarket: true,
                                avgPriceMins: 5,
                            },
                            {
                                filterType: 'LOT_SIZE',
                                minQty: '0.00100000',
                                maxQty: '100000.00000000',
                                stepSize: '0.00100000',
                            },
                            {
                                filterType: 'PERCENT_PRICE_BY_SIDE',
                                bidMultiplierUp: '1.2',
                                bidMultiplierDown: '0.2',
                                askMultiplierUp: '5',
                                askMultiplierDown: '0.8',
                                avgPriceMins: 1,
                            },
                            {
                                filterType: 'PERCENT_PRICE',
                                multiplierUp: '1.3000',
                                multiplierDown: '0.7000',
                                avgPriceMins: 5,
                            },
                            {
                                filterType: 'PRICE_FILTER',
                                minPrice: '0.00000100',
                                maxPrice: '100000.00000000',
                                tickSize: '0.00000100',
                            },
                        ],
                        permissions: [],
                        permissionSets: [['SPOT', 'MARGIN']],
                        defaultSelfTradePreventionMode: 'NONE',
                        allowedSelfTradePreventionModes: ['NONE'],
                    },
                ],
            };

            const spy = jest.spyOn(client, 'exchangeInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ExchangeInfoResponse>)
            );
            const response = await client.exchangeInfo();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute exchangeInfo() successfully with optional parameters', async () => {
            const params: ExchangeInfoRequest = {
                symbol: 'BNBUSDT',
                symbols: ['null'],
                permissions: ['null'],
                showPermissionSets: true,
                symbolStatus: ExchangeInfoSymbolStatusEnum.TRADING,
            };

            mockResponse = {
                timezone: 'UTC',
                serverTime: 1565246363776,
                rateLimits: [
                    {
                        rateLimitType: 'RAW_REQUESTS',
                        interval: 'MINUTE',
                        intervalNum: 5,
                        limit: 61000,
                    },
                    { rateLimitType: 'ORDERS', interval: 'DAY', intervalNum: 1, limit: 160000 },
                    {
                        rateLimitType: 'REQUEST_WEIGHT',
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 6000,
                    },
                ],
                exchangeFilters: [
                    { filterType: 'EXCHANGE_MAX_NUM_ICEBERG_ORDERS', maxNumIcebergOrders: 10000 },
                    { filterType: 'EXCHANGE_MAX_NUM_ALGO_ORDERS', maxNumAlgoOrders: 200 },
                    { filterType: 'EXCHANGE_MAX_NUM_ORDERS', maxNumOrders: 1000 },
                    {
                        filterType: 'TRAILING_DELTA',
                        minTrailingAboveDelta: 10,
                        maxTrailingAboveDelta: 2000,
                        minTrailingBelowDelta: 10,
                        maxTrailingBelowDelta: 2000,
                    },
                    { filterType: 'MAX_POSITION', maxPosition: '10.00000000' },
                    { filterType: 'MAX_NUM_ICEBERG_ORDERS', maxNumIcebergOrders: 5 },
                    { filterType: 'MAX_NUM_ALGO_ORDERS', maxNumAlgoOrders: 5 },
                    { filterType: 'MAX_NUM_ORDERS', maxNumOrders: 25 },
                    {
                        filterType: 'MARKET_LOT_SIZE',
                        minQty: '0.00100000',
                        maxQty: '100000.00000000',
                        stepSize: '0.00100000',
                    },
                    { filterType: 'ICEBERG_PARTS', limit: 10 },
                    {
                        filterType: 'NOTIONAL',
                        minNotional: '10.00000000',
                        applyMinToMarket: false,
                        maxNotional: '10000.00000000',
                        applyMaxToMarket: false,
                        avgPriceMins: 5,
                    },
                    {
                        filterType: 'MIN_NOTIONAL',
                        minNotional: '0.00100000',
                        applyToMarket: true,
                        avgPriceMins: 5,
                    },
                    {
                        filterType: 'LOT_SIZE',
                        minQty: '0.00100000',
                        maxQty: '100000.00000000',
                        stepSize: '0.00100000',
                    },
                    {
                        filterType: 'PERCENT_PRICE_BY_SIDE',
                        bidMultiplierUp: '1.2',
                        bidMultiplierDown: '0.2',
                        askMultiplierUp: '5',
                        askMultiplierDown: '0.8',
                        avgPriceMins: 1,
                    },
                    {
                        filterType: 'PERCENT_PRICE',
                        multiplierUp: '1.3000',
                        multiplierDown: '0.7000',
                        avgPriceMins: 5,
                    },
                    {
                        filterType: 'PRICE_FILTER',
                        minPrice: '0.00000100',
                        maxPrice: '100000.00000000',
                        tickSize: '0.00000100',
                    },
                ],
                symbols: [
                    {
                        symbol: 'ETHBTC',
                        status: 'TRADING',
                        baseAsset: 'ETH',
                        baseAssetPrecision: 8,
                        quoteAsset: 'BTC',
                        quotePrecision: 8,
                        quoteAssetPrecision: 8,
                        baseCommissionPrecision: 8,
                        quoteCommissionPrecision: 8,
                        orderTypes: [
                            'LIMIT LIMIT_MAKER MARKET STOP_LOSS STOP_LOSS_LIMIT TAKE_PROFIT TAKE_PROFIT_LIMIT',
                        ],
                        icebergAllowed: true,
                        ocoAllowed: true,
                        otoAllowed: true,
                        quoteOrderQtyMarketAllowed: true,
                        allowTrailingStop: false,
                        cancelReplaceAllowed: false,
                        amendAllowed: false,
                        isSpotTradingAllowed: true,
                        isMarginTradingAllowed: true,
                        filters: [
                            {
                                filterType: 'EXCHANGE_MAX_NUM_ICEBERG_ORDERS',
                                maxNumIcebergOrders: 10000,
                            },
                            { filterType: 'EXCHANGE_MAX_NUM_ALGO_ORDERS', maxNumAlgoOrders: 200 },
                            { filterType: 'EXCHANGE_MAX_NUM_ORDERS', maxNumOrders: 1000 },
                            {
                                filterType: 'TRAILING_DELTA',
                                minTrailingAboveDelta: 10,
                                maxTrailingAboveDelta: 2000,
                                minTrailingBelowDelta: 10,
                                maxTrailingBelowDelta: 2000,
                            },
                            { filterType: 'MAX_POSITION', maxPosition: '10.00000000' },
                            { filterType: 'MAX_NUM_ICEBERG_ORDERS', maxNumIcebergOrders: 5 },
                            { filterType: 'MAX_NUM_ALGO_ORDERS', maxNumAlgoOrders: 5 },
                            { filterType: 'MAX_NUM_ORDERS', maxNumOrders: 25 },
                            {
                                filterType: 'MARKET_LOT_SIZE',
                                minQty: '0.00100000',
                                maxQty: '100000.00000000',
                                stepSize: '0.00100000',
                            },
                            { filterType: 'ICEBERG_PARTS', limit: 10 },
                            {
                                filterType: 'NOTIONAL',
                                minNotional: '10.00000000',
                                applyMinToMarket: false,
                                maxNotional: '10000.00000000',
                                applyMaxToMarket: false,
                                avgPriceMins: 5,
                            },
                            {
                                filterType: 'MIN_NOTIONAL',
                                minNotional: '0.00100000',
                                applyToMarket: true,
                                avgPriceMins: 5,
                            },
                            {
                                filterType: 'LOT_SIZE',
                                minQty: '0.00100000',
                                maxQty: '100000.00000000',
                                stepSize: '0.00100000',
                            },
                            {
                                filterType: 'PERCENT_PRICE_BY_SIDE',
                                bidMultiplierUp: '1.2',
                                bidMultiplierDown: '0.2',
                                askMultiplierUp: '5',
                                askMultiplierDown: '0.8',
                                avgPriceMins: 1,
                            },
                            {
                                filterType: 'PERCENT_PRICE',
                                multiplierUp: '1.3000',
                                multiplierDown: '0.7000',
                                avgPriceMins: 5,
                            },
                            {
                                filterType: 'PRICE_FILTER',
                                minPrice: '0.00000100',
                                maxPrice: '100000.00000000',
                                tickSize: '0.00000100',
                            },
                        ],
                        permissions: [],
                        permissionSets: [['SPOT', 'MARGIN']],
                        defaultSelfTradePreventionMode: 'NONE',
                        allowedSelfTradePreventionModes: ['NONE'],
                    },
                ],
            };

            const spy = jest.spyOn(client, 'exchangeInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ExchangeInfoResponse>)
            );
            const response = await client.exchangeInfo(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'exchangeInfo').mockRejectedValueOnce(mockError);
            await expect(client.exchangeInfo()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('ping()', () => {
        it('should execute ping() successfully with required parameters only', async () => {
            const spy = jest.spyOn(client, 'ping').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.ping();

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'ping').mockRejectedValueOnce(mockError);
            await expect(client.ping()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('time()', () => {
        it('should execute time() successfully with required parameters only', async () => {
            mockResponse = { serverTime: 1499827319559 };

            const spy = jest.spyOn(client, 'time').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TimeResponse>)
            );
            const response = await client.time();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'time').mockRejectedValueOnce(mockError);
            await expect(client.time()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
