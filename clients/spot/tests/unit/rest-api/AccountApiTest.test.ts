/**
 * Binance Spot REST API
 *
 * OpenAPI Specifications for the Binance Spot REST API
 *
 * API documents:
 * - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)
 * - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)
 *
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { AccountApi } from '../../../src/rest-api';
import {
    AccountCommissionRequest,
    AllOrderListRequest,
    AllOrdersRequest,
    GetAccountRequest,
    GetOpenOrdersRequest,
    GetOrderRequest,
    GetOrderListRequest,
    MyAllocationsRequest,
    MyPreventedMatchesRequest,
    MyTradesRequest,
    OpenOrderListRequest,
    OrderAmendmentsRequest,
    RateLimitOrderRequest,
} from '../../../src/rest-api';
import type {
    AccountCommissionResponse,
    AllOrderListResponse,
    AllOrdersResponse,
    GetAccountResponse,
    GetOpenOrdersResponse,
    GetOrderListResponse,
    GetOrderResponse,
    MyAllocationsResponse,
    MyPreventedMatchesResponse,
    MyTradesResponse,
    OpenOrderListResponse,
    OrderAmendmentsResponse,
    RateLimitOrderResponse,
} from '../../../src/rest-api/types';

describe('AccountApi', () => {
    let client: AccountApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new AccountApi(config);
    });

    describe('accountCommission()', () => {
        it('should execute accountCommission() successfully with required parameters only', async () => {
            const params: AccountCommissionRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                standardCommission: {
                    maker: '0.00000010',
                    taker: '0.00000020',
                    buyer: '0.00000030',
                    seller: '0.00000040',
                },
                taxCommission: {
                    maker: '0.00000112',
                    taker: '0.00000114',
                    buyer: '0.00000118',
                    seller: '0.00000116',
                },
                discount: {
                    enabledForAccount: true,
                    enabledForSymbol: true,
                    discountAsset: 'BNB',
                    discount: '0.75000000',
                },
            };

            const spy = jest.spyOn(client, 'accountCommission').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountCommissionResponse>)
            );
            const response = await client.accountCommission(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute accountCommission() successfully with optional parameters', async () => {
            const params: AccountCommissionRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                standardCommission: {
                    maker: '0.00000010',
                    taker: '0.00000020',
                    buyer: '0.00000030',
                    seller: '0.00000040',
                },
                taxCommission: {
                    maker: '0.00000112',
                    taker: '0.00000114',
                    buyer: '0.00000118',
                    seller: '0.00000116',
                },
                discount: {
                    enabledForAccount: true,
                    enabledForSymbol: true,
                    discountAsset: 'BNB',
                    discount: '0.75000000',
                },
            };

            const spy = jest.spyOn(client, 'accountCommission').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountCommissionResponse>)
            );
            const response = await client.accountCommission(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: AccountCommissionRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.accountCommission(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling accountCommission.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AccountCommissionRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'accountCommission').mockRejectedValueOnce(mockError);
            await expect(client.accountCommission(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('allOrderList()', () => {
        it('should execute allOrderList() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    orderListId: 29,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'amEEAXryFzFwYF1FeRpUoZ',
                    transactionTime: 1565245913483,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'Jr1h6xirOxgeJOUuYQS7V3' },
                        { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'oD7aesZqjEGlZrbtRpy5zB' },
                    ],
                },
                {
                    orderListId: 28,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'hG7hFNxJV6cZy3Ze4AUT4d',
                    transactionTime: 1565245913407,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'j6lFOfbmFMRjTYA7rRJ0LP' },
                        { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'z0KCjOdditiLS5ekAFtK81' },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'allOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AllOrderListResponse>)
            );
            const response = await client.allOrderList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute allOrderList() successfully with optional parameters', async () => {
            const params: AllOrderListRequest = {
                fromId: 1,
                startTime: 1735693200000,
                endTime: 1735693200000,
                limit: 500,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    orderListId: 29,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'amEEAXryFzFwYF1FeRpUoZ',
                    transactionTime: 1565245913483,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'Jr1h6xirOxgeJOUuYQS7V3' },
                        { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'oD7aesZqjEGlZrbtRpy5zB' },
                    ],
                },
                {
                    orderListId: 28,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'hG7hFNxJV6cZy3Ze4AUT4d',
                    transactionTime: 1565245913407,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'j6lFOfbmFMRjTYA7rRJ0LP' },
                        { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'z0KCjOdditiLS5ekAFtK81' },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'allOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AllOrderListResponse>)
            );
            const response = await client.allOrderList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'allOrderList').mockRejectedValueOnce(mockError);
            await expect(client.allOrderList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('allOrders()', () => {
        it('should execute allOrders() successfully with required parameters only', async () => {
            const params: AllOrdersRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = [
                {
                    symbol: 'LTCBTC',
                    orderId: 1,
                    orderListId: -1,
                    clientOrderId: 'myOrder1',
                    price: '0.1',
                    origQty: '1.0',
                    executedQty: '0.0',
                    cummulativeQuoteQty: '0.0',
                    status: 'NEW',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    stopPrice: '0.0',
                    icebergQty: '0.0',
                    time: 1499827319559,
                    updateTime: 1499827319559,
                    isWorking: true,
                    origQuoteOrderQty: '0.000000',
                    workingTime: 1499827319559,
                    selfTradePreventionMode: 'NONE',
                },
            ];

            const spy = jest.spyOn(client, 'allOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AllOrdersResponse>)
            );
            const response = await client.allOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute allOrders() successfully with optional parameters', async () => {
            const params: AllOrdersRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
                startTime: 1735693200000,
                endTime: 1735693200000,
                limit: 500,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'LTCBTC',
                    orderId: 1,
                    orderListId: -1,
                    clientOrderId: 'myOrder1',
                    price: '0.1',
                    origQty: '1.0',
                    executedQty: '0.0',
                    cummulativeQuoteQty: '0.0',
                    status: 'NEW',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    stopPrice: '0.0',
                    icebergQty: '0.0',
                    time: 1499827319559,
                    updateTime: 1499827319559,
                    isWorking: true,
                    origQuoteOrderQty: '0.000000',
                    workingTime: 1499827319559,
                    selfTradePreventionMode: 'NONE',
                },
            ];

            const spy = jest.spyOn(client, 'allOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AllOrdersResponse>)
            );
            const response = await client.allOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: AllOrdersRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.allOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling allOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AllOrdersRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'allOrders').mockRejectedValueOnce(mockError);
            await expect(client.allOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getAccount()', () => {
        it('should execute getAccount() successfully with required parameters only', async () => {
            mockResponse = {
                makerCommission: 15,
                takerCommission: 15,
                buyerCommission: 0,
                sellerCommission: 0,
                commissionRates: {
                    maker: '0.00150000',
                    taker: '0.00150000',
                    buyer: '0.00000000',
                    seller: '0.00000000',
                },
                canTrade: true,
                canWithdraw: true,
                canDeposit: true,
                brokered: false,
                requireSelfTradePrevention: false,
                preventSor: false,
                updateTime: 123456789,
                accountType: 'SPOT',
                balances: [
                    { asset: 'LTC', free: '4763368.68006011', locked: '0.00000000' },
                    { asset: 'BTC', free: '4723846.89208129', locked: '0.00000000' },
                ],
                permissions: ['SPOT'],
                uid: 354937868,
            };

            const spy = jest.spyOn(client, 'getAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetAccountResponse>)
            );
            const response = await client.getAccount();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getAccount() successfully with optional parameters', async () => {
            const params: GetAccountRequest = {
                omitZeroBalances: false,
                recvWindow: 5000,
            };

            mockResponse = {
                makerCommission: 15,
                takerCommission: 15,
                buyerCommission: 0,
                sellerCommission: 0,
                commissionRates: {
                    maker: '0.00150000',
                    taker: '0.00150000',
                    buyer: '0.00000000',
                    seller: '0.00000000',
                },
                canTrade: true,
                canWithdraw: true,
                canDeposit: true,
                brokered: false,
                requireSelfTradePrevention: false,
                preventSor: false,
                updateTime: 123456789,
                accountType: 'SPOT',
                balances: [
                    { asset: 'LTC', free: '4763368.68006011', locked: '0.00000000' },
                    { asset: 'BTC', free: '4723846.89208129', locked: '0.00000000' },
                ],
                permissions: ['SPOT'],
                uid: 354937868,
            };

            const spy = jest.spyOn(client, 'getAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetAccountResponse>)
            );
            const response = await client.getAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getAccount').mockRejectedValueOnce(mockError);
            await expect(client.getAccount()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getOpenOrders()', () => {
        it('should execute getOpenOrders() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    symbol: 'LTCBTC',
                    orderId: 1,
                    orderListId: -1,
                    clientOrderId: 'myOrder1',
                    price: '0.1',
                    origQty: '1.0',
                    executedQty: '0.0',
                    cummulativeQuoteQty: '0.0',
                    status: 'NEW',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    stopPrice: '0.0',
                    icebergQty: '0.0',
                    time: 1499827319559,
                    updateTime: 1499827319559,
                    isWorking: true,
                    origQuoteOrderQty: '0.000000',
                    workingTime: 1499827319559,
                    selfTradePreventionMode: 'NONE',
                },
            ];

            const spy = jest.spyOn(client, 'getOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOpenOrdersResponse>)
            );
            const response = await client.getOpenOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOpenOrders() successfully with optional parameters', async () => {
            const params: GetOpenOrdersRequest = {
                symbol: 'BNBUSDT',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'LTCBTC',
                    orderId: 1,
                    orderListId: -1,
                    clientOrderId: 'myOrder1',
                    price: '0.1',
                    origQty: '1.0',
                    executedQty: '0.0',
                    cummulativeQuoteQty: '0.0',
                    status: 'NEW',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                    stopPrice: '0.0',
                    icebergQty: '0.0',
                    time: 1499827319559,
                    updateTime: 1499827319559,
                    isWorking: true,
                    origQuoteOrderQty: '0.000000',
                    workingTime: 1499827319559,
                    selfTradePreventionMode: 'NONE',
                },
            ];

            const spy = jest.spyOn(client, 'getOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOpenOrdersResponse>)
            );
            const response = await client.getOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getOpenOrders').mockRejectedValueOnce(mockError);
            await expect(client.getOpenOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getOrder()', () => {
        it('should execute getOrder() successfully with required parameters only', async () => {
            const params: GetOrderRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = {
                symbol: 'LTCBTC',
                orderId: 1,
                orderListId: -1,
                clientOrderId: 'myOrder1',
                price: '0.1',
                origQty: '1.0',
                executedQty: '0.0',
                cummulativeQuoteQty: '0.0',
                status: 'NEW',
                timeInForce: 'GTC',
                type: 'LIMIT',
                side: 'BUY',
                stopPrice: '0.0',
                icebergQty: '0.0',
                time: 1499827319559,
                updateTime: 1499827319559,
                isWorking: true,
                workingTime: 1499827319559,
                origQuoteOrderQty: '0.000000',
                selfTradePreventionMode: 'NONE',
            };

            const spy = jest.spyOn(client, 'getOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOrderResponse>)
            );
            const response = await client.getOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOrder() successfully with optional parameters', async () => {
            const params: GetOrderRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
                origClientOrderId: 'origClientOrderId_example',
                recvWindow: 5000,
            };

            mockResponse = {
                symbol: 'LTCBTC',
                orderId: 1,
                orderListId: -1,
                clientOrderId: 'myOrder1',
                price: '0.1',
                origQty: '1.0',
                executedQty: '0.0',
                cummulativeQuoteQty: '0.0',
                status: 'NEW',
                timeInForce: 'GTC',
                type: 'LIMIT',
                side: 'BUY',
                stopPrice: '0.0',
                icebergQty: '0.0',
                time: 1499827319559,
                updateTime: 1499827319559,
                isWorking: true,
                workingTime: 1499827319559,
                origQuoteOrderQty: '0.000000',
                selfTradePreventionMode: 'NONE',
            };

            const spy = jest.spyOn(client, 'getOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOrderResponse>)
            );
            const response = await client.getOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: GetOrderRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.getOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling getOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetOrderRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getOrder').mockRejectedValueOnce(mockError);
            await expect(client.getOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getOrderList()', () => {
        it('should execute getOrderList() successfully with required parameters only', async () => {
            mockResponse = {
                orderListId: 27,
                contingencyType: 'OCO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'h2USkA5YQpaXHPIrkd96xE',
                transactionTime: 1565245656253,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'ARzZ9I00CPM8i3NhmU9Ega' },
                    { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'qD1gy3kc3Gx0rihm9Y3xwS' },
                ],
            };

            const spy = jest.spyOn(client, 'getOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOrderListResponse>)
            );
            const response = await client.getOrderList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOrderList() successfully with optional parameters', async () => {
            const params: GetOrderListRequest = {
                orderListId: 1,
                origClientOrderId: 'origClientOrderId_example',
                recvWindow: 5000,
            };

            mockResponse = {
                orderListId: 27,
                contingencyType: 'OCO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'h2USkA5YQpaXHPIrkd96xE',
                transactionTime: 1565245656253,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'ARzZ9I00CPM8i3NhmU9Ega' },
                    { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'qD1gy3kc3Gx0rihm9Y3xwS' },
                ],
            };

            const spy = jest.spyOn(client, 'getOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOrderListResponse>)
            );
            const response = await client.getOrderList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getOrderList').mockRejectedValueOnce(mockError);
            await expect(client.getOrderList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('myAllocations()', () => {
        it('should execute myAllocations() successfully with required parameters only', async () => {
            const params: MyAllocationsRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    allocationId: 0,
                    allocationType: 'SOR',
                    orderId: 1,
                    orderListId: -1,
                    price: '1.00000000',
                    qty: '5.00000000',
                    quoteQty: '5.00000000',
                    commission: '0.00000000',
                    commissionAsset: 'BTC',
                    time: 1687506878118,
                    isBuyer: true,
                    isMaker: false,
                    isAllocator: false,
                },
            ];

            const spy = jest.spyOn(client, 'myAllocations').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MyAllocationsResponse>)
            );
            const response = await client.myAllocations(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute myAllocations() successfully with optional parameters', async () => {
            const params: MyAllocationsRequest = {
                symbol: 'BNBUSDT',
                startTime: 1735693200000,
                endTime: 1735693200000,
                fromAllocationId: 1,
                limit: 500,
                orderId: 1,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    allocationId: 0,
                    allocationType: 'SOR',
                    orderId: 1,
                    orderListId: -1,
                    price: '1.00000000',
                    qty: '5.00000000',
                    quoteQty: '5.00000000',
                    commission: '0.00000000',
                    commissionAsset: 'BTC',
                    time: 1687506878118,
                    isBuyer: true,
                    isMaker: false,
                    isAllocator: false,
                },
            ];

            const spy = jest.spyOn(client, 'myAllocations').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MyAllocationsResponse>)
            );
            const response = await client.myAllocations(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MyAllocationsRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.myAllocations(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling myAllocations.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MyAllocationsRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'myAllocations').mockRejectedValueOnce(mockError);
            await expect(client.myAllocations(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('myPreventedMatches()', () => {
        it('should execute myPreventedMatches() successfully with required parameters only', async () => {
            const params: MyPreventedMatchesRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    preventedMatchId: 1,
                    takerOrderId: 5,
                    makerSymbol: 'BTCUSDT',
                    makerOrderId: 3,
                    tradeGroupId: 1,
                    selfTradePreventionMode: 'EXPIRE_MAKER',
                    price: '1.100000',
                    makerPreventedQuantity: '1.300000',
                    transactTime: 1669101687094,
                },
            ];

            const spy = jest.spyOn(client, 'myPreventedMatches').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MyPreventedMatchesResponse>)
            );
            const response = await client.myPreventedMatches(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute myPreventedMatches() successfully with optional parameters', async () => {
            const params: MyPreventedMatchesRequest = {
                symbol: 'BNBUSDT',
                preventedMatchId: 1,
                orderId: 1,
                fromPreventedMatchId: 1,
                limit: 500,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    preventedMatchId: 1,
                    takerOrderId: 5,
                    makerSymbol: 'BTCUSDT',
                    makerOrderId: 3,
                    tradeGroupId: 1,
                    selfTradePreventionMode: 'EXPIRE_MAKER',
                    price: '1.100000',
                    makerPreventedQuantity: '1.300000',
                    transactTime: 1669101687094,
                },
            ];

            const spy = jest.spyOn(client, 'myPreventedMatches').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MyPreventedMatchesResponse>)
            );
            const response = await client.myPreventedMatches(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MyPreventedMatchesRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.myPreventedMatches(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling myPreventedMatches.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MyPreventedMatchesRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'myPreventedMatches').mockRejectedValueOnce(mockError);
            await expect(client.myPreventedMatches(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('myTrades()', () => {
        it('should execute myTrades() successfully with required parameters only', async () => {
            const params: MyTradesRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = [
                {
                    symbol: 'BNBBTC',
                    id: 28457,
                    orderId: 100234,
                    orderListId: -1,
                    price: '4.00000100',
                    qty: '12.00000000',
                    quoteQty: '48.000012',
                    commission: '10.10000000',
                    commissionAsset: 'BNB',
                    time: 1499865549590,
                    isBuyer: true,
                    isMaker: false,
                    isBestMatch: true,
                },
            ];

            const spy = jest.spyOn(client, 'myTrades').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MyTradesResponse>)
            );
            const response = await client.myTrades(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute myTrades() successfully with optional parameters', async () => {
            const params: MyTradesRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
                startTime: 1735693200000,
                endTime: 1735693200000,
                fromId: 1,
                limit: 500,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'BNBBTC',
                    id: 28457,
                    orderId: 100234,
                    orderListId: -1,
                    price: '4.00000100',
                    qty: '12.00000000',
                    quoteQty: '48.000012',
                    commission: '10.10000000',
                    commissionAsset: 'BNB',
                    time: 1499865549590,
                    isBuyer: true,
                    isMaker: false,
                    isBestMatch: true,
                },
            ];

            const spy = jest.spyOn(client, 'myTrades').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MyTradesResponse>)
            );
            const response = await client.myTrades(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MyTradesRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.myTrades(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling myTrades.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MyTradesRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'myTrades').mockRejectedValueOnce(mockError);
            await expect(client.myTrades(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('openOrderList()', () => {
        it('should execute openOrderList() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    orderListId: 31,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'wuB13fmulKj3YjdqWEcsnp',
                    transactionTime: 1565246080644,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'Cv1SnyPD3qhqpbjpYEHbd2' },
                        { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'r3EH2N76dHfLoSZWIUw1bT' },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'openOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenOrderListResponse>)
            );
            const response = await client.openOrderList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute openOrderList() successfully with optional parameters', async () => {
            const params: OpenOrderListRequest = {
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    orderListId: 31,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'wuB13fmulKj3YjdqWEcsnp',
                    transactionTime: 1565246080644,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'Cv1SnyPD3qhqpbjpYEHbd2' },
                        { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'r3EH2N76dHfLoSZWIUw1bT' },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'openOrderList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenOrderListResponse>)
            );
            const response = await client.openOrderList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'openOrderList').mockRejectedValueOnce(mockError);
            await expect(client.openOrderList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderAmendments()', () => {
        it('should execute orderAmendments() successfully with required parameters only', async () => {
            const params: OrderAmendmentsRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    orderId: 9,
                    executionId: 22,
                    origClientOrderId: 'W0fJ9fiLKHOJutovPK3oJp',
                    newClientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi',
                    origQty: '5.00000000',
                    newQty: '4.00000000',
                    time: 1741669661670,
                },
                {
                    symbol: 'BTCUDST',
                    orderId: 9,
                    executionId: 25,
                    origClientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi',
                    newClientOrderId: '5uS0r35ohuQyDlCzZuYXq2',
                    origQty: '4.00000000',
                    newQty: '3.00000000',
                    time: 1741672924895,
                },
            ];

            const spy = jest.spyOn(client, 'orderAmendments').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderAmendmentsResponse>)
            );
            const response = await client.orderAmendments(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderAmendments() successfully with optional parameters', async () => {
            const params: OrderAmendmentsRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
                fromExecutionId: 1,
                limit: 500,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    orderId: 9,
                    executionId: 22,
                    origClientOrderId: 'W0fJ9fiLKHOJutovPK3oJp',
                    newClientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi',
                    origQty: '5.00000000',
                    newQty: '4.00000000',
                    time: 1741669661670,
                },
                {
                    symbol: 'BTCUDST',
                    orderId: 9,
                    executionId: 25,
                    origClientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi',
                    newClientOrderId: '5uS0r35ohuQyDlCzZuYXq2',
                    origQty: '4.00000000',
                    newQty: '3.00000000',
                    time: 1741672924895,
                },
            ];

            const spy = jest.spyOn(client, 'orderAmendments').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderAmendmentsResponse>)
            );
            const response = await client.orderAmendments(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderAmendmentsRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderAmendments(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderAmendments.'
            );
        });

        it('should throw RequiredError when orderId is missing', async () => {
            const _params: OrderAmendmentsRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.orderId;

            await expect(client.orderAmendments(params)).rejects.toThrow(
                'Required parameter orderId was null or undefined when calling orderAmendments.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderAmendmentsRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderAmendments').mockRejectedValueOnce(mockError);
            await expect(client.orderAmendments(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('rateLimitOrder()', () => {
        it('should execute rateLimitOrder() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    rateLimitType: 'ORDERS',
                    interval: 'SECOND',
                    intervalNum: 10,
                    limit: 50,
                    count: 0,
                },
                {
                    rateLimitType: 'ORDERS',
                    interval: 'DAY',
                    intervalNum: 1,
                    limit: 160000,
                    count: 0,
                },
            ];

            const spy = jest.spyOn(client, 'rateLimitOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RateLimitOrderResponse>)
            );
            const response = await client.rateLimitOrder();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute rateLimitOrder() successfully with optional parameters', async () => {
            const params: RateLimitOrderRequest = {
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    rateLimitType: 'ORDERS',
                    interval: 'SECOND',
                    intervalNum: 10,
                    limit: 50,
                    count: 0,
                },
                {
                    rateLimitType: 'ORDERS',
                    interval: 'DAY',
                    intervalNum: 1,
                    limit: 160000,
                    count: 0,
                },
            ];

            const spy = jest.spyOn(client, 'rateLimitOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RateLimitOrderResponse>)
            );
            const response = await client.rateLimitOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'rateLimitOrder').mockRejectedValueOnce(mockError);
            await expect(client.rateLimitOrder()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
