/**
 * Binance Spot REST API
 *
 * OpenAPI Specifications for the Binance Spot REST API
 *
 * API documents:
 * - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)
 * - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)
 *
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { AccountApi } from '../../../src/rest-api';
import {
    AccountCommissionRequest,
    GetAccountRequest,
    MyAllocationsRequest,
    MyPreventedMatchesRequest,
    MyTradesRequest,
    OrderAmendmentsRequest,
    RateLimitOrderRequest,
} from '../../../src/rest-api';
import type {
    AccountCommissionResponse,
    GetAccountResponse,
    MyAllocationsResponse,
    MyPreventedMatchesResponse,
    MyTradesResponse,
    OrderAmendmentsResponse,
    RateLimitOrderResponse,
} from '../../../src/rest-api/types';

describe('AccountApi', () => {
    let client: AccountApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new AccountApi(config);
    });

    describe('accountCommission()', () => {
        it('should execute accountCommission() successfully with required parameters only', async () => {
            const params: AccountCommissionRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                standardCommission: {
                    maker: '0.00000010',
                    taker: '0.00000020',
                    buyer: '0.00000030',
                    seller: '0.00000040',
                },
                taxCommission: {
                    maker: '0.00000112',
                    taker: '0.00000114',
                    buyer: '0.00000118',
                    seller: '0.00000116',
                },
                discount: {
                    enabledForAccount: true,
                    enabledForSymbol: true,
                    discountAsset: 'BNB',
                    discount: '0.75000000',
                },
            };

            const spy = jest.spyOn(client, 'accountCommission').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountCommissionResponse>)
            );
            const response = await client.accountCommission(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute accountCommission() successfully with optional parameters', async () => {
            const params: AccountCommissionRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                standardCommission: {
                    maker: '0.00000010',
                    taker: '0.00000020',
                    buyer: '0.00000030',
                    seller: '0.00000040',
                },
                taxCommission: {
                    maker: '0.00000112',
                    taker: '0.00000114',
                    buyer: '0.00000118',
                    seller: '0.00000116',
                },
                discount: {
                    enabledForAccount: true,
                    enabledForSymbol: true,
                    discountAsset: 'BNB',
                    discount: '0.75000000',
                },
            };

            const spy = jest.spyOn(client, 'accountCommission').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountCommissionResponse>)
            );
            const response = await client.accountCommission(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: AccountCommissionRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.accountCommission(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling accountCommission.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AccountCommissionRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'accountCommission').mockRejectedValueOnce(mockError);
            await expect(client.accountCommission(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getAccount()', () => {
        it('should execute getAccount() successfully with required parameters only', async () => {
            mockResponse = {
                makerCommission: 15,
                takerCommission: 15,
                buyerCommission: 0,
                sellerCommission: 0,
                commissionRates: {
                    maker: '0.00150000',
                    taker: '0.00150000',
                    buyer: '0.00000000',
                    seller: '0.00000000',
                },
                canTrade: true,
                canWithdraw: true,
                canDeposit: true,
                brokered: false,
                requireSelfTradePrevention: false,
                preventSor: false,
                updateTime: 123456789,
                accountType: 'SPOT',
                balances: [
                    { asset: 'BTC', free: '4723846.89208129', locked: '0.00000000' },
                    { asset: 'LTC', free: '4763368.68006011', locked: '0.00000000' },
                ],
                permissions: ['SPOT'],
                uid: 354937868,
            };

            const spy = jest.spyOn(client, 'getAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetAccountResponse>)
            );
            const response = await client.getAccount();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getAccount() successfully with optional parameters', async () => {
            const params: GetAccountRequest = {
                omitZeroBalances: false,
                recvWindow: 5000,
            };

            mockResponse = {
                makerCommission: 15,
                takerCommission: 15,
                buyerCommission: 0,
                sellerCommission: 0,
                commissionRates: {
                    maker: '0.00150000',
                    taker: '0.00150000',
                    buyer: '0.00000000',
                    seller: '0.00000000',
                },
                canTrade: true,
                canWithdraw: true,
                canDeposit: true,
                brokered: false,
                requireSelfTradePrevention: false,
                preventSor: false,
                updateTime: 123456789,
                accountType: 'SPOT',
                balances: [
                    { asset: 'BTC', free: '4723846.89208129', locked: '0.00000000' },
                    { asset: 'LTC', free: '4763368.68006011', locked: '0.00000000' },
                ],
                permissions: ['SPOT'],
                uid: 354937868,
            };

            const spy = jest.spyOn(client, 'getAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetAccountResponse>)
            );
            const response = await client.getAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getAccount').mockRejectedValueOnce(mockError);
            await expect(client.getAccount()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('myAllocations()', () => {
        it('should execute myAllocations() successfully with required parameters only', async () => {
            const params: MyAllocationsRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    allocationId: 0,
                    allocationType: 'SOR',
                    orderId: 1,
                    orderListId: -1,
                    price: '1.00000000',
                    qty: '5.00000000',
                    quoteQty: '5.00000000',
                    commission: '0.00000000',
                    commissionAsset: 'BTC',
                    time: 1687506878118,
                    isBuyer: true,
                    isMaker: false,
                    isAllocator: false,
                },
            ];

            const spy = jest.spyOn(client, 'myAllocations').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MyAllocationsResponse>)
            );
            const response = await client.myAllocations(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute myAllocations() successfully with optional parameters', async () => {
            const params: MyAllocationsRequest = {
                symbol: 'BNBUSDT',
                startTime: 1735693200000,
                endTime: 1735693200000,
                fromAllocationId: 1,
                limit: 500,
                orderId: 1,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    allocationId: 0,
                    allocationType: 'SOR',
                    orderId: 1,
                    orderListId: -1,
                    price: '1.00000000',
                    qty: '5.00000000',
                    quoteQty: '5.00000000',
                    commission: '0.00000000',
                    commissionAsset: 'BTC',
                    time: 1687506878118,
                    isBuyer: true,
                    isMaker: false,
                    isAllocator: false,
                },
            ];

            const spy = jest.spyOn(client, 'myAllocations').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MyAllocationsResponse>)
            );
            const response = await client.myAllocations(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MyAllocationsRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.myAllocations(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling myAllocations.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MyAllocationsRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'myAllocations').mockRejectedValueOnce(mockError);
            await expect(client.myAllocations(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('myPreventedMatches()', () => {
        it('should execute myPreventedMatches() successfully with required parameters only', async () => {
            const params: MyPreventedMatchesRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    preventedMatchId: 1,
                    takerOrderId: 5,
                    makerSymbol: 'BTCUSDT',
                    makerOrderId: 3,
                    tradeGroupId: 1,
                    selfTradePreventionMode: 'EXPIRE_MAKER',
                    price: '1.100000',
                    makerPreventedQuantity: '1.300000',
                    transactTime: 1669101687094,
                },
            ];

            const spy = jest.spyOn(client, 'myPreventedMatches').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MyPreventedMatchesResponse>)
            );
            const response = await client.myPreventedMatches(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute myPreventedMatches() successfully with optional parameters', async () => {
            const params: MyPreventedMatchesRequest = {
                symbol: 'BNBUSDT',
                preventedMatchId: 1,
                orderId: 1,
                fromPreventedMatchId: 1,
                limit: 500,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    preventedMatchId: 1,
                    takerOrderId: 5,
                    makerSymbol: 'BTCUSDT',
                    makerOrderId: 3,
                    tradeGroupId: 1,
                    selfTradePreventionMode: 'EXPIRE_MAKER',
                    price: '1.100000',
                    makerPreventedQuantity: '1.300000',
                    transactTime: 1669101687094,
                },
            ];

            const spy = jest.spyOn(client, 'myPreventedMatches').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MyPreventedMatchesResponse>)
            );
            const response = await client.myPreventedMatches(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MyPreventedMatchesRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.myPreventedMatches(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling myPreventedMatches.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MyPreventedMatchesRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'myPreventedMatches').mockRejectedValueOnce(mockError);
            await expect(client.myPreventedMatches(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('myTrades()', () => {
        it('should execute myTrades() successfully with required parameters only', async () => {
            const params: MyTradesRequest = {
                symbol: 'BNBUSDT',
            };

            mockResponse = [
                {
                    symbol: 'BNBBTC',
                    id: 28457,
                    orderId: 100234,
                    orderListId: -1,
                    price: '4.00000100',
                    qty: '12.00000000',
                    quoteQty: '48.000012',
                    commission: '10.10000000',
                    commissionAsset: 'BNB',
                    time: 1499865549590,
                    isBuyer: true,
                    isMaker: false,
                    isBestMatch: true,
                },
            ];

            const spy = jest.spyOn(client, 'myTrades').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MyTradesResponse>)
            );
            const response = await client.myTrades(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute myTrades() successfully with optional parameters', async () => {
            const params: MyTradesRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
                startTime: 1735693200000,
                endTime: 1735693200000,
                fromId: 1,
                limit: 500,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'BNBBTC',
                    id: 28457,
                    orderId: 100234,
                    orderListId: -1,
                    price: '4.00000100',
                    qty: '12.00000000',
                    quoteQty: '48.000012',
                    commission: '10.10000000',
                    commissionAsset: 'BNB',
                    time: 1499865549590,
                    isBuyer: true,
                    isMaker: false,
                    isBestMatch: true,
                },
            ];

            const spy = jest.spyOn(client, 'myTrades').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MyTradesResponse>)
            );
            const response = await client.myTrades(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MyTradesRequest = {
                symbol: 'BNBUSDT',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.myTrades(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling myTrades.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MyTradesRequest = {
                symbol: 'BNBUSDT',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'myTrades').mockRejectedValueOnce(mockError);
            await expect(client.myTrades(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderAmendments()', () => {
        it('should execute orderAmendments() successfully with required parameters only', async () => {
            const params: OrderAmendmentsRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    orderId: 9,
                    executionId: 22,
                    origClientOrderId: 'W0fJ9fiLKHOJutovPK3oJp',
                    newClientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi',
                    origQty: '5.00000000',
                    newQty: '4.00000000',
                    time: 1741669661670,
                },
                {
                    symbol: 'BTCUDST',
                    orderId: 9,
                    executionId: 25,
                    origClientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi',
                    newClientOrderId: '5uS0r35ohuQyDlCzZuYXq2',
                    origQty: '4.00000000',
                    newQty: '3.00000000',
                    time: 1741672924895,
                },
            ];

            const spy = jest.spyOn(client, 'orderAmendments').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderAmendmentsResponse>)
            );
            const response = await client.orderAmendments(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderAmendments() successfully with optional parameters', async () => {
            const params: OrderAmendmentsRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
                fromExecutionId: 1,
                limit: 500,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    orderId: 9,
                    executionId: 22,
                    origClientOrderId: 'W0fJ9fiLKHOJutovPK3oJp',
                    newClientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi',
                    origQty: '5.00000000',
                    newQty: '4.00000000',
                    time: 1741669661670,
                },
                {
                    symbol: 'BTCUDST',
                    orderId: 9,
                    executionId: 25,
                    origClientOrderId: 'UQ1Np3bmQ71jJzsSDW9Vpi',
                    newClientOrderId: '5uS0r35ohuQyDlCzZuYXq2',
                    origQty: '4.00000000',
                    newQty: '3.00000000',
                    time: 1741672924895,
                },
            ];

            const spy = jest.spyOn(client, 'orderAmendments').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderAmendmentsResponse>)
            );
            const response = await client.orderAmendments(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderAmendmentsRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderAmendments(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderAmendments.'
            );
        });

        it('should throw RequiredError when orderId is missing', async () => {
            const _params: OrderAmendmentsRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.orderId;

            await expect(client.orderAmendments(params)).rejects.toThrow(
                'Required parameter orderId was null or undefined when calling orderAmendments.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderAmendmentsRequest = {
                symbol: 'BNBUSDT',
                orderId: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderAmendments').mockRejectedValueOnce(mockError);
            await expect(client.orderAmendments(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('rateLimitOrder()', () => {
        it('should execute rateLimitOrder() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    rateLimitType: 'ORDERS',
                    interval: 'SECOND',
                    intervalNum: 10,
                    limit: 50,
                    count: 0,
                },
                {
                    rateLimitType: 'ORDERS',
                    interval: 'DAY',
                    intervalNum: 1,
                    limit: 160000,
                    count: 0,
                },
            ];

            const spy = jest.spyOn(client, 'rateLimitOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RateLimitOrderResponse>)
            );
            const response = await client.rateLimitOrder();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute rateLimitOrder() successfully with optional parameters', async () => {
            const params: RateLimitOrderRequest = {
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    rateLimitType: 'ORDERS',
                    interval: 'SECOND',
                    intervalNum: 10,
                    limit: 50,
                    count: 0,
                },
                {
                    rateLimitType: 'ORDERS',
                    interval: 'DAY',
                    intervalNum: 1,
                    limit: 160000,
                    count: 0,
                },
            ];

            const spy = jest.spyOn(client, 'rateLimitOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RateLimitOrderResponse>)
            );
            const response = await client.rateLimitOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'rateLimitOrder').mockRejectedValueOnce(mockError);
            await expect(client.rateLimitOrder()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
