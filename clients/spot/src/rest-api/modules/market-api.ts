/**
 * Binance Spot REST API
 *
 * OpenAPI Specifications for the Binance Spot REST API
 *
 * API documents:
 * - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)
 * - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)
 *
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
    ConfigurationRestAPI,
    TimeUnit,
    RestApiResponse,
    assertParamExists,
    sendRequest,
    type RequestArgs,
} from '@binance/common';
import type {
    AggTradesResponse,
    AvgPriceResponse,
    DepthResponse,
    GetTradesResponse,
    HistoricalTradesResponse,
    KlinesResponse,
    Ticker24hrResponse,
    TickerBookTickerResponse,
    TickerPriceResponse,
    TickerResponse,
    TickerTradingDayResponse,
    UiKlinesResponse,
} from '../types';

/**
 * MarketApi - axios parameter creator
 */
const MarketApiAxiosParamCreator = function (configuration: ConfigurationRestAPI) {
    return {
        /**
         * Get compressed, aggregate trades. Trades that fill at the time, from the same taker order, with the same price will have the quantity aggregated.
         * Weight: 4
         *
         * @summary Compressed/Aggregate trades list
         * @param {string} symbol
         * @param {number} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {number} [limit] Default: 500; Maximum: 1000.
         *
         * @throws {RequiredError}
         */
        aggTrades: async (
            symbol: string,
            fromId?: number,
            startTime?: number,
            endTime?: number,
            limit?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('aggTrades', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (fromId !== undefined && fromId !== null) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/aggTrades',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Current average price for a symbol.
         * Weight: 2
         *
         * @summary Current average price
         * @param {string} symbol
         *
         * @throws {RequiredError}
         */
        avgPrice: async (symbol: string): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('avgPrice', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/avgPrice',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         *
         * Weight: Adjusted based on the limit:
         *
         * |Limit|Request Weight
         * ------|-------
         * 1-100|  5
         * 101-500| 25
         * 501-1000| 50
         * 1001-5000| 250
         *
         * @summary Order book
         * @param {string} symbol
         * @param {number} [limit] Default: 500; Maximum: 1000.
         *
         * @throws {RequiredError}
         */
        depth: async (symbol: string, limit?: number): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('depth', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/depth',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get recent trades.
         * Weight: 25
         *
         * @summary Recent trades list
         * @param {string} symbol
         * @param {number} [limit] Default: 500; Maximum: 1000.
         *
         * @throws {RequiredError}
         */
        getTrades: async (symbol: string, limit?: number): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getTrades', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/trades',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get older trades.
         * Weight: 25
         *
         * @summary Old trade lookup
         * @param {string} symbol
         * @param {number} [limit] Default: 500; Maximum: 1000.
         * @param {number} [fromId] ID to get aggregate trades from INCLUSIVE.
         *
         * @throws {RequiredError}
         */
        historicalTrades: async (
            symbol: string,
            limit?: number,
            fromId?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('historicalTrades', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fromId !== undefined && fromId !== null) {
                localVarQueryParameter['fromId'] = fromId;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/historicalTrades',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Kline/candlestick bars for a symbol.
         * Klines are uniquely identified by their open time.
         * Weight: 2
         *
         * @summary Kline/Candlestick data
         * @param {string} symbol
         * @param {KlinesIntervalEnum} [interval]
         * @param {number} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {string} [timeZone] Default: 0 (UTC)
         * @param {number} [limit] Default: 500; Maximum: 1000.
         *
         * @throws {RequiredError}
         */
        klines: async (
            symbol: string,
            interval?: KlinesIntervalEnum,
            startTime?: number,
            endTime?: number,
            timeZone?: string,
            limit?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('klines', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined && interval !== null) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (timeZone !== undefined && timeZone !== null) {
                localVarQueryParameter['timeZone'] = timeZone;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/klines',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         *
         * Weight: 4 for each requested <tt>symbol</tt> regardless of <tt>windowSize</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.
         *
         * @summary Rolling window price change statistics
         * @param {string} [symbol] Symbol to query
         * @param {Array<string>} [symbols] List of symbols to query
         * @param {TickerWindowSizeEnum} [windowSize]
         * @param {TickerTypeEnum} [type]
         *
         * @throws {RequiredError}
         */
        ticker: async (
            symbol?: string,
            symbols?: Array<string>,
            windowSize?: TickerWindowSizeEnum,
            type?: TickerTypeEnum
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (symbols) {
                localVarQueryParameter['symbols'] = symbols;
            }

            if (windowSize !== undefined && windowSize !== null) {
                localVarQueryParameter['windowSize'] = windowSize;
            }

            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/ticker',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * 24 hour rolling window price change statistics. **Careful** when accessing this with no symbol.
         * Weight: <table>
         * <thead>
         * <tr>
         * <th>Parameter</th>
         * <th>Symbols Provided</th>
         * <th>Weight</th>
         * </tr>
         * </thead>
         * <tbody>
         * <tr>
         * <td rowspan="2">symbol</td>
         * <td>1</td>
         * <td>2</td>
         * </tr>
         * <tr>
         * <td>symbol parameter is omitted</td>
         * <td>80</td>
         * </tr>
         * <tr>
         * <td rowspan="4">symbols</td>
         * <td>1-20</td>
         * <td>2</td>
         * </tr>
         * <tr>
         * <td>21-100</td>
         * <td>40</td>
         * </tr>
         * <tr>
         * <td>101 or more</td>
         * <td>80</td>
         * </tr>
         * <tr>
         * <td>symbols parameter is omitted</td>
         * <td>80</td>
         * </tr>
         * </tbody>
         * </table>
         *
         * @summary 24hr ticker price change statistics
         * @param {string} [symbol] Symbol to query
         * @param {Array<string>} [symbols] List of symbols to query
         * @param {Ticker24hrTypeEnum} [type]
         *
         * @throws {RequiredError}
         */
        ticker24hr: async (
            symbol?: string,
            symbols?: Array<string>,
            type?: Ticker24hrTypeEnum
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (symbols) {
                localVarQueryParameter['symbols'] = symbols;
            }

            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/ticker/24hr',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         * Weight: <table>
         * <thead>
         * <tr>
         * <th>Parameter</th>
         * <th>Symbols Provided</th>
         * <th>Weight</th>
         * </tr>
         * </thead>
         * <tbody>
         * <tr>
         * <td rowspan="2">symbol</td>
         * <td>1</td>
         * <td>2</td>
         * </tr>
         * <tr>
         * <td>symbol parameter is omitted</td>
         * <td>4</td>
         * </tr>
         * <tr>
         * <td>symbols</td>
         * <td>Any</td>
         * <td>4</td>
         * </tr>
         * </tbody>
         * </table>
         *
         * @summary Symbol order book ticker
         * @param {string} [symbol] Symbol to query
         * @param {Array<string>} [symbols] List of symbols to query
         *
         * @throws {RequiredError}
         */
        tickerBookTicker: async (
            symbol?: string,
            symbols?: Array<string>
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (symbols) {
                localVarQueryParameter['symbols'] = symbols;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/ticker/bookTicker',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Latest price for a symbol or symbols.
         * Weight: <table>
         * <thead>
         * <tr>
         * <th>Parameter</th>
         * <th>Symbols Provided</th>
         * <th>Weight</th>
         * </tr>
         * </thead>
         * <tbody>
         * <tr>
         * <td rowspan="2">symbol</td>
         * <td>1</td>
         * <td>2</td>
         * </tr>
         * <tr>
         * <td>symbol parameter is omitted</td>
         * <td>4</td>
         * </tr>
         * <tr>
         * <td>symbols</td>
         * <td>Any</td>
         * <td>4</td>
         * </tr>
         * </tbody>
         * </table>
         *
         * @summary Symbol price ticker
         * @param {string} [symbol] Symbol to query
         * @param {Array<string>} [symbols] List of symbols to query
         *
         * @throws {RequiredError}
         */
        tickerPrice: async (symbol?: string, symbols?: Array<string>): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (symbols) {
                localVarQueryParameter['symbols'] = symbols;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/ticker/price',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Price change statistics for a trading day.
         * Weight: 4 for each requested <tt>symbol</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.
         *
         * @summary Trading Day Ticker
         * @param {string} [symbol] Symbol to query
         * @param {Array<string>} [symbols] List of symbols to query
         * @param {string} [timeZone] Default: 0 (UTC)
         * @param {TickerTradingDayTypeEnum} [type]
         *
         * @throws {RequiredError}
         */
        tickerTradingDay: async (
            symbol?: string,
            symbols?: Array<string>,
            timeZone?: string,
            type?: TickerTradingDayTypeEnum
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (symbols) {
                localVarQueryParameter['symbols'] = symbols;
            }

            if (timeZone !== undefined && timeZone !== null) {
                localVarQueryParameter['timeZone'] = timeZone;
            }

            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/ticker/tradingDay',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * The request is similar to klines having the same parameters and response.
         *
         * `uiKlines` return modified kline data, optimized for presentation of candlestick charts.
         * Weight: 2
         *
         * @summary UIKlines
         * @param {string} symbol
         * @param {UiKlinesIntervalEnum} [interval]
         * @param {number} [startTime] Timestamp in ms to get aggregate trades from INCLUSIVE.
         * @param {number} [endTime] Timestamp in ms to get aggregate trades until INCLUSIVE.
         * @param {string} [timeZone] Default: 0 (UTC)
         * @param {number} [limit] Default: 500; Maximum: 1000.
         *
         * @throws {RequiredError}
         */
        uiKlines: async (
            symbol: string,
            interval?: UiKlinesIntervalEnum,
            startTime?: number,
            endTime?: number,
            timeZone?: string,
            limit?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('uiKlines', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined && interval !== null) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (timeZone !== undefined && timeZone !== null) {
                localVarQueryParameter['timeZone'] = timeZone;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/api/v3/uiKlines',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
    };
};

/**
 * MarketApi - interface
 * @interface MarketApi
 */
export interface MarketApiInterface {
    /**
     * Get compressed, aggregate trades. Trades that fill at the time, from the same taker order, with the same price will have the quantity aggregated.
     * Weight: 4
     *
     * @summary Compressed/Aggregate trades list
     * @param {AggTradesRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    aggTrades(requestParameters: AggTradesRequest): Promise<RestApiResponse<AggTradesResponse>>;
    /**
     * Current average price for a symbol.
     * Weight: 2
     *
     * @summary Current average price
     * @param {AvgPriceRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    avgPrice(requestParameters: AvgPriceRequest): Promise<RestApiResponse<AvgPriceResponse>>;
    /**
     *
     * Weight: Adjusted based on the limit:
     *
     * |Limit|Request Weight
     * ------|-------
     * 1-100|  5
     * 101-500| 25
     * 501-1000| 50
     * 1001-5000| 250
     *
     * @summary Order book
     * @param {DepthRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    depth(requestParameters: DepthRequest): Promise<RestApiResponse<DepthResponse>>;
    /**
     * Get recent trades.
     * Weight: 25
     *
     * @summary Recent trades list
     * @param {GetTradesRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    getTrades(requestParameters: GetTradesRequest): Promise<RestApiResponse<GetTradesResponse>>;
    /**
     * Get older trades.
     * Weight: 25
     *
     * @summary Old trade lookup
     * @param {HistoricalTradesRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    historicalTrades(
        requestParameters: HistoricalTradesRequest
    ): Promise<RestApiResponse<HistoricalTradesResponse>>;
    /**
     * Kline/candlestick bars for a symbol.
     * Klines are uniquely identified by their open time.
     * Weight: 2
     *
     * @summary Kline/Candlestick data
     * @param {KlinesRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    klines(requestParameters: KlinesRequest): Promise<RestApiResponse<KlinesResponse>>;
    /**
     *
     * Weight: 4 for each requested <tt>symbol</tt> regardless of <tt>windowSize</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.
     *
     * @summary Rolling window price change statistics
     * @param {TickerRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    ticker(requestParameters?: TickerRequest): Promise<RestApiResponse<TickerResponse>>;
    /**
     * 24 hour rolling window price change statistics. **Careful** when accessing this with no symbol.
     * Weight: <table>
     * <thead>
     * <tr>
     * <th>Parameter</th>
     * <th>Symbols Provided</th>
     * <th>Weight</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td rowspan="2">symbol</td>
     * <td>1</td>
     * <td>2</td>
     * </tr>
     * <tr>
     * <td>symbol parameter is omitted</td>
     * <td>80</td>
     * </tr>
     * <tr>
     * <td rowspan="4">symbols</td>
     * <td>1-20</td>
     * <td>2</td>
     * </tr>
     * <tr>
     * <td>21-100</td>
     * <td>40</td>
     * </tr>
     * <tr>
     * <td>101 or more</td>
     * <td>80</td>
     * </tr>
     * <tr>
     * <td>symbols parameter is omitted</td>
     * <td>80</td>
     * </tr>
     * </tbody>
     * </table>
     *
     * @summary 24hr ticker price change statistics
     * @param {Ticker24hrRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    ticker24hr(requestParameters?: Ticker24hrRequest): Promise<RestApiResponse<Ticker24hrResponse>>;
    /**
     * Best price/qty on the order book for a symbol or symbols.
     * Weight: <table>
     * <thead>
     * <tr>
     * <th>Parameter</th>
     * <th>Symbols Provided</th>
     * <th>Weight</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td rowspan="2">symbol</td>
     * <td>1</td>
     * <td>2</td>
     * </tr>
     * <tr>
     * <td>symbol parameter is omitted</td>
     * <td>4</td>
     * </tr>
     * <tr>
     * <td>symbols</td>
     * <td>Any</td>
     * <td>4</td>
     * </tr>
     * </tbody>
     * </table>
     *
     * @summary Symbol order book ticker
     * @param {TickerBookTickerRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    tickerBookTicker(
        requestParameters?: TickerBookTickerRequest
    ): Promise<RestApiResponse<TickerBookTickerResponse>>;
    /**
     * Latest price for a symbol or symbols.
     * Weight: <table>
     * <thead>
     * <tr>
     * <th>Parameter</th>
     * <th>Symbols Provided</th>
     * <th>Weight</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td rowspan="2">symbol</td>
     * <td>1</td>
     * <td>2</td>
     * </tr>
     * <tr>
     * <td>symbol parameter is omitted</td>
     * <td>4</td>
     * </tr>
     * <tr>
     * <td>symbols</td>
     * <td>Any</td>
     * <td>4</td>
     * </tr>
     * </tbody>
     * </table>
     *
     * @summary Symbol price ticker
     * @param {TickerPriceRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    tickerPrice(
        requestParameters?: TickerPriceRequest
    ): Promise<RestApiResponse<TickerPriceResponse>>;
    /**
     * Price change statistics for a trading day.
     * Weight: 4 for each requested <tt>symbol</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.
     *
     * @summary Trading Day Ticker
     * @param {TickerTradingDayRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    tickerTradingDay(
        requestParameters?: TickerTradingDayRequest
    ): Promise<RestApiResponse<TickerTradingDayResponse>>;
    /**
     * The request is similar to klines having the same parameters and response.
     *
     * `uiKlines` return modified kline data, optimized for presentation of candlestick charts.
     * Weight: 2
     *
     * @summary UIKlines
     * @param {UiKlinesRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApiInterface
     */
    uiKlines(requestParameters: UiKlinesRequest): Promise<RestApiResponse<UiKlinesResponse>>;
}

/**
 * Request parameters for aggTrades operation in MarketApi.
 * @interface AggTradesRequest
 */
export interface AggTradesRequest {
    /**
     *
     * @type {string}
     * @memberof MarketApiAggTrades
     */
    readonly symbol: string;

    /**
     * ID to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof MarketApiAggTrades
     */
    readonly fromId?: number;

    /**
     * Timestamp in ms to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof MarketApiAggTrades
     */
    readonly startTime?: number;

    /**
     * Timestamp in ms to get aggregate trades until INCLUSIVE.
     * @type {number}
     * @memberof MarketApiAggTrades
     */
    readonly endTime?: number;

    /**
     * Default: 500; Maximum: 1000.
     * @type {number}
     * @memberof MarketApiAggTrades
     */
    readonly limit?: number;
}

/**
 * Request parameters for avgPrice operation in MarketApi.
 * @interface AvgPriceRequest
 */
export interface AvgPriceRequest {
    /**
     *
     * @type {string}
     * @memberof MarketApiAvgPrice
     */
    readonly symbol: string;
}

/**
 * Request parameters for depth operation in MarketApi.
 * @interface DepthRequest
 */
export interface DepthRequest {
    /**
     *
     * @type {string}
     * @memberof MarketApiDepth
     */
    readonly symbol: string;

    /**
     * Default: 500; Maximum: 1000.
     * @type {number}
     * @memberof MarketApiDepth
     */
    readonly limit?: number;
}

/**
 * Request parameters for getTrades operation in MarketApi.
 * @interface GetTradesRequest
 */
export interface GetTradesRequest {
    /**
     *
     * @type {string}
     * @memberof MarketApiGetTrades
     */
    readonly symbol: string;

    /**
     * Default: 500; Maximum: 1000.
     * @type {number}
     * @memberof MarketApiGetTrades
     */
    readonly limit?: number;
}

/**
 * Request parameters for historicalTrades operation in MarketApi.
 * @interface HistoricalTradesRequest
 */
export interface HistoricalTradesRequest {
    /**
     *
     * @type {string}
     * @memberof MarketApiHistoricalTrades
     */
    readonly symbol: string;

    /**
     * Default: 500; Maximum: 1000.
     * @type {number}
     * @memberof MarketApiHistoricalTrades
     */
    readonly limit?: number;

    /**
     * ID to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof MarketApiHistoricalTrades
     */
    readonly fromId?: number;
}

/**
 * Request parameters for klines operation in MarketApi.
 * @interface KlinesRequest
 */
export interface KlinesRequest {
    /**
     *
     * @type {string}
     * @memberof MarketApiKlines
     */
    readonly symbol: string;

    /**
     *
     * @type {'1s' | '1m' | '3m' | '5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '8h' | '12h' | '1d' | '3d' | '1w' | '1M'}
     * @memberof MarketApiKlines
     */
    readonly interval?: KlinesIntervalEnum;

    /**
     * Timestamp in ms to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof MarketApiKlines
     */
    readonly startTime?: number;

    /**
     * Timestamp in ms to get aggregate trades until INCLUSIVE.
     * @type {number}
     * @memberof MarketApiKlines
     */
    readonly endTime?: number;

    /**
     * Default: 0 (UTC)
     * @type {string}
     * @memberof MarketApiKlines
     */
    readonly timeZone?: string;

    /**
     * Default: 500; Maximum: 1000.
     * @type {number}
     * @memberof MarketApiKlines
     */
    readonly limit?: number;
}

/**
 * Request parameters for ticker operation in MarketApi.
 * @interface TickerRequest
 */
export interface TickerRequest {
    /**
     * Symbol to query
     * @type {string}
     * @memberof MarketApiTicker
     */
    readonly symbol?: string;

    /**
     * List of symbols to query
     * @type {Array<string>}
     * @memberof MarketApiTicker
     */
    readonly symbols?: Array<string>;

    /**
     *
     * @type {'1m' | '2m' | '3m' | '4m' | '5m' | '6m' | '7m' | '8m' | '9m' | '10m' | '11m' | '12m' | '13m' | '14m' | '15m' | '16m' | '17m' | '18m' | '19m' | '20m' | '21m' | '22m' | '23m' | '24m' | '25m' | '26m' | '27m' | '28m' | '29m' | '30m' | '31m' | '32m' | '33m' | '34m' | '35m' | '36m' | '37m' | '38m' | '39m' | '40m' | '41m' | '42m' | '43m' | '44m' | '45m' | '46m' | '47m' | '48m' | '49m' | '50m' | '51m' | '52m' | '53m' | '54m' | '55m' | '56m' | '57m' | '58m' | '59m' | '1h' | '2h' | '3h' | '4h' | '5h' | '6h' | '7h' | '8h' | '9h' | '10h' | '11h' | '12h' | '13h' | '14h' | '15h' | '16h' | '17h' | '18h' | '19h' | '20h' | '21h' | '22h' | '23h' | '1d' | '2d' | '3d' | '4d' | '5d' | '6d'}
     * @memberof MarketApiTicker
     */
    readonly windowSize?: TickerWindowSizeEnum;

    /**
     *
     * @type {'FULL' | 'MINI'}
     * @memberof MarketApiTicker
     */
    readonly type?: TickerTypeEnum;
}

/**
 * Request parameters for ticker24hr operation in MarketApi.
 * @interface Ticker24hrRequest
 */
export interface Ticker24hrRequest {
    /**
     * Symbol to query
     * @type {string}
     * @memberof MarketApiTicker24hr
     */
    readonly symbol?: string;

    /**
     * List of symbols to query
     * @type {Array<string>}
     * @memberof MarketApiTicker24hr
     */
    readonly symbols?: Array<string>;

    /**
     *
     * @type {'FULL' | 'MINI'}
     * @memberof MarketApiTicker24hr
     */
    readonly type?: Ticker24hrTypeEnum;
}

/**
 * Request parameters for tickerBookTicker operation in MarketApi.
 * @interface TickerBookTickerRequest
 */
export interface TickerBookTickerRequest {
    /**
     * Symbol to query
     * @type {string}
     * @memberof MarketApiTickerBookTicker
     */
    readonly symbol?: string;

    /**
     * List of symbols to query
     * @type {Array<string>}
     * @memberof MarketApiTickerBookTicker
     */
    readonly symbols?: Array<string>;
}

/**
 * Request parameters for tickerPrice operation in MarketApi.
 * @interface TickerPriceRequest
 */
export interface TickerPriceRequest {
    /**
     * Symbol to query
     * @type {string}
     * @memberof MarketApiTickerPrice
     */
    readonly symbol?: string;

    /**
     * List of symbols to query
     * @type {Array<string>}
     * @memberof MarketApiTickerPrice
     */
    readonly symbols?: Array<string>;
}

/**
 * Request parameters for tickerTradingDay operation in MarketApi.
 * @interface TickerTradingDayRequest
 */
export interface TickerTradingDayRequest {
    /**
     * Symbol to query
     * @type {string}
     * @memberof MarketApiTickerTradingDay
     */
    readonly symbol?: string;

    /**
     * List of symbols to query
     * @type {Array<string>}
     * @memberof MarketApiTickerTradingDay
     */
    readonly symbols?: Array<string>;

    /**
     * Default: 0 (UTC)
     * @type {string}
     * @memberof MarketApiTickerTradingDay
     */
    readonly timeZone?: string;

    /**
     *
     * @type {'FULL' | 'MINI'}
     * @memberof MarketApiTickerTradingDay
     */
    readonly type?: TickerTradingDayTypeEnum;
}

/**
 * Request parameters for uiKlines operation in MarketApi.
 * @interface UiKlinesRequest
 */
export interface UiKlinesRequest {
    /**
     *
     * @type {string}
     * @memberof MarketApiUiKlines
     */
    readonly symbol: string;

    /**
     *
     * @type {'1s' | '1m' | '3m' | '5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '8h' | '12h' | '1d' | '3d' | '1w' | '1M'}
     * @memberof MarketApiUiKlines
     */
    readonly interval?: UiKlinesIntervalEnum;

    /**
     * Timestamp in ms to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof MarketApiUiKlines
     */
    readonly startTime?: number;

    /**
     * Timestamp in ms to get aggregate trades until INCLUSIVE.
     * @type {number}
     * @memberof MarketApiUiKlines
     */
    readonly endTime?: number;

    /**
     * Default: 0 (UTC)
     * @type {string}
     * @memberof MarketApiUiKlines
     */
    readonly timeZone?: string;

    /**
     * Default: 500; Maximum: 1000.
     * @type {number}
     * @memberof MarketApiUiKlines
     */
    readonly limit?: number;
}

/**
 * MarketApi - object-oriented interface
 * @class MarketApi
 */
export class MarketApi implements MarketApiInterface {
    private readonly configuration: ConfigurationRestAPI;
    private localVarAxiosParamCreator;

    constructor(configuration: ConfigurationRestAPI) {
        this.configuration = configuration;
        this.localVarAxiosParamCreator = MarketApiAxiosParamCreator(configuration);
    }

    /**
     * Get compressed, aggregate trades. Trades that fill at the time, from the same taker order, with the same price will have the quantity aggregated.
     * Weight: 4
     *
     * @summary Compressed/Aggregate trades list
     * @param {AggTradesRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<AggTradesResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#compressedaggregate-trades-list Binance API Documentation}
     */
    public async aggTrades(
        requestParameters: AggTradesRequest
    ): Promise<RestApiResponse<AggTradesResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.aggTrades(
            requestParameters?.symbol,
            requestParameters?.fromId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit
        );
        return sendRequest<AggTradesResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Current average price for a symbol.
     * Weight: 2
     *
     * @summary Current average price
     * @param {AvgPriceRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<AvgPriceResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#current-average-price Binance API Documentation}
     */
    public async avgPrice(
        requestParameters: AvgPriceRequest
    ): Promise<RestApiResponse<AvgPriceResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.avgPrice(
            requestParameters?.symbol
        );
        return sendRequest<AvgPriceResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     *
     * Weight: Adjusted based on the limit:
     *
     * |Limit|Request Weight
     * ------|-------
     * 1-100|  5
     * 101-500| 25
     * 501-1000| 50
     * 1001-5000| 250
     *
     * @summary Order book
     * @param {DepthRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<DepthResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#order-book Binance API Documentation}
     */
    public async depth(requestParameters: DepthRequest): Promise<RestApiResponse<DepthResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.depth(
            requestParameters?.symbol,
            requestParameters?.limit
        );
        return sendRequest<DepthResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Get recent trades.
     * Weight: 25
     *
     * @summary Recent trades list
     * @param {GetTradesRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetTradesResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#recent-trades-list Binance API Documentation}
     */
    public async getTrades(
        requestParameters: GetTradesRequest
    ): Promise<RestApiResponse<GetTradesResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getTrades(
            requestParameters?.symbol,
            requestParameters?.limit
        );
        return sendRequest<GetTradesResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Get older trades.
     * Weight: 25
     *
     * @summary Old trade lookup
     * @param {HistoricalTradesRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<HistoricalTradesResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#old-trade-lookup Binance API Documentation}
     */
    public async historicalTrades(
        requestParameters: HistoricalTradesRequest
    ): Promise<RestApiResponse<HistoricalTradesResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.historicalTrades(
            requestParameters?.symbol,
            requestParameters?.limit,
            requestParameters?.fromId
        );
        return sendRequest<HistoricalTradesResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Kline/candlestick bars for a symbol.
     * Klines are uniquely identified by their open time.
     * Weight: 2
     *
     * @summary Kline/Candlestick data
     * @param {KlinesRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<KlinesResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#klinecandlestick-data Binance API Documentation}
     */
    public async klines(
        requestParameters: KlinesRequest
    ): Promise<RestApiResponse<KlinesResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.klines(
            requestParameters?.symbol,
            requestParameters?.interval,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.timeZone,
            requestParameters?.limit
        );
        return sendRequest<KlinesResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     *
     * Weight: 4 for each requested <tt>symbol</tt> regardless of <tt>windowSize</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.
     *
     * @summary Rolling window price change statistics
     * @param {TickerRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<TickerResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#rolling-window-price-change-statistics Binance API Documentation}
     */
    public async ticker(
        requestParameters: TickerRequest = {}
    ): Promise<RestApiResponse<TickerResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.ticker(
            requestParameters?.symbol,
            requestParameters?.symbols,
            requestParameters?.windowSize,
            requestParameters?.type
        );
        return sendRequest<TickerResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * 24 hour rolling window price change statistics. **Careful** when accessing this with no symbol.
     * Weight: <table>
     * <thead>
     * <tr>
     * <th>Parameter</th>
     * <th>Symbols Provided</th>
     * <th>Weight</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td rowspan="2">symbol</td>
     * <td>1</td>
     * <td>2</td>
     * </tr>
     * <tr>
     * <td>symbol parameter is omitted</td>
     * <td>80</td>
     * </tr>
     * <tr>
     * <td rowspan="4">symbols</td>
     * <td>1-20</td>
     * <td>2</td>
     * </tr>
     * <tr>
     * <td>21-100</td>
     * <td>40</td>
     * </tr>
     * <tr>
     * <td>101 or more</td>
     * <td>80</td>
     * </tr>
     * <tr>
     * <td>symbols parameter is omitted</td>
     * <td>80</td>
     * </tr>
     * </tbody>
     * </table>
     *
     * @summary 24hr ticker price change statistics
     * @param {Ticker24hrRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<Ticker24hrResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#24hr-ticker-price-change-statistics Binance API Documentation}
     */
    public async ticker24hr(
        requestParameters: Ticker24hrRequest = {}
    ): Promise<RestApiResponse<Ticker24hrResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.ticker24hr(
            requestParameters?.symbol,
            requestParameters?.symbols,
            requestParameters?.type
        );
        return sendRequest<Ticker24hrResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Best price/qty on the order book for a symbol or symbols.
     * Weight: <table>
     * <thead>
     * <tr>
     * <th>Parameter</th>
     * <th>Symbols Provided</th>
     * <th>Weight</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td rowspan="2">symbol</td>
     * <td>1</td>
     * <td>2</td>
     * </tr>
     * <tr>
     * <td>symbol parameter is omitted</td>
     * <td>4</td>
     * </tr>
     * <tr>
     * <td>symbols</td>
     * <td>Any</td>
     * <td>4</td>
     * </tr>
     * </tbody>
     * </table>
     *
     * @summary Symbol order book ticker
     * @param {TickerBookTickerRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<TickerBookTickerResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#symbol-order-book-ticker Binance API Documentation}
     */
    public async tickerBookTicker(
        requestParameters: TickerBookTickerRequest = {}
    ): Promise<RestApiResponse<TickerBookTickerResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.tickerBookTicker(
            requestParameters?.symbol,
            requestParameters?.symbols
        );
        return sendRequest<TickerBookTickerResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Latest price for a symbol or symbols.
     * Weight: <table>
     * <thead>
     * <tr>
     * <th>Parameter</th>
     * <th>Symbols Provided</th>
     * <th>Weight</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td rowspan="2">symbol</td>
     * <td>1</td>
     * <td>2</td>
     * </tr>
     * <tr>
     * <td>symbol parameter is omitted</td>
     * <td>4</td>
     * </tr>
     * <tr>
     * <td>symbols</td>
     * <td>Any</td>
     * <td>4</td>
     * </tr>
     * </tbody>
     * </table>
     *
     * @summary Symbol price ticker
     * @param {TickerPriceRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<TickerPriceResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#symbol-price-ticker Binance API Documentation}
     */
    public async tickerPrice(
        requestParameters: TickerPriceRequest = {}
    ): Promise<RestApiResponse<TickerPriceResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.tickerPrice(
            requestParameters?.symbol,
            requestParameters?.symbols
        );
        return sendRequest<TickerPriceResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Price change statistics for a trading day.
     * Weight: 4 for each requested <tt>symbol</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.
     *
     * @summary Trading Day Ticker
     * @param {TickerTradingDayRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<TickerTradingDayResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#trading-day-ticker Binance API Documentation}
     */
    public async tickerTradingDay(
        requestParameters: TickerTradingDayRequest = {}
    ): Promise<RestApiResponse<TickerTradingDayResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.tickerTradingDay(
            requestParameters?.symbol,
            requestParameters?.symbols,
            requestParameters?.timeZone,
            requestParameters?.type
        );
        return sendRequest<TickerTradingDayResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * The request is similar to klines having the same parameters and response.
     *
     * `uiKlines` return modified kline data, optimized for presentation of candlestick charts.
     * Weight: 2
     *
     * @summary UIKlines
     * @param {UiKlinesRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<UiKlinesResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketApi
     * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#uiklines Binance API Documentation}
     */
    public async uiKlines(
        requestParameters: UiKlinesRequest
    ): Promise<RestApiResponse<UiKlinesResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.uiKlines(
            requestParameters?.symbol,
            requestParameters?.interval,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.timeZone,
            requestParameters?.limit
        );
        return sendRequest<UiKlinesResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }
}

export const KlinesIntervalEnum = {
    INTERVAL_1s: '1s',
    INTERVAL_1m: '1m',
    INTERVAL_3m: '3m',
    INTERVAL_5m: '5m',
    INTERVAL_15m: '15m',
    INTERVAL_30m: '30m',
    INTERVAL_1h: '1h',
    INTERVAL_2h: '2h',
    INTERVAL_4h: '4h',
    INTERVAL_6h: '6h',
    INTERVAL_8h: '8h',
    INTERVAL_12h: '12h',
    INTERVAL_1d: '1d',
    INTERVAL_3d: '3d',
    INTERVAL_1w: '1w',
    INTERVAL_1M: '1M',
} as const;
export type KlinesIntervalEnum = (typeof KlinesIntervalEnum)[keyof typeof KlinesIntervalEnum];

export const TickerWindowSizeEnum = {
    WINDOW_SIZE_1m: '1m',
    WINDOW_SIZE_2m: '2m',
    WINDOW_SIZE_3m: '3m',
    WINDOW_SIZE_4m: '4m',
    WINDOW_SIZE_5m: '5m',
    WINDOW_SIZE_6m: '6m',
    WINDOW_SIZE_7m: '7m',
    WINDOW_SIZE_8m: '8m',
    WINDOW_SIZE_9m: '9m',
    WINDOW_SIZE_10m: '10m',
    WINDOW_SIZE_11m: '11m',
    WINDOW_SIZE_12m: '12m',
    WINDOW_SIZE_13m: '13m',
    WINDOW_SIZE_14m: '14m',
    WINDOW_SIZE_15m: '15m',
    WINDOW_SIZE_16m: '16m',
    WINDOW_SIZE_17m: '17m',
    WINDOW_SIZE_18m: '18m',
    WINDOW_SIZE_19m: '19m',
    WINDOW_SIZE_20m: '20m',
    WINDOW_SIZE_21m: '21m',
    WINDOW_SIZE_22m: '22m',
    WINDOW_SIZE_23m: '23m',
    WINDOW_SIZE_24m: '24m',
    WINDOW_SIZE_25m: '25m',
    WINDOW_SIZE_26m: '26m',
    WINDOW_SIZE_27m: '27m',
    WINDOW_SIZE_28m: '28m',
    WINDOW_SIZE_29m: '29m',
    WINDOW_SIZE_30m: '30m',
    WINDOW_SIZE_31m: '31m',
    WINDOW_SIZE_32m: '32m',
    WINDOW_SIZE_33m: '33m',
    WINDOW_SIZE_34m: '34m',
    WINDOW_SIZE_35m: '35m',
    WINDOW_SIZE_36m: '36m',
    WINDOW_SIZE_37m: '37m',
    WINDOW_SIZE_38m: '38m',
    WINDOW_SIZE_39m: '39m',
    WINDOW_SIZE_40m: '40m',
    WINDOW_SIZE_41m: '41m',
    WINDOW_SIZE_42m: '42m',
    WINDOW_SIZE_43m: '43m',
    WINDOW_SIZE_44m: '44m',
    WINDOW_SIZE_45m: '45m',
    WINDOW_SIZE_46m: '46m',
    WINDOW_SIZE_47m: '47m',
    WINDOW_SIZE_48m: '48m',
    WINDOW_SIZE_49m: '49m',
    WINDOW_SIZE_50m: '50m',
    WINDOW_SIZE_51m: '51m',
    WINDOW_SIZE_52m: '52m',
    WINDOW_SIZE_53m: '53m',
    WINDOW_SIZE_54m: '54m',
    WINDOW_SIZE_55m: '55m',
    WINDOW_SIZE_56m: '56m',
    WINDOW_SIZE_57m: '57m',
    WINDOW_SIZE_58m: '58m',
    WINDOW_SIZE_59m: '59m',
    WINDOW_SIZE_1h: '1h',
    WINDOW_SIZE_2h: '2h',
    WINDOW_SIZE_3h: '3h',
    WINDOW_SIZE_4h: '4h',
    WINDOW_SIZE_5h: '5h',
    WINDOW_SIZE_6h: '6h',
    WINDOW_SIZE_7h: '7h',
    WINDOW_SIZE_8h: '8h',
    WINDOW_SIZE_9h: '9h',
    WINDOW_SIZE_10h: '10h',
    WINDOW_SIZE_11h: '11h',
    WINDOW_SIZE_12h: '12h',
    WINDOW_SIZE_13h: '13h',
    WINDOW_SIZE_14h: '14h',
    WINDOW_SIZE_15h: '15h',
    WINDOW_SIZE_16h: '16h',
    WINDOW_SIZE_17h: '17h',
    WINDOW_SIZE_18h: '18h',
    WINDOW_SIZE_19h: '19h',
    WINDOW_SIZE_20h: '20h',
    WINDOW_SIZE_21h: '21h',
    WINDOW_SIZE_22h: '22h',
    WINDOW_SIZE_23h: '23h',
    WINDOW_SIZE_1d: '1d',
    WINDOW_SIZE_2d: '2d',
    WINDOW_SIZE_3d: '3d',
    WINDOW_SIZE_4d: '4d',
    WINDOW_SIZE_5d: '5d',
    WINDOW_SIZE_6d: '6d',
} as const;
export type TickerWindowSizeEnum = (typeof TickerWindowSizeEnum)[keyof typeof TickerWindowSizeEnum];

export const TickerTypeEnum = {
    FULL: 'FULL',
    MINI: 'MINI',
} as const;
export type TickerTypeEnum = (typeof TickerTypeEnum)[keyof typeof TickerTypeEnum];
export const Ticker24hrTypeEnum = {
    FULL: 'FULL',
    MINI: 'MINI',
} as const;
export type Ticker24hrTypeEnum = (typeof Ticker24hrTypeEnum)[keyof typeof Ticker24hrTypeEnum];
export const TickerTradingDayTypeEnum = {
    FULL: 'FULL',
    MINI: 'MINI',
} as const;
export type TickerTradingDayTypeEnum =
    (typeof TickerTradingDayTypeEnum)[keyof typeof TickerTradingDayTypeEnum];
export const UiKlinesIntervalEnum = {
    INTERVAL_1s: '1s',
    INTERVAL_1m: '1m',
    INTERVAL_3m: '3m',
    INTERVAL_5m: '5m',
    INTERVAL_15m: '15m',
    INTERVAL_30m: '30m',
    INTERVAL_1h: '1h',
    INTERVAL_2h: '2h',
    INTERVAL_4h: '4h',
    INTERVAL_6h: '6h',
    INTERVAL_8h: '8h',
    INTERVAL_12h: '12h',
    INTERVAL_1d: '1d',
    INTERVAL_3d: '3d',
    INTERVAL_1w: '1w',
    INTERVAL_1M: '1M',
} as const;
export type UiKlinesIntervalEnum = (typeof UiKlinesIntervalEnum)[keyof typeof UiKlinesIntervalEnum];
