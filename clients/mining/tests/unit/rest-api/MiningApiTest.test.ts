/**
 * Binance Public Mining REST API
 *
 * OpenAPI Specification for the Binance Public Mining REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { MiningApi } from '../../../src/rest-api';
import {
    AccountListRequest,
    CancelHashrateResaleConfigurationRequest,
    EarningsListRequest,
    ExtraBonusListRequest,
    HashrateResaleDetailRequest,
    HashrateResaleListRequest,
    HashrateResaleRequestRequest,
    MiningAccountEarningRequest,
    RequestForDetailMinerListRequest,
    RequestForMinerListRequest,
    StatisticListRequest,
} from '../../../src/rest-api';
import type {
    AccountListResponse,
    AcquiringAlgorithmResponse,
    AcquiringCoinnameResponse,
    CancelHashrateResaleConfigurationResponse,
    EarningsListResponse,
    ExtraBonusListResponse,
    HashrateResaleDetailResponse,
    HashrateResaleListResponse,
    HashrateResaleRequestResponse,
    MiningAccountEarningResponse,
    RequestForDetailMinerListResponse,
    RequestForMinerListResponse,
    StatisticListResponse,
} from '../../../src/rest-api/types';

describe('MiningApi', () => {
    let client: MiningApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new MiningApi(config);
    });

    describe('accountList()', () => {
        it('should execute accountList() successfully with required parameters only', async () => {
            const params: AccountListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
            };

            mockResponse = {
                code: 0,
                msg: '',
                data: [
                    {
                        type: 'H_hashrate',
                        userName: 'test',
                        list: [
                            { time: 1585267200000, hashrate: '0.00000000', reject: '0.00000000' },
                            { time: 1585353600000, hashrate: '0.00000000', reject: '0.00000000' },
                        ],
                    },
                    {
                        type: 'D_hashrate',
                        userName: 'test',
                        list: [
                            { time: 1587906000000, hashrate: '0.00000000', reject: '0.00000000' },
                            { time: 1587909600000, hashrate: '0.00000000', reject: '0.00000000' },
                        ],
                    },
                ],
            };

            const spy = jest.spyOn(client, 'accountList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountListResponse>)
            );
            const response = await client.accountList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute accountList() successfully with optional parameters', async () => {
            const params: AccountListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
                recvWindow: 5000,
            };

            mockResponse = {
                code: 0,
                msg: '',
                data: [
                    {
                        type: 'H_hashrate',
                        userName: 'test',
                        list: [
                            { time: 1585267200000, hashrate: '0.00000000', reject: '0.00000000' },
                            { time: 1585353600000, hashrate: '0.00000000', reject: '0.00000000' },
                        ],
                    },
                    {
                        type: 'D_hashrate',
                        userName: 'test',
                        list: [
                            { time: 1587906000000, hashrate: '0.00000000', reject: '0.00000000' },
                            { time: 1587909600000, hashrate: '0.00000000', reject: '0.00000000' },
                        ],
                    },
                ],
            };

            const spy = jest.spyOn(client, 'accountList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountListResponse>)
            );
            const response = await client.accountList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when algo is missing', async () => {
            const _params: AccountListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.algo;

            await expect(client.accountList(params)).rejects.toThrow(
                'Required parameter algo was null or undefined when calling accountList.'
            );
        });

        it('should throw RequiredError when userName is missing', async () => {
            const _params: AccountListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.userName;

            await expect(client.accountList(params)).rejects.toThrow(
                'Required parameter userName was null or undefined when calling accountList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AccountListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'accountList').mockRejectedValueOnce(mockError);
            await expect(client.accountList(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('acquiringAlgorithm()', () => {
        it('should execute acquiringAlgorithm() successfully with required parameters only', async () => {
            mockResponse = {
                code: 0,
                msg: '',
                data: [{ algoName: 'sha256', algoId: 1, poolIndex: 0, unit: 'h/s' }],
            };

            const spy = jest.spyOn(client, 'acquiringAlgorithm').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AcquiringAlgorithmResponse>)
            );
            const response = await client.acquiringAlgorithm();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'acquiringAlgorithm').mockRejectedValueOnce(mockError);
            await expect(client.acquiringAlgorithm()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('acquiringCoinname()', () => {
        it('should execute acquiringCoinname() successfully with required parameters only', async () => {
            mockResponse = {
                code: 0,
                msg: '',
                data: [{ coinName: 'BTC', coinId: 1, poolIndex: 0, algoId: 1, algoName: 'sha256' }],
            };

            const spy = jest.spyOn(client, 'acquiringCoinname').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AcquiringCoinnameResponse>)
            );
            const response = await client.acquiringCoinname();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'acquiringCoinname').mockRejectedValueOnce(mockError);
            await expect(client.acquiringCoinname()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cancelHashrateResaleConfiguration()', () => {
        it('should execute cancelHashrateResaleConfiguration() successfully with required parameters only', async () => {
            const params: CancelHashrateResaleConfigurationRequest = {
                configId: 1,
                userName: 'userName_example',
            };

            mockResponse = { code: 0, msg: '', data: true };

            const spy = jest.spyOn(client, 'cancelHashrateResaleConfiguration').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelHashrateResaleConfigurationResponse>)
            );
            const response = await client.cancelHashrateResaleConfiguration(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelHashrateResaleConfiguration() successfully with optional parameters', async () => {
            const params: CancelHashrateResaleConfigurationRequest = {
                configId: 1,
                userName: 'userName_example',
                recvWindow: 5000,
            };

            mockResponse = { code: 0, msg: '', data: true };

            const spy = jest.spyOn(client, 'cancelHashrateResaleConfiguration').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelHashrateResaleConfigurationResponse>)
            );
            const response = await client.cancelHashrateResaleConfiguration(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when configId is missing', async () => {
            const _params: CancelHashrateResaleConfigurationRequest = {
                configId: 1,
                userName: 'userName_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.configId;

            await expect(client.cancelHashrateResaleConfiguration(params)).rejects.toThrow(
                'Required parameter configId was null or undefined when calling cancelHashrateResaleConfiguration.'
            );
        });

        it('should throw RequiredError when userName is missing', async () => {
            const _params: CancelHashrateResaleConfigurationRequest = {
                configId: 1,
                userName: 'userName_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.userName;

            await expect(client.cancelHashrateResaleConfiguration(params)).rejects.toThrow(
                'Required parameter userName was null or undefined when calling cancelHashrateResaleConfiguration.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelHashrateResaleConfigurationRequest = {
                configId: 1,
                userName: 'userName_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'cancelHashrateResaleConfiguration')
                .mockRejectedValueOnce(mockError);
            await expect(client.cancelHashrateResaleConfiguration(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('earningsList()', () => {
        it('should execute earningsList() successfully with required parameters only', async () => {
            const params: EarningsListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
            };

            mockResponse = {
                code: 0,
                msg: '',
                data: {
                    accountProfits: [
                        {
                            time: 1586188800000,
                            type: 31,
                            hashTransfer: null,
                            transferAmount: null,
                            dayHashRate: 129129903378244,
                            profitAmount: 8.6083060304,
                            coinName: 'BTC',
                            status: 2,
                        },
                        {
                            time: 1607529600000,
                            coinName: 'BTC',
                            type: 0,
                            dayHashRate: 9942053925926,
                            profitAmount: 0.85426469,
                            hashTransfer: 200000000000,
                            transferAmount: 0.02180958,
                            status: 2,
                        },
                        {
                            time: 1607443200000,
                            coinName: 'BTC',
                            type: 31,
                            dayHashRate: 200000000000,
                            profitAmount: 0.02905916,
                            hashTransfer: null,
                            transferAmount: null,
                            status: 2,
                        },
                    ],
                    totalNum: 3,
                    pageSize: 20,
                },
            };

            const spy = jest.spyOn(client, 'earningsList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<EarningsListResponse>)
            );
            const response = await client.earningsList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute earningsList() successfully with optional parameters', async () => {
            const params: EarningsListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
                coin: 'coin_example',
                startDate: 789,
                endDate: 789,
                pageIndex: 1,
                pageSize: 789,
                recvWindow: 5000,
            };

            mockResponse = {
                code: 0,
                msg: '',
                data: {
                    accountProfits: [
                        {
                            time: 1586188800000,
                            type: 31,
                            hashTransfer: null,
                            transferAmount: null,
                            dayHashRate: 129129903378244,
                            profitAmount: 8.6083060304,
                            coinName: 'BTC',
                            status: 2,
                        },
                        {
                            time: 1607529600000,
                            coinName: 'BTC',
                            type: 0,
                            dayHashRate: 9942053925926,
                            profitAmount: 0.85426469,
                            hashTransfer: 200000000000,
                            transferAmount: 0.02180958,
                            status: 2,
                        },
                        {
                            time: 1607443200000,
                            coinName: 'BTC',
                            type: 31,
                            dayHashRate: 200000000000,
                            profitAmount: 0.02905916,
                            hashTransfer: null,
                            transferAmount: null,
                            status: 2,
                        },
                    ],
                    totalNum: 3,
                    pageSize: 20,
                },
            };

            const spy = jest.spyOn(client, 'earningsList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<EarningsListResponse>)
            );
            const response = await client.earningsList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when algo is missing', async () => {
            const _params: EarningsListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.algo;

            await expect(client.earningsList(params)).rejects.toThrow(
                'Required parameter algo was null or undefined when calling earningsList.'
            );
        });

        it('should throw RequiredError when userName is missing', async () => {
            const _params: EarningsListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.userName;

            await expect(client.earningsList(params)).rejects.toThrow(
                'Required parameter userName was null or undefined when calling earningsList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: EarningsListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'earningsList').mockRejectedValueOnce(mockError);
            await expect(client.earningsList(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('extraBonusList()', () => {
        it('should execute extraBonusList() successfully with required parameters only', async () => {
            const params: ExtraBonusListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
            };

            mockResponse = {
                code: 0,
                msg: '',
                data: {
                    otherProfits: [
                        {
                            time: 1607443200000,
                            coinName: 'BTC',
                            type: 4,
                            profitAmount: 0.0011859,
                            status: 2,
                        },
                    ],
                    totalNum: 3,
                    pageSize: 20,
                },
            };

            const spy = jest.spyOn(client, 'extraBonusList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ExtraBonusListResponse>)
            );
            const response = await client.extraBonusList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute extraBonusList() successfully with optional parameters', async () => {
            const params: ExtraBonusListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
                coin: 'coin_example',
                startDate: 789,
                endDate: 789,
                pageIndex: 1,
                pageSize: 789,
                recvWindow: 5000,
            };

            mockResponse = {
                code: 0,
                msg: '',
                data: {
                    otherProfits: [
                        {
                            time: 1607443200000,
                            coinName: 'BTC',
                            type: 4,
                            profitAmount: 0.0011859,
                            status: 2,
                        },
                    ],
                    totalNum: 3,
                    pageSize: 20,
                },
            };

            const spy = jest.spyOn(client, 'extraBonusList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ExtraBonusListResponse>)
            );
            const response = await client.extraBonusList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when algo is missing', async () => {
            const _params: ExtraBonusListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.algo;

            await expect(client.extraBonusList(params)).rejects.toThrow(
                'Required parameter algo was null or undefined when calling extraBonusList.'
            );
        });

        it('should throw RequiredError when userName is missing', async () => {
            const _params: ExtraBonusListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.userName;

            await expect(client.extraBonusList(params)).rejects.toThrow(
                'Required parameter userName was null or undefined when calling extraBonusList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ExtraBonusListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'extraBonusList').mockRejectedValueOnce(mockError);
            await expect(client.extraBonusList(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('hashrateResaleDetail()', () => {
        it('should execute hashrateResaleDetail() successfully with required parameters only', async () => {
            const params: HashrateResaleDetailRequest = {
                configId: 1,
                userName: 'userName_example',
            };

            mockResponse = {
                code: 0,
                msg: '',
                data: {
                    profitTransferDetails: [
                        {
                            poolUsername: 'test4001',
                            toPoolUsername: 'pop',
                            algoName: 'sha256',
                            hashRate: 200000000000,
                            day: 20201213,
                            amount: 0.2256872,
                            coinName: 'BTC',
                        },
                        {
                            poolUsername: 'test4001',
                            toPoolUsername: 'pop',
                            algoName: 'sha256',
                            hashRate: 200000000000,
                            day: 20201213,
                            amount: 0.2256872,
                            coinName: 'BTC',
                        },
                    ],
                    totalNum: 8,
                    pageSize: 200,
                },
            };

            const spy = jest.spyOn(client, 'hashrateResaleDetail').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<HashrateResaleDetailResponse>)
            );
            const response = await client.hashrateResaleDetail(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute hashrateResaleDetail() successfully with optional parameters', async () => {
            const params: HashrateResaleDetailRequest = {
                configId: 1,
                userName: 'userName_example',
                pageIndex: 1,
                pageSize: 789,
                recvWindow: 5000,
            };

            mockResponse = {
                code: 0,
                msg: '',
                data: {
                    profitTransferDetails: [
                        {
                            poolUsername: 'test4001',
                            toPoolUsername: 'pop',
                            algoName: 'sha256',
                            hashRate: 200000000000,
                            day: 20201213,
                            amount: 0.2256872,
                            coinName: 'BTC',
                        },
                        {
                            poolUsername: 'test4001',
                            toPoolUsername: 'pop',
                            algoName: 'sha256',
                            hashRate: 200000000000,
                            day: 20201213,
                            amount: 0.2256872,
                            coinName: 'BTC',
                        },
                    ],
                    totalNum: 8,
                    pageSize: 200,
                },
            };

            const spy = jest.spyOn(client, 'hashrateResaleDetail').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<HashrateResaleDetailResponse>)
            );
            const response = await client.hashrateResaleDetail(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when configId is missing', async () => {
            const _params: HashrateResaleDetailRequest = {
                configId: 1,
                userName: 'userName_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.configId;

            await expect(client.hashrateResaleDetail(params)).rejects.toThrow(
                'Required parameter configId was null or undefined when calling hashrateResaleDetail.'
            );
        });

        it('should throw RequiredError when userName is missing', async () => {
            const _params: HashrateResaleDetailRequest = {
                configId: 1,
                userName: 'userName_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.userName;

            await expect(client.hashrateResaleDetail(params)).rejects.toThrow(
                'Required parameter userName was null or undefined when calling hashrateResaleDetail.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: HashrateResaleDetailRequest = {
                configId: 1,
                userName: 'userName_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'hashrateResaleDetail').mockRejectedValueOnce(mockError);
            await expect(client.hashrateResaleDetail(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('hashrateResaleList()', () => {
        it('should execute hashrateResaleList() successfully with required parameters only', async () => {
            mockResponse = {
                code: 0,
                msg: '',
                data: {
                    configDetails: [
                        {
                            configId: 168,
                            poolUsername: '123',
                            toPoolUsername: 'user1',
                            algoName: 'Ethash',
                            hashRate: 5000000,
                            startDay: 20201210,
                            endDay: 20210405,
                            status: 1,
                        },
                        {
                            configId: 166,
                            poolUsername: 'pop',
                            toPoolUsername: '111111',
                            algoName: 'Ethash',
                            hashRate: 3320000,
                            startDay: 20201226,
                            endDay: 20201227,
                            status: 0,
                        },
                    ],
                    totalNum: 21,
                    pageSize: 200,
                },
            };

            const spy = jest.spyOn(client, 'hashrateResaleList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<HashrateResaleListResponse>)
            );
            const response = await client.hashrateResaleList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute hashrateResaleList() successfully with optional parameters', async () => {
            const params: HashrateResaleListRequest = {
                pageIndex: 1,
                pageSize: 789,
                recvWindow: 5000,
            };

            mockResponse = {
                code: 0,
                msg: '',
                data: {
                    configDetails: [
                        {
                            configId: 168,
                            poolUsername: '123',
                            toPoolUsername: 'user1',
                            algoName: 'Ethash',
                            hashRate: 5000000,
                            startDay: 20201210,
                            endDay: 20210405,
                            status: 1,
                        },
                        {
                            configId: 166,
                            poolUsername: 'pop',
                            toPoolUsername: '111111',
                            algoName: 'Ethash',
                            hashRate: 3320000,
                            startDay: 20201226,
                            endDay: 20201227,
                            status: 0,
                        },
                    ],
                    totalNum: 21,
                    pageSize: 200,
                },
            };

            const spy = jest.spyOn(client, 'hashrateResaleList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<HashrateResaleListResponse>)
            );
            const response = await client.hashrateResaleList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'hashrateResaleList').mockRejectedValueOnce(mockError);
            await expect(client.hashrateResaleList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('hashrateResaleRequest()', () => {
        it('should execute hashrateResaleRequest() successfully with required parameters only', async () => {
            const params: HashrateResaleRequestRequest = {
                userName: 'userName_example',
                algo: 'algo_example',
                endDate: 789,
                startDate: 789,
                toPoolUser: 'toPoolUser_example',
                hashRate: 789,
            };

            mockResponse = { code: 0, msg: '', data: 171 };

            const spy = jest.spyOn(client, 'hashrateResaleRequest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<HashrateResaleRequestResponse>)
            );
            const response = await client.hashrateResaleRequest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute hashrateResaleRequest() successfully with optional parameters', async () => {
            const params: HashrateResaleRequestRequest = {
                userName: 'userName_example',
                algo: 'algo_example',
                endDate: 789,
                startDate: 789,
                toPoolUser: 'toPoolUser_example',
                hashRate: 789,
                recvWindow: 5000,
            };

            mockResponse = { code: 0, msg: '', data: 171 };

            const spy = jest.spyOn(client, 'hashrateResaleRequest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<HashrateResaleRequestResponse>)
            );
            const response = await client.hashrateResaleRequest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when userName is missing', async () => {
            const _params: HashrateResaleRequestRequest = {
                userName: 'userName_example',
                algo: 'algo_example',
                endDate: 789,
                startDate: 789,
                toPoolUser: 'toPoolUser_example',
                hashRate: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.userName;

            await expect(client.hashrateResaleRequest(params)).rejects.toThrow(
                'Required parameter userName was null or undefined when calling hashrateResaleRequest.'
            );
        });

        it('should throw RequiredError when algo is missing', async () => {
            const _params: HashrateResaleRequestRequest = {
                userName: 'userName_example',
                algo: 'algo_example',
                endDate: 789,
                startDate: 789,
                toPoolUser: 'toPoolUser_example',
                hashRate: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.algo;

            await expect(client.hashrateResaleRequest(params)).rejects.toThrow(
                'Required parameter algo was null or undefined when calling hashrateResaleRequest.'
            );
        });

        it('should throw RequiredError when endDate is missing', async () => {
            const _params: HashrateResaleRequestRequest = {
                userName: 'userName_example',
                algo: 'algo_example',
                endDate: 789,
                startDate: 789,
                toPoolUser: 'toPoolUser_example',
                hashRate: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.endDate;

            await expect(client.hashrateResaleRequest(params)).rejects.toThrow(
                'Required parameter endDate was null or undefined when calling hashrateResaleRequest.'
            );
        });

        it('should throw RequiredError when startDate is missing', async () => {
            const _params: HashrateResaleRequestRequest = {
                userName: 'userName_example',
                algo: 'algo_example',
                endDate: 789,
                startDate: 789,
                toPoolUser: 'toPoolUser_example',
                hashRate: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.startDate;

            await expect(client.hashrateResaleRequest(params)).rejects.toThrow(
                'Required parameter startDate was null or undefined when calling hashrateResaleRequest.'
            );
        });

        it('should throw RequiredError when toPoolUser is missing', async () => {
            const _params: HashrateResaleRequestRequest = {
                userName: 'userName_example',
                algo: 'algo_example',
                endDate: 789,
                startDate: 789,
                toPoolUser: 'toPoolUser_example',
                hashRate: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.toPoolUser;

            await expect(client.hashrateResaleRequest(params)).rejects.toThrow(
                'Required parameter toPoolUser was null or undefined when calling hashrateResaleRequest.'
            );
        });

        it('should throw RequiredError when hashRate is missing', async () => {
            const _params: HashrateResaleRequestRequest = {
                userName: 'userName_example',
                algo: 'algo_example',
                endDate: 789,
                startDate: 789,
                toPoolUser: 'toPoolUser_example',
                hashRate: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.hashRate;

            await expect(client.hashrateResaleRequest(params)).rejects.toThrow(
                'Required parameter hashRate was null or undefined when calling hashrateResaleRequest.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: HashrateResaleRequestRequest = {
                userName: 'userName_example',
                algo: 'algo_example',
                endDate: 789,
                startDate: 789,
                toPoolUser: 'toPoolUser_example',
                hashRate: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'hashrateResaleRequest')
                .mockRejectedValueOnce(mockError);
            await expect(client.hashrateResaleRequest(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('miningAccountEarning()', () => {
        it('should execute miningAccountEarning() successfully with required parameters only', async () => {
            const params: MiningAccountEarningRequest = {
                algo: 'algo_example',
            };

            mockResponse = {
                code: 0,
                msg: '',
                data: {
                    accountProfits: [
                        {
                            time: 1607443200000,
                            coinName: 'BTC',
                            type: 2,
                            puid: 59985472,
                            subName: 'vdvaghani',
                            amount: 0.09186957,
                        },
                    ],
                    totalNum: 3,
                    pageSize: 20,
                },
            };

            const spy = jest.spyOn(client, 'miningAccountEarning').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MiningAccountEarningResponse>)
            );
            const response = await client.miningAccountEarning(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute miningAccountEarning() successfully with optional parameters', async () => {
            const params: MiningAccountEarningRequest = {
                algo: 'algo_example',
                startDate: 789,
                endDate: 789,
                pageIndex: 1,
                pageSize: 789,
                recvWindow: 5000,
            };

            mockResponse = {
                code: 0,
                msg: '',
                data: {
                    accountProfits: [
                        {
                            time: 1607443200000,
                            coinName: 'BTC',
                            type: 2,
                            puid: 59985472,
                            subName: 'vdvaghani',
                            amount: 0.09186957,
                        },
                    ],
                    totalNum: 3,
                    pageSize: 20,
                },
            };

            const spy = jest.spyOn(client, 'miningAccountEarning').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MiningAccountEarningResponse>)
            );
            const response = await client.miningAccountEarning(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when algo is missing', async () => {
            const _params: MiningAccountEarningRequest = {
                algo: 'algo_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.algo;

            await expect(client.miningAccountEarning(params)).rejects.toThrow(
                'Required parameter algo was null or undefined when calling miningAccountEarning.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MiningAccountEarningRequest = {
                algo: 'algo_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'miningAccountEarning').mockRejectedValueOnce(mockError);
            await expect(client.miningAccountEarning(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('requestForDetailMinerList()', () => {
        it('should execute requestForDetailMinerList() successfully with required parameters only', async () => {
            const params: RequestForDetailMinerListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
                workerName: 'workerName_example',
            };

            mockResponse = {
                code: 0,
                msg: '',
                data: [
                    {
                        workerName: 'bhdc1.16A10404B',
                        type: 'H_hashrate',
                        hashrateDatas: [
                            { time: 1587902400000, hashrate: '0', reject: 0 },
                            { time: 1587906000000, hashrate: '0', reject: 0 },
                        ],
                    },
                    {
                        workerName: 'bhdc1.16A10404B',
                        type: 'D_hashrate',
                        hashrateDatas: [
                            { time: 1587902400000, hashrate: '0', reject: 0 },
                            { time: 1587906000000, hashrate: '0', reject: 0 },
                        ],
                    },
                ],
            };

            const spy = jest.spyOn(client, 'requestForDetailMinerList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RequestForDetailMinerListResponse>)
            );
            const response = await client.requestForDetailMinerList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute requestForDetailMinerList() successfully with optional parameters', async () => {
            const params: RequestForDetailMinerListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
                workerName: 'workerName_example',
                recvWindow: 5000,
            };

            mockResponse = {
                code: 0,
                msg: '',
                data: [
                    {
                        workerName: 'bhdc1.16A10404B',
                        type: 'H_hashrate',
                        hashrateDatas: [
                            { time: 1587902400000, hashrate: '0', reject: 0 },
                            { time: 1587906000000, hashrate: '0', reject: 0 },
                        ],
                    },
                    {
                        workerName: 'bhdc1.16A10404B',
                        type: 'D_hashrate',
                        hashrateDatas: [
                            { time: 1587902400000, hashrate: '0', reject: 0 },
                            { time: 1587906000000, hashrate: '0', reject: 0 },
                        ],
                    },
                ],
            };

            const spy = jest.spyOn(client, 'requestForDetailMinerList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RequestForDetailMinerListResponse>)
            );
            const response = await client.requestForDetailMinerList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when algo is missing', async () => {
            const _params: RequestForDetailMinerListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
                workerName: 'workerName_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.algo;

            await expect(client.requestForDetailMinerList(params)).rejects.toThrow(
                'Required parameter algo was null or undefined when calling requestForDetailMinerList.'
            );
        });

        it('should throw RequiredError when userName is missing', async () => {
            const _params: RequestForDetailMinerListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
                workerName: 'workerName_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.userName;

            await expect(client.requestForDetailMinerList(params)).rejects.toThrow(
                'Required parameter userName was null or undefined when calling requestForDetailMinerList.'
            );
        });

        it('should throw RequiredError when workerName is missing', async () => {
            const _params: RequestForDetailMinerListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
                workerName: 'workerName_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.workerName;

            await expect(client.requestForDetailMinerList(params)).rejects.toThrow(
                'Required parameter workerName was null or undefined when calling requestForDetailMinerList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: RequestForDetailMinerListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
                workerName: 'workerName_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'requestForDetailMinerList')
                .mockRejectedValueOnce(mockError);
            await expect(client.requestForDetailMinerList(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('requestForMinerList()', () => {
        it('should execute requestForMinerList() successfully with required parameters only', async () => {
            const params: RequestForMinerListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
            };

            mockResponse = {
                code: 0,
                msg: '',
                data: {
                    workerDatas: [
                        {
                            workerId: '1420554439452400131',
                            workerName: '2X73',
                            status: 3,
                            hashRate: 0,
                            dayHashRate: 0,
                            rejectRate: 0,
                            lastShareTime: 1587712919000,
                        },
                        {
                            workerId: '7893926126382807951',
                            workerName: 'AZDC1.1A10101',
                            status: 2,
                            hashRate: 29711247541680,
                            dayHashRate: 1.269778129801366e13,
                            rejectRate: 0,
                            lastShareTime: 1587969727000,
                        },
                    ],
                    totalNum: 18530,
                    pageSize: 20,
                },
            };

            const spy = jest.spyOn(client, 'requestForMinerList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RequestForMinerListResponse>)
            );
            const response = await client.requestForMinerList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute requestForMinerList() successfully with optional parameters', async () => {
            const params: RequestForMinerListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
                pageIndex: 1,
                sort: 0,
                sortColumn: 1,
                workerStatus: 0,
                recvWindow: 5000,
            };

            mockResponse = {
                code: 0,
                msg: '',
                data: {
                    workerDatas: [
                        {
                            workerId: '1420554439452400131',
                            workerName: '2X73',
                            status: 3,
                            hashRate: 0,
                            dayHashRate: 0,
                            rejectRate: 0,
                            lastShareTime: 1587712919000,
                        },
                        {
                            workerId: '7893926126382807951',
                            workerName: 'AZDC1.1A10101',
                            status: 2,
                            hashRate: 29711247541680,
                            dayHashRate: 1.269778129801366e13,
                            rejectRate: 0,
                            lastShareTime: 1587969727000,
                        },
                    ],
                    totalNum: 18530,
                    pageSize: 20,
                },
            };

            const spy = jest.spyOn(client, 'requestForMinerList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RequestForMinerListResponse>)
            );
            const response = await client.requestForMinerList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when algo is missing', async () => {
            const _params: RequestForMinerListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.algo;

            await expect(client.requestForMinerList(params)).rejects.toThrow(
                'Required parameter algo was null or undefined when calling requestForMinerList.'
            );
        });

        it('should throw RequiredError when userName is missing', async () => {
            const _params: RequestForMinerListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.userName;

            await expect(client.requestForMinerList(params)).rejects.toThrow(
                'Required parameter userName was null or undefined when calling requestForMinerList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: RequestForMinerListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'requestForMinerList').mockRejectedValueOnce(mockError);
            await expect(client.requestForMinerList(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('statisticList()', () => {
        it('should execute statisticList() successfully with required parameters only', async () => {
            const params: StatisticListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
            };

            mockResponse = {
                code: 0,
                msg: '',
                data: {
                    fifteenMinHashRate: '457835490067496409.00000000',
                    dayHashRate: '214289268068874127.65000000',
                    validNum: 0,
                    invalidNum: 17562,
                    profitToday: { BTC: '0.00314332', BSV: '56.17055953', BCH: '106.61586001' },
                    profitYesterday: { BTC: '0.00314332', BSV: '56.17055953', BCH: '106.61586001' },
                    userName: 'test',
                    unit: 'h/s',
                    algo: 'sha256',
                },
            };

            const spy = jest.spyOn(client, 'statisticList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<StatisticListResponse>)
            );
            const response = await client.statisticList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute statisticList() successfully with optional parameters', async () => {
            const params: StatisticListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
                recvWindow: 5000,
            };

            mockResponse = {
                code: 0,
                msg: '',
                data: {
                    fifteenMinHashRate: '457835490067496409.00000000',
                    dayHashRate: '214289268068874127.65000000',
                    validNum: 0,
                    invalidNum: 17562,
                    profitToday: { BTC: '0.00314332', BSV: '56.17055953', BCH: '106.61586001' },
                    profitYesterday: { BTC: '0.00314332', BSV: '56.17055953', BCH: '106.61586001' },
                    userName: 'test',
                    unit: 'h/s',
                    algo: 'sha256',
                },
            };

            const spy = jest.spyOn(client, 'statisticList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<StatisticListResponse>)
            );
            const response = await client.statisticList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when algo is missing', async () => {
            const _params: StatisticListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.algo;

            await expect(client.statisticList(params)).rejects.toThrow(
                'Required parameter algo was null or undefined when calling statisticList.'
            );
        });

        it('should throw RequiredError when userName is missing', async () => {
            const _params: StatisticListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.userName;

            await expect(client.statisticList(params)).rejects.toThrow(
                'Required parameter userName was null or undefined when calling statisticList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: StatisticListRequest = {
                algo: 'algo_example',
                userName: 'userName_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'statisticList').mockRejectedValueOnce(mockError);
            await expect(client.statisticList(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
