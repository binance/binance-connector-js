/**
 * Binance Public Convert REST API
 *
 * OpenAPI Specification for the Binance Public Convert REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { TradeApi } from '../../../src/rest-api';
import {
    AcceptQuoteRequest,
    CancelLimitOrderRequest,
    GetConvertTradeHistoryRequest,
    OrderStatusRequest,
    PlaceLimitOrderRequest,
    QueryLimitOpenOrdersRequest,
    SendQuoteRequestRequest,
} from '../../../src/rest-api';
import type {
    AcceptQuoteResponse,
    CancelLimitOrderResponse,
    GetConvertTradeHistoryResponse,
    OrderStatusResponse,
    PlaceLimitOrderResponse,
    QueryLimitOpenOrdersResponse,
    SendQuoteRequestResponse,
} from '../../../src/rest-api/types';

describe('TradeApi', () => {
    let client: TradeApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new TradeApi(config);
    });

    describe('acceptQuote()', () => {
        it('should execute acceptQuote() successfully with required parameters only', async () => {
            const params: AcceptQuoteRequest = {
                quoteId: '1',
            };

            mockResponse = {
                orderId: '933256278426274426',
                createTime: 1623381330472,
                orderStatus: 'PROCESS',
            };

            const spy = jest.spyOn(client, 'acceptQuote').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AcceptQuoteResponse>)
            );
            const response = await client.acceptQuote(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute acceptQuote() successfully with optional parameters', async () => {
            const params: AcceptQuoteRequest = {
                quoteId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                orderId: '933256278426274426',
                createTime: 1623381330472,
                orderStatus: 'PROCESS',
            };

            const spy = jest.spyOn(client, 'acceptQuote').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AcceptQuoteResponse>)
            );
            const response = await client.acceptQuote(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when quoteId is missing', async () => {
            const _params: AcceptQuoteRequest = {
                quoteId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.quoteId;

            await expect(client.acceptQuote(params)).rejects.toThrow(
                'Required parameter quoteId was null or undefined when calling acceptQuote.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AcceptQuoteRequest = {
                quoteId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'acceptQuote').mockRejectedValueOnce(mockError);
            await expect(client.acceptQuote(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cancelLimitOrder()', () => {
        it('should execute cancelLimitOrder() successfully with required parameters only', async () => {
            const params: CancelLimitOrderRequest = {
                orderId: 1,
            };

            mockResponse = { orderId: 1603680255057330400, status: 'CANCELED' };

            const spy = jest.spyOn(client, 'cancelLimitOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelLimitOrderResponse>)
            );
            const response = await client.cancelLimitOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelLimitOrder() successfully with optional parameters', async () => {
            const params: CancelLimitOrderRequest = {
                orderId: 1,
                recvWindow: 5000,
            };

            mockResponse = { orderId: 1603680255057330400, status: 'CANCELED' };

            const spy = jest.spyOn(client, 'cancelLimitOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelLimitOrderResponse>)
            );
            const response = await client.cancelLimitOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when orderId is missing', async () => {
            const _params: CancelLimitOrderRequest = {
                orderId: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.orderId;

            await expect(client.cancelLimitOrder(params)).rejects.toThrow(
                'Required parameter orderId was null or undefined when calling cancelLimitOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelLimitOrderRequest = {
                orderId: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'cancelLimitOrder').mockRejectedValueOnce(mockError);
            await expect(client.cancelLimitOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getConvertTradeHistory()', () => {
        it('should execute getConvertTradeHistory() successfully with required parameters only', async () => {
            const params: GetConvertTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = {
                list: [
                    {
                        quoteId: 'f3b91c525b2644c7bc1e1cd31b6e1aa6',
                        orderId: 940708407462087200,
                        orderStatus: 'SUCCESS',
                        fromAsset: 'USDT',
                        fromAmount: '20',
                        toAsset: 'BNB',
                        toAmount: '0.06154036',
                        ratio: '0.00307702',
                        inverseRatio: '324.99',
                        createTime: 1624248872184,
                    },
                ],
                startTime: 1623824139000,
                endTime: 1626416139000,
                limit: 100,
                moreData: false,
            };

            const spy = jest.spyOn(client, 'getConvertTradeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetConvertTradeHistoryResponse>)
            );
            const response = await client.getConvertTradeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getConvertTradeHistory() successfully with optional parameters', async () => {
            const params: GetConvertTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = {
                list: [
                    {
                        quoteId: 'f3b91c525b2644c7bc1e1cd31b6e1aa6',
                        orderId: 940708407462087200,
                        orderStatus: 'SUCCESS',
                        fromAsset: 'USDT',
                        fromAmount: '20',
                        toAsset: 'BNB',
                        toAmount: '0.06154036',
                        ratio: '0.00307702',
                        inverseRatio: '324.99',
                        createTime: 1624248872184,
                    },
                ],
                startTime: 1623824139000,
                endTime: 1626416139000,
                limit: 100,
                moreData: false,
            };

            const spy = jest.spyOn(client, 'getConvertTradeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetConvertTradeHistoryResponse>)
            );
            const response = await client.getConvertTradeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: GetConvertTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(client.getConvertTradeHistory(params)).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling getConvertTradeHistory.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: GetConvertTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(client.getConvertTradeHistory(params)).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling getConvertTradeHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetConvertTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getConvertTradeHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getConvertTradeHistory(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderStatus()', () => {
        it('should execute orderStatus() successfully with required parameters only', async () => {
            mockResponse = {
                orderId: 933256278426274400,
                orderStatus: 'SUCCESS',
                fromAsset: 'BTC',
                fromAmount: '0.00054414',
                toAsset: 'USDT',
                toAmount: '20',
                ratio: '36755',
                inverseRatio: '0.00002721',
                createTime: 1623381330472,
            };

            const spy = jest.spyOn(client, 'orderStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderStatusResponse>)
            );
            const response = await client.orderStatus();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderStatus() successfully with optional parameters', async () => {
            const params: OrderStatusRequest = {
                orderId: '1',
                quoteId: '1',
            };

            mockResponse = {
                orderId: 933256278426274400,
                orderStatus: 'SUCCESS',
                fromAsset: 'BTC',
                fromAmount: '0.00054414',
                toAsset: 'USDT',
                toAmount: '20',
                ratio: '36755',
                inverseRatio: '0.00002721',
                createTime: 1623381330472,
            };

            const spy = jest.spyOn(client, 'orderStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderStatusResponse>)
            );
            const response = await client.orderStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderStatus').mockRejectedValueOnce(mockError);
            await expect(client.orderStatus()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('placeLimitOrder()', () => {
        it('should execute placeLimitOrder() successfully with required parameters only', async () => {
            const params: PlaceLimitOrderRequest = {
                baseAsset: 'baseAsset_example',
                quoteAsset: 'quoteAsset_example',
                limitPrice: 1,
                side: 'BUY',
                expiredType: 'expiredType_example',
            };

            mockResponse = {
                quoteId: '12415572564',
                ratio: '38163.7',
                inverseRatio: '0.0000262',
                validTimestamp: 1623319461670,
                toAmount: '3816.37',
                fromAmount: '0.1',
            };

            const spy = jest.spyOn(client, 'placeLimitOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PlaceLimitOrderResponse>)
            );
            const response = await client.placeLimitOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute placeLimitOrder() successfully with optional parameters', async () => {
            const params: PlaceLimitOrderRequest = {
                baseAsset: 'baseAsset_example',
                quoteAsset: 'quoteAsset_example',
                limitPrice: 1,
                side: 'BUY',
                expiredType: 'expiredType_example',
                baseAmount: 1,
                quoteAmount: 1,
                walletType: 'SPOT',
                recvWindow: 5000,
            };

            mockResponse = {
                quoteId: '12415572564',
                ratio: '38163.7',
                inverseRatio: '0.0000262',
                validTimestamp: 1623319461670,
                toAmount: '3816.37',
                fromAmount: '0.1',
            };

            const spy = jest.spyOn(client, 'placeLimitOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PlaceLimitOrderResponse>)
            );
            const response = await client.placeLimitOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when baseAsset is missing', async () => {
            const _params: PlaceLimitOrderRequest = {
                baseAsset: 'baseAsset_example',
                quoteAsset: 'quoteAsset_example',
                limitPrice: 1,
                side: 'BUY',
                expiredType: 'expiredType_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.baseAsset;

            await expect(client.placeLimitOrder(params)).rejects.toThrow(
                'Required parameter baseAsset was null or undefined when calling placeLimitOrder.'
            );
        });

        it('should throw RequiredError when quoteAsset is missing', async () => {
            const _params: PlaceLimitOrderRequest = {
                baseAsset: 'baseAsset_example',
                quoteAsset: 'quoteAsset_example',
                limitPrice: 1,
                side: 'BUY',
                expiredType: 'expiredType_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.quoteAsset;

            await expect(client.placeLimitOrder(params)).rejects.toThrow(
                'Required parameter quoteAsset was null or undefined when calling placeLimitOrder.'
            );
        });

        it('should throw RequiredError when limitPrice is missing', async () => {
            const _params: PlaceLimitOrderRequest = {
                baseAsset: 'baseAsset_example',
                quoteAsset: 'quoteAsset_example',
                limitPrice: 1,
                side: 'BUY',
                expiredType: 'expiredType_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.limitPrice;

            await expect(client.placeLimitOrder(params)).rejects.toThrow(
                'Required parameter limitPrice was null or undefined when calling placeLimitOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: PlaceLimitOrderRequest = {
                baseAsset: 'baseAsset_example',
                quoteAsset: 'quoteAsset_example',
                limitPrice: 1,
                side: 'BUY',
                expiredType: 'expiredType_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.placeLimitOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling placeLimitOrder.'
            );
        });

        it('should throw RequiredError when expiredType is missing', async () => {
            const _params: PlaceLimitOrderRequest = {
                baseAsset: 'baseAsset_example',
                quoteAsset: 'quoteAsset_example',
                limitPrice: 1,
                side: 'BUY',
                expiredType: 'expiredType_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.expiredType;

            await expect(client.placeLimitOrder(params)).rejects.toThrow(
                'Required parameter expiredType was null or undefined when calling placeLimitOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: PlaceLimitOrderRequest = {
                baseAsset: 'baseAsset_example',
                quoteAsset: 'quoteAsset_example',
                limitPrice: 1,
                side: 'BUY',
                expiredType: 'expiredType_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'placeLimitOrder').mockRejectedValueOnce(mockError);
            await expect(client.placeLimitOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryLimitOpenOrders()', () => {
        it('should execute queryLimitOpenOrders() successfully with required parameters only', async () => {
            mockResponse = {
                list: [
                    {
                        quoteId: '18sdf87kh9df',
                        orderId: 1150901289839,
                        orderStatus: 'SUCCESS',
                        fromAsset: 'BNB',
                        fromAmount: '10',
                        toAsset: 'USDT',
                        toAmount: '2317.89',
                        ratio: '231.789',
                        inverseRatio: '0.00431427',
                        createTime: 1614089498000,
                        expiredTimestamp: 1614099498000,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'queryLimitOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryLimitOpenOrdersResponse>)
            );
            const response = await client.queryLimitOpenOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryLimitOpenOrders() successfully with optional parameters', async () => {
            const params: QueryLimitOpenOrdersRequest = {
                recvWindow: 5000,
            };

            mockResponse = {
                list: [
                    {
                        quoteId: '18sdf87kh9df',
                        orderId: 1150901289839,
                        orderStatus: 'SUCCESS',
                        fromAsset: 'BNB',
                        fromAmount: '10',
                        toAsset: 'USDT',
                        toAmount: '2317.89',
                        ratio: '231.789',
                        inverseRatio: '0.00431427',
                        createTime: 1614089498000,
                        expiredTimestamp: 1614099498000,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'queryLimitOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryLimitOpenOrdersResponse>)
            );
            const response = await client.queryLimitOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'queryLimitOpenOrders').mockRejectedValueOnce(mockError);
            await expect(client.queryLimitOpenOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('sendQuoteRequest()', () => {
        it('should execute sendQuoteRequest() successfully with required parameters only', async () => {
            const params: SendQuoteRequestRequest = {
                fromAsset: 'fromAsset_example',
                toAsset: 'toAsset_example',
            };

            mockResponse = {
                quoteId: '12415572564',
                ratio: '38163.7',
                inverseRatio: '0.0000262',
                validTimestamp: 1623319461670,
                toAmount: '3816.37',
                fromAmount: '0.1',
            };

            const spy = jest.spyOn(client, 'sendQuoteRequest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SendQuoteRequestResponse>)
            );
            const response = await client.sendQuoteRequest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute sendQuoteRequest() successfully with optional parameters', async () => {
            const params: SendQuoteRequestRequest = {
                fromAsset: 'fromAsset_example',
                toAsset: 'toAsset_example',
                fromAmount: 1,
                toAmount: 1,
                walletType: 'SPOT',
                validTime: '10s',
                recvWindow: 5000,
            };

            mockResponse = {
                quoteId: '12415572564',
                ratio: '38163.7',
                inverseRatio: '0.0000262',
                validTimestamp: 1623319461670,
                toAmount: '3816.37',
                fromAmount: '0.1',
            };

            const spy = jest.spyOn(client, 'sendQuoteRequest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SendQuoteRequestResponse>)
            );
            const response = await client.sendQuoteRequest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when fromAsset is missing', async () => {
            const _params: SendQuoteRequestRequest = {
                fromAsset: 'fromAsset_example',
                toAsset: 'toAsset_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.fromAsset;

            await expect(client.sendQuoteRequest(params)).rejects.toThrow(
                'Required parameter fromAsset was null or undefined when calling sendQuoteRequest.'
            );
        });

        it('should throw RequiredError when toAsset is missing', async () => {
            const _params: SendQuoteRequestRequest = {
                fromAsset: 'fromAsset_example',
                toAsset: 'toAsset_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.toAsset;

            await expect(client.sendQuoteRequest(params)).rejects.toThrow(
                'Required parameter toAsset was null or undefined when calling sendQuoteRequest.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SendQuoteRequestRequest = {
                fromAsset: 'fromAsset_example',
                toAsset: 'toAsset_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'sendQuoteRequest').mockRejectedValueOnce(mockError);
            await expect(client.sendQuoteRequest(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
