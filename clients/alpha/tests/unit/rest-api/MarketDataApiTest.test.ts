/**
 * Binance Alpha REST API
 *
 * OpenAPI Specification for the Binance Alpha REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { JSONParse, JSONStringify } from 'json-with-bigint';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { MarketDataApi } from '../../../src/rest-api';
import { AggregatedTradesRequest, KlinesRequest, TickerRequest } from '../../../src/rest-api';
import type {
    AggregatedTradesResponse,
    GetExchangeInfoResponse,
    KlinesResponse,
    TickerResponse,
    TokenListResponse,
} from '../../../src/rest-api/types';

describe('MarketDataApi', () => {
    let client: MarketDataApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new MarketDataApi(config);
    });

    describe('aggregatedTrades()', () => {
        it('should execute aggregatedTrades() successfully with required parameters only', async () => {
            const params: AggregatedTradesRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: '',
                    messageDetail: '',
                    data: [
                        {
                            a: 58470,
                            p: '1.00',
                            q: '1.00',
                            f: 58470,
                            l: 58665,
                            T: 1752568680000,
                            m: true,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'aggregatedTrades').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AggregatedTradesResponse>)
            );
            const response = await client.aggregatedTrades(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute aggregatedTrades() successfully with optional parameters', async () => {
            const params: AggregatedTradesRequest = {
                symbol: 'symbol_example',
                fromId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 500,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: '',
                    messageDetail: '',
                    data: [
                        {
                            a: 58470,
                            p: '1.00',
                            q: '1.00',
                            f: 58470,
                            l: 58665,
                            T: 1752568680000,
                            m: true,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'aggregatedTrades').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AggregatedTradesResponse>)
            );
            const response = await client.aggregatedTrades(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: AggregatedTradesRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.aggregatedTrades(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling aggregatedTrades.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AggregatedTradesRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'aggregatedTrades').mockRejectedValueOnce(mockError);
            await expect(client.aggregatedTrades(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getExchangeInfo()', () => {
        it('should execute getExchangeInfo() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: '',
                    messageDetail: '',
                    success: true,
                    data: {
                        timezone: 'UTC',
                        assets: [{ asset: 'USDT' }],
                        symbols: [
                            {
                                symbol: 'ALPHA_105USDT',
                                status: 'TRADING',
                                baseAsset: 'ALPHA_105',
                                quoteAsset: 'USDT',
                                pricePrecision: 8,
                                quantityPrecision: 8,
                                baseAssetPrecision: 8,
                                quotePrecision: 8,
                                filters: [
                                    {
                                        filterType: 'PRICE_FILTER',
                                        minPrice: '0.00000001',
                                        maxPrice: '1000',
                                        tickSize: '0.00000001',
                                    },
                                    {
                                        filterType: 'LOT_SIZE',
                                        stepSize: '0.01000000',
                                        maxQty: '277778',
                                        minQty: '0.01000000',
                                    },
                                    { filterType: 'MAX_NUM_ORDERS', limit: 200 },
                                    { filterType: 'MIN_NOTIONAL', minNotional: '0.1' },
                                    { filterType: 'MAX_NOTIONAL', maxNotional: '1000000' },
                                    {
                                        filterType: 'NOTIONAL',
                                        minNotional: '0.1',
                                        maxNotional: '1000000',
                                    },
                                    {
                                        filterType: 'PERCENT_PRICE',
                                        multiplierDown: '0.20000',
                                        multiplierUp: '5',
                                    },
                                    {
                                        filterType: 'PERCENT_PRICE_BY_SIDE',
                                        bidMultiplierUp: '5',
                                        askMultiplierUp: '5',
                                        bidMultiplierDown: '0.20000',
                                        askMultiplierDown: '0.20000',
                                    },
                                ],
                                orderTypes: ['LIMIT'],
                            },
                        ],
                        orderTypes: '',
                    },
                })
            );

            const spy = jest.spyOn(client, 'getExchangeInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetExchangeInfoResponse>)
            );
            const response = await client.getExchangeInfo();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getExchangeInfo').mockRejectedValueOnce(mockError);
            await expect(client.getExchangeInfo()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('klines()', () => {
        it('should execute klines() successfully with required parameters only', async () => {
            const params: KlinesRequest = {
                symbol: 'symbol_example',
                interval: 'interval_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: '',
                    messageDetail: '',
                    success: true,
                    data: [
                        [
                            '1752642000000',
                            '0.00171473',
                            '0.00172515',
                            '0.00171473',
                            '0.00172515',
                            '1771.86000000',
                            '1752645599999',
                            '3.05093481',
                            '2',
                            '1771.86000000',
                            '3.05093481',
                            0,
                        ],
                    ],
                })
            );

            const spy = jest.spyOn(client, 'klines').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<KlinesResponse>)
            );
            const response = await client.klines(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute klines() successfully with optional parameters', async () => {
            const params: KlinesRequest = {
                symbol: 'symbol_example',
                interval: 'interval_example',
                limit: 500,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: '',
                    messageDetail: '',
                    success: true,
                    data: [
                        [
                            '1752642000000',
                            '0.00171473',
                            '0.00172515',
                            '0.00171473',
                            '0.00172515',
                            '1771.86000000',
                            '1752645599999',
                            '3.05093481',
                            '2',
                            '1771.86000000',
                            '3.05093481',
                            0,
                        ],
                    ],
                })
            );

            const spy = jest.spyOn(client, 'klines').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<KlinesResponse>)
            );
            const response = await client.klines(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: KlinesRequest = {
                symbol: 'symbol_example',
                interval: 'interval_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.klines(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling klines.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: KlinesRequest = {
                symbol: 'symbol_example',
                interval: 'interval_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.klines(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling klines.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: KlinesRequest = {
                symbol: 'symbol_example',
                interval: 'interval_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'klines').mockRejectedValueOnce(mockError);
            await expect(client.klines(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('ticker()', () => {
        it('should execute ticker() successfully with required parameters only', async () => {
            const params: TickerRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: '',
                    messageDetail: '',
                    data: {
                        symbol: 'ALPHA_175USDT',
                        priceChange: '-0.00007172',
                        priceChangePercent: '-8.841',
                        weightedAvgPrice: '0.00079608',
                        lastPrice: '0.00073954',
                        lastQty: '12600.43000000',
                        openPrice: '0.00081126',
                        highPrice: '0.00081126',
                        lowPrice: '0.00073954',
                        volume: '1204754.30000000',
                        quoteVolume: '959.07729927',
                        openTime: 1768808100000,
                        closeTime: 1768893244772,
                        firstId: 93742,
                        lastId: 93768,
                        count: 38,
                    },
                    success: true,
                })
            );

            const spy = jest.spyOn(client, 'ticker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TickerResponse>)
            );
            const response = await client.ticker(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute ticker() successfully with optional parameters', async () => {
            const params: TickerRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: '',
                    messageDetail: '',
                    data: {
                        symbol: 'ALPHA_175USDT',
                        priceChange: '-0.00007172',
                        priceChangePercent: '-8.841',
                        weightedAvgPrice: '0.00079608',
                        lastPrice: '0.00073954',
                        lastQty: '12600.43000000',
                        openPrice: '0.00081126',
                        highPrice: '0.00081126',
                        lowPrice: '0.00073954',
                        volume: '1204754.30000000',
                        quoteVolume: '959.07729927',
                        openTime: 1768808100000,
                        closeTime: 1768893244772,
                        firstId: 93742,
                        lastId: 93768,
                        count: 38,
                    },
                    success: true,
                })
            );

            const spy = jest.spyOn(client, 'ticker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TickerResponse>)
            );
            const response = await client.ticker(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: TickerRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.ticker(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling ticker.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TickerRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'ticker').mockRejectedValueOnce(mockError);
            await expect(client.ticker(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('tokenList()', () => {
        it('should execute tokenList() successfully with required parameters only', async () => {
            mockResponse = JSONParse(
                JSONStringify({
                    code: '000000',
                    message: '',
                    messageDetail: '',
                    success: true,
                    data: [
                        {
                            tokenId: '3F350C8B3621770A673159B7A19BC034',
                            chainId: '56',
                            chainIconUrl:
                                'https://bin.bnbstatic.com/image/admin_mgs_image_upload/20250228/d0216ce4-a3e9-4bda-8937-4a6aa943ccf2.png',
                            chainName: 'BSC',
                            contractAddress: '0xcf640fdf9b3d9e45cbd69fda91d7e22579c14444',
                            name: 'gorilla',
                            symbol: 'gorilla',
                            iconUrl:
                                'https://bin.bnbstatic.com/images/web3-data/public/token/logos/248b5406f88a4ee28913a29107875339.png',
                            price: '0.00080595003978242023',
                            percentChange24h: '-7.42',
                            volume24h: '14847.711222633409558029675',
                            marketCap: '805950.03978242',
                            fdv: '805950.03978242',
                            liquidity: '263192.72813121626034',
                            totalSupply: '1000000000',
                            circulatingSupply: '1000000000',
                            holders: '7120',
                            decimals: 18,
                            listingCex: false,
                            hotTag: false,
                            cexCoinName: '',
                            canTransfer: false,
                            denomination: 1,
                            offline: false,
                            tradeDecimal: 8,
                            alphaId: 'ALPHA_175',
                            offsell: false,
                            priceHigh24h: '0.00088873864475645879',
                            priceLow24h: '0.0008020805165487083',
                            count24h: '166',
                            onlineTge: false,
                            onlineAirdrop: false,
                            score: 1,
                            cexOffDisplay: false,
                            stockState: false,
                            listingTime: 1746686700000,
                            mulPoint: 1,
                            bnExclusiveState: false,
                        },
                    ],
                })
            );

            const spy = jest.spyOn(client, 'tokenList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TokenListResponse>)
            );
            const response = await client.tokenList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'tokenList').mockRejectedValueOnce(mockError);
            await expect(client.tokenList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
