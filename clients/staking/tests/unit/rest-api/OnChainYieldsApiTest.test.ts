/**
 * Binance Staking REST API
 *
 * OpenAPI Specification for the Binance Staking REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { OnChainYieldsApi } from '../../../src/rest-api';
import {
    GetOnChainYieldsLockedPersonalLeftQuotaRequest,
    GetOnChainYieldsLockedProductListRequest,
    GetOnChainYieldsLockedProductPositionRequest,
    GetOnChainYieldsLockedRedemptionRecordRequest,
    GetOnChainYieldsLockedRewardsHistoryRequest,
    GetOnChainYieldsLockedSubscriptionPreviewRequest,
    GetOnChainYieldsLockedSubscriptionRecordRequest,
    OnChainYieldsAccountRequest,
    RedeemOnChainYieldsLockedProductRequest,
    SetOnChainYieldsLockedAutoSubscribeRequest,
    SetOnChainYieldsLockedProductRedeemOptionRequest,
    SubscribeOnChainYieldsLockedProductRequest,
} from '../../../src/rest-api';
import type {
    GetOnChainYieldsLockedPersonalLeftQuotaResponse,
    GetOnChainYieldsLockedProductListResponse,
    GetOnChainYieldsLockedProductPositionResponse,
    GetOnChainYieldsLockedRedemptionRecordResponse,
    GetOnChainYieldsLockedRewardsHistoryResponse,
    GetOnChainYieldsLockedSubscriptionPreviewResponse,
    GetOnChainYieldsLockedSubscriptionRecordResponse,
    OnChainYieldsAccountResponse,
    RedeemOnChainYieldsLockedProductResponse,
    SetOnChainYieldsLockedAutoSubscribeResponse,
    SetOnChainYieldsLockedProductRedeemOptionResponse,
    SubscribeOnChainYieldsLockedProductResponse,
} from '../../../src/rest-api/types';

describe('OnChainYieldsApi', () => {
    let client: OnChainYieldsApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new OnChainYieldsApi(config);
    });

    describe('getOnChainYieldsLockedPersonalLeftQuota()', () => {
        it('should execute getOnChainYieldsLockedPersonalLeftQuota() successfully with required parameters only', async () => {
            const params: GetOnChainYieldsLockedPersonalLeftQuotaRequest = {
                projectId: '1',
            };

            mockResponse = { leftPersonalQuota: '1000' };

            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedPersonalLeftQuota')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetOnChainYieldsLockedPersonalLeftQuotaResponse>)
                );
            const response = await client.getOnChainYieldsLockedPersonalLeftQuota(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOnChainYieldsLockedPersonalLeftQuota() successfully with optional parameters', async () => {
            const params: GetOnChainYieldsLockedPersonalLeftQuotaRequest = {
                projectId: '1',
                recvWindow: 5000,
            };

            mockResponse = { leftPersonalQuota: '1000' };

            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedPersonalLeftQuota')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetOnChainYieldsLockedPersonalLeftQuotaResponse>)
                );
            const response = await client.getOnChainYieldsLockedPersonalLeftQuota(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when projectId is missing', async () => {
            const _params: GetOnChainYieldsLockedPersonalLeftQuotaRequest = {
                projectId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.projectId;

            await expect(client.getOnChainYieldsLockedPersonalLeftQuota(params)).rejects.toThrow(
                'Required parameter projectId was null or undefined when calling getOnChainYieldsLockedPersonalLeftQuota.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetOnChainYieldsLockedPersonalLeftQuotaRequest = {
                projectId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedPersonalLeftQuota')
                .mockRejectedValueOnce(mockError);
            await expect(client.getOnChainYieldsLockedPersonalLeftQuota(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getOnChainYieldsLockedProductList()', () => {
        it('should execute getOnChainYieldsLockedProductList() successfully with required parameters only', async () => {
            mockResponse = {
                rows: [
                    {
                        projectId: 'Solv-60d',
                        detail: {
                            asset: 'BTC',
                            rewardAsset: 'SOLV',
                            duration: 60,
                            renewable: true,
                            isSoldOut: true,
                            apr: '0.039',
                            status: 'PREHEATING',
                            subscriptionStartTime: '1646182276000',
                            canRedeemToFlex: true,
                        },
                        quota: { totalPersonalQuota: '2', minimum: '0.001' },
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getOnChainYieldsLockedProductList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOnChainYieldsLockedProductListResponse>)
            );
            const response = await client.getOnChainYieldsLockedProductList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOnChainYieldsLockedProductList() successfully with optional parameters', async () => {
            const params: GetOnChainYieldsLockedProductListRequest = {
                asset: 'BETH',
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        projectId: 'Solv-60d',
                        detail: {
                            asset: 'BTC',
                            rewardAsset: 'SOLV',
                            duration: 60,
                            renewable: true,
                            isSoldOut: true,
                            apr: '0.039',
                            status: 'PREHEATING',
                            subscriptionStartTime: '1646182276000',
                            canRedeemToFlex: true,
                        },
                        quota: { totalPersonalQuota: '2', minimum: '0.001' },
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getOnChainYieldsLockedProductList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOnChainYieldsLockedProductListResponse>)
            );
            const response = await client.getOnChainYieldsLockedProductList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedProductList')
                .mockRejectedValueOnce(mockError);
            await expect(client.getOnChainYieldsLockedProductList()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getOnChainYieldsLockedProductPosition()', () => {
        it('should execute getOnChainYieldsLockedProductPosition() successfully with required parameters only', async () => {
            mockResponse = {
                rows: [
                    {
                        positionId: '123123',
                        projectId: 'Solv-60d',
                        asset: 'BTC',
                        amount: '122.09202928',
                        purchaseTime: '1646182276000',
                        duration: '60',
                        accrualDays: '4',
                        rewardAsset: 'SOLV',
                        APY: '0.039',
                        rewardAmt: '5.17181528',
                        nextPay: '1.29295383',
                        nextPayDate: '1646697600000',
                        payPeriod: '1',
                        rewardsPayDate: '1646697600000',
                        rewardsEndDate: '1651449600000',
                        deliverDate: '1651536000000',
                        nextSubscriptionDate: '1651536000000',
                        redeemingAmt: '232.2323',
                        redeemTo: 'FLEXIBLE',
                        canRedeemEarly: true,
                        autoSubscribe: true,
                        type: 'AUTO',
                        status: 'HOLDING',
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getOnChainYieldsLockedProductPosition').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOnChainYieldsLockedProductPositionResponse>)
            );
            const response = await client.getOnChainYieldsLockedProductPosition();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOnChainYieldsLockedProductPosition() successfully with optional parameters', async () => {
            const params: GetOnChainYieldsLockedProductPositionRequest = {
                asset: 'BETH',
                positionId: 1,
                projectId: '1',
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        positionId: '123123',
                        projectId: 'Solv-60d',
                        asset: 'BTC',
                        amount: '122.09202928',
                        purchaseTime: '1646182276000',
                        duration: '60',
                        accrualDays: '4',
                        rewardAsset: 'SOLV',
                        APY: '0.039',
                        rewardAmt: '5.17181528',
                        nextPay: '1.29295383',
                        nextPayDate: '1646697600000',
                        payPeriod: '1',
                        rewardsPayDate: '1646697600000',
                        rewardsEndDate: '1651449600000',
                        deliverDate: '1651536000000',
                        nextSubscriptionDate: '1651536000000',
                        redeemingAmt: '232.2323',
                        redeemTo: 'FLEXIBLE',
                        canRedeemEarly: true,
                        autoSubscribe: true,
                        type: 'AUTO',
                        status: 'HOLDING',
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getOnChainYieldsLockedProductPosition').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOnChainYieldsLockedProductPositionResponse>)
            );
            const response = await client.getOnChainYieldsLockedProductPosition(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedProductPosition')
                .mockRejectedValueOnce(mockError);
            await expect(client.getOnChainYieldsLockedProductPosition()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getOnChainYieldsLockedRedemptionRecord()', () => {
        it('should execute getOnChainYieldsLockedRedemptionRecord() successfully with required parameters only', async () => {
            mockResponse = {
                rows: [
                    {
                        positionId: '123123',
                        redeemId: 40607,
                        time: 1575018510000,
                        asset: 'BTC',
                        lockPeriod: '30',
                        amount: '21312.23223',
                        originalAmount: '21312.23223',
                        type: 'NORMAL',
                        deliverDate: '1575018510000',
                        lossAmount: '0.00001232',
                        isComplete: true,
                        rewardAsset: 'SOLV',
                        rewardAmt: '5.17181528',
                        status: 'PAID',
                    },
                ],
                total: 1,
            };

            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedRedemptionRecord')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetOnChainYieldsLockedRedemptionRecordResponse>)
                );
            const response = await client.getOnChainYieldsLockedRedemptionRecord();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOnChainYieldsLockedRedemptionRecord() successfully with optional parameters', async () => {
            const params: GetOnChainYieldsLockedRedemptionRecordRequest = {
                positionId: 1,
                redeemId: '1',
                asset: 'BETH',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        positionId: '123123',
                        redeemId: 40607,
                        time: 1575018510000,
                        asset: 'BTC',
                        lockPeriod: '30',
                        amount: '21312.23223',
                        originalAmount: '21312.23223',
                        type: 'NORMAL',
                        deliverDate: '1575018510000',
                        lossAmount: '0.00001232',
                        isComplete: true,
                        rewardAsset: 'SOLV',
                        rewardAmt: '5.17181528',
                        status: 'PAID',
                    },
                ],
                total: 1,
            };

            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedRedemptionRecord')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetOnChainYieldsLockedRedemptionRecordResponse>)
                );
            const response = await client.getOnChainYieldsLockedRedemptionRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedRedemptionRecord')
                .mockRejectedValueOnce(mockError);
            await expect(client.getOnChainYieldsLockedRedemptionRecord()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getOnChainYieldsLockedRewardsHistory()', () => {
        it('should execute getOnChainYieldsLockedRewardsHistory() successfully with required parameters only', async () => {
            mockResponse = {
                rows: [
                    {
                        positionId: '123123',
                        time: 1575018510000,
                        asset: 'BNB',
                        lockPeriod: '30',
                        amount: '21312.23223',
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getOnChainYieldsLockedRewardsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOnChainYieldsLockedRewardsHistoryResponse>)
            );
            const response = await client.getOnChainYieldsLockedRewardsHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOnChainYieldsLockedRewardsHistory() successfully with optional parameters', async () => {
            const params: GetOnChainYieldsLockedRewardsHistoryRequest = {
                positionId: '1',
                asset: 'BETH',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        positionId: '123123',
                        time: 1575018510000,
                        asset: 'BNB',
                        lockPeriod: '30',
                        amount: '21312.23223',
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'getOnChainYieldsLockedRewardsHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOnChainYieldsLockedRewardsHistoryResponse>)
            );
            const response = await client.getOnChainYieldsLockedRewardsHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedRewardsHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getOnChainYieldsLockedRewardsHistory()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getOnChainYieldsLockedSubscriptionPreview()', () => {
        it('should execute getOnChainYieldsLockedSubscriptionPreview() successfully with required parameters only', async () => {
            const params: GetOnChainYieldsLockedSubscriptionPreviewRequest = {
                projectId: '1',
                amount: 1.0,
            };

            mockResponse = {
                rewardAsset: 'SOLV',
                totalRewardAmt: '5.17181528',
                nextPay: '1.29295383',
                nextPayDate: '1646697600000',
                rewardsPayDate: '1646697600000',
                valueDate: '1646697600000',
                rewardsEndDate: '1651449600000',
                deliverDate: '1651536000000',
                nextSubscriptionDate: '1651536000000',
            };

            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedSubscriptionPreview')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetOnChainYieldsLockedSubscriptionPreviewResponse>)
                );
            const response = await client.getOnChainYieldsLockedSubscriptionPreview(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOnChainYieldsLockedSubscriptionPreview() successfully with optional parameters', async () => {
            const params: GetOnChainYieldsLockedSubscriptionPreviewRequest = {
                projectId: '1',
                amount: 1.0,
                autoSubscribe: true,
                recvWindow: 5000,
            };

            mockResponse = {
                rewardAsset: 'SOLV',
                totalRewardAmt: '5.17181528',
                nextPay: '1.29295383',
                nextPayDate: '1646697600000',
                rewardsPayDate: '1646697600000',
                valueDate: '1646697600000',
                rewardsEndDate: '1651449600000',
                deliverDate: '1651536000000',
                nextSubscriptionDate: '1651536000000',
            };

            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedSubscriptionPreview')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetOnChainYieldsLockedSubscriptionPreviewResponse>)
                );
            const response = await client.getOnChainYieldsLockedSubscriptionPreview(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when projectId is missing', async () => {
            const _params: GetOnChainYieldsLockedSubscriptionPreviewRequest = {
                projectId: '1',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.projectId;

            await expect(client.getOnChainYieldsLockedSubscriptionPreview(params)).rejects.toThrow(
                'Required parameter projectId was null or undefined when calling getOnChainYieldsLockedSubscriptionPreview.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: GetOnChainYieldsLockedSubscriptionPreviewRequest = {
                projectId: '1',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.getOnChainYieldsLockedSubscriptionPreview(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling getOnChainYieldsLockedSubscriptionPreview.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetOnChainYieldsLockedSubscriptionPreviewRequest = {
                projectId: '1',
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedSubscriptionPreview')
                .mockRejectedValueOnce(mockError);
            await expect(client.getOnChainYieldsLockedSubscriptionPreview(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getOnChainYieldsLockedSubscriptionRecord()', () => {
        it('should execute getOnChainYieldsLockedSubscriptionRecord() successfully with required parameters only', async () => {
            mockResponse = {
                rows: [
                    {
                        positionId: '123123',
                        purchaseId: '26055',
                        projectId: 'Solv-60d',
                        clientId: 'ABC',
                        time: 1575018510000,
                        asset: 'BTC',
                        amount: '21312.23223',
                        lockPeriod: '30',
                        type: 'AUTO',
                        sourceAccount: 'SPOT',
                        amtFromSpot: '30',
                        amtFromFunding: '70',
                        status: 'SUCCESS',
                    },
                ],
                total: 1,
            };

            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedSubscriptionRecord')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetOnChainYieldsLockedSubscriptionRecordResponse>)
                );
            const response = await client.getOnChainYieldsLockedSubscriptionRecord();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOnChainYieldsLockedSubscriptionRecord() successfully with optional parameters', async () => {
            const params: GetOnChainYieldsLockedSubscriptionRecordRequest = {
                purchaseId: '1',
                clientId: '1',
                asset: 'BETH',
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        positionId: '123123',
                        purchaseId: '26055',
                        projectId: 'Solv-60d',
                        clientId: 'ABC',
                        time: 1575018510000,
                        asset: 'BTC',
                        amount: '21312.23223',
                        lockPeriod: '30',
                        type: 'AUTO',
                        sourceAccount: 'SPOT',
                        amtFromSpot: '30',
                        amtFromFunding: '70',
                        status: 'SUCCESS',
                    },
                ],
                total: 1,
            };

            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedSubscriptionRecord')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetOnChainYieldsLockedSubscriptionRecordResponse>)
                );
            const response = await client.getOnChainYieldsLockedSubscriptionRecord(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getOnChainYieldsLockedSubscriptionRecord')
                .mockRejectedValueOnce(mockError);
            await expect(client.getOnChainYieldsLockedSubscriptionRecord()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('onChainYieldsAccount()', () => {
        it('should execute onChainYieldsAccount() successfully with required parameters only', async () => {
            mockResponse = {
                totalAmountInBTC: '0.01067982',
                totalAmountInUSDT: '77.13289230',
                totalFlexibleAmountInBTC: '0.00000000',
                totalFlexibleAmountInUSDT: '0.00000000',
                totalLockedInBTC: '0.01067982',
                totalLockedInUSDT: '77.13289230',
            };

            const spy = jest.spyOn(client, 'onChainYieldsAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OnChainYieldsAccountResponse>)
            );
            const response = await client.onChainYieldsAccount();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute onChainYieldsAccount() successfully with optional parameters', async () => {
            const params: OnChainYieldsAccountRequest = {
                recvWindow: 5000,
            };

            mockResponse = {
                totalAmountInBTC: '0.01067982',
                totalAmountInUSDT: '77.13289230',
                totalFlexibleAmountInBTC: '0.00000000',
                totalFlexibleAmountInUSDT: '0.00000000',
                totalLockedInBTC: '0.01067982',
                totalLockedInUSDT: '77.13289230',
            };

            const spy = jest.spyOn(client, 'onChainYieldsAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OnChainYieldsAccountResponse>)
            );
            const response = await client.onChainYieldsAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'onChainYieldsAccount').mockRejectedValueOnce(mockError);
            await expect(client.onChainYieldsAccount()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('redeemOnChainYieldsLockedProduct()', () => {
        it('should execute redeemOnChainYieldsLockedProduct() successfully with required parameters only', async () => {
            const params: RedeemOnChainYieldsLockedProductRequest = {
                positionId: '1',
            };

            mockResponse = { redeemId: 40607, success: true };

            const spy = jest.spyOn(client, 'redeemOnChainYieldsLockedProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RedeemOnChainYieldsLockedProductResponse>)
            );
            const response = await client.redeemOnChainYieldsLockedProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute redeemOnChainYieldsLockedProduct() successfully with optional parameters', async () => {
            const params: RedeemOnChainYieldsLockedProductRequest = {
                positionId: '1',
                channelId: '1',
                recvWindow: 5000,
            };

            mockResponse = { redeemId: 40607, success: true };

            const spy = jest.spyOn(client, 'redeemOnChainYieldsLockedProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RedeemOnChainYieldsLockedProductResponse>)
            );
            const response = await client.redeemOnChainYieldsLockedProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when positionId is missing', async () => {
            const _params: RedeemOnChainYieldsLockedProductRequest = {
                positionId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.positionId;

            await expect(client.redeemOnChainYieldsLockedProduct(params)).rejects.toThrow(
                'Required parameter positionId was null or undefined when calling redeemOnChainYieldsLockedProduct.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: RedeemOnChainYieldsLockedProductRequest = {
                positionId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'redeemOnChainYieldsLockedProduct')
                .mockRejectedValueOnce(mockError);
            await expect(client.redeemOnChainYieldsLockedProduct(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('setOnChainYieldsLockedAutoSubscribe()', () => {
        it('should execute setOnChainYieldsLockedAutoSubscribe() successfully with required parameters only', async () => {
            const params: SetOnChainYieldsLockedAutoSubscribeRequest = {
                positionId: '1',
                autoSubscribe: true,
            };

            mockResponse = { success: true };

            const spy = jest.spyOn(client, 'setOnChainYieldsLockedAutoSubscribe').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SetOnChainYieldsLockedAutoSubscribeResponse>)
            );
            const response = await client.setOnChainYieldsLockedAutoSubscribe(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute setOnChainYieldsLockedAutoSubscribe() successfully with optional parameters', async () => {
            const params: SetOnChainYieldsLockedAutoSubscribeRequest = {
                positionId: '1',
                autoSubscribe: true,
                recvWindow: 5000,
            };

            mockResponse = { success: true };

            const spy = jest.spyOn(client, 'setOnChainYieldsLockedAutoSubscribe').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SetOnChainYieldsLockedAutoSubscribeResponse>)
            );
            const response = await client.setOnChainYieldsLockedAutoSubscribe(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when positionId is missing', async () => {
            const _params: SetOnChainYieldsLockedAutoSubscribeRequest = {
                positionId: '1',
                autoSubscribe: true,
            };
            const params = Object.assign({ ..._params });
            delete params?.positionId;

            await expect(client.setOnChainYieldsLockedAutoSubscribe(params)).rejects.toThrow(
                'Required parameter positionId was null or undefined when calling setOnChainYieldsLockedAutoSubscribe.'
            );
        });

        it('should throw RequiredError when autoSubscribe is missing', async () => {
            const _params: SetOnChainYieldsLockedAutoSubscribeRequest = {
                positionId: '1',
                autoSubscribe: true,
            };
            const params = Object.assign({ ..._params });
            delete params?.autoSubscribe;

            await expect(client.setOnChainYieldsLockedAutoSubscribe(params)).rejects.toThrow(
                'Required parameter autoSubscribe was null or undefined when calling setOnChainYieldsLockedAutoSubscribe.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SetOnChainYieldsLockedAutoSubscribeRequest = {
                positionId: '1',
                autoSubscribe: true,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'setOnChainYieldsLockedAutoSubscribe')
                .mockRejectedValueOnce(mockError);
            await expect(client.setOnChainYieldsLockedAutoSubscribe(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('setOnChainYieldsLockedProductRedeemOption()', () => {
        it('should execute setOnChainYieldsLockedProductRedeemOption() successfully with required parameters only', async () => {
            const params: SetOnChainYieldsLockedProductRedeemOptionRequest = {
                positionId: '1',
                redeemTo: 'redeemTo_example',
            };

            mockResponse = { success: true };

            const spy = jest
                .spyOn(client, 'setOnChainYieldsLockedProductRedeemOption')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<SetOnChainYieldsLockedProductRedeemOptionResponse>)
                );
            const response = await client.setOnChainYieldsLockedProductRedeemOption(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute setOnChainYieldsLockedProductRedeemOption() successfully with optional parameters', async () => {
            const params: SetOnChainYieldsLockedProductRedeemOptionRequest = {
                positionId: '1',
                redeemTo: 'redeemTo_example',
                recvWindow: 5000,
            };

            mockResponse = { success: true };

            const spy = jest
                .spyOn(client, 'setOnChainYieldsLockedProductRedeemOption')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<SetOnChainYieldsLockedProductRedeemOptionResponse>)
                );
            const response = await client.setOnChainYieldsLockedProductRedeemOption(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when positionId is missing', async () => {
            const _params: SetOnChainYieldsLockedProductRedeemOptionRequest = {
                positionId: '1',
                redeemTo: 'redeemTo_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.positionId;

            await expect(client.setOnChainYieldsLockedProductRedeemOption(params)).rejects.toThrow(
                'Required parameter positionId was null or undefined when calling setOnChainYieldsLockedProductRedeemOption.'
            );
        });

        it('should throw RequiredError when redeemTo is missing', async () => {
            const _params: SetOnChainYieldsLockedProductRedeemOptionRequest = {
                positionId: '1',
                redeemTo: 'redeemTo_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.redeemTo;

            await expect(client.setOnChainYieldsLockedProductRedeemOption(params)).rejects.toThrow(
                'Required parameter redeemTo was null or undefined when calling setOnChainYieldsLockedProductRedeemOption.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SetOnChainYieldsLockedProductRedeemOptionRequest = {
                positionId: '1',
                redeemTo: 'redeemTo_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'setOnChainYieldsLockedProductRedeemOption')
                .mockRejectedValueOnce(mockError);
            await expect(client.setOnChainYieldsLockedProductRedeemOption(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('subscribeOnChainYieldsLockedProduct()', () => {
        it('should execute subscribeOnChainYieldsLockedProduct() successfully with required parameters only', async () => {
            const params: SubscribeOnChainYieldsLockedProductRequest = {
                projectId: '1',
                amount: 1.0,
            };

            mockResponse = {
                purchaseId: 40607,
                positionId: '12345',
                amount: '75.46000000',
                success: true,
            };

            const spy = jest.spyOn(client, 'subscribeOnChainYieldsLockedProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubscribeOnChainYieldsLockedProductResponse>)
            );
            const response = await client.subscribeOnChainYieldsLockedProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute subscribeOnChainYieldsLockedProduct() successfully with optional parameters', async () => {
            const params: SubscribeOnChainYieldsLockedProductRequest = {
                projectId: '1',
                amount: 1.0,
                autoSubscribe: true,
                sourceAccount: 'SPOT',
                redeemTo: '',
                channelId: '1',
                clientId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                purchaseId: 40607,
                positionId: '12345',
                amount: '75.46000000',
                success: true,
            };

            const spy = jest.spyOn(client, 'subscribeOnChainYieldsLockedProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubscribeOnChainYieldsLockedProductResponse>)
            );
            const response = await client.subscribeOnChainYieldsLockedProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when projectId is missing', async () => {
            const _params: SubscribeOnChainYieldsLockedProductRequest = {
                projectId: '1',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.projectId;

            await expect(client.subscribeOnChainYieldsLockedProduct(params)).rejects.toThrow(
                'Required parameter projectId was null or undefined when calling subscribeOnChainYieldsLockedProduct.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: SubscribeOnChainYieldsLockedProductRequest = {
                projectId: '1',
                amount: 1.0,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.subscribeOnChainYieldsLockedProduct(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling subscribeOnChainYieldsLockedProduct.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SubscribeOnChainYieldsLockedProductRequest = {
                projectId: '1',
                amount: 1.0,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'subscribeOnChainYieldsLockedProduct')
                .mockRejectedValueOnce(mockError);
            await expect(client.subscribeOnChainYieldsLockedProduct(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });
});
