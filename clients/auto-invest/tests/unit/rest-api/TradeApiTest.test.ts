/**
 * Binance Auto Invest REST API
 *
 * OpenAPI Specification for the Binance Auto Invest REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { TradeApi } from '../../../src/rest-api';
import {
    ChangePlanStatusRequest,
    IndexLinkedPlanRebalanceDetailsRequest,
    IndexLinkedPlanRedemptionRequest,
    IndexLinkedPlanRedemptionTradeRequest,
    InvestmentPlanAdjustmentRequest,
    InvestmentPlanCreationRequest,
    OneTimeTransactionRequest,
    QueryHoldingDetailsOfThePlanRequest,
    QueryIndexLinkedPlanPositionDetailsRequest,
    QueryOneTimeTransactionStatusRequest,
    QuerySubscriptionTransactionHistoryRequest,
} from '../../../src/rest-api';
import type {
    ChangePlanStatusResponse,
    IndexLinkedPlanRebalanceDetailsResponse,
    IndexLinkedPlanRedemptionResponse,
    IndexLinkedPlanRedemptionTradeResponse,
    InvestmentPlanAdjustmentResponse,
    InvestmentPlanCreationResponse,
    OneTimeTransactionResponse,
    QueryHoldingDetailsOfThePlanResponse,
    QueryIndexLinkedPlanPositionDetailsResponse,
    QueryOneTimeTransactionStatusResponse,
    QuerySubscriptionTransactionHistoryResponse,
} from '../../../src/rest-api/types';

describe('TradeApi', () => {
    let client: TradeApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new TradeApi(config);
    });

    describe('changePlanStatus()', () => {
        it('should execute changePlanStatus() successfully with required parameters only', async () => {
            const params: ChangePlanStatusRequest = {
                planId: 1,
                status: 'status_example',
            };

            mockResponse = {
                planId: 12345,
                nextExecutionDateTime: 1648378800000,
                status: 'ONGOING',
            };

            const spy = jest.spyOn(client, 'changePlanStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangePlanStatusResponse>)
            );
            const response = await client.changePlanStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute changePlanStatus() successfully with optional parameters', async () => {
            const params: ChangePlanStatusRequest = {
                planId: 1,
                status: 'status_example',
                recvWindow: 5000,
            };

            mockResponse = {
                planId: 12345,
                nextExecutionDateTime: 1648378800000,
                status: 'ONGOING',
            };

            const spy = jest.spyOn(client, 'changePlanStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangePlanStatusResponse>)
            );
            const response = await client.changePlanStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when planId is missing', async () => {
            const _params: ChangePlanStatusRequest = {
                planId: 1,
                status: 'status_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.planId;

            await expect(client.changePlanStatus(params)).rejects.toThrow(
                'Required parameter planId was null or undefined when calling changePlanStatus.'
            );
        });

        it('should throw RequiredError when status is missing', async () => {
            const _params: ChangePlanStatusRequest = {
                planId: 1,
                status: 'status_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.status;

            await expect(client.changePlanStatus(params)).rejects.toThrow(
                'Required parameter status was null or undefined when calling changePlanStatus.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ChangePlanStatusRequest = {
                planId: 1,
                status: 'status_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'changePlanStatus').mockRejectedValueOnce(mockError);
            await expect(client.changePlanStatus(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('indexLinkedPlanRebalanceDetails()', () => {
        it('should execute indexLinkedPlanRebalanceDetails() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    indexId: 1,
                    indexName: 'BINANCE TOP 10 EW',
                    rebalanceId: 11,
                    status: 'SUCCESS',
                    rebalanceFee: '10',
                    rebalanceFeeUnit: 'USDT',
                    transactionDetails: [
                        {
                            asset: 'BTC',
                            transactionDateTime: 1648378800000,
                            rebalanceDirection: 'BUY',
                            rebalanceAmount: '0.005',
                        },
                        {
                            asset: 'ETH',
                            transactionDateTime: 1648378800000,
                            rebalanceDirection: 'BUY',
                            rebalanceAmount: '0.005',
                        },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'indexLinkedPlanRebalanceDetails').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<IndexLinkedPlanRebalanceDetailsResponse>)
            );
            const response = await client.indexLinkedPlanRebalanceDetails();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute indexLinkedPlanRebalanceDetails() successfully with optional parameters', async () => {
            const params: IndexLinkedPlanRebalanceDetailsRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 8,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    indexId: 1,
                    indexName: 'BINANCE TOP 10 EW',
                    rebalanceId: 11,
                    status: 'SUCCESS',
                    rebalanceFee: '10',
                    rebalanceFeeUnit: 'USDT',
                    transactionDetails: [
                        {
                            asset: 'BTC',
                            transactionDateTime: 1648378800000,
                            rebalanceDirection: 'BUY',
                            rebalanceAmount: '0.005',
                        },
                        {
                            asset: 'ETH',
                            transactionDateTime: 1648378800000,
                            rebalanceDirection: 'BUY',
                            rebalanceAmount: '0.005',
                        },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'indexLinkedPlanRebalanceDetails').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<IndexLinkedPlanRebalanceDetailsResponse>)
            );
            const response = await client.indexLinkedPlanRebalanceDetails(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'indexLinkedPlanRebalanceDetails')
                .mockRejectedValueOnce(mockError);
            await expect(client.indexLinkedPlanRebalanceDetails()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('indexLinkedPlanRedemption()', () => {
        it('should execute indexLinkedPlanRedemption() successfully with required parameters only', async () => {
            const params: IndexLinkedPlanRedemptionRequest = {
                indexId: 1,
                redemptionPercentage: 789,
            };

            mockResponse = { redemptionId: 19 };

            const spy = jest.spyOn(client, 'indexLinkedPlanRedemption').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<IndexLinkedPlanRedemptionResponse>)
            );
            const response = await client.indexLinkedPlanRedemption(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute indexLinkedPlanRedemption() successfully with optional parameters', async () => {
            const params: IndexLinkedPlanRedemptionRequest = {
                indexId: 1,
                redemptionPercentage: 789,
                requestId: '1',
                recvWindow: 5000,
            };

            mockResponse = { redemptionId: 19 };

            const spy = jest.spyOn(client, 'indexLinkedPlanRedemption').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<IndexLinkedPlanRedemptionResponse>)
            );
            const response = await client.indexLinkedPlanRedemption(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when indexId is missing', async () => {
            const _params: IndexLinkedPlanRedemptionRequest = {
                indexId: 1,
                redemptionPercentage: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.indexId;

            await expect(client.indexLinkedPlanRedemption(params)).rejects.toThrow(
                'Required parameter indexId was null or undefined when calling indexLinkedPlanRedemption.'
            );
        });

        it('should throw RequiredError when redemptionPercentage is missing', async () => {
            const _params: IndexLinkedPlanRedemptionRequest = {
                indexId: 1,
                redemptionPercentage: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.redemptionPercentage;

            await expect(client.indexLinkedPlanRedemption(params)).rejects.toThrow(
                'Required parameter redemptionPercentage was null or undefined when calling indexLinkedPlanRedemption.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: IndexLinkedPlanRedemptionRequest = {
                indexId: 1,
                redemptionPercentage: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'indexLinkedPlanRedemption')
                .mockRejectedValueOnce(mockError);
            await expect(client.indexLinkedPlanRedemption(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('indexLinkedPlanRedemptionTrade()', () => {
        it('should execute indexLinkedPlanRedemptionTrade() successfully with required parameters only', async () => {
            const params: IndexLinkedPlanRedemptionTradeRequest = {
                requestId: 1,
            };

            mockResponse = [
                {
                    indexId: 1,
                    indexName: 'BINANCE TOP 10 EW',
                    redemptionId: 11,
                    status: 'SUCCESS',
                    asset: 'BTC',
                    amount: '0.005',
                    redemptionDateTime: 1648378800000,
                    transactionFee: '0',
                    transactionFeeUnit: 'USDT',
                },
                {
                    indexId: 1,
                    indexName: 'BINANCE TOP 10 EW',
                    redemptionId: 12,
                    status: 'SUCCESS',
                    asset: 'BNB',
                    amount: '0.005',
                    redemptionDateTime: 1648378800000,
                    transactionFee: '0',
                    transactionFeeUnit: 'USDT',
                },
            ];

            const spy = jest.spyOn(client, 'indexLinkedPlanRedemptionTrade').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<IndexLinkedPlanRedemptionTradeResponse>)
            );
            const response = await client.indexLinkedPlanRedemptionTrade(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute indexLinkedPlanRedemptionTrade() successfully with optional parameters', async () => {
            const params: IndexLinkedPlanRedemptionTradeRequest = {
                requestId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                asset: 'asset_example',
                size: 8,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    indexId: 1,
                    indexName: 'BINANCE TOP 10 EW',
                    redemptionId: 11,
                    status: 'SUCCESS',
                    asset: 'BTC',
                    amount: '0.005',
                    redemptionDateTime: 1648378800000,
                    transactionFee: '0',
                    transactionFeeUnit: 'USDT',
                },
                {
                    indexId: 1,
                    indexName: 'BINANCE TOP 10 EW',
                    redemptionId: 12,
                    status: 'SUCCESS',
                    asset: 'BNB',
                    amount: '0.005',
                    redemptionDateTime: 1648378800000,
                    transactionFee: '0',
                    transactionFeeUnit: 'USDT',
                },
            ];

            const spy = jest.spyOn(client, 'indexLinkedPlanRedemptionTrade').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<IndexLinkedPlanRedemptionTradeResponse>)
            );
            const response = await client.indexLinkedPlanRedemptionTrade(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when requestId is missing', async () => {
            const _params: IndexLinkedPlanRedemptionTradeRequest = {
                requestId: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.requestId;

            await expect(client.indexLinkedPlanRedemptionTrade(params)).rejects.toThrow(
                'Required parameter requestId was null or undefined when calling indexLinkedPlanRedemptionTrade.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: IndexLinkedPlanRedemptionTradeRequest = {
                requestId: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'indexLinkedPlanRedemptionTrade')
                .mockRejectedValueOnce(mockError);
            await expect(client.indexLinkedPlanRedemptionTrade(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('investmentPlanAdjustment()', () => {
        it('should execute investmentPlanAdjustment() successfully with required parameters only', async () => {
            const params: InvestmentPlanAdjustmentRequest = {
                planId: 1,
                subscriptionAmount: 1,
                subscriptionCycle: 'subscriptionCycle_example',
                subscriptionStartTime: 789,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };

            mockResponse = { planId: 12345, nextExecutionDateTime: 1648378800000 };

            const spy = jest.spyOn(client, 'investmentPlanAdjustment').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<InvestmentPlanAdjustmentResponse>)
            );
            const response = await client.investmentPlanAdjustment(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute investmentPlanAdjustment() successfully with optional parameters', async () => {
            const params: InvestmentPlanAdjustmentRequest = {
                planId: 1,
                subscriptionAmount: 1,
                subscriptionCycle: 'subscriptionCycle_example',
                subscriptionStartTime: 789,
                sourceAsset: 'sourceAsset_example',
                details: [],
                flexibleAllowedToUse: true,
                recvWindow: 5000,
            };

            mockResponse = { planId: 12345, nextExecutionDateTime: 1648378800000 };

            const spy = jest.spyOn(client, 'investmentPlanAdjustment').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<InvestmentPlanAdjustmentResponse>)
            );
            const response = await client.investmentPlanAdjustment(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when planId is missing', async () => {
            const _params: InvestmentPlanAdjustmentRequest = {
                planId: 1,
                subscriptionAmount: 1,
                subscriptionCycle: 'subscriptionCycle_example',
                subscriptionStartTime: 789,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.planId;

            await expect(client.investmentPlanAdjustment(params)).rejects.toThrow(
                'Required parameter planId was null or undefined when calling investmentPlanAdjustment.'
            );
        });

        it('should throw RequiredError when subscriptionAmount is missing', async () => {
            const _params: InvestmentPlanAdjustmentRequest = {
                planId: 1,
                subscriptionAmount: 1,
                subscriptionCycle: 'subscriptionCycle_example',
                subscriptionStartTime: 789,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.subscriptionAmount;

            await expect(client.investmentPlanAdjustment(params)).rejects.toThrow(
                'Required parameter subscriptionAmount was null or undefined when calling investmentPlanAdjustment.'
            );
        });

        it('should throw RequiredError when subscriptionCycle is missing', async () => {
            const _params: InvestmentPlanAdjustmentRequest = {
                planId: 1,
                subscriptionAmount: 1,
                subscriptionCycle: 'subscriptionCycle_example',
                subscriptionStartTime: 789,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.subscriptionCycle;

            await expect(client.investmentPlanAdjustment(params)).rejects.toThrow(
                'Required parameter subscriptionCycle was null or undefined when calling investmentPlanAdjustment.'
            );
        });

        it('should throw RequiredError when subscriptionStartTime is missing', async () => {
            const _params: InvestmentPlanAdjustmentRequest = {
                planId: 1,
                subscriptionAmount: 1,
                subscriptionCycle: 'subscriptionCycle_example',
                subscriptionStartTime: 789,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.subscriptionStartTime;

            await expect(client.investmentPlanAdjustment(params)).rejects.toThrow(
                'Required parameter subscriptionStartTime was null or undefined when calling investmentPlanAdjustment.'
            );
        });

        it('should throw RequiredError when sourceAsset is missing', async () => {
            const _params: InvestmentPlanAdjustmentRequest = {
                planId: 1,
                subscriptionAmount: 1,
                subscriptionCycle: 'subscriptionCycle_example',
                subscriptionStartTime: 789,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.sourceAsset;

            await expect(client.investmentPlanAdjustment(params)).rejects.toThrow(
                'Required parameter sourceAsset was null or undefined when calling investmentPlanAdjustment.'
            );
        });

        it('should throw RequiredError when details is missing', async () => {
            const _params: InvestmentPlanAdjustmentRequest = {
                planId: 1,
                subscriptionAmount: 1,
                subscriptionCycle: 'subscriptionCycle_example',
                subscriptionStartTime: 789,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.details;

            await expect(client.investmentPlanAdjustment(params)).rejects.toThrow(
                'Required parameter details was null or undefined when calling investmentPlanAdjustment.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: InvestmentPlanAdjustmentRequest = {
                planId: 1,
                subscriptionAmount: 1,
                subscriptionCycle: 'subscriptionCycle_example',
                subscriptionStartTime: 789,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'investmentPlanAdjustment')
                .mockRejectedValueOnce(mockError);
            await expect(client.investmentPlanAdjustment(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('investmentPlanCreation()', () => {
        it('should execute investmentPlanCreation() successfully with required parameters only', async () => {
            const params: InvestmentPlanCreationRequest = {
                sourceType: 'sourceType_example',
                planType: 'planType_example',
                subscriptionAmount: 1,
                subscriptionCycle: 'subscriptionCycle_example',
                subscriptionStartTime: 789,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };

            mockResponse = { planId: 12345, nextExecutionDateTime: 1648378800000 };

            const spy = jest.spyOn(client, 'investmentPlanCreation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<InvestmentPlanCreationResponse>)
            );
            const response = await client.investmentPlanCreation(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute investmentPlanCreation() successfully with optional parameters', async () => {
            const params: InvestmentPlanCreationRequest = {
                sourceType: 'sourceType_example',
                planType: 'planType_example',
                subscriptionAmount: 1,
                subscriptionCycle: 'subscriptionCycle_example',
                subscriptionStartTime: 789,
                sourceAsset: 'sourceAsset_example',
                details: [],
                requestId: '1',
                indexId: 1,
                flexibleAllowedToUse: true,
                recvWindow: 5000,
            };

            mockResponse = { planId: 12345, nextExecutionDateTime: 1648378800000 };

            const spy = jest.spyOn(client, 'investmentPlanCreation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<InvestmentPlanCreationResponse>)
            );
            const response = await client.investmentPlanCreation(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when sourceType is missing', async () => {
            const _params: InvestmentPlanCreationRequest = {
                sourceType: 'sourceType_example',
                planType: 'planType_example',
                subscriptionAmount: 1,
                subscriptionCycle: 'subscriptionCycle_example',
                subscriptionStartTime: 789,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.sourceType;

            await expect(client.investmentPlanCreation(params)).rejects.toThrow(
                'Required parameter sourceType was null or undefined when calling investmentPlanCreation.'
            );
        });

        it('should throw RequiredError when planType is missing', async () => {
            const _params: InvestmentPlanCreationRequest = {
                sourceType: 'sourceType_example',
                planType: 'planType_example',
                subscriptionAmount: 1,
                subscriptionCycle: 'subscriptionCycle_example',
                subscriptionStartTime: 789,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.planType;

            await expect(client.investmentPlanCreation(params)).rejects.toThrow(
                'Required parameter planType was null or undefined when calling investmentPlanCreation.'
            );
        });

        it('should throw RequiredError when subscriptionAmount is missing', async () => {
            const _params: InvestmentPlanCreationRequest = {
                sourceType: 'sourceType_example',
                planType: 'planType_example',
                subscriptionAmount: 1,
                subscriptionCycle: 'subscriptionCycle_example',
                subscriptionStartTime: 789,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.subscriptionAmount;

            await expect(client.investmentPlanCreation(params)).rejects.toThrow(
                'Required parameter subscriptionAmount was null or undefined when calling investmentPlanCreation.'
            );
        });

        it('should throw RequiredError when subscriptionCycle is missing', async () => {
            const _params: InvestmentPlanCreationRequest = {
                sourceType: 'sourceType_example',
                planType: 'planType_example',
                subscriptionAmount: 1,
                subscriptionCycle: 'subscriptionCycle_example',
                subscriptionStartTime: 789,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.subscriptionCycle;

            await expect(client.investmentPlanCreation(params)).rejects.toThrow(
                'Required parameter subscriptionCycle was null or undefined when calling investmentPlanCreation.'
            );
        });

        it('should throw RequiredError when subscriptionStartTime is missing', async () => {
            const _params: InvestmentPlanCreationRequest = {
                sourceType: 'sourceType_example',
                planType: 'planType_example',
                subscriptionAmount: 1,
                subscriptionCycle: 'subscriptionCycle_example',
                subscriptionStartTime: 789,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.subscriptionStartTime;

            await expect(client.investmentPlanCreation(params)).rejects.toThrow(
                'Required parameter subscriptionStartTime was null or undefined when calling investmentPlanCreation.'
            );
        });

        it('should throw RequiredError when sourceAsset is missing', async () => {
            const _params: InvestmentPlanCreationRequest = {
                sourceType: 'sourceType_example',
                planType: 'planType_example',
                subscriptionAmount: 1,
                subscriptionCycle: 'subscriptionCycle_example',
                subscriptionStartTime: 789,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.sourceAsset;

            await expect(client.investmentPlanCreation(params)).rejects.toThrow(
                'Required parameter sourceAsset was null or undefined when calling investmentPlanCreation.'
            );
        });

        it('should throw RequiredError when details is missing', async () => {
            const _params: InvestmentPlanCreationRequest = {
                sourceType: 'sourceType_example',
                planType: 'planType_example',
                subscriptionAmount: 1,
                subscriptionCycle: 'subscriptionCycle_example',
                subscriptionStartTime: 789,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.details;

            await expect(client.investmentPlanCreation(params)).rejects.toThrow(
                'Required parameter details was null or undefined when calling investmentPlanCreation.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: InvestmentPlanCreationRequest = {
                sourceType: 'sourceType_example',
                planType: 'planType_example',
                subscriptionAmount: 1,
                subscriptionCycle: 'subscriptionCycle_example',
                subscriptionStartTime: 789,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'investmentPlanCreation')
                .mockRejectedValueOnce(mockError);
            await expect(client.investmentPlanCreation(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('oneTimeTransaction()', () => {
        it('should execute oneTimeTransaction() successfully with required parameters only', async () => {
            const params: OneTimeTransactionRequest = {
                sourceType: 'sourceType_example',
                subscriptionAmount: 1,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };

            mockResponse = { transactionId: 12345, waitSecond: 5 };

            const spy = jest.spyOn(client, 'oneTimeTransaction').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OneTimeTransactionResponse>)
            );
            const response = await client.oneTimeTransaction(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute oneTimeTransaction() successfully with optional parameters', async () => {
            const params: OneTimeTransactionRequest = {
                sourceType: 'sourceType_example',
                subscriptionAmount: 1,
                sourceAsset: 'sourceAsset_example',
                details: [],
                requestId: '1',
                flexibleAllowedToUse: true,
                planId: 1,
                indexId: 1,
                recvWindow: 5000,
            };

            mockResponse = { transactionId: 12345, waitSecond: 5 };

            const spy = jest.spyOn(client, 'oneTimeTransaction').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OneTimeTransactionResponse>)
            );
            const response = await client.oneTimeTransaction(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when sourceType is missing', async () => {
            const _params: OneTimeTransactionRequest = {
                sourceType: 'sourceType_example',
                subscriptionAmount: 1,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.sourceType;

            await expect(client.oneTimeTransaction(params)).rejects.toThrow(
                'Required parameter sourceType was null or undefined when calling oneTimeTransaction.'
            );
        });

        it('should throw RequiredError when subscriptionAmount is missing', async () => {
            const _params: OneTimeTransactionRequest = {
                sourceType: 'sourceType_example',
                subscriptionAmount: 1,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.subscriptionAmount;

            await expect(client.oneTimeTransaction(params)).rejects.toThrow(
                'Required parameter subscriptionAmount was null or undefined when calling oneTimeTransaction.'
            );
        });

        it('should throw RequiredError when sourceAsset is missing', async () => {
            const _params: OneTimeTransactionRequest = {
                sourceType: 'sourceType_example',
                subscriptionAmount: 1,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.sourceAsset;

            await expect(client.oneTimeTransaction(params)).rejects.toThrow(
                'Required parameter sourceAsset was null or undefined when calling oneTimeTransaction.'
            );
        });

        it('should throw RequiredError when details is missing', async () => {
            const _params: OneTimeTransactionRequest = {
                sourceType: 'sourceType_example',
                subscriptionAmount: 1,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.details;

            await expect(client.oneTimeTransaction(params)).rejects.toThrow(
                'Required parameter details was null or undefined when calling oneTimeTransaction.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OneTimeTransactionRequest = {
                sourceType: 'sourceType_example',
                subscriptionAmount: 1,
                sourceAsset: 'sourceAsset_example',
                details: [],
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'oneTimeTransaction').mockRejectedValueOnce(mockError);
            await expect(client.oneTimeTransaction(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryHoldingDetailsOfThePlan()', () => {
        it('should execute queryHoldingDetailsOfThePlan() successfully with required parameters only', async () => {
            mockResponse = {
                planId: 111212,
                planType: 'INDEX',
                editAllowed: 'true',
                flexibleAllowedToUse: 'false',
                creationDateTime: 1648378800000,
                firstExecutionDateTime: 1648378800000,
                nextExecutionDateTime: 1648378800000,
                status: 'ONGOING',
                targetAsset: 'BTC',
                sourceAsset: 'BUSD',
                planValueInUSD: '101.2',
                pnlInUSD: '101.2',
                roi: '1.023',
                totalInvestedInUSD: '122',
                details: [
                    {
                        targetAsset: 'ADA',
                        averagePriceInUSD: '3.4',
                        totalInvestedInUSD: '222.21',
                        purchasedAmount: '122.12345678',
                        purchasedAmountUnit: 'ADA',
                        pnlInUSD: '109.2',
                        roi: '0.1',
                        percentage: '50',
                        assetStatus: 'ACTIVE',
                        availableAmount: '122.12345678',
                        availableAmountUnit: 'ADA',
                        redeemedAmout: '122.12345678',
                        redeemedAmoutUnit: 'ADA',
                        assetValueInUSD: '101.2',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'queryHoldingDetailsOfThePlan').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryHoldingDetailsOfThePlanResponse>)
            );
            const response = await client.queryHoldingDetailsOfThePlan();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryHoldingDetailsOfThePlan() successfully with optional parameters', async () => {
            const params: QueryHoldingDetailsOfThePlanRequest = {
                planId: 1,
                requestId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                planId: 111212,
                planType: 'INDEX',
                editAllowed: 'true',
                flexibleAllowedToUse: 'false',
                creationDateTime: 1648378800000,
                firstExecutionDateTime: 1648378800000,
                nextExecutionDateTime: 1648378800000,
                status: 'ONGOING',
                targetAsset: 'BTC',
                sourceAsset: 'BUSD',
                planValueInUSD: '101.2',
                pnlInUSD: '101.2',
                roi: '1.023',
                totalInvestedInUSD: '122',
                details: [
                    {
                        targetAsset: 'ADA',
                        averagePriceInUSD: '3.4',
                        totalInvestedInUSD: '222.21',
                        purchasedAmount: '122.12345678',
                        purchasedAmountUnit: 'ADA',
                        pnlInUSD: '109.2',
                        roi: '0.1',
                        percentage: '50',
                        assetStatus: 'ACTIVE',
                        availableAmount: '122.12345678',
                        availableAmountUnit: 'ADA',
                        redeemedAmout: '122.12345678',
                        redeemedAmoutUnit: 'ADA',
                        assetValueInUSD: '101.2',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'queryHoldingDetailsOfThePlan').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryHoldingDetailsOfThePlanResponse>)
            );
            const response = await client.queryHoldingDetailsOfThePlan(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryHoldingDetailsOfThePlan')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryHoldingDetailsOfThePlan()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryIndexLinkedPlanPositionDetails()', () => {
        it('should execute queryIndexLinkedPlanPositionDetails() successfully with required parameters only', async () => {
            const params: QueryIndexLinkedPlanPositionDetailsRequest = {
                indexId: 1,
            };

            mockResponse = {
                indexId: 1,
                totalInvestedInUSD: '114.555',
                currentInvestedInUSD: '101.2',
                pnlInUSD: '101.2',
                roi: '1.023',
                assetAllocation: [
                    { targetAsset: 'ADA', allocation: '10' },
                    { targetAsset: 'BTC', allocation: '10' },
                ],
                details: [
                    {
                        targetAsset: 'ADA',
                        averagePriceInUSD: '3.4',
                        totalInvestedInUSD: '222.21',
                        currentInvestedInUSD: '101.2',
                        purchasedAmount: '122.12345678',
                        pnlInUSD: '109.2',
                        roi: '0.1',
                        percentage: '10',
                        availableAmount: '122.12345678',
                        redeemedAmount: '122.12345678',
                        assetValueInUSD: '101.2',
                    },
                    {
                        targetAsset: 'MATIC',
                        averagePriceInUSD: '3.4',
                        totalInvestedInUSD: '222.21',
                        currentInvestedInUSD: '101.2',
                        purchasedAmount: '122.12345678',
                        pnlInUSD: '109.2',
                        roi: '0.1',
                        percentage: '10',
                        availableAmount: '122.12345678',
                        redeemedAmount: '122.12345678',
                        assetValueInUSD: '101.2',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'queryIndexLinkedPlanPositionDetails').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryIndexLinkedPlanPositionDetailsResponse>)
            );
            const response = await client.queryIndexLinkedPlanPositionDetails(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryIndexLinkedPlanPositionDetails() successfully with optional parameters', async () => {
            const params: QueryIndexLinkedPlanPositionDetailsRequest = {
                indexId: 1,
                recvWindow: 5000,
            };

            mockResponse = {
                indexId: 1,
                totalInvestedInUSD: '114.555',
                currentInvestedInUSD: '101.2',
                pnlInUSD: '101.2',
                roi: '1.023',
                assetAllocation: [
                    { targetAsset: 'ADA', allocation: '10' },
                    { targetAsset: 'BTC', allocation: '10' },
                ],
                details: [
                    {
                        targetAsset: 'ADA',
                        averagePriceInUSD: '3.4',
                        totalInvestedInUSD: '222.21',
                        currentInvestedInUSD: '101.2',
                        purchasedAmount: '122.12345678',
                        pnlInUSD: '109.2',
                        roi: '0.1',
                        percentage: '10',
                        availableAmount: '122.12345678',
                        redeemedAmount: '122.12345678',
                        assetValueInUSD: '101.2',
                    },
                    {
                        targetAsset: 'MATIC',
                        averagePriceInUSD: '3.4',
                        totalInvestedInUSD: '222.21',
                        currentInvestedInUSD: '101.2',
                        purchasedAmount: '122.12345678',
                        pnlInUSD: '109.2',
                        roi: '0.1',
                        percentage: '10',
                        availableAmount: '122.12345678',
                        redeemedAmount: '122.12345678',
                        assetValueInUSD: '101.2',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'queryIndexLinkedPlanPositionDetails').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryIndexLinkedPlanPositionDetailsResponse>)
            );
            const response = await client.queryIndexLinkedPlanPositionDetails(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when indexId is missing', async () => {
            const _params: QueryIndexLinkedPlanPositionDetailsRequest = {
                indexId: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.indexId;

            await expect(client.queryIndexLinkedPlanPositionDetails(params)).rejects.toThrow(
                'Required parameter indexId was null or undefined when calling queryIndexLinkedPlanPositionDetails.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryIndexLinkedPlanPositionDetailsRequest = {
                indexId: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryIndexLinkedPlanPositionDetails')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryIndexLinkedPlanPositionDetails(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryOneTimeTransactionStatus()', () => {
        it('should execute queryOneTimeTransactionStatus() successfully with required parameters only', async () => {
            const params: QueryOneTimeTransactionStatusRequest = {
                transactionId: 1,
            };

            mockResponse = { transactionId: 12345, status: 'SUCCESS' };

            const spy = jest.spyOn(client, 'queryOneTimeTransactionStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryOneTimeTransactionStatusResponse>)
            );
            const response = await client.queryOneTimeTransactionStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryOneTimeTransactionStatus() successfully with optional parameters', async () => {
            const params: QueryOneTimeTransactionStatusRequest = {
                transactionId: 1,
                requestId: '1',
                recvWindow: 5000,
            };

            mockResponse = { transactionId: 12345, status: 'SUCCESS' };

            const spy = jest.spyOn(client, 'queryOneTimeTransactionStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryOneTimeTransactionStatusResponse>)
            );
            const response = await client.queryOneTimeTransactionStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when transactionId is missing', async () => {
            const _params: QueryOneTimeTransactionStatusRequest = {
                transactionId: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.transactionId;

            await expect(client.queryOneTimeTransactionStatus(params)).rejects.toThrow(
                'Required parameter transactionId was null or undefined when calling queryOneTimeTransactionStatus.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryOneTimeTransactionStatusRequest = {
                transactionId: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryOneTimeTransactionStatus')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryOneTimeTransactionStatus(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('querySubscriptionTransactionHistory()', () => {
        it('should execute querySubscriptionTransactionHistory() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    id: 1111,
                    targetAsset: 'BTC',
                    planType: 'SINGLE',
                    planName: 'BTC',
                    planId: 1234,
                    transactionDateTime: 1648378800000,
                    transactionStatus: 'SUCCESS',
                    failedType: 'INSUFFICIENT_BALANCE',
                    sourceAsset: 'BUSD',
                    sourceAssetAmount: '297.12345',
                    targetAssetAmount: '0.005',
                    sourceWallet: 'SPOT_WALLET',
                    flexibleUsed: 'false',
                    transactionFee: '0.002',
                    transactionFeeUnit: 'BUSD',
                    executionPrice: '2342',
                    executionType: 'RECURRING',
                    subscriptionCycle: 'WEEKLY',
                },
            ];

            const spy = jest.spyOn(client, 'querySubscriptionTransactionHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySubscriptionTransactionHistoryResponse>)
            );
            const response = await client.querySubscriptionTransactionHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute querySubscriptionTransactionHistory() successfully with optional parameters', async () => {
            const params: QuerySubscriptionTransactionHistoryRequest = {
                planId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                targetAsset: 789,
                planType: 789,
                size: 8,
                current: 1,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    id: 1111,
                    targetAsset: 'BTC',
                    planType: 'SINGLE',
                    planName: 'BTC',
                    planId: 1234,
                    transactionDateTime: 1648378800000,
                    transactionStatus: 'SUCCESS',
                    failedType: 'INSUFFICIENT_BALANCE',
                    sourceAsset: 'BUSD',
                    sourceAssetAmount: '297.12345',
                    targetAssetAmount: '0.005',
                    sourceWallet: 'SPOT_WALLET',
                    flexibleUsed: 'false',
                    transactionFee: '0.002',
                    transactionFeeUnit: 'BUSD',
                    executionPrice: '2342',
                    executionType: 'RECURRING',
                    subscriptionCycle: 'WEEKLY',
                },
            ];

            const spy = jest.spyOn(client, 'querySubscriptionTransactionHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySubscriptionTransactionHistoryResponse>)
            );
            const response = await client.querySubscriptionTransactionHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'querySubscriptionTransactionHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.querySubscriptionTransactionHistory()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });
});
