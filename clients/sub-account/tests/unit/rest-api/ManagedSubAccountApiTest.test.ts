/**
 * Binance Public Sub Account REST API
 *
 * OpenAPI Specification for the Binance Public Sub Account REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { ManagedSubAccountApi } from '../../../src/rest-api';
import {
    DepositAssetsIntoTheManagedSubAccountRequest,
    GetManagedSubAccountDepositAddressRequest,
    QueryManagedSubAccountAssetDetailsRequest,
    QueryManagedSubAccountFuturesAssetDetailsRequest,
    QueryManagedSubAccountListRequest,
    QueryManagedSubAccountMarginAssetDetailsRequest,
    QueryManagedSubAccountSnapshotRequest,
    QueryManagedSubAccountTransferLogMasterAccountInvestorRequest,
    QueryManagedSubAccountTransferLogMasterAccountTradingRequest,
    QueryManagedSubAccountTransferLogSubAccountTradingRequest,
    WithdrawlAssetsFromTheManagedSubAccountRequest,
} from '../../../src/rest-api';
import type {
    DepositAssetsIntoTheManagedSubAccountResponse,
    GetManagedSubAccountDepositAddressResponse,
    QueryManagedSubAccountAssetDetailsResponse,
    QueryManagedSubAccountFuturesAssetDetailsResponse,
    QueryManagedSubAccountListResponse,
    QueryManagedSubAccountMarginAssetDetailsResponse,
    QueryManagedSubAccountSnapshotResponse,
    QueryManagedSubAccountTransferLogMasterAccountInvestorResponse,
    QueryManagedSubAccountTransferLogMasterAccountTradingResponse,
    QueryManagedSubAccountTransferLogSubAccountTradingResponse,
    WithdrawlAssetsFromTheManagedSubAccountResponse,
} from '../../../src/rest-api/types';

describe('ManagedSubAccountApi', () => {
    let client: ManagedSubAccountApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new ManagedSubAccountApi(config);
    });

    describe('depositAssetsIntoTheManagedSubAccount()', () => {
        it('should execute depositAssetsIntoTheManagedSubAccount() successfully with required parameters only', async () => {
            const params: DepositAssetsIntoTheManagedSubAccountRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1,
            };

            mockResponse = { tranId: 66157362489 };

            const spy = jest.spyOn(client, 'depositAssetsIntoTheManagedSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepositAssetsIntoTheManagedSubAccountResponse>)
            );
            const response = await client.depositAssetsIntoTheManagedSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute depositAssetsIntoTheManagedSubAccount() successfully with optional parameters', async () => {
            const params: DepositAssetsIntoTheManagedSubAccountRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1,
                recvWindow: 5000,
            };

            mockResponse = { tranId: 66157362489 };

            const spy = jest.spyOn(client, 'depositAssetsIntoTheManagedSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<DepositAssetsIntoTheManagedSubAccountResponse>)
            );
            const response = await client.depositAssetsIntoTheManagedSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when toEmail is missing', async () => {
            const _params: DepositAssetsIntoTheManagedSubAccountRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.toEmail;

            await expect(client.depositAssetsIntoTheManagedSubAccount(params)).rejects.toThrow(
                'Required parameter toEmail was null or undefined when calling depositAssetsIntoTheManagedSubAccount.'
            );
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: DepositAssetsIntoTheManagedSubAccountRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.depositAssetsIntoTheManagedSubAccount(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling depositAssetsIntoTheManagedSubAccount.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: DepositAssetsIntoTheManagedSubAccountRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.depositAssetsIntoTheManagedSubAccount(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling depositAssetsIntoTheManagedSubAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: DepositAssetsIntoTheManagedSubAccountRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'depositAssetsIntoTheManagedSubAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.depositAssetsIntoTheManagedSubAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getManagedSubAccountDepositAddress()', () => {
        it('should execute getManagedSubAccountDepositAddress() successfully with required parameters only', async () => {
            const params: GetManagedSubAccountDepositAddressRequest = {
                email: 'sub-account-email@email.com',
                coin: 'coin_example',
            };

            mockResponse = {
                coin: 'USDT',
                address: '0x206c22d833bb0bb2102da6b7c7d4c3eb14bcf73d',
                tag: '',
                url: 'https://etherscan.io/address/0x206c22d833bb0bb2102da6b7c7d4c3eb14bcf73d',
            };

            const spy = jest.spyOn(client, 'getManagedSubAccountDepositAddress').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetManagedSubAccountDepositAddressResponse>)
            );
            const response = await client.getManagedSubAccountDepositAddress(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getManagedSubAccountDepositAddress() successfully with optional parameters', async () => {
            const params: GetManagedSubAccountDepositAddressRequest = {
                email: 'sub-account-email@email.com',
                coin: 'coin_example',
                network: 'network_example',
                amount: 1,
                recvWindow: 5000,
            };

            mockResponse = {
                coin: 'USDT',
                address: '0x206c22d833bb0bb2102da6b7c7d4c3eb14bcf73d',
                tag: '',
                url: 'https://etherscan.io/address/0x206c22d833bb0bb2102da6b7c7d4c3eb14bcf73d',
            };

            const spy = jest.spyOn(client, 'getManagedSubAccountDepositAddress').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetManagedSubAccountDepositAddressResponse>)
            );
            const response = await client.getManagedSubAccountDepositAddress(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: GetManagedSubAccountDepositAddressRequest = {
                email: 'sub-account-email@email.com',
                coin: 'coin_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.getManagedSubAccountDepositAddress(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling getManagedSubAccountDepositAddress.'
            );
        });

        it('should throw RequiredError when coin is missing', async () => {
            const _params: GetManagedSubAccountDepositAddressRequest = {
                email: 'sub-account-email@email.com',
                coin: 'coin_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.coin;

            await expect(client.getManagedSubAccountDepositAddress(params)).rejects.toThrow(
                'Required parameter coin was null or undefined when calling getManagedSubAccountDepositAddress.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetManagedSubAccountDepositAddressRequest = {
                email: 'sub-account-email@email.com',
                coin: 'coin_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getManagedSubAccountDepositAddress')
                .mockRejectedValueOnce(mockError);
            await expect(client.getManagedSubAccountDepositAddress(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryManagedSubAccountAssetDetails()', () => {
        it('should execute queryManagedSubAccountAssetDetails() successfully with required parameters only', async () => {
            const params: QueryManagedSubAccountAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = [
                {
                    coin: 'INJ',
                    name: 'Injective Protocol',
                    totalBalance: '0',
                    availableBalance: '0',
                    inOrder: '0',
                    btcValue: '0',
                },
                {
                    coin: 'FILDOWN',
                    name: 'FILDOWN',
                    totalBalance: '0',
                    availableBalance: '0',
                    inOrder: '0',
                    btcValue: '0',
                },
            ];

            const spy = jest.spyOn(client, 'queryManagedSubAccountAssetDetails').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryManagedSubAccountAssetDetailsResponse>)
            );
            const response = await client.queryManagedSubAccountAssetDetails(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryManagedSubAccountAssetDetails() successfully with optional parameters', async () => {
            const params: QueryManagedSubAccountAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    coin: 'INJ',
                    name: 'Injective Protocol',
                    totalBalance: '0',
                    availableBalance: '0',
                    inOrder: '0',
                    btcValue: '0',
                },
                {
                    coin: 'FILDOWN',
                    name: 'FILDOWN',
                    totalBalance: '0',
                    availableBalance: '0',
                    inOrder: '0',
                    btcValue: '0',
                },
            ];

            const spy = jest.spyOn(client, 'queryManagedSubAccountAssetDetails').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryManagedSubAccountAssetDetailsResponse>)
            );
            const response = await client.queryManagedSubAccountAssetDetails(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: QueryManagedSubAccountAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.queryManagedSubAccountAssetDetails(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling queryManagedSubAccountAssetDetails.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryManagedSubAccountAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryManagedSubAccountAssetDetails')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryManagedSubAccountAssetDetails(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryManagedSubAccountFuturesAssetDetails()', () => {
        it('should execute queryManagedSubAccountFuturesAssetDetails() successfully with required parameters only', async () => {
            const params: QueryManagedSubAccountFuturesAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = {
                code: '200',
                message: 'OK',
                snapshotVos: [
                    {
                        type: 'FUTURES',
                        updateTime: 1672893855394,
                        data: {
                            assets: [{ asset: 'USDT', marginBalance: 100, walletBalance: 120 }],
                            position: [
                                {
                                    symbol: 'BTCUSDT',
                                    entryPrice: 17000,
                                    markPrice: 17000,
                                    positionAmt: 1.0e-4,
                                },
                            ],
                        },
                    },
                ],
            };

            const spy = jest
                .spyOn(client, 'queryManagedSubAccountFuturesAssetDetails')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryManagedSubAccountFuturesAssetDetailsResponse>)
                );
            const response = await client.queryManagedSubAccountFuturesAssetDetails(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryManagedSubAccountFuturesAssetDetails() successfully with optional parameters', async () => {
            const params: QueryManagedSubAccountFuturesAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
                accountType: 'accountType_example',
            };

            mockResponse = {
                code: '200',
                message: 'OK',
                snapshotVos: [
                    {
                        type: 'FUTURES',
                        updateTime: 1672893855394,
                        data: {
                            assets: [{ asset: 'USDT', marginBalance: 100, walletBalance: 120 }],
                            position: [
                                {
                                    symbol: 'BTCUSDT',
                                    entryPrice: 17000,
                                    markPrice: 17000,
                                    positionAmt: 1.0e-4,
                                },
                            ],
                        },
                    },
                ],
            };

            const spy = jest
                .spyOn(client, 'queryManagedSubAccountFuturesAssetDetails')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryManagedSubAccountFuturesAssetDetailsResponse>)
                );
            const response = await client.queryManagedSubAccountFuturesAssetDetails(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: QueryManagedSubAccountFuturesAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.queryManagedSubAccountFuturesAssetDetails(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling queryManagedSubAccountFuturesAssetDetails.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryManagedSubAccountFuturesAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryManagedSubAccountFuturesAssetDetails')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryManagedSubAccountFuturesAssetDetails(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryManagedSubAccountList()', () => {
        it('should execute queryManagedSubAccountList() successfully with required parameters only', async () => {
            mockResponse = {
                total: 3,
                managerSubUserInfoVoList: [
                    {
                        rootUserId: 1000138475670,
                        managersubUserId: 1000137842513,
                        bindParentUserId: 1000138475669,
                        email: 'test_0_virtual@kq3kno9imanagedsub.com',
                        insertTimeStamp: 1678435149000,
                        bindParentEmail: 'wdyw8xsh8pey@test.com',
                        isSubUserEnabled: true,
                        isUserActive: true,
                        isMarginEnabled: false,
                        isFutureEnabled: false,
                        isSignedLVTRiskAgreement: false,
                    },
                    {
                        rootUserId: 1000138475670,
                        managersubUserId: 1000137842514,
                        bindParentUserId: 1000138475669,
                        email: 'test_1_virtual@4qd2u7zxmanagedsub.com',
                        insertTimeStamp: 1678435152000,
                        bindParentEmail: 'wdyw8xsh8pey@test.com',
                        isSubUserEnabled: true,
                        isUserActive: true,
                        isMarginEnabled: false,
                        isFutureEnabled: false,
                        isSignedLVTRiskAgreement: false,
                    },
                    {
                        rootUserId: 1000138475670,
                        managersubUserId: 1000137842515,
                        bindParentUserId: 1000138475669,
                        email: 'test_2_virtual@akc05o8hmanagedsub.com',
                        insertTimeStamp: 1678435153000,
                        bindParentEmail: 'wdyw8xsh8pey@test.com',
                        isSubUserEnabled: true,
                        isUserActive: true,
                        isMarginEnabled: false,
                        isFutureEnabled: false,
                        isSignedLVTRiskAgreement: false,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'queryManagedSubAccountList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryManagedSubAccountListResponse>)
            );
            const response = await client.queryManagedSubAccountList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryManagedSubAccountList() successfully with optional parameters', async () => {
            const params: QueryManagedSubAccountListRequest = {
                email: 'email_example',
                page: 1,
                limit: 1,
                recvWindow: 5000,
            };

            mockResponse = {
                total: 3,
                managerSubUserInfoVoList: [
                    {
                        rootUserId: 1000138475670,
                        managersubUserId: 1000137842513,
                        bindParentUserId: 1000138475669,
                        email: 'test_0_virtual@kq3kno9imanagedsub.com',
                        insertTimeStamp: 1678435149000,
                        bindParentEmail: 'wdyw8xsh8pey@test.com',
                        isSubUserEnabled: true,
                        isUserActive: true,
                        isMarginEnabled: false,
                        isFutureEnabled: false,
                        isSignedLVTRiskAgreement: false,
                    },
                    {
                        rootUserId: 1000138475670,
                        managersubUserId: 1000137842514,
                        bindParentUserId: 1000138475669,
                        email: 'test_1_virtual@4qd2u7zxmanagedsub.com',
                        insertTimeStamp: 1678435152000,
                        bindParentEmail: 'wdyw8xsh8pey@test.com',
                        isSubUserEnabled: true,
                        isUserActive: true,
                        isMarginEnabled: false,
                        isFutureEnabled: false,
                        isSignedLVTRiskAgreement: false,
                    },
                    {
                        rootUserId: 1000138475670,
                        managersubUserId: 1000137842515,
                        bindParentUserId: 1000138475669,
                        email: 'test_2_virtual@akc05o8hmanagedsub.com',
                        insertTimeStamp: 1678435153000,
                        bindParentEmail: 'wdyw8xsh8pey@test.com',
                        isSubUserEnabled: true,
                        isUserActive: true,
                        isMarginEnabled: false,
                        isFutureEnabled: false,
                        isSignedLVTRiskAgreement: false,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'queryManagedSubAccountList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryManagedSubAccountListResponse>)
            );
            const response = await client.queryManagedSubAccountList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryManagedSubAccountList')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryManagedSubAccountList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryManagedSubAccountMarginAssetDetails()', () => {
        it('should execute queryManagedSubAccountMarginAssetDetails() successfully with required parameters only', async () => {
            const params: QueryManagedSubAccountMarginAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = {
                marginLevel: '999',
                totalAssetOfBtc: '0',
                totalLiabilityOfBtc: '0',
                totalNetAssetOfBtc: '0',
                userAssets: [
                    {
                        asset: 'MATIC',
                        borrowed: '0',
                        free: '0',
                        interest: '0',
                        locked: '0',
                        netAsset: '0',
                    },
                    {
                        asset: 'VET',
                        borrowed: '0',
                        free: '0',
                        interest: '0',
                        locked: '0',
                        netAsset: '0',
                    },
                    {
                        asset: 'BAKE',
                        borrowed: '0',
                        free: '0',
                        interest: '0',
                        locked: '0',
                        netAsset: '0',
                    },
                ],
            };

            const spy = jest
                .spyOn(client, 'queryManagedSubAccountMarginAssetDetails')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryManagedSubAccountMarginAssetDetailsResponse>)
                );
            const response = await client.queryManagedSubAccountMarginAssetDetails(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryManagedSubAccountMarginAssetDetails() successfully with optional parameters', async () => {
            const params: QueryManagedSubAccountMarginAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
                accountType: 'accountType_example',
            };

            mockResponse = {
                marginLevel: '999',
                totalAssetOfBtc: '0',
                totalLiabilityOfBtc: '0',
                totalNetAssetOfBtc: '0',
                userAssets: [
                    {
                        asset: 'MATIC',
                        borrowed: '0',
                        free: '0',
                        interest: '0',
                        locked: '0',
                        netAsset: '0',
                    },
                    {
                        asset: 'VET',
                        borrowed: '0',
                        free: '0',
                        interest: '0',
                        locked: '0',
                        netAsset: '0',
                    },
                    {
                        asset: 'BAKE',
                        borrowed: '0',
                        free: '0',
                        interest: '0',
                        locked: '0',
                        netAsset: '0',
                    },
                ],
            };

            const spy = jest
                .spyOn(client, 'queryManagedSubAccountMarginAssetDetails')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryManagedSubAccountMarginAssetDetailsResponse>)
                );
            const response = await client.queryManagedSubAccountMarginAssetDetails(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: QueryManagedSubAccountMarginAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.queryManagedSubAccountMarginAssetDetails(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling queryManagedSubAccountMarginAssetDetails.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryManagedSubAccountMarginAssetDetailsRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryManagedSubAccountMarginAssetDetails')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryManagedSubAccountMarginAssetDetails(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryManagedSubAccountSnapshot()', () => {
        it('should execute queryManagedSubAccountSnapshot() successfully with required parameters only', async () => {
            const params: QueryManagedSubAccountSnapshotRequest = {
                email: 'sub-account-email@email.com',
                type: 'type_example',
            };

            mockResponse = {
                code: 200,
                msg: '',
                snapshotVos: [
                    {
                        data: {
                            balances: [
                                { asset: 'BTC', free: '0.09905021', locked: '0.00000000' },
                                { asset: 'USDT', free: '1.89109409', locked: '0.00000000' },
                            ],
                            totalAssetOfBtc: '0.09942700',
                        },
                        type: 'spot',
                        updateTime: 1576281599000,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'queryManagedSubAccountSnapshot').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryManagedSubAccountSnapshotResponse>)
            );
            const response = await client.queryManagedSubAccountSnapshot(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryManagedSubAccountSnapshot() successfully with optional parameters', async () => {
            const params: QueryManagedSubAccountSnapshotRequest = {
                email: 'sub-account-email@email.com',
                type: 'type_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 1,
                recvWindow: 5000,
            };

            mockResponse = {
                code: 200,
                msg: '',
                snapshotVos: [
                    {
                        data: {
                            balances: [
                                { asset: 'BTC', free: '0.09905021', locked: '0.00000000' },
                                { asset: 'USDT', free: '1.89109409', locked: '0.00000000' },
                            ],
                            totalAssetOfBtc: '0.09942700',
                        },
                        type: 'spot',
                        updateTime: 1576281599000,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'queryManagedSubAccountSnapshot').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryManagedSubAccountSnapshotResponse>)
            );
            const response = await client.queryManagedSubAccountSnapshot(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: QueryManagedSubAccountSnapshotRequest = {
                email: 'sub-account-email@email.com',
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.queryManagedSubAccountSnapshot(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling queryManagedSubAccountSnapshot.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: QueryManagedSubAccountSnapshotRequest = {
                email: 'sub-account-email@email.com',
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.queryManagedSubAccountSnapshot(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling queryManagedSubAccountSnapshot.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryManagedSubAccountSnapshotRequest = {
                email: 'sub-account-email@email.com',
                type: 'type_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryManagedSubAccountSnapshot')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryManagedSubAccountSnapshot(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryManagedSubAccountTransferLogMasterAccountInvestor()', () => {
        it('should execute queryManagedSubAccountTransferLogMasterAccountInvestor() successfully with required parameters only', async () => {
            const params: QueryManagedSubAccountTransferLogMasterAccountInvestorRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };

            mockResponse = {
                managerSubTransferHistoryVos: [
                    {
                        fromEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                        fromAccountType: 'SPOT',
                        toEmail: 'wdywl0lddakh@test.com',
                        toAccountType: 'SPOT',
                        asset: 'BNB',
                        amount: '0.01',
                        scheduledData: 1679416673000,
                        createTime: 1679416673000,
                        status: 'SUCCESS',
                        tranId: 91077779,
                    },
                    {
                        fromEmail: 'wdywl0lddakh@test.com',
                        fromAccountType: 'SPOT',
                        toEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                        toAccountType: 'SPOT',
                        asset: 'BNB',
                        amount: '1',
                        scheduledData: 1679416616000,
                        createTime: 1679416616000,
                        status: 'SUCCESS',
                        tranId: 91077676,
                    },
                ],
                count: 2,
            };

            const spy = jest
                .spyOn(client, 'queryManagedSubAccountTransferLogMasterAccountInvestor')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryManagedSubAccountTransferLogMasterAccountInvestorResponse>)
                );
            const response =
                await client.queryManagedSubAccountTransferLogMasterAccountInvestor(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryManagedSubAccountTransferLogMasterAccountInvestor() successfully with optional parameters', async () => {
            const params: QueryManagedSubAccountTransferLogMasterAccountInvestorRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
                transfers: 'transfers_example',
                transferFunctionAccountType: 'transferFunctionAccountType_example',
            };

            mockResponse = {
                managerSubTransferHistoryVos: [
                    {
                        fromEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                        fromAccountType: 'SPOT',
                        toEmail: 'wdywl0lddakh@test.com',
                        toAccountType: 'SPOT',
                        asset: 'BNB',
                        amount: '0.01',
                        scheduledData: 1679416673000,
                        createTime: 1679416673000,
                        status: 'SUCCESS',
                        tranId: 91077779,
                    },
                    {
                        fromEmail: 'wdywl0lddakh@test.com',
                        fromAccountType: 'SPOT',
                        toEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                        toAccountType: 'SPOT',
                        asset: 'BNB',
                        amount: '1',
                        scheduledData: 1679416616000,
                        createTime: 1679416616000,
                        status: 'SUCCESS',
                        tranId: 91077676,
                    },
                ],
                count: 2,
            };

            const spy = jest
                .spyOn(client, 'queryManagedSubAccountTransferLogMasterAccountInvestor')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryManagedSubAccountTransferLogMasterAccountInvestorResponse>)
                );
            const response =
                await client.queryManagedSubAccountTransferLogMasterAccountInvestor(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogMasterAccountInvestorRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountInvestor(params)
            ).rejects.toThrow(
                'Required parameter email was null or undefined when calling queryManagedSubAccountTransferLogMasterAccountInvestor.'
            );
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogMasterAccountInvestorRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountInvestor(params)
            ).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling queryManagedSubAccountTransferLogMasterAccountInvestor.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogMasterAccountInvestorRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountInvestor(params)
            ).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling queryManagedSubAccountTransferLogMasterAccountInvestor.'
            );
        });

        it('should throw RequiredError when page is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogMasterAccountInvestorRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.page;

            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountInvestor(params)
            ).rejects.toThrow(
                'Required parameter page was null or undefined when calling queryManagedSubAccountTransferLogMasterAccountInvestor.'
            );
        });

        it('should throw RequiredError when limit is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogMasterAccountInvestorRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.limit;

            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountInvestor(params)
            ).rejects.toThrow(
                'Required parameter limit was null or undefined when calling queryManagedSubAccountTransferLogMasterAccountInvestor.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryManagedSubAccountTransferLogMasterAccountInvestorRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryManagedSubAccountTransferLogMasterAccountInvestor')
                .mockRejectedValueOnce(mockError);
            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountInvestor(params)
            ).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryManagedSubAccountTransferLogMasterAccountTrading()', () => {
        it('should execute queryManagedSubAccountTransferLogMasterAccountTrading() successfully with required parameters only', async () => {
            const params: QueryManagedSubAccountTransferLogMasterAccountTradingRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };

            mockResponse = {
                managerSubTransferHistoryVos: [
                    {
                        fromEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                        fromAccountType: 'SPOT',
                        toEmail: 'wdywl0lddakh@test.com',
                        toAccountType: 'SPOT',
                        asset: 'BNB',
                        amount: '0.01',
                        scheduledData: 1679416673000,
                        createTime: 1679416673000,
                        status: 'SUCCESS',
                        tranId: 91077779,
                    },
                    {
                        fromEmail: 'wdywl0lddakh@test.com',
                        fromAccountType: 'SPOT',
                        toEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                        toAccountType: 'SPOT',
                        asset: 'BNB',
                        amount: '1',
                        scheduledData: 1679416616000,
                        createTime: 1679416616000,
                        status: 'SUCCESS',
                        tranId: 91077676,
                    },
                ],
                count: 2,
            };

            const spy = jest
                .spyOn(client, 'queryManagedSubAccountTransferLogMasterAccountTrading')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryManagedSubAccountTransferLogMasterAccountTradingResponse>)
                );
            const response =
                await client.queryManagedSubAccountTransferLogMasterAccountTrading(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryManagedSubAccountTransferLogMasterAccountTrading() successfully with optional parameters', async () => {
            const params: QueryManagedSubAccountTransferLogMasterAccountTradingRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
                transfers: 'transfers_example',
                transferFunctionAccountType: 'transferFunctionAccountType_example',
            };

            mockResponse = {
                managerSubTransferHistoryVos: [
                    {
                        fromEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                        fromAccountType: 'SPOT',
                        toEmail: 'wdywl0lddakh@test.com',
                        toAccountType: 'SPOT',
                        asset: 'BNB',
                        amount: '0.01',
                        scheduledData: 1679416673000,
                        createTime: 1679416673000,
                        status: 'SUCCESS',
                        tranId: 91077779,
                    },
                    {
                        fromEmail: 'wdywl0lddakh@test.com',
                        fromAccountType: 'SPOT',
                        toEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                        toAccountType: 'SPOT',
                        asset: 'BNB',
                        amount: '1',
                        scheduledData: 1679416616000,
                        createTime: 1679416616000,
                        status: 'SUCCESS',
                        tranId: 91077676,
                    },
                ],
                count: 2,
            };

            const spy = jest
                .spyOn(client, 'queryManagedSubAccountTransferLogMasterAccountTrading')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryManagedSubAccountTransferLogMasterAccountTradingResponse>)
                );
            const response =
                await client.queryManagedSubAccountTransferLogMasterAccountTrading(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogMasterAccountTradingRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountTrading(params)
            ).rejects.toThrow(
                'Required parameter email was null or undefined when calling queryManagedSubAccountTransferLogMasterAccountTrading.'
            );
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogMasterAccountTradingRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountTrading(params)
            ).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling queryManagedSubAccountTransferLogMasterAccountTrading.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogMasterAccountTradingRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountTrading(params)
            ).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling queryManagedSubAccountTransferLogMasterAccountTrading.'
            );
        });

        it('should throw RequiredError when page is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogMasterAccountTradingRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.page;

            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountTrading(params)
            ).rejects.toThrow(
                'Required parameter page was null or undefined when calling queryManagedSubAccountTransferLogMasterAccountTrading.'
            );
        });

        it('should throw RequiredError when limit is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogMasterAccountTradingRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.limit;

            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountTrading(params)
            ).rejects.toThrow(
                'Required parameter limit was null or undefined when calling queryManagedSubAccountTransferLogMasterAccountTrading.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryManagedSubAccountTransferLogMasterAccountTradingRequest = {
                email: 'sub-account-email@email.com',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryManagedSubAccountTransferLogMasterAccountTrading')
                .mockRejectedValueOnce(mockError);
            await expect(
                client.queryManagedSubAccountTransferLogMasterAccountTrading(params)
            ).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryManagedSubAccountTransferLogSubAccountTrading()', () => {
        it('should execute queryManagedSubAccountTransferLogSubAccountTrading() successfully with required parameters only', async () => {
            const params: QueryManagedSubAccountTransferLogSubAccountTradingRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };

            mockResponse = {
                managerSubTransferHistoryVos: [
                    {
                        fromEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                        fromAccountType: 'SPOT',
                        toEmail: 'wdywl0lddakh@test.com',
                        toAccountType: 'SPOT',
                        asset: 'BNB',
                        amount: '0.01',
                        scheduledData: 1679416673000,
                        createTime: 1679416673000,
                        status: 'SUCCESS',
                        tranId: 91077779,
                    },
                    {
                        fromEmail: 'wdywl0lddakh@test.com',
                        fromAccountType: 'SPOT',
                        toEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                        toAccountType: 'SPOT',
                        asset: 'BNB',
                        amount: '1',
                        scheduledData: 1679416616000,
                        createTime: 1679416616000,
                        status: 'SUCCESS',
                        tranId: 91077676,
                    },
                ],
                count: 2,
            };

            const spy = jest
                .spyOn(client, 'queryManagedSubAccountTransferLogSubAccountTrading')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryManagedSubAccountTransferLogSubAccountTradingResponse>)
                );
            const response =
                await client.queryManagedSubAccountTransferLogSubAccountTrading(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryManagedSubAccountTransferLogSubAccountTrading() successfully with optional parameters', async () => {
            const params: QueryManagedSubAccountTransferLogSubAccountTradingRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
                transfers: 'transfers_example',
                transferFunctionAccountType: 'transferFunctionAccountType_example',
                recvWindow: 5000,
            };

            mockResponse = {
                managerSubTransferHistoryVos: [
                    {
                        fromEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                        fromAccountType: 'SPOT',
                        toEmail: 'wdywl0lddakh@test.com',
                        toAccountType: 'SPOT',
                        asset: 'BNB',
                        amount: '0.01',
                        scheduledData: 1679416673000,
                        createTime: 1679416673000,
                        status: 'SUCCESS',
                        tranId: 91077779,
                    },
                    {
                        fromEmail: 'wdywl0lddakh@test.com',
                        fromAccountType: 'SPOT',
                        toEmail: 'test_0_virtual@kq3kno9imanagedsub.com',
                        toAccountType: 'SPOT',
                        asset: 'BNB',
                        amount: '1',
                        scheduledData: 1679416616000,
                        createTime: 1679416616000,
                        status: 'SUCCESS',
                        tranId: 91077676,
                    },
                ],
                count: 2,
            };

            const spy = jest
                .spyOn(client, 'queryManagedSubAccountTransferLogSubAccountTrading')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryManagedSubAccountTransferLogSubAccountTradingResponse>)
                );
            const response =
                await client.queryManagedSubAccountTransferLogSubAccountTrading(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogSubAccountTradingRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(
                client.queryManagedSubAccountTransferLogSubAccountTrading(params)
            ).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling queryManagedSubAccountTransferLogSubAccountTrading.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogSubAccountTradingRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(
                client.queryManagedSubAccountTransferLogSubAccountTrading(params)
            ).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling queryManagedSubAccountTransferLogSubAccountTrading.'
            );
        });

        it('should throw RequiredError when page is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogSubAccountTradingRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.page;

            await expect(
                client.queryManagedSubAccountTransferLogSubAccountTrading(params)
            ).rejects.toThrow(
                'Required parameter page was null or undefined when calling queryManagedSubAccountTransferLogSubAccountTrading.'
            );
        });

        it('should throw RequiredError when limit is missing', async () => {
            const _params: QueryManagedSubAccountTransferLogSubAccountTradingRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.limit;

            await expect(
                client.queryManagedSubAccountTransferLogSubAccountTrading(params)
            ).rejects.toThrow(
                'Required parameter limit was null or undefined when calling queryManagedSubAccountTransferLogSubAccountTrading.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryManagedSubAccountTransferLogSubAccountTradingRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryManagedSubAccountTransferLogSubAccountTrading')
                .mockRejectedValueOnce(mockError);
            await expect(
                client.queryManagedSubAccountTransferLogSubAccountTrading(params)
            ).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('withdrawlAssetsFromTheManagedSubAccount()', () => {
        it('should execute withdrawlAssetsFromTheManagedSubAccount() successfully with required parameters only', async () => {
            const params: WithdrawlAssetsFromTheManagedSubAccountRequest = {
                fromEmail: 'fromEmail_example',
                asset: 'asset_example',
                amount: 1,
            };

            mockResponse = { tranId: 66157362489 };

            const spy = jest
                .spyOn(client, 'withdrawlAssetsFromTheManagedSubAccount')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<WithdrawlAssetsFromTheManagedSubAccountResponse>)
                );
            const response = await client.withdrawlAssetsFromTheManagedSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute withdrawlAssetsFromTheManagedSubAccount() successfully with optional parameters', async () => {
            const params: WithdrawlAssetsFromTheManagedSubAccountRequest = {
                fromEmail: 'fromEmail_example',
                asset: 'asset_example',
                amount: 1,
                transferDate: 789,
                recvWindow: 5000,
            };

            mockResponse = { tranId: 66157362489 };

            const spy = jest
                .spyOn(client, 'withdrawlAssetsFromTheManagedSubAccount')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<WithdrawlAssetsFromTheManagedSubAccountResponse>)
                );
            const response = await client.withdrawlAssetsFromTheManagedSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when fromEmail is missing', async () => {
            const _params: WithdrawlAssetsFromTheManagedSubAccountRequest = {
                fromEmail: 'fromEmail_example',
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.fromEmail;

            await expect(client.withdrawlAssetsFromTheManagedSubAccount(params)).rejects.toThrow(
                'Required parameter fromEmail was null or undefined when calling withdrawlAssetsFromTheManagedSubAccount.'
            );
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: WithdrawlAssetsFromTheManagedSubAccountRequest = {
                fromEmail: 'fromEmail_example',
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.withdrawlAssetsFromTheManagedSubAccount(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling withdrawlAssetsFromTheManagedSubAccount.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: WithdrawlAssetsFromTheManagedSubAccountRequest = {
                fromEmail: 'fromEmail_example',
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.withdrawlAssetsFromTheManagedSubAccount(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling withdrawlAssetsFromTheManagedSubAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: WithdrawlAssetsFromTheManagedSubAccountRequest = {
                fromEmail: 'fromEmail_example',
                asset: 'asset_example',
                amount: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'withdrawlAssetsFromTheManagedSubAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.withdrawlAssetsFromTheManagedSubAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });
});
