/**
 * Binance Public Sub Account REST API
 *
 * OpenAPI Specification for the Binance Public Sub Account REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { AssetManagementApi } from '../../../src/rest-api';
import {
    FuturesTransferForSubAccountRequest,
    GetDetailOnSubAccountsFuturesAccountRequest,
    GetDetailOnSubAccountsFuturesAccountV2Request,
    GetDetailOnSubAccountsMarginAccountRequest,
    GetSubAccountDepositAddressRequest,
    GetSubAccountDepositHistoryRequest,
    GetSummaryOfSubAccountsFuturesAccountRequest,
    GetSummaryOfSubAccountsFuturesAccountV2Request,
    GetSummaryOfSubAccountsMarginAccountRequest,
    MarginTransferForSubAccountRequest,
    QuerySubAccountAssetsRequest,
    QuerySubAccountAssetsAssetManagementRequest,
    QuerySubAccountFuturesAssetTransferHistoryRequest,
    QuerySubAccountSpotAssetTransferHistoryRequest,
    QuerySubAccountSpotAssetsSummaryRequest,
    QueryUniversalTransferHistoryRequest,
    SubAccountFuturesAssetTransferRequest,
    SubAccountTransferHistoryRequest,
    TransferToMasterRequest,
    TransferToSubAccountOfSameMasterRequest,
    UniversalTransferRequest,
} from '../../../src/rest-api';
import type {
    FuturesTransferForSubAccountResponse,
    GetDetailOnSubAccountsFuturesAccountResponse,
    GetDetailOnSubAccountsFuturesAccountV2Response,
    GetDetailOnSubAccountsMarginAccountResponse,
    GetSubAccountDepositAddressResponse,
    GetSubAccountDepositHistoryResponse,
    GetSummaryOfSubAccountsFuturesAccountResponse,
    GetSummaryOfSubAccountsFuturesAccountV2Response,
    GetSummaryOfSubAccountsMarginAccountResponse,
    MarginTransferForSubAccountResponse,
    QuerySubAccountAssetsAssetManagementResponse,
    QuerySubAccountAssetsResponse,
    QuerySubAccountFuturesAssetTransferHistoryResponse,
    QuerySubAccountSpotAssetTransferHistoryResponse,
    QuerySubAccountSpotAssetsSummaryResponse,
    QueryUniversalTransferHistoryResponse,
    SubAccountFuturesAssetTransferResponse,
    SubAccountTransferHistoryResponse,
    TransferToMasterResponse,
    TransferToSubAccountOfSameMasterResponse,
    UniversalTransferResponse,
} from '../../../src/rest-api/types';

describe('AssetManagementApi', () => {
    let client: AssetManagementApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new AssetManagementApi(config);
    });

    describe('futuresTransferForSubAccount()', () => {
        it('should execute futuresTransferForSubAccount() successfully with required parameters only', async () => {
            const params: FuturesTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1,
                type: 789,
            };

            mockResponse = { txnId: '2966662589' };

            const spy = jest.spyOn(client, 'futuresTransferForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FuturesTransferForSubAccountResponse>)
            );
            const response = await client.futuresTransferForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute futuresTransferForSubAccount() successfully with optional parameters', async () => {
            const params: FuturesTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1,
                type: 789,
                recvWindow: 5000,
            };

            mockResponse = { txnId: '2966662589' };

            const spy = jest.spyOn(client, 'futuresTransferForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FuturesTransferForSubAccountResponse>)
            );
            const response = await client.futuresTransferForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: FuturesTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1,
                type: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.futuresTransferForSubAccount(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling futuresTransferForSubAccount.'
            );
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: FuturesTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1,
                type: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.futuresTransferForSubAccount(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling futuresTransferForSubAccount.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: FuturesTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1,
                type: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.futuresTransferForSubAccount(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling futuresTransferForSubAccount.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: FuturesTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1,
                type: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.futuresTransferForSubAccount(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling futuresTransferForSubAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: FuturesTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1,
                type: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'futuresTransferForSubAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.futuresTransferForSubAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getDetailOnSubAccountsFuturesAccount()', () => {
        it('should execute getDetailOnSubAccountsFuturesAccount() successfully with required parameters only', async () => {
            const params: GetDetailOnSubAccountsFuturesAccountRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = {
                email: 'abc@test.com',
                asset: 'USDT',
                assets: [
                    {
                        asset: 'USDT',
                        initialMargin: '0.00000000',
                        maintenanceMargin: '0.00000000',
                        marginBalance: '0.88308000',
                        maxWithdrawAmount: '0.88308000',
                        openOrderInitialMargin: '0.00000000',
                        positionInitialMargin: '0.00000000',
                        unrealizedProfit: '0.00000000',
                        walletBalance: '0.88308000',
                    },
                ],
                canDeposit: true,
                canTrade: true,
                canWithdraw: true,
                feeTier: 2,
                maxWithdrawAmount: '0.88308000',
                totalInitialMargin: '0.00000000',
                totalMaintenanceMargin: '0.00000000',
                totalMarginBalance: '0.88308000',
                totalOpenOrderInitialMargin: '0.00000000',
                totalPositionInitialMargin: '0.00000000',
                totalUnrealizedProfit: '0.00000000',
                totalWalletBalance: '0.88308000',
                updateTime: 1576756674610,
            };

            const spy = jest.spyOn(client, 'getDetailOnSubAccountsFuturesAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDetailOnSubAccountsFuturesAccountResponse>)
            );
            const response = await client.getDetailOnSubAccountsFuturesAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getDetailOnSubAccountsFuturesAccount() successfully with optional parameters', async () => {
            const params: GetDetailOnSubAccountsFuturesAccountRequest = {
                email: 'sub-account-email@email.com',
                recvWindow: 5000,
            };

            mockResponse = {
                email: 'abc@test.com',
                asset: 'USDT',
                assets: [
                    {
                        asset: 'USDT',
                        initialMargin: '0.00000000',
                        maintenanceMargin: '0.00000000',
                        marginBalance: '0.88308000',
                        maxWithdrawAmount: '0.88308000',
                        openOrderInitialMargin: '0.00000000',
                        positionInitialMargin: '0.00000000',
                        unrealizedProfit: '0.00000000',
                        walletBalance: '0.88308000',
                    },
                ],
                canDeposit: true,
                canTrade: true,
                canWithdraw: true,
                feeTier: 2,
                maxWithdrawAmount: '0.88308000',
                totalInitialMargin: '0.00000000',
                totalMaintenanceMargin: '0.00000000',
                totalMarginBalance: '0.88308000',
                totalOpenOrderInitialMargin: '0.00000000',
                totalPositionInitialMargin: '0.00000000',
                totalUnrealizedProfit: '0.00000000',
                totalWalletBalance: '0.88308000',
                updateTime: 1576756674610,
            };

            const spy = jest.spyOn(client, 'getDetailOnSubAccountsFuturesAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDetailOnSubAccountsFuturesAccountResponse>)
            );
            const response = await client.getDetailOnSubAccountsFuturesAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: GetDetailOnSubAccountsFuturesAccountRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.getDetailOnSubAccountsFuturesAccount(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling getDetailOnSubAccountsFuturesAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetDetailOnSubAccountsFuturesAccountRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getDetailOnSubAccountsFuturesAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.getDetailOnSubAccountsFuturesAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getDetailOnSubAccountsFuturesAccountV2()', () => {
        it('should execute getDetailOnSubAccountsFuturesAccountV2() successfully with required parameters only', async () => {
            const params: GetDetailOnSubAccountsFuturesAccountV2Request = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };

            mockResponse = {
                futureAccountResp: {
                    email: 'abc@test.com',
                    assets: [
                        {
                            asset: 'USDT',
                            initialMargin: '0.00000000',
                            maintenanceMargin: '0.00000000',
                            marginBalance: '0.88308000',
                            maxWithdrawAmount: '0.88308000',
                            openOrderInitialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            unrealizedProfit: '0.00000000',
                            walletBalance: '0.88308000',
                        },
                    ],
                    canDeposit: true,
                    canTrade: true,
                    canWithdraw: true,
                    feeTier: 2,
                    maxWithdrawAmount: '0.88308000',
                    totalInitialMargin: '0.00000000',
                    totalMaintenanceMargin: '0.00000000',
                    totalMarginBalance: '0.88308000',
                    totalOpenOrderInitialMargin: '0.00000000',
                    totalPositionInitialMargin: '0.00000000',
                    totalUnrealizedProfit: '0.00000000',
                    totalWalletBalance: '0.88308000',
                    updateTime: 1576756674610,
                },
            };

            const spy = jest
                .spyOn(client, 'getDetailOnSubAccountsFuturesAccountV2')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetDetailOnSubAccountsFuturesAccountV2Response>)
                );
            const response = await client.getDetailOnSubAccountsFuturesAccountV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getDetailOnSubAccountsFuturesAccountV2() successfully with optional parameters', async () => {
            const params: GetDetailOnSubAccountsFuturesAccountV2Request = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
                recvWindow: 5000,
            };

            mockResponse = {
                futureAccountResp: {
                    email: 'abc@test.com',
                    assets: [
                        {
                            asset: 'USDT',
                            initialMargin: '0.00000000',
                            maintenanceMargin: '0.00000000',
                            marginBalance: '0.88308000',
                            maxWithdrawAmount: '0.88308000',
                            openOrderInitialMargin: '0.00000000',
                            positionInitialMargin: '0.00000000',
                            unrealizedProfit: '0.00000000',
                            walletBalance: '0.88308000',
                        },
                    ],
                    canDeposit: true,
                    canTrade: true,
                    canWithdraw: true,
                    feeTier: 2,
                    maxWithdrawAmount: '0.88308000',
                    totalInitialMargin: '0.00000000',
                    totalMaintenanceMargin: '0.00000000',
                    totalMarginBalance: '0.88308000',
                    totalOpenOrderInitialMargin: '0.00000000',
                    totalPositionInitialMargin: '0.00000000',
                    totalUnrealizedProfit: '0.00000000',
                    totalWalletBalance: '0.88308000',
                    updateTime: 1576756674610,
                },
            };

            const spy = jest
                .spyOn(client, 'getDetailOnSubAccountsFuturesAccountV2')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetDetailOnSubAccountsFuturesAccountV2Response>)
                );
            const response = await client.getDetailOnSubAccountsFuturesAccountV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: GetDetailOnSubAccountsFuturesAccountV2Request = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.getDetailOnSubAccountsFuturesAccountV2(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling getDetailOnSubAccountsFuturesAccountV2.'
            );
        });

        it('should throw RequiredError when futuresType is missing', async () => {
            const _params: GetDetailOnSubAccountsFuturesAccountV2Request = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.futuresType;

            await expect(client.getDetailOnSubAccountsFuturesAccountV2(params)).rejects.toThrow(
                'Required parameter futuresType was null or undefined when calling getDetailOnSubAccountsFuturesAccountV2.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetDetailOnSubAccountsFuturesAccountV2Request = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getDetailOnSubAccountsFuturesAccountV2')
                .mockRejectedValueOnce(mockError);
            await expect(client.getDetailOnSubAccountsFuturesAccountV2(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getDetailOnSubAccountsMarginAccount()', () => {
        it('should execute getDetailOnSubAccountsMarginAccount() successfully with required parameters only', async () => {
            const params: GetDetailOnSubAccountsMarginAccountRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = {
                email: '123@test.com',
                marginLevel: '11.64405625',
                totalAssetOfBtc: '6.82728457',
                totalLiabilityOfBtc: '0.58633215',
                totalNetAssetOfBtc: '6.24095242',
                marginTradeCoeffVo: {
                    forceLiquidationBar: '1.10000000',
                    marginCallBar: '1.50000000',
                    normalBar: '2.00000000',
                },
                marginUserAssetVoList: [
                    {
                        asset: 'BTC',
                        borrowed: '0.00000000',
                        free: '0.00499500',
                        interest: '0.00000000',
                        locked: '0.00000000',
                        netAsset: '0.00499500',
                    },
                    {
                        asset: 'BNB',
                        borrowed: '201.66666672',
                        free: '2346.50000000',
                        interest: '0.00000000',
                        locked: '0.00000000',
                        netAsset: '2144.83333328',
                    },
                    {
                        asset: 'ETH',
                        borrowed: '0.00000000',
                        free: '0.00000000',
                        interest: '0.00000000',
                        locked: '0.00000000',
                        netAsset: '0.00000000',
                    },
                    {
                        asset: 'USDT',
                        borrowed: '0.00000000',
                        free: '0.00000000',
                        interest: '0.00000000',
                        locked: '0.00000000',
                        netAsset: '0.00000000',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'getDetailOnSubAccountsMarginAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDetailOnSubAccountsMarginAccountResponse>)
            );
            const response = await client.getDetailOnSubAccountsMarginAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getDetailOnSubAccountsMarginAccount() successfully with optional parameters', async () => {
            const params: GetDetailOnSubAccountsMarginAccountRequest = {
                email: 'sub-account-email@email.com',
                recvWindow: 5000,
            };

            mockResponse = {
                email: '123@test.com',
                marginLevel: '11.64405625',
                totalAssetOfBtc: '6.82728457',
                totalLiabilityOfBtc: '0.58633215',
                totalNetAssetOfBtc: '6.24095242',
                marginTradeCoeffVo: {
                    forceLiquidationBar: '1.10000000',
                    marginCallBar: '1.50000000',
                    normalBar: '2.00000000',
                },
                marginUserAssetVoList: [
                    {
                        asset: 'BTC',
                        borrowed: '0.00000000',
                        free: '0.00499500',
                        interest: '0.00000000',
                        locked: '0.00000000',
                        netAsset: '0.00499500',
                    },
                    {
                        asset: 'BNB',
                        borrowed: '201.66666672',
                        free: '2346.50000000',
                        interest: '0.00000000',
                        locked: '0.00000000',
                        netAsset: '2144.83333328',
                    },
                    {
                        asset: 'ETH',
                        borrowed: '0.00000000',
                        free: '0.00000000',
                        interest: '0.00000000',
                        locked: '0.00000000',
                        netAsset: '0.00000000',
                    },
                    {
                        asset: 'USDT',
                        borrowed: '0.00000000',
                        free: '0.00000000',
                        interest: '0.00000000',
                        locked: '0.00000000',
                        netAsset: '0.00000000',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'getDetailOnSubAccountsMarginAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDetailOnSubAccountsMarginAccountResponse>)
            );
            const response = await client.getDetailOnSubAccountsMarginAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: GetDetailOnSubAccountsMarginAccountRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.getDetailOnSubAccountsMarginAccount(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling getDetailOnSubAccountsMarginAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetDetailOnSubAccountsMarginAccountRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getDetailOnSubAccountsMarginAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.getDetailOnSubAccountsMarginAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getSubAccountDepositAddress()', () => {
        it('should execute getSubAccountDepositAddress() successfully with required parameters only', async () => {
            const params: GetSubAccountDepositAddressRequest = {
                email: 'sub-account-email@email.com',
                coin: 'coin_example',
            };

            mockResponse = {
                address: 'TDunhSa7jkTNuKrusUTU1MUHtqXoBPKETV',
                coin: 'USDT',
                tag: '',
                url: 'https://tronscan.org/#/address/TDunhSa7jkTNuKrusUTU1MUHtqXoBPKETV',
            };

            const spy = jest.spyOn(client, 'getSubAccountDepositAddress').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSubAccountDepositAddressResponse>)
            );
            const response = await client.getSubAccountDepositAddress(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSubAccountDepositAddress() successfully with optional parameters', async () => {
            const params: GetSubAccountDepositAddressRequest = {
                email: 'sub-account-email@email.com',
                coin: 'coin_example',
                network: 'network_example',
                amount: 1,
                recvWindow: 5000,
            };

            mockResponse = {
                address: 'TDunhSa7jkTNuKrusUTU1MUHtqXoBPKETV',
                coin: 'USDT',
                tag: '',
                url: 'https://tronscan.org/#/address/TDunhSa7jkTNuKrusUTU1MUHtqXoBPKETV',
            };

            const spy = jest.spyOn(client, 'getSubAccountDepositAddress').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSubAccountDepositAddressResponse>)
            );
            const response = await client.getSubAccountDepositAddress(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: GetSubAccountDepositAddressRequest = {
                email: 'sub-account-email@email.com',
                coin: 'coin_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.getSubAccountDepositAddress(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling getSubAccountDepositAddress.'
            );
        });

        it('should throw RequiredError when coin is missing', async () => {
            const _params: GetSubAccountDepositAddressRequest = {
                email: 'sub-account-email@email.com',
                coin: 'coin_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.coin;

            await expect(client.getSubAccountDepositAddress(params)).rejects.toThrow(
                'Required parameter coin was null or undefined when calling getSubAccountDepositAddress.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetSubAccountDepositAddressRequest = {
                email: 'sub-account-email@email.com',
                coin: 'coin_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getSubAccountDepositAddress')
                .mockRejectedValueOnce(mockError);
            await expect(client.getSubAccountDepositAddress(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getSubAccountDepositHistory()', () => {
        it('should execute getSubAccountDepositHistory() successfully with required parameters only', async () => {
            const params: GetSubAccountDepositHistoryRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = [
                {
                    id: '769800519366885376',
                    amount: '0.001',
                    coin: 'BNB',
                    network: 'BNB',
                    status: 0,
                    address: 'bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23',
                    addressTag: '101764890',
                    txId: '98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC',
                    insertTime: 1661493146000,
                    transferType: 0,
                    confirmTimes: '1/1',
                    unlockConfirm: 0,
                    walletType: 0,
                },
                {
                    id: '769754833590042625',
                    amount: '0.50000000',
                    coin: 'IOTA',
                    network: 'IOTA',
                    status: 1,
                    address:
                        'SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW',
                    addressTag: '',
                    txId: 'ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999',
                    insertTime: 1599620082000,
                    transferType: 0,
                    confirmTimes: '1/1',
                    unlockConfirm: 0,
                    walletType: 0,
                },
            ];

            const spy = jest.spyOn(client, 'getSubAccountDepositHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSubAccountDepositHistoryResponse>)
            );
            const response = await client.getSubAccountDepositHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSubAccountDepositHistory() successfully with optional parameters', async () => {
            const params: GetSubAccountDepositHistoryRequest = {
                email: 'sub-account-email@email.com',
                coin: 'coin_example',
                status: 789,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 1,
                offset: 0,
                recvWindow: 5000,
                txId: '1',
            };

            mockResponse = [
                {
                    id: '769800519366885376',
                    amount: '0.001',
                    coin: 'BNB',
                    network: 'BNB',
                    status: 0,
                    address: 'bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23',
                    addressTag: '101764890',
                    txId: '98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC',
                    insertTime: 1661493146000,
                    transferType: 0,
                    confirmTimes: '1/1',
                    unlockConfirm: 0,
                    walletType: 0,
                },
                {
                    id: '769754833590042625',
                    amount: '0.50000000',
                    coin: 'IOTA',
                    network: 'IOTA',
                    status: 1,
                    address:
                        'SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW',
                    addressTag: '',
                    txId: 'ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999',
                    insertTime: 1599620082000,
                    transferType: 0,
                    confirmTimes: '1/1',
                    unlockConfirm: 0,
                    walletType: 0,
                },
            ];

            const spy = jest.spyOn(client, 'getSubAccountDepositHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSubAccountDepositHistoryResponse>)
            );
            const response = await client.getSubAccountDepositHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: GetSubAccountDepositHistoryRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.getSubAccountDepositHistory(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling getSubAccountDepositHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetSubAccountDepositHistoryRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getSubAccountDepositHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getSubAccountDepositHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getSummaryOfSubAccountsFuturesAccount()', () => {
        it('should execute getSummaryOfSubAccountsFuturesAccount() successfully with required parameters only', async () => {
            mockResponse = {
                totalInitialMargin: '9.83137400',
                totalMaintenanceMargin: '0.41568700',
                totalMarginBalance: '23.03235621',
                totalOpenOrderInitialMargin: '9.00000000',
                totalPositionInitialMargin: '0.83137400',
                totalUnrealizedProfit: '0.03219710',
                totalWalletBalance: '22.15879444',
                asset: 'USD',
                subAccountList: [
                    {
                        email: '123@test.com',
                        totalInitialMargin: '9.00000000',
                        totalMaintenanceMargin: '0.00000000',
                        totalMarginBalance: '22.12659734',
                        totalOpenOrderInitialMargin: '9.00000000',
                        totalPositionInitialMargin: '0.00000000',
                        totalUnrealizedProfit: '0.00000000',
                        totalWalletBalance: '22.12659734',
                        asset: 'USD',
                    },
                    {
                        email: '345@test.com',
                        totalInitialMargin: '0.83137400',
                        totalMaintenanceMargin: '0.41568700',
                        totalMarginBalance: '0.90575887',
                        totalOpenOrderInitialMargin: '0.00000000',
                        totalPositionInitialMargin: '0.83137400',
                        totalUnrealizedProfit: '0.03219710',
                        totalWalletBalance: '0.87356177',
                        asset: 'USD',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'getSummaryOfSubAccountsFuturesAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSummaryOfSubAccountsFuturesAccountResponse>)
            );
            const response = await client.getSummaryOfSubAccountsFuturesAccount();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSummaryOfSubAccountsFuturesAccount() successfully with optional parameters', async () => {
            const params: GetSummaryOfSubAccountsFuturesAccountRequest = {
                recvWindow: 5000,
            };

            mockResponse = {
                totalInitialMargin: '9.83137400',
                totalMaintenanceMargin: '0.41568700',
                totalMarginBalance: '23.03235621',
                totalOpenOrderInitialMargin: '9.00000000',
                totalPositionInitialMargin: '0.83137400',
                totalUnrealizedProfit: '0.03219710',
                totalWalletBalance: '22.15879444',
                asset: 'USD',
                subAccountList: [
                    {
                        email: '123@test.com',
                        totalInitialMargin: '9.00000000',
                        totalMaintenanceMargin: '0.00000000',
                        totalMarginBalance: '22.12659734',
                        totalOpenOrderInitialMargin: '9.00000000',
                        totalPositionInitialMargin: '0.00000000',
                        totalUnrealizedProfit: '0.00000000',
                        totalWalletBalance: '22.12659734',
                        asset: 'USD',
                    },
                    {
                        email: '345@test.com',
                        totalInitialMargin: '0.83137400',
                        totalMaintenanceMargin: '0.41568700',
                        totalMarginBalance: '0.90575887',
                        totalOpenOrderInitialMargin: '0.00000000',
                        totalPositionInitialMargin: '0.83137400',
                        totalUnrealizedProfit: '0.03219710',
                        totalWalletBalance: '0.87356177',
                        asset: 'USD',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'getSummaryOfSubAccountsFuturesAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSummaryOfSubAccountsFuturesAccountResponse>)
            );
            const response = await client.getSummaryOfSubAccountsFuturesAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getSummaryOfSubAccountsFuturesAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.getSummaryOfSubAccountsFuturesAccount()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getSummaryOfSubAccountsFuturesAccountV2()', () => {
        it('should execute getSummaryOfSubAccountsFuturesAccountV2() successfully with required parameters only', async () => {
            const params: GetSummaryOfSubAccountsFuturesAccountV2Request = {
                futuresType: 789,
            };

            mockResponse = {
                futureAccountSummaryResp: {
                    totalInitialMargin: '9.83137400',
                    totalMaintenanceMargin: '0.41568700',
                    totalMarginBalance: '23.03235621',
                    totalOpenOrderInitialMargin: '9.00000000',
                    totalPositionInitialMargin: '0.83137400',
                    totalUnrealizedProfit: '0.03219710',
                    totalWalletBalance: '22.15879444',
                    asset: 'USD',
                    subAccountList: [
                        {
                            email: '123@test.com',
                            totalInitialMargin: '9.00000000',
                            totalMaintenanceMargin: '0.00000000',
                            totalMarginBalance: '22.12659734',
                            totalOpenOrderInitialMargin: '9.00000000',
                            totalPositionInitialMargin: '0.00000000',
                            totalUnrealizedProfit: '0.00000000',
                            totalWalletBalance: '22.12659734',
                            asset: 'USD',
                        },
                        {
                            email: '345@test.com',
                            totalInitialMargin: '0.83137400',
                            totalMaintenanceMargin: '0.41568700',
                            totalMarginBalance: '0.90575887',
                            totalOpenOrderInitialMargin: '0.00000000',
                            totalPositionInitialMargin: '0.83137400',
                            totalUnrealizedProfit: '0.03219710',
                            totalWalletBalance: '0.87356177',
                            asset: 'USD',
                        },
                    ],
                },
            };

            const spy = jest
                .spyOn(client, 'getSummaryOfSubAccountsFuturesAccountV2')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetSummaryOfSubAccountsFuturesAccountV2Response>)
                );
            const response = await client.getSummaryOfSubAccountsFuturesAccountV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSummaryOfSubAccountsFuturesAccountV2() successfully with optional parameters', async () => {
            const params: GetSummaryOfSubAccountsFuturesAccountV2Request = {
                futuresType: 789,
                page: 1,
                limit: 1,
                recvWindow: 5000,
            };

            mockResponse = {
                futureAccountSummaryResp: {
                    totalInitialMargin: '9.83137400',
                    totalMaintenanceMargin: '0.41568700',
                    totalMarginBalance: '23.03235621',
                    totalOpenOrderInitialMargin: '9.00000000',
                    totalPositionInitialMargin: '0.83137400',
                    totalUnrealizedProfit: '0.03219710',
                    totalWalletBalance: '22.15879444',
                    asset: 'USD',
                    subAccountList: [
                        {
                            email: '123@test.com',
                            totalInitialMargin: '9.00000000',
                            totalMaintenanceMargin: '0.00000000',
                            totalMarginBalance: '22.12659734',
                            totalOpenOrderInitialMargin: '9.00000000',
                            totalPositionInitialMargin: '0.00000000',
                            totalUnrealizedProfit: '0.00000000',
                            totalWalletBalance: '22.12659734',
                            asset: 'USD',
                        },
                        {
                            email: '345@test.com',
                            totalInitialMargin: '0.83137400',
                            totalMaintenanceMargin: '0.41568700',
                            totalMarginBalance: '0.90575887',
                            totalOpenOrderInitialMargin: '0.00000000',
                            totalPositionInitialMargin: '0.83137400',
                            totalUnrealizedProfit: '0.03219710',
                            totalWalletBalance: '0.87356177',
                            asset: 'USD',
                        },
                    ],
                },
            };

            const spy = jest
                .spyOn(client, 'getSummaryOfSubAccountsFuturesAccountV2')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetSummaryOfSubAccountsFuturesAccountV2Response>)
                );
            const response = await client.getSummaryOfSubAccountsFuturesAccountV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when futuresType is missing', async () => {
            const _params: GetSummaryOfSubAccountsFuturesAccountV2Request = {
                futuresType: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.futuresType;

            await expect(client.getSummaryOfSubAccountsFuturesAccountV2(params)).rejects.toThrow(
                'Required parameter futuresType was null or undefined when calling getSummaryOfSubAccountsFuturesAccountV2.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetSummaryOfSubAccountsFuturesAccountV2Request = {
                futuresType: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getSummaryOfSubAccountsFuturesAccountV2')
                .mockRejectedValueOnce(mockError);
            await expect(client.getSummaryOfSubAccountsFuturesAccountV2(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getSummaryOfSubAccountsMarginAccount()', () => {
        it('should execute getSummaryOfSubAccountsMarginAccount() successfully with required parameters only', async () => {
            mockResponse = {
                totalAssetOfBtc: '4.33333333',
                totalLiabilityOfBtc: '2.11111112',
                totalNetAssetOfBtc: '2.22222221',
                subAccountList: [
                    {
                        email: '123@test.com',
                        totalAssetOfBtc: '2.11111111',
                        totalLiabilityOfBtc: '1.11111111',
                        totalNetAssetOfBtc: '1.00000000',
                    },
                    {
                        email: '345@test.com',
                        totalAssetOfBtc: '2.22222222',
                        totalLiabilityOfBtc: '1.00000001',
                        totalNetAssetOfBtc: '1.22222221',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'getSummaryOfSubAccountsMarginAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSummaryOfSubAccountsMarginAccountResponse>)
            );
            const response = await client.getSummaryOfSubAccountsMarginAccount();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSummaryOfSubAccountsMarginAccount() successfully with optional parameters', async () => {
            const params: GetSummaryOfSubAccountsMarginAccountRequest = {
                recvWindow: 5000,
            };

            mockResponse = {
                totalAssetOfBtc: '4.33333333',
                totalLiabilityOfBtc: '2.11111112',
                totalNetAssetOfBtc: '2.22222221',
                subAccountList: [
                    {
                        email: '123@test.com',
                        totalAssetOfBtc: '2.11111111',
                        totalLiabilityOfBtc: '1.11111111',
                        totalNetAssetOfBtc: '1.00000000',
                    },
                    {
                        email: '345@test.com',
                        totalAssetOfBtc: '2.22222222',
                        totalLiabilityOfBtc: '1.00000001',
                        totalNetAssetOfBtc: '1.22222221',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'getSummaryOfSubAccountsMarginAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSummaryOfSubAccountsMarginAccountResponse>)
            );
            const response = await client.getSummaryOfSubAccountsMarginAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getSummaryOfSubAccountsMarginAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.getSummaryOfSubAccountsMarginAccount()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('marginTransferForSubAccount()', () => {
        it('should execute marginTransferForSubAccount() successfully with required parameters only', async () => {
            const params: MarginTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1,
                type: 789,
            };

            mockResponse = { txnId: '2966662589' };

            const spy = jest.spyOn(client, 'marginTransferForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginTransferForSubAccountResponse>)
            );
            const response = await client.marginTransferForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute marginTransferForSubAccount() successfully with optional parameters', async () => {
            const params: MarginTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1,
                type: 789,
                recvWindow: 5000,
            };

            mockResponse = { txnId: '2966662589' };

            const spy = jest.spyOn(client, 'marginTransferForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginTransferForSubAccountResponse>)
            );
            const response = await client.marginTransferForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: MarginTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1,
                type: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.marginTransferForSubAccount(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling marginTransferForSubAccount.'
            );
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: MarginTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1,
                type: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.marginTransferForSubAccount(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling marginTransferForSubAccount.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: MarginTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1,
                type: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.marginTransferForSubAccount(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling marginTransferForSubAccount.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: MarginTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1,
                type: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.marginTransferForSubAccount(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling marginTransferForSubAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MarginTransferForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                asset: 'asset_example',
                amount: 1,
                type: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'marginTransferForSubAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.marginTransferForSubAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('querySubAccountAssets()', () => {
        it('should execute querySubAccountAssets() successfully with required parameters only', async () => {
            const params: QuerySubAccountAssetsRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = {
                balances: [
                    { freeze: 0, withdrawing: 0, asset: 'ADA', free: 10000, locked: 0 },
                    { freeze: 0, withdrawing: 0, asset: 'BNB', free: 10003, locked: 0 },
                    { freeze: 0, withdrawing: 0, asset: 'BTC', free: 11467.6399, locked: 0 },
                    { freeze: 0, withdrawing: 0, asset: 'ETH', free: 10004.995, locked: 0 },
                    { freeze: 0, withdrawing: 0, asset: 'USDT', free: 11652.14213, locked: 0 },
                ],
            };

            const spy = jest.spyOn(client, 'querySubAccountAssets').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySubAccountAssetsResponse>)
            );
            const response = await client.querySubAccountAssets(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute querySubAccountAssets() successfully with optional parameters', async () => {
            const params: QuerySubAccountAssetsRequest = {
                email: 'sub-account-email@email.com',
                recvWindow: 5000,
            };

            mockResponse = {
                balances: [
                    { freeze: 0, withdrawing: 0, asset: 'ADA', free: 10000, locked: 0 },
                    { freeze: 0, withdrawing: 0, asset: 'BNB', free: 10003, locked: 0 },
                    { freeze: 0, withdrawing: 0, asset: 'BTC', free: 11467.6399, locked: 0 },
                    { freeze: 0, withdrawing: 0, asset: 'ETH', free: 10004.995, locked: 0 },
                    { freeze: 0, withdrawing: 0, asset: 'USDT', free: 11652.14213, locked: 0 },
                ],
            };

            const spy = jest.spyOn(client, 'querySubAccountAssets').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySubAccountAssetsResponse>)
            );
            const response = await client.querySubAccountAssets(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: QuerySubAccountAssetsRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.querySubAccountAssets(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling querySubAccountAssets.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QuerySubAccountAssetsRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'querySubAccountAssets')
                .mockRejectedValueOnce(mockError);
            await expect(client.querySubAccountAssets(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('querySubAccountAssetsAssetManagement()', () => {
        it('should execute querySubAccountAssetsAssetManagement() successfully with required parameters only', async () => {
            const params: QuerySubAccountAssetsAssetManagementRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = {
                balances: [
                    { freeze: '0', withdrawing: '0', asset: 'ADA', free: '10000', locked: '0' },
                    { freeze: '0', withdrawing: '0', asset: 'BNB', free: '10003', locked: '0' },
                    {
                        freeze: '0',
                        withdrawing: '0',
                        asset: 'BTC',
                        free: '11467.6399',
                        locked: '0',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'querySubAccountAssetsAssetManagement').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySubAccountAssetsAssetManagementResponse>)
            );
            const response = await client.querySubAccountAssetsAssetManagement(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute querySubAccountAssetsAssetManagement() successfully with optional parameters', async () => {
            const params: QuerySubAccountAssetsAssetManagementRequest = {
                email: 'sub-account-email@email.com',
                recvWindow: 5000,
            };

            mockResponse = {
                balances: [
                    { freeze: '0', withdrawing: '0', asset: 'ADA', free: '10000', locked: '0' },
                    { freeze: '0', withdrawing: '0', asset: 'BNB', free: '10003', locked: '0' },
                    {
                        freeze: '0',
                        withdrawing: '0',
                        asset: 'BTC',
                        free: '11467.6399',
                        locked: '0',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'querySubAccountAssetsAssetManagement').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySubAccountAssetsAssetManagementResponse>)
            );
            const response = await client.querySubAccountAssetsAssetManagement(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: QuerySubAccountAssetsAssetManagementRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.querySubAccountAssetsAssetManagement(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling querySubAccountAssetsAssetManagement.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QuerySubAccountAssetsAssetManagementRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'querySubAccountAssetsAssetManagement')
                .mockRejectedValueOnce(mockError);
            await expect(client.querySubAccountAssetsAssetManagement(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('querySubAccountFuturesAssetTransferHistory()', () => {
        it('should execute querySubAccountFuturesAssetTransferHistory() successfully with required parameters only', async () => {
            const params: QuerySubAccountFuturesAssetTransferHistoryRequest = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };

            mockResponse = {
                success: true,
                futuresType: 2,
                transfers: [
                    {
                        from: 'aaa@test.com',
                        to: 'bbb@test.com',
                        asset: 'BTC',
                        qty: '1',
                        tranId: 11897001102,
                        time: 1544433328000,
                    },
                    {
                        from: 'bbb@test.com',
                        to: 'ccc@test.com',
                        asset: 'ETH',
                        qty: '2',
                        tranId: 11631474902,
                        time: 1544433328000,
                    },
                ],
            };

            const spy = jest
                .spyOn(client, 'querySubAccountFuturesAssetTransferHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QuerySubAccountFuturesAssetTransferHistoryResponse>)
                );
            const response = await client.querySubAccountFuturesAssetTransferHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute querySubAccountFuturesAssetTransferHistory() successfully with optional parameters', async () => {
            const params: QuerySubAccountFuturesAssetTransferHistoryRequest = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 1,
                limit: 1,
                recvWindow: 5000,
            };

            mockResponse = {
                success: true,
                futuresType: 2,
                transfers: [
                    {
                        from: 'aaa@test.com',
                        to: 'bbb@test.com',
                        asset: 'BTC',
                        qty: '1',
                        tranId: 11897001102,
                        time: 1544433328000,
                    },
                    {
                        from: 'bbb@test.com',
                        to: 'ccc@test.com',
                        asset: 'ETH',
                        qty: '2',
                        tranId: 11631474902,
                        time: 1544433328000,
                    },
                ],
            };

            const spy = jest
                .spyOn(client, 'querySubAccountFuturesAssetTransferHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QuerySubAccountFuturesAssetTransferHistoryResponse>)
                );
            const response = await client.querySubAccountFuturesAssetTransferHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: QuerySubAccountFuturesAssetTransferHistoryRequest = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.querySubAccountFuturesAssetTransferHistory(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling querySubAccountFuturesAssetTransferHistory.'
            );
        });

        it('should throw RequiredError when futuresType is missing', async () => {
            const _params: QuerySubAccountFuturesAssetTransferHistoryRequest = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.futuresType;

            await expect(client.querySubAccountFuturesAssetTransferHistory(params)).rejects.toThrow(
                'Required parameter futuresType was null or undefined when calling querySubAccountFuturesAssetTransferHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QuerySubAccountFuturesAssetTransferHistoryRequest = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'querySubAccountFuturesAssetTransferHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.querySubAccountFuturesAssetTransferHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('querySubAccountSpotAssetTransferHistory()', () => {
        it('should execute querySubAccountSpotAssetTransferHistory() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    from: 'aaa@test.com',
                    to: 'bbb@test.com',
                    asset: 'BTC',
                    qty: '10',
                    status: 'SUCCESS',
                    tranId: 6489943656,
                    time: 1544433328000,
                },
                {
                    from: 'bbb@test.com',
                    to: 'ccc@test.com',
                    asset: 'ETH',
                    qty: '2',
                    status: 'SUCCESS',
                    tranId: 6489938713,
                    time: 1544433328000,
                },
            ];

            const spy = jest
                .spyOn(client, 'querySubAccountSpotAssetTransferHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QuerySubAccountSpotAssetTransferHistoryResponse>)
                );
            const response = await client.querySubAccountSpotAssetTransferHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute querySubAccountSpotAssetTransferHistory() successfully with optional parameters', async () => {
            const params: QuerySubAccountSpotAssetTransferHistoryRequest = {
                fromEmail: 'fromEmail_example',
                toEmail: 'toEmail_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 1,
                limit: 1,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    from: 'aaa@test.com',
                    to: 'bbb@test.com',
                    asset: 'BTC',
                    qty: '10',
                    status: 'SUCCESS',
                    tranId: 6489943656,
                    time: 1544433328000,
                },
                {
                    from: 'bbb@test.com',
                    to: 'ccc@test.com',
                    asset: 'ETH',
                    qty: '2',
                    status: 'SUCCESS',
                    tranId: 6489938713,
                    time: 1544433328000,
                },
            ];

            const spy = jest
                .spyOn(client, 'querySubAccountSpotAssetTransferHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QuerySubAccountSpotAssetTransferHistoryResponse>)
                );
            const response = await client.querySubAccountSpotAssetTransferHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'querySubAccountSpotAssetTransferHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.querySubAccountSpotAssetTransferHistory()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('querySubAccountSpotAssetsSummary()', () => {
        it('should execute querySubAccountSpotAssetsSummary() successfully with required parameters only', async () => {
            mockResponse = {
                totalCount: 2,
                masterAccountTotalAsset: '0.23231201',
                spotSubUserAssetBtcVoList: [
                    { email: 'sub123@test.com', totalAsset: '9999.00000000' },
                    { email: 'test456@test.com', totalAsset: '0.00000000' },
                ],
            };

            const spy = jest.spyOn(client, 'querySubAccountSpotAssetsSummary').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySubAccountSpotAssetsSummaryResponse>)
            );
            const response = await client.querySubAccountSpotAssetsSummary();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute querySubAccountSpotAssetsSummary() successfully with optional parameters', async () => {
            const params: QuerySubAccountSpotAssetsSummaryRequest = {
                email: 'email_example',
                page: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = {
                totalCount: 2,
                masterAccountTotalAsset: '0.23231201',
                spotSubUserAssetBtcVoList: [
                    { email: 'sub123@test.com', totalAsset: '9999.00000000' },
                    { email: 'test456@test.com', totalAsset: '0.00000000' },
                ],
            };

            const spy = jest.spyOn(client, 'querySubAccountSpotAssetsSummary').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySubAccountSpotAssetsSummaryResponse>)
            );
            const response = await client.querySubAccountSpotAssetsSummary(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'querySubAccountSpotAssetsSummary')
                .mockRejectedValueOnce(mockError);
            await expect(client.querySubAccountSpotAssetsSummary()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryUniversalTransferHistory()', () => {
        it('should execute queryUniversalTransferHistory() successfully with required parameters only', async () => {
            mockResponse = {
                result: [
                    {
                        tranId: 92275823339,
                        fromEmail: 'abctest@gmail.com',
                        toEmail: 'deftest@gmail.com',
                        asset: 'BNB',
                        amount: '0.01',
                        createTimeStamp: 1640317374000,
                        fromAccountType: 'USDT_FUTURE',
                        toAccountType: 'SPOT',
                        status: 'SUCCESS',
                        clientTranId: 'test',
                    },
                ],
                totalCount: 1,
            };

            const spy = jest.spyOn(client, 'queryUniversalTransferHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUniversalTransferHistoryResponse>)
            );
            const response = await client.queryUniversalTransferHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryUniversalTransferHistory() successfully with optional parameters', async () => {
            const params: QueryUniversalTransferHistoryRequest = {
                fromEmail: 'fromEmail_example',
                toEmail: 'toEmail_example',
                clientTranId: '1',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 1,
                limit: 1,
                recvWindow: 5000,
            };

            mockResponse = {
                result: [
                    {
                        tranId: 92275823339,
                        fromEmail: 'abctest@gmail.com',
                        toEmail: 'deftest@gmail.com',
                        asset: 'BNB',
                        amount: '0.01',
                        createTimeStamp: 1640317374000,
                        fromAccountType: 'USDT_FUTURE',
                        toAccountType: 'SPOT',
                        status: 'SUCCESS',
                        clientTranId: 'test',
                    },
                ],
                totalCount: 1,
            };

            const spy = jest.spyOn(client, 'queryUniversalTransferHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUniversalTransferHistoryResponse>)
            );
            const response = await client.queryUniversalTransferHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryUniversalTransferHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryUniversalTransferHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('subAccountFuturesAssetTransfer()', () => {
        it('should execute subAccountFuturesAssetTransfer() successfully with required parameters only', async () => {
            const params: SubAccountFuturesAssetTransferRequest = {
                fromEmail: 'fromEmail_example',
                toEmail: 'toEmail_example',
                futuresType: 789,
                asset: 'asset_example',
                amount: 1,
            };

            mockResponse = { success: true, txnId: '2934662589' };

            const spy = jest.spyOn(client, 'subAccountFuturesAssetTransfer').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubAccountFuturesAssetTransferResponse>)
            );
            const response = await client.subAccountFuturesAssetTransfer(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute subAccountFuturesAssetTransfer() successfully with optional parameters', async () => {
            const params: SubAccountFuturesAssetTransferRequest = {
                fromEmail: 'fromEmail_example',
                toEmail: 'toEmail_example',
                futuresType: 789,
                asset: 'asset_example',
                amount: 1,
                recvWindow: 5000,
            };

            mockResponse = { success: true, txnId: '2934662589' };

            const spy = jest.spyOn(client, 'subAccountFuturesAssetTransfer').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubAccountFuturesAssetTransferResponse>)
            );
            const response = await client.subAccountFuturesAssetTransfer(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when fromEmail is missing', async () => {
            const _params: SubAccountFuturesAssetTransferRequest = {
                fromEmail: 'fromEmail_example',
                toEmail: 'toEmail_example',
                futuresType: 789,
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.fromEmail;

            await expect(client.subAccountFuturesAssetTransfer(params)).rejects.toThrow(
                'Required parameter fromEmail was null or undefined when calling subAccountFuturesAssetTransfer.'
            );
        });

        it('should throw RequiredError when toEmail is missing', async () => {
            const _params: SubAccountFuturesAssetTransferRequest = {
                fromEmail: 'fromEmail_example',
                toEmail: 'toEmail_example',
                futuresType: 789,
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.toEmail;

            await expect(client.subAccountFuturesAssetTransfer(params)).rejects.toThrow(
                'Required parameter toEmail was null or undefined when calling subAccountFuturesAssetTransfer.'
            );
        });

        it('should throw RequiredError when futuresType is missing', async () => {
            const _params: SubAccountFuturesAssetTransferRequest = {
                fromEmail: 'fromEmail_example',
                toEmail: 'toEmail_example',
                futuresType: 789,
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.futuresType;

            await expect(client.subAccountFuturesAssetTransfer(params)).rejects.toThrow(
                'Required parameter futuresType was null or undefined when calling subAccountFuturesAssetTransfer.'
            );
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: SubAccountFuturesAssetTransferRequest = {
                fromEmail: 'fromEmail_example',
                toEmail: 'toEmail_example',
                futuresType: 789,
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.subAccountFuturesAssetTransfer(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling subAccountFuturesAssetTransfer.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: SubAccountFuturesAssetTransferRequest = {
                fromEmail: 'fromEmail_example',
                toEmail: 'toEmail_example',
                futuresType: 789,
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.subAccountFuturesAssetTransfer(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling subAccountFuturesAssetTransfer.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SubAccountFuturesAssetTransferRequest = {
                fromEmail: 'fromEmail_example',
                toEmail: 'toEmail_example',
                futuresType: 789,
                asset: 'asset_example',
                amount: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'subAccountFuturesAssetTransfer')
                .mockRejectedValueOnce(mockError);
            await expect(client.subAccountFuturesAssetTransfer(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('subAccountTransferHistory()', () => {
        it('should execute subAccountTransferHistory() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    counterParty: 'master',
                    email: 'master@test.com',
                    type: 1,
                    asset: 'BTC',
                    qty: '1',
                    fromAccountType: 'SPOT',
                    toAccountType: 'SPOT',
                    status: 'SUCCESS',
                    tranId: 11798835829,
                    time: 1544433325000,
                },
                {
                    counterParty: 'subAccount',
                    email: 'sub2@test.com',
                    type: 1,
                    asset: 'ETH',
                    qty: '2',
                    fromAccountType: 'SPOT',
                    toAccountType: 'COIN_FUTURE',
                    status: 'SUCCESS',
                    tranId: 11798829519,
                    time: 1544433326000,
                },
            ];

            const spy = jest.spyOn(client, 'subAccountTransferHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubAccountTransferHistoryResponse>)
            );
            const response = await client.subAccountTransferHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute subAccountTransferHistory() successfully with optional parameters', async () => {
            const params: SubAccountTransferHistoryRequest = {
                asset: 'asset_example',
                type: 789,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 1,
                returnFailHistory: false,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    counterParty: 'master',
                    email: 'master@test.com',
                    type: 1,
                    asset: 'BTC',
                    qty: '1',
                    fromAccountType: 'SPOT',
                    toAccountType: 'SPOT',
                    status: 'SUCCESS',
                    tranId: 11798835829,
                    time: 1544433325000,
                },
                {
                    counterParty: 'subAccount',
                    email: 'sub2@test.com',
                    type: 1,
                    asset: 'ETH',
                    qty: '2',
                    fromAccountType: 'SPOT',
                    toAccountType: 'COIN_FUTURE',
                    status: 'SUCCESS',
                    tranId: 11798829519,
                    time: 1544433326000,
                },
            ];

            const spy = jest.spyOn(client, 'subAccountTransferHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubAccountTransferHistoryResponse>)
            );
            const response = await client.subAccountTransferHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'subAccountTransferHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.subAccountTransferHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('transferToMaster()', () => {
        it('should execute transferToMaster() successfully with required parameters only', async () => {
            const params: TransferToMasterRequest = {
                asset: 'asset_example',
                amount: 1,
            };

            mockResponse = { txnId: '2966662589' };

            const spy = jest.spyOn(client, 'transferToMaster').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TransferToMasterResponse>)
            );
            const response = await client.transferToMaster(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute transferToMaster() successfully with optional parameters', async () => {
            const params: TransferToMasterRequest = {
                asset: 'asset_example',
                amount: 1,
                recvWindow: 5000,
            };

            mockResponse = { txnId: '2966662589' };

            const spy = jest.spyOn(client, 'transferToMaster').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TransferToMasterResponse>)
            );
            const response = await client.transferToMaster(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: TransferToMasterRequest = {
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.transferToMaster(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling transferToMaster.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: TransferToMasterRequest = {
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.transferToMaster(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling transferToMaster.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TransferToMasterRequest = {
                asset: 'asset_example',
                amount: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'transferToMaster').mockRejectedValueOnce(mockError);
            await expect(client.transferToMaster(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('transferToSubAccountOfSameMaster()', () => {
        it('should execute transferToSubAccountOfSameMaster() successfully with required parameters only', async () => {
            const params: TransferToSubAccountOfSameMasterRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1,
            };

            mockResponse = { txnId: '2966662589' };

            const spy = jest.spyOn(client, 'transferToSubAccountOfSameMaster').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TransferToSubAccountOfSameMasterResponse>)
            );
            const response = await client.transferToSubAccountOfSameMaster(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute transferToSubAccountOfSameMaster() successfully with optional parameters', async () => {
            const params: TransferToSubAccountOfSameMasterRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1,
                recvWindow: 5000,
            };

            mockResponse = { txnId: '2966662589' };

            const spy = jest.spyOn(client, 'transferToSubAccountOfSameMaster').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TransferToSubAccountOfSameMasterResponse>)
            );
            const response = await client.transferToSubAccountOfSameMaster(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when toEmail is missing', async () => {
            const _params: TransferToSubAccountOfSameMasterRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.toEmail;

            await expect(client.transferToSubAccountOfSameMaster(params)).rejects.toThrow(
                'Required parameter toEmail was null or undefined when calling transferToSubAccountOfSameMaster.'
            );
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: TransferToSubAccountOfSameMasterRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.transferToSubAccountOfSameMaster(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling transferToSubAccountOfSameMaster.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: TransferToSubAccountOfSameMasterRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.transferToSubAccountOfSameMaster(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling transferToSubAccountOfSameMaster.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TransferToSubAccountOfSameMasterRequest = {
                toEmail: 'toEmail_example',
                asset: 'asset_example',
                amount: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'transferToSubAccountOfSameMaster')
                .mockRejectedValueOnce(mockError);
            await expect(client.transferToSubAccountOfSameMaster(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('universalTransfer()', () => {
        it('should execute universalTransfer() successfully with required parameters only', async () => {
            const params: UniversalTransferRequest = {
                fromAccountType: 'fromAccountType_example',
                toAccountType: 'toAccountType_example',
                asset: 'asset_example',
                amount: 1,
            };

            mockResponse = { tranId: 11945860693, clientTranId: 'test' };

            const spy = jest.spyOn(client, 'universalTransfer').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UniversalTransferResponse>)
            );
            const response = await client.universalTransfer(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute universalTransfer() successfully with optional parameters', async () => {
            const params: UniversalTransferRequest = {
                fromAccountType: 'fromAccountType_example',
                toAccountType: 'toAccountType_example',
                asset: 'asset_example',
                amount: 1,
                fromEmail: 'fromEmail_example',
                toEmail: 'toEmail_example',
                clientTranId: '1',
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = { tranId: 11945860693, clientTranId: 'test' };

            const spy = jest.spyOn(client, 'universalTransfer').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UniversalTransferResponse>)
            );
            const response = await client.universalTransfer(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when fromAccountType is missing', async () => {
            const _params: UniversalTransferRequest = {
                fromAccountType: 'fromAccountType_example',
                toAccountType: 'toAccountType_example',
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.fromAccountType;

            await expect(client.universalTransfer(params)).rejects.toThrow(
                'Required parameter fromAccountType was null or undefined when calling universalTransfer.'
            );
        });

        it('should throw RequiredError when toAccountType is missing', async () => {
            const _params: UniversalTransferRequest = {
                fromAccountType: 'fromAccountType_example',
                toAccountType: 'toAccountType_example',
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.toAccountType;

            await expect(client.universalTransfer(params)).rejects.toThrow(
                'Required parameter toAccountType was null or undefined when calling universalTransfer.'
            );
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: UniversalTransferRequest = {
                fromAccountType: 'fromAccountType_example',
                toAccountType: 'toAccountType_example',
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.universalTransfer(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling universalTransfer.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: UniversalTransferRequest = {
                fromAccountType: 'fromAccountType_example',
                toAccountType: 'toAccountType_example',
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.universalTransfer(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling universalTransfer.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: UniversalTransferRequest = {
                fromAccountType: 'fromAccountType_example',
                toAccountType: 'toAccountType_example',
                asset: 'asset_example',
                amount: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'universalTransfer').mockRejectedValueOnce(mockError);
            await expect(client.universalTransfer(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
