/**
 * Binance Public Sub Account REST API
 *
 * OpenAPI Specification for the Binance Public Sub Account REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { AccountManagementApi } from '../../../src/rest-api';
import {
    CreateAVirtualSubAccountRequest,
    EnableFuturesForSubAccountRequest,
    EnableLeverageTokenForSubAccountRequest,
    EnableMarginForSubAccountRequest,
    EnableOptionsForSubAccountRequest,
    GetFuturesPositionRiskOfSubAccountRequest,
    GetFuturesPositionRiskOfSubAccountV2Request,
    GetSubAccountsStatusOnMarginOrFuturesRequest,
    QuerySubAccountListRequest,
    QuerySubAccountTransactionStatisticsRequest,
} from '../../../src/rest-api';
import type {
    CreateAVirtualSubAccountResponse,
    EnableFuturesForSubAccountResponse,
    EnableLeverageTokenForSubAccountResponse,
    EnableMarginForSubAccountResponse,
    EnableOptionsForSubAccountResponse,
    GetFuturesPositionRiskOfSubAccountResponse,
    GetFuturesPositionRiskOfSubAccountV2Response,
    GetSubAccountsStatusOnMarginOrFuturesResponse,
    QuerySubAccountListResponse,
    QuerySubAccountTransactionStatisticsResponse,
} from '../../../src/rest-api/types';

describe('AccountManagementApi', () => {
    let client: AccountManagementApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new AccountManagementApi(config);
    });

    describe('createAVirtualSubAccount()', () => {
        it('should execute createAVirtualSubAccount() successfully with required parameters only', async () => {
            const params: CreateAVirtualSubAccountRequest = {
                subAccountString: 'subAccountString_example',
            };

            mockResponse = { email: 'addsdd_virtual@aasaixwqnoemail.com' };

            const spy = jest.spyOn(client, 'createAVirtualSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CreateAVirtualSubAccountResponse>)
            );
            const response = await client.createAVirtualSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute createAVirtualSubAccount() successfully with optional parameters', async () => {
            const params: CreateAVirtualSubAccountRequest = {
                subAccountString: 'subAccountString_example',
                recvWindow: 5000,
            };

            mockResponse = { email: 'addsdd_virtual@aasaixwqnoemail.com' };

            const spy = jest.spyOn(client, 'createAVirtualSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CreateAVirtualSubAccountResponse>)
            );
            const response = await client.createAVirtualSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when subAccountString is missing', async () => {
            const _params: CreateAVirtualSubAccountRequest = {
                subAccountString: 'subAccountString_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.subAccountString;

            await expect(client.createAVirtualSubAccount(params)).rejects.toThrow(
                'Required parameter subAccountString was null or undefined when calling createAVirtualSubAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CreateAVirtualSubAccountRequest = {
                subAccountString: 'subAccountString_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'createAVirtualSubAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.createAVirtualSubAccount(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('enableFuturesForSubAccount()', () => {
        it('should execute enableFuturesForSubAccount() successfully with required parameters only', async () => {
            const params: EnableFuturesForSubAccountRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = { email: '123@test.com', isFuturesEnabled: true };

            const spy = jest.spyOn(client, 'enableFuturesForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<EnableFuturesForSubAccountResponse>)
            );
            const response = await client.enableFuturesForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute enableFuturesForSubAccount() successfully with optional parameters', async () => {
            const params: EnableFuturesForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                recvWindow: 5000,
            };

            mockResponse = { email: '123@test.com', isFuturesEnabled: true };

            const spy = jest.spyOn(client, 'enableFuturesForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<EnableFuturesForSubAccountResponse>)
            );
            const response = await client.enableFuturesForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: EnableFuturesForSubAccountRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.enableFuturesForSubAccount(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling enableFuturesForSubAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: EnableFuturesForSubAccountRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'enableFuturesForSubAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.enableFuturesForSubAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('enableLeverageTokenForSubAccount()', () => {
        it('should execute enableLeverageTokenForSubAccount() successfully with required parameters only', async () => {
            const params: EnableLeverageTokenForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                enableBlvt: true,
            };

            mockResponse = { email: '123@test.com', enableBlvt: true };

            const spy = jest.spyOn(client, 'enableLeverageTokenForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<EnableLeverageTokenForSubAccountResponse>)
            );
            const response = await client.enableLeverageTokenForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute enableLeverageTokenForSubAccount() successfully with optional parameters', async () => {
            const params: EnableLeverageTokenForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                enableBlvt: true,
                recvWindow: 5000,
            };

            mockResponse = { email: '123@test.com', enableBlvt: true };

            const spy = jest.spyOn(client, 'enableLeverageTokenForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<EnableLeverageTokenForSubAccountResponse>)
            );
            const response = await client.enableLeverageTokenForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: EnableLeverageTokenForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                enableBlvt: true,
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.enableLeverageTokenForSubAccount(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling enableLeverageTokenForSubAccount.'
            );
        });

        it('should throw RequiredError when enableBlvt is missing', async () => {
            const _params: EnableLeverageTokenForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                enableBlvt: true,
            };
            const params = Object.assign({ ..._params });
            delete params?.enableBlvt;

            await expect(client.enableLeverageTokenForSubAccount(params)).rejects.toThrow(
                'Required parameter enableBlvt was null or undefined when calling enableLeverageTokenForSubAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: EnableLeverageTokenForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                enableBlvt: true,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'enableLeverageTokenForSubAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.enableLeverageTokenForSubAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('enableMarginForSubAccount()', () => {
        it('should execute enableMarginForSubAccount() successfully with required parameters only', async () => {
            const params: EnableMarginForSubAccountRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = { email: '123@test.com', isMarginEnabled: true };

            const spy = jest.spyOn(client, 'enableMarginForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<EnableMarginForSubAccountResponse>)
            );
            const response = await client.enableMarginForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute enableMarginForSubAccount() successfully with optional parameters', async () => {
            const params: EnableMarginForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                recvWindow: 5000,
            };

            mockResponse = { email: '123@test.com', isMarginEnabled: true };

            const spy = jest.spyOn(client, 'enableMarginForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<EnableMarginForSubAccountResponse>)
            );
            const response = await client.enableMarginForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: EnableMarginForSubAccountRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.enableMarginForSubAccount(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling enableMarginForSubAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: EnableMarginForSubAccountRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'enableMarginForSubAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.enableMarginForSubAccount(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('enableOptionsForSubAccount()', () => {
        it('should execute enableOptionsForSubAccount() successfully with required parameters only', async () => {
            const params: EnableOptionsForSubAccountRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = { email: '123@test.com', isEOptionsEnabled: true };

            const spy = jest.spyOn(client, 'enableOptionsForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<EnableOptionsForSubAccountResponse>)
            );
            const response = await client.enableOptionsForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute enableOptionsForSubAccount() successfully with optional parameters', async () => {
            const params: EnableOptionsForSubAccountRequest = {
                email: 'sub-account-email@email.com',
                recvWindow: 5000,
            };

            mockResponse = { email: '123@test.com', isEOptionsEnabled: true };

            const spy = jest.spyOn(client, 'enableOptionsForSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<EnableOptionsForSubAccountResponse>)
            );
            const response = await client.enableOptionsForSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: EnableOptionsForSubAccountRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.enableOptionsForSubAccount(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling enableOptionsForSubAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: EnableOptionsForSubAccountRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'enableOptionsForSubAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.enableOptionsForSubAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getFuturesPositionRiskOfSubAccount()', () => {
        it('should execute getFuturesPositionRiskOfSubAccount() successfully with required parameters only', async () => {
            const params: GetFuturesPositionRiskOfSubAccountRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = [
                {
                    entryPrice: '9975.12000',
                    leverage: '50',
                    maxNotional: '1000000',
                    liquidationPrice: '7963.54',
                    markPrice: '9973.50770517',
                    positionAmount: '0.010',
                    symbol: 'BTCUSDT',
                    unrealizedProfit: '-0.01612295',
                },
            ];

            const spy = jest.spyOn(client, 'getFuturesPositionRiskOfSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFuturesPositionRiskOfSubAccountResponse>)
            );
            const response = await client.getFuturesPositionRiskOfSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFuturesPositionRiskOfSubAccount() successfully with optional parameters', async () => {
            const params: GetFuturesPositionRiskOfSubAccountRequest = {
                email: 'sub-account-email@email.com',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    entryPrice: '9975.12000',
                    leverage: '50',
                    maxNotional: '1000000',
                    liquidationPrice: '7963.54',
                    markPrice: '9973.50770517',
                    positionAmount: '0.010',
                    symbol: 'BTCUSDT',
                    unrealizedProfit: '-0.01612295',
                },
            ];

            const spy = jest.spyOn(client, 'getFuturesPositionRiskOfSubAccount').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFuturesPositionRiskOfSubAccountResponse>)
            );
            const response = await client.getFuturesPositionRiskOfSubAccount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: GetFuturesPositionRiskOfSubAccountRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.getFuturesPositionRiskOfSubAccount(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling getFuturesPositionRiskOfSubAccount.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFuturesPositionRiskOfSubAccountRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFuturesPositionRiskOfSubAccount')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFuturesPositionRiskOfSubAccount(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getFuturesPositionRiskOfSubAccountV2()', () => {
        it('should execute getFuturesPositionRiskOfSubAccountV2() successfully with required parameters only', async () => {
            const params: GetFuturesPositionRiskOfSubAccountV2Request = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };

            mockResponse = {
                futurePositionRiskVos: [
                    {
                        entryPrice: '9975.12000',
                        leverage: '50',
                        maxNotional: '1000000',
                        liquidationPrice: '7963.54',
                        markPrice: '9973.50770517',
                        positionAmount: '0.010',
                        symbol: 'BTCUSDT',
                        unrealizedProfit: '-0.01612295',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'getFuturesPositionRiskOfSubAccountV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFuturesPositionRiskOfSubAccountV2Response>)
            );
            const response = await client.getFuturesPositionRiskOfSubAccountV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFuturesPositionRiskOfSubAccountV2() successfully with optional parameters', async () => {
            const params: GetFuturesPositionRiskOfSubAccountV2Request = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
                recvWindow: 5000,
            };

            mockResponse = {
                futurePositionRiskVos: [
                    {
                        entryPrice: '9975.12000',
                        leverage: '50',
                        maxNotional: '1000000',
                        liquidationPrice: '7963.54',
                        markPrice: '9973.50770517',
                        positionAmount: '0.010',
                        symbol: 'BTCUSDT',
                        unrealizedProfit: '-0.01612295',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'getFuturesPositionRiskOfSubAccountV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFuturesPositionRiskOfSubAccountV2Response>)
            );
            const response = await client.getFuturesPositionRiskOfSubAccountV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: GetFuturesPositionRiskOfSubAccountV2Request = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.getFuturesPositionRiskOfSubAccountV2(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling getFuturesPositionRiskOfSubAccountV2.'
            );
        });

        it('should throw RequiredError when futuresType is missing', async () => {
            const _params: GetFuturesPositionRiskOfSubAccountV2Request = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.futuresType;

            await expect(client.getFuturesPositionRiskOfSubAccountV2(params)).rejects.toThrow(
                'Required parameter futuresType was null or undefined when calling getFuturesPositionRiskOfSubAccountV2.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFuturesPositionRiskOfSubAccountV2Request = {
                email: 'sub-account-email@email.com',
                futuresType: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFuturesPositionRiskOfSubAccountV2')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFuturesPositionRiskOfSubAccountV2(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getSubAccountsStatusOnMarginOrFutures()', () => {
        it('should execute getSubAccountsStatusOnMarginOrFutures() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    email: '123@test.com',
                    isSubUserEnabled: true,
                    isUserActive: true,
                    insertTime: 1570791523523,
                    isMarginEnabled: true,
                    isFutureEnabled: true,
                    mobile: 1570791523523,
                },
            ];

            const spy = jest.spyOn(client, 'getSubAccountsStatusOnMarginOrFutures').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSubAccountsStatusOnMarginOrFuturesResponse>)
            );
            const response = await client.getSubAccountsStatusOnMarginOrFutures();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getSubAccountsStatusOnMarginOrFutures() successfully with optional parameters', async () => {
            const params: GetSubAccountsStatusOnMarginOrFuturesRequest = {
                email: 'email_example',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    email: '123@test.com',
                    isSubUserEnabled: true,
                    isUserActive: true,
                    insertTime: 1570791523523,
                    isMarginEnabled: true,
                    isFutureEnabled: true,
                    mobile: 1570791523523,
                },
            ];

            const spy = jest.spyOn(client, 'getSubAccountsStatusOnMarginOrFutures').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetSubAccountsStatusOnMarginOrFuturesResponse>)
            );
            const response = await client.getSubAccountsStatusOnMarginOrFutures(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getSubAccountsStatusOnMarginOrFutures')
                .mockRejectedValueOnce(mockError);
            await expect(client.getSubAccountsStatusOnMarginOrFutures()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('querySubAccountList()', () => {
        it('should execute querySubAccountList() successfully with required parameters only', async () => {
            mockResponse = {
                subAccounts: [
                    {
                        email: 'testsub@gmail.com',
                        isFreeze: false,
                        createTime: 1544433328000,
                        isManagedSubAccount: false,
                        isAssetManagementSubAccount: false,
                    },
                    {
                        email: 'virtual@oxebmvfonoemail.com',
                        isFreeze: false,
                        createTime: 1544433328000,
                        isManagedSubAccount: false,
                        isAssetManagementSubAccount: false,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'querySubAccountList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySubAccountListResponse>)
            );
            const response = await client.querySubAccountList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute querySubAccountList() successfully with optional parameters', async () => {
            const params: QuerySubAccountListRequest = {
                email: 'email_example',
                isFreeze: 'isFreeze_example',
                page: 1,
                limit: 1,
                recvWindow: 5000,
            };

            mockResponse = {
                subAccounts: [
                    {
                        email: 'testsub@gmail.com',
                        isFreeze: false,
                        createTime: 1544433328000,
                        isManagedSubAccount: false,
                        isAssetManagementSubAccount: false,
                    },
                    {
                        email: 'virtual@oxebmvfonoemail.com',
                        isFreeze: false,
                        createTime: 1544433328000,
                        isManagedSubAccount: false,
                        isAssetManagementSubAccount: false,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'querySubAccountList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySubAccountListResponse>)
            );
            const response = await client.querySubAccountList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'querySubAccountList').mockRejectedValueOnce(mockError);
            await expect(client.querySubAccountList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('querySubAccountTransactionStatistics()', () => {
        it('should execute querySubAccountTransactionStatistics() successfully with required parameters only', async () => {
            const params: QuerySubAccountTransactionStatisticsRequest = {
                email: 'sub-account-email@email.com',
            };

            mockResponse = {
                recent30BtcTotal: '0',
                recent30BtcFuturesTotal: '0',
                recent30BtcMarginTotal: '0',
                recent30BusdTotal: '0',
                recent30BusdFuturesTotal: '0',
                recent30BusdMarginTotal: '0',
                tradeInfoVos: [],
            };

            const spy = jest.spyOn(client, 'querySubAccountTransactionStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySubAccountTransactionStatisticsResponse>)
            );
            const response = await client.querySubAccountTransactionStatistics(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute querySubAccountTransactionStatistics() successfully with optional parameters', async () => {
            const params: QuerySubAccountTransactionStatisticsRequest = {
                email: 'sub-account-email@email.com',
                recvWindow: 5000,
            };

            mockResponse = {
                recent30BtcTotal: '0',
                recent30BtcFuturesTotal: '0',
                recent30BtcMarginTotal: '0',
                recent30BusdTotal: '0',
                recent30BusdFuturesTotal: '0',
                recent30BusdMarginTotal: '0',
                tradeInfoVos: [],
            };

            const spy = jest.spyOn(client, 'querySubAccountTransactionStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuerySubAccountTransactionStatisticsResponse>)
            );
            const response = await client.querySubAccountTransactionStatistics(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when email is missing', async () => {
            const _params: QuerySubAccountTransactionStatisticsRequest = {
                email: 'sub-account-email@email.com',
            };
            const params = Object.assign({ ..._params });
            delete params?.email;

            await expect(client.querySubAccountTransactionStatistics(params)).rejects.toThrow(
                'Required parameter email was null or undefined when calling querySubAccountTransactionStatistics.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QuerySubAccountTransactionStatisticsRequest = {
                email: 'sub-account-email@email.com',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'querySubAccountTransactionStatistics')
                .mockRejectedValueOnce(mockError);
            await expect(client.querySubAccountTransactionStatistics(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });
});
