/**
 * Binance Derivatives Trading USDS Futures REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading USDS Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
    ConfigurationRestAPI,
    TimeUnit,
    RestApiResponse,
    assertParamExists,
    sendRequest,
    type RequestArgs,
} from '@binance/common';
import type {
    AcceptTheOfferedQuoteResponse,
    ListAllConvertPairsResponse,
    OrderStatusResponse,
    SendQuoteRequestResponse,
} from '../types';

/**
 * ConvertApi - axios parameter creator
 */
const ConvertApiAxiosParamCreator = function (configuration: ConfigurationRestAPI) {
    return {
        /**
         * Accept the offered quote by quote ID.
         *
         * Weight: 200(IP)
         *
         * @summary Accept the offered quote (USER_DATA)
         * @param {string} quoteId
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        acceptTheOfferedQuote: async (
            quoteId: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'quoteId' is not null or undefined
            assertParamExists('acceptTheOfferedQuote', 'quoteId', quoteId);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (quoteId !== undefined && quoteId !== null) {
                localVarQueryParameter['quoteId'] = quoteId;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/convert/acceptQuote',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query for all convertible token pairs and the tokens’ respective upper/lower limits
         *
         * User needs to supply either or both of the input parameter
         * If not defined for both fromAsset and toAsset, only partial token pairs will be returned
         * Asset BNFCR is only available to convert for MICA region users.
         *
         * Weight: 20(IP)
         *
         * @summary List All Convert Pairs
         * @param {string} [fromAsset] User spends coin
         * @param {string} [toAsset] User receives coin
         *
         * @throws {RequiredError}
         */
        listAllConvertPairs: async (fromAsset?: string, toAsset?: string): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (fromAsset !== undefined && fromAsset !== null) {
                localVarQueryParameter['fromAsset'] = fromAsset;
            }

            if (toAsset !== undefined && toAsset !== null) {
                localVarQueryParameter['toAsset'] = toAsset;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/convert/exchangeInfo',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query order status by order ID.
         *
         * Weight: 50(IP)
         *
         * @summary Order status(USER_DATA)
         * @param {string} [orderId] Either orderId or quoteId is required
         * @param {string} [quoteId] Either orderId or quoteId is required
         *
         * @throws {RequiredError}
         */
        orderStatus: async (orderId?: string, quoteId?: string): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (quoteId !== undefined && quoteId !== null) {
                localVarQueryParameter['quoteId'] = quoteId;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/convert/orderStatus',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Request a quote for the requested token pairs
         *
         * Either fromAmount or toAmount should be sent
         * `quoteId` will be returned only if you have enough funds to convert
         *
         * Weight: 50(IP)
         *
         * @summary Send Quote Request(USER_DATA)
         * @param {string} fromAsset
         * @param {string} toAsset
         * @param {number} [fromAmount] When specified, it is the amount you will be debited after the conversion
         * @param {number} [toAmount] When specified, it is the amount you will be credited after the conversion
         * @param {string} [validTime] 10s, default 10s
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        sendQuoteRequest: async (
            fromAsset: string,
            toAsset: string,
            fromAmount?: number,
            toAmount?: number,
            validTime?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'fromAsset' is not null or undefined
            assertParamExists('sendQuoteRequest', 'fromAsset', fromAsset);
            // verify required parameter 'toAsset' is not null or undefined
            assertParamExists('sendQuoteRequest', 'toAsset', toAsset);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (fromAsset !== undefined && fromAsset !== null) {
                localVarQueryParameter['fromAsset'] = fromAsset;
            }

            if (toAsset !== undefined && toAsset !== null) {
                localVarQueryParameter['toAsset'] = toAsset;
            }

            if (fromAmount !== undefined && fromAmount !== null) {
                localVarQueryParameter['fromAmount'] = fromAmount;
            }

            if (toAmount !== undefined && toAmount !== null) {
                localVarQueryParameter['toAmount'] = toAmount;
            }

            if (validTime !== undefined && validTime !== null) {
                localVarQueryParameter['validTime'] = validTime;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/convert/getQuote',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
    };
};

/**
 * ConvertApi - interface
 * @interface ConvertApi
 */
export interface ConvertApiInterface {
    /**
     * Accept the offered quote by quote ID.
     *
     * Weight: 200(IP)
     *
     * @summary Accept the offered quote (USER_DATA)
     * @param {AcceptTheOfferedQuoteRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof ConvertApiInterface
     */
    acceptTheOfferedQuote(
        requestParameters: AcceptTheOfferedQuoteRequest
    ): Promise<RestApiResponse<AcceptTheOfferedQuoteResponse>>;
    /**
     * Query for all convertible token pairs and the tokens’ respective upper/lower limits
     *
     * User needs to supply either or both of the input parameter
     * If not defined for both fromAsset and toAsset, only partial token pairs will be returned
     * Asset BNFCR is only available to convert for MICA region users.
     *
     * Weight: 20(IP)
     *
     * @summary List All Convert Pairs
     * @param {ListAllConvertPairsRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof ConvertApiInterface
     */
    listAllConvertPairs(
        requestParameters?: ListAllConvertPairsRequest
    ): Promise<RestApiResponse<ListAllConvertPairsResponse>>;
    /**
     * Query order status by order ID.
     *
     * Weight: 50(IP)
     *
     * @summary Order status(USER_DATA)
     * @param {OrderStatusRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof ConvertApiInterface
     */
    orderStatus(
        requestParameters?: OrderStatusRequest
    ): Promise<RestApiResponse<OrderStatusResponse>>;
    /**
     * Request a quote for the requested token pairs
     *
     * Either fromAmount or toAmount should be sent
     * `quoteId` will be returned only if you have enough funds to convert
     *
     * Weight: 50(IP)
     *
     * @summary Send Quote Request(USER_DATA)
     * @param {SendQuoteRequestRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof ConvertApiInterface
     */
    sendQuoteRequest(
        requestParameters: SendQuoteRequestRequest
    ): Promise<RestApiResponse<SendQuoteRequestResponse>>;
}

/**
 * Request parameters for acceptTheOfferedQuote operation in ConvertApi.
 * @interface AcceptTheOfferedQuoteRequest
 */
export interface AcceptTheOfferedQuoteRequest {
    /**
     *
     * @type {string}
     * @memberof ConvertApiAcceptTheOfferedQuote
     */
    readonly quoteId: string;

    /**
     *
     * @type {number}
     * @memberof ConvertApiAcceptTheOfferedQuote
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for listAllConvertPairs operation in ConvertApi.
 * @interface ListAllConvertPairsRequest
 */
export interface ListAllConvertPairsRequest {
    /**
     * User spends coin
     * @type {string}
     * @memberof ConvertApiListAllConvertPairs
     */
    readonly fromAsset?: string;

    /**
     * User receives coin
     * @type {string}
     * @memberof ConvertApiListAllConvertPairs
     */
    readonly toAsset?: string;
}

/**
 * Request parameters for orderStatus operation in ConvertApi.
 * @interface OrderStatusRequest
 */
export interface OrderStatusRequest {
    /**
     * Either orderId or quoteId is required
     * @type {string}
     * @memberof ConvertApiOrderStatus
     */
    readonly orderId?: string;

    /**
     * Either orderId or quoteId is required
     * @type {string}
     * @memberof ConvertApiOrderStatus
     */
    readonly quoteId?: string;
}

/**
 * Request parameters for sendQuoteRequest operation in ConvertApi.
 * @interface SendQuoteRequestRequest
 */
export interface SendQuoteRequestRequest {
    /**
     *
     * @type {string}
     * @memberof ConvertApiSendQuoteRequest
     */
    readonly fromAsset: string;

    /**
     *
     * @type {string}
     * @memberof ConvertApiSendQuoteRequest
     */
    readonly toAsset: string;

    /**
     * When specified, it is the amount you will be debited after the conversion
     * @type {number}
     * @memberof ConvertApiSendQuoteRequest
     */
    readonly fromAmount?: number;

    /**
     * When specified, it is the amount you will be credited after the conversion
     * @type {number}
     * @memberof ConvertApiSendQuoteRequest
     */
    readonly toAmount?: number;

    /**
     * 10s, default 10s
     * @type {string}
     * @memberof ConvertApiSendQuoteRequest
     */
    readonly validTime?: string;

    /**
     *
     * @type {number}
     * @memberof ConvertApiSendQuoteRequest
     */
    readonly recvWindow?: number;
}

/**
 * ConvertApi - object-oriented interface
 * @class ConvertApi
 */
export class ConvertApi implements ConvertApiInterface {
    private readonly configuration: ConfigurationRestAPI;
    private localVarAxiosParamCreator;

    constructor(configuration: ConfigurationRestAPI) {
        this.configuration = configuration;
        this.localVarAxiosParamCreator = ConvertApiAxiosParamCreator(configuration);
    }

    /**
     * Accept the offered quote by quote ID.
     *
     * Weight: 200(IP)
     *
     * @summary Accept the offered quote (USER_DATA)
     * @param {AcceptTheOfferedQuoteRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<AcceptTheOfferedQuoteResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof ConvertApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/convert/Accept-Quote Binance API Documentation}
     */
    public async acceptTheOfferedQuote(
        requestParameters: AcceptTheOfferedQuoteRequest
    ): Promise<RestApiResponse<AcceptTheOfferedQuoteResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.acceptTheOfferedQuote(
            requestParameters?.quoteId,
            requestParameters?.recvWindow
        );
        return sendRequest<AcceptTheOfferedQuoteResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query for all convertible token pairs and the tokens’ respective upper/lower limits
     *
     * User needs to supply either or both of the input parameter
     * If not defined for both fromAsset and toAsset, only partial token pairs will be returned
     * Asset BNFCR is only available to convert for MICA region users.
     *
     * Weight: 20(IP)
     *
     * @summary List All Convert Pairs
     * @param {ListAllConvertPairsRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ListAllConvertPairsResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof ConvertApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/convert/List-All-Convert-Pairs Binance API Documentation}
     */
    public async listAllConvertPairs(
        requestParameters: ListAllConvertPairsRequest = {}
    ): Promise<RestApiResponse<ListAllConvertPairsResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.listAllConvertPairs(
            requestParameters?.fromAsset,
            requestParameters?.toAsset
        );
        return sendRequest<ListAllConvertPairsResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Query order status by order ID.
     *
     * Weight: 50(IP)
     *
     * @summary Order status(USER_DATA)
     * @param {OrderStatusRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OrderStatusResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof ConvertApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/convert/Order-Status Binance API Documentation}
     */
    public async orderStatus(
        requestParameters: OrderStatusRequest = {}
    ): Promise<RestApiResponse<OrderStatusResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderStatus(
            requestParameters?.orderId,
            requestParameters?.quoteId
        );
        return sendRequest<OrderStatusResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Request a quote for the requested token pairs
     *
     * Either fromAmount or toAmount should be sent
     * `quoteId` will be returned only if you have enough funds to convert
     *
     * Weight: 50(IP)
     *
     * @summary Send Quote Request(USER_DATA)
     * @param {SendQuoteRequestRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<SendQuoteRequestResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof ConvertApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/convert/Send-quote-request Binance API Documentation}
     */
    public async sendQuoteRequest(
        requestParameters: SendQuoteRequestRequest
    ): Promise<RestApiResponse<SendQuoteRequestResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.sendQuoteRequest(
            requestParameters?.fromAsset,
            requestParameters?.toAsset,
            requestParameters?.fromAmount,
            requestParameters?.toAmount,
            requestParameters?.validTime,
            requestParameters?.recvWindow
        );
        return sendRequest<SendQuoteRequestResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }
}
