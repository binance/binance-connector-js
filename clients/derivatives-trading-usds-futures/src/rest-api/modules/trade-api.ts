/**
 * Binance Derivatives Trading USDS Futures REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading USDS Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
    ConfigurationRestAPI,
    TimeUnit,
    RestApiResponse,
    assertParamExists,
    sendRequest,
    type RequestArgs,
} from '@binance/common';
import type {
    AccountTradeListResponse,
    AllOrdersResponse,
    AutoCancelAllOpenOrdersResponse,
    CancelAllOpenOrdersResponse,
    CancelMultipleOrdersResponse,
    CancelOrderResponse,
    ChangeInitialLeverageResponse,
    ChangeMarginTypeResponse,
    ChangeMultiAssetsModeResponse,
    ChangePositionModeResponse,
    CurrentAllOpenOrdersResponse,
    GetOrderModifyHistoryResponse,
    GetPositionMarginChangeHistoryResponse,
    ModifyIsolatedPositionMarginResponse,
    ModifyMultipleOrdersBatchOrdersParameterInner,
    ModifyMultipleOrdersResponse,
    ModifyOrderResponse,
    NewOrderResponse,
    PlaceMultipleOrdersResponse,
    PositionAdlQuantileEstimationResponse,
    PositionInformationV2Response,
    PositionInformationV3Response,
    QueryCurrentOpenOrderResponse,
    QueryOrderResponse,
    TestOrderResponse,
    UsersForceOrdersResponse,
} from '../types';

/**
 * TradeApi - axios parameter creator
 */
const TradeApiAxiosParamCreator = function (configuration: ConfigurationRestAPI) {
    return {
        /**
         * Get trades for a specific account and symbol.
         *
         * If `startTime` and `endTime` are both not sent, then the last 7 days' data will be returned.
         * The time between `startTime` and `endTime` cannot be longer than 7 days.
         * The parameter `fromId` cannot be sent with `startTime` or `endTime`.
         * Only support querying trade in the past 6 months
         *
         * Weight: 5
         *
         * @summary Account Trade List (USER_DATA)
         * @param {string} symbol
         * @param {number} [orderId]
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        accountTradeList: async (
            symbol: string,
            orderId?: number,
            startTime?: number,
            endTime?: number,
            fromId?: number,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('accountTradeList', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (fromId !== undefined && fromId !== null) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/userTrades',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get all account orders; active, canceled, or filled.
         *
         * These orders will not be found:
         * order status is `CANCELED` or `EXPIRED` **AND** order has NO filled trade **AND** created time + 3 days < current time
         * order create time + 90 days < current time
         *
         * If `orderId` is set, it will get orders >= that `orderId`. Otherwise most recent orders are returned.
         * The query time period must be less then 7 days( default as the recent 7 days).
         *
         * Weight: 5
         *
         * @summary All Orders (USER_DATA)
         * @param {string} symbol
         * @param {number} [orderId]
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        allOrders: async (
            symbol: string,
            orderId?: number,
            startTime?: number,
            endTime?: number,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('allOrders', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/allOrders',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel all open orders of the specified symbol at the end of the specified countdown.
         * The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and replaced by a new one.
         *
         * Example usage:
         * Call this endpoint at 30s intervals with an countdownTime of 120000 (120s).
         * If this endpoint is not called within 120 seconds, all your orders of the specified symbol will be automatically canceled.
         * If this endpoint is called with an countdownTime of 0, the countdown timer will be stopped.
         *
         * The system will check all countdowns **approximately every 10 milliseconds**, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.
         *
         * Weight: 10
         *
         * @summary Auto-Cancel All Open Orders (TRADE)
         * @param {string} symbol
         * @param {number} countdownTime countdown time, 1000 for 1 second. 0 to cancel the timer
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        autoCancelAllOpenOrders: async (
            symbol: string,
            countdownTime: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('autoCancelAllOpenOrders', 'symbol', symbol);
            // verify required parameter 'countdownTime' is not null or undefined
            assertParamExists('autoCancelAllOpenOrders', 'countdownTime', countdownTime);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (countdownTime !== undefined && countdownTime !== null) {
                localVarQueryParameter['countdownTime'] = countdownTime;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/countdownCancelAll',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel All Open Orders
         *
         * Weight: 1
         *
         * @summary Cancel All Open Orders (TRADE)
         * @param {string} symbol
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cancelAllOpenOrders: async (symbol: string, recvWindow?: number): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cancelAllOpenOrders', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/allOpenOrders',
                method: 'DELETE',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel Multiple Orders
         *
         * Either `orderIdList` or `origClientOrderIdList ` must be sent.
         *
         * Weight: 1
         *
         * @summary Cancel Multiple Orders (TRADE)
         * @param {string} symbol
         * @param {Array<number>} [orderIdList] max length 10 <br /> e.g. [1234567,2345678]
         * @param {Array<string>} [origClientOrderIdList] max length 10<br /> e.g. ["my_id_1","my_id_2"], encode the double quotes. No space after comma.
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cancelMultipleOrders: async (
            symbol: string,
            orderIdList?: Array<number>,
            origClientOrderIdList?: Array<string>,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cancelMultipleOrders', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderIdList) {
                localVarQueryParameter['orderIdList'] = orderIdList;
            }

            if (origClientOrderIdList) {
                localVarQueryParameter['origClientOrderIdList'] = origClientOrderIdList;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/batchOrders',
                method: 'DELETE',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel an active order.
         *
         * Either `orderId` or `origClientOrderId` must be sent.
         *
         * Weight: 1
         *
         * @summary Cancel Order (TRADE)
         * @param {string} symbol
         * @param {number} [orderId]
         * @param {string} [origClientOrderId]
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cancelOrder: async (
            symbol: string,
            orderId?: number,
            origClientOrderId?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cancelOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/order',
                method: 'DELETE',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Change user's initial leverage of specific symbol market.
         *
         * Weight: 1
         *
         * @summary Change Initial Leverage(TRADE)
         * @param {string} symbol
         * @param {number} leverage target initial leverage: int from 1 to 125
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        changeInitialLeverage: async (
            symbol: string,
            leverage: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('changeInitialLeverage', 'symbol', symbol);
            // verify required parameter 'leverage' is not null or undefined
            assertParamExists('changeInitialLeverage', 'leverage', leverage);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (leverage !== undefined && leverage !== null) {
                localVarQueryParameter['leverage'] = leverage;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/leverage',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Change symbol level margin type
         *
         * Weight: 1
         *
         * @summary Change Margin Type(TRADE)
         * @param {string} symbol
         * @param {ChangeMarginTypeMarginTypeEnum} marginType ISOLATED, CROSSED
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        changeMarginType: async (
            symbol: string,
            marginType: ChangeMarginTypeMarginTypeEnum,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('changeMarginType', 'symbol', symbol);
            // verify required parameter 'marginType' is not null or undefined
            assertParamExists('changeMarginType', 'marginType', marginType);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (marginType !== undefined && marginType !== null) {
                localVarQueryParameter['marginType'] = marginType;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/marginType',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Change user's Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on ***Every symbol***
         *
         * Weight: 1
         *
         * @summary Change Multi-Assets Mode (TRADE)
         * @param {string} multiAssetsMargin "true": Multi-Assets Mode; "false": Single-Asset Mode
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        changeMultiAssetsMode: async (
            multiAssetsMargin: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'multiAssetsMargin' is not null or undefined
            assertParamExists('changeMultiAssetsMode', 'multiAssetsMargin', multiAssetsMargin);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (multiAssetsMargin !== undefined && multiAssetsMargin !== null) {
                localVarQueryParameter['multiAssetsMargin'] = multiAssetsMargin;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/multiAssetsMargin',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Change user's position mode (Hedge Mode or One-way Mode ) on ***EVERY symbol***
         *
         * Weight: 1
         *
         * @summary Change Position Mode(TRADE)
         * @param {string} dualSidePosition "true": Hedge Mode; "false": One-way Mode
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        changePositionMode: async (
            dualSidePosition: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'dualSidePosition' is not null or undefined
            assertParamExists('changePositionMode', 'dualSidePosition', dualSidePosition);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (dualSidePosition !== undefined && dualSidePosition !== null) {
                localVarQueryParameter['dualSidePosition'] = dualSidePosition;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/positionSide/dual',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get all open orders on a symbol.
         *
         * If the symbol is not sent, orders for all symbols will be returned in an array.
         *
         * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
         * Careful when accessing this with no symbol.
         *
         * @summary Current All Open Orders (USER_DATA)
         * @param {string} [symbol]
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        currentAllOpenOrders: async (
            symbol?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/openOrders',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get order modification history
         *
         * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
         * Order modify history longer than 3 month is not avaliable
         *
         * Weight: 1
         *
         * @summary Get Order Modify History (USER_DATA)
         * @param {string} symbol
         * @param {number} [orderId]
         * @param {string} [origClientOrderId]
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        getOrderModifyHistory: async (
            symbol: string,
            orderId?: number,
            origClientOrderId?: string,
            startTime?: number,
            endTime?: number,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOrderModifyHistory', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/orderAmendment',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get Position Margin Change History
         *
         * Support querying future histories that are not older than 30 days
         * The time between `startTime` and `endTime`can't be more than 30 days
         *
         * Weight: 1
         *
         * @summary Get Position Margin Change History (TRADE)
         * @param {string} symbol
         * @param {number} [type] 1: Add position margin，2: Reduce position margin
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        getPositionMarginChangeHistory: async (
            symbol: string,
            type?: number,
            startTime?: number,
            endTime?: number,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getPositionMarginChangeHistory', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/positionMargin/history',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Modify Isolated Position Margin
         *
         *
         * Only for isolated symbol
         *
         * Weight: 1
         *
         * @summary Modify Isolated Position Margin(TRADE)
         * @param {string} symbol
         * @param {number} amount
         * @param {string} type
         * @param {ModifyIsolatedPositionMarginPositionSideEnum} [positionSide] Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent with Hedge Mode.
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        modifyIsolatedPositionMargin: async (
            symbol: string,
            amount: number,
            type: string,
            positionSide?: ModifyIsolatedPositionMarginPositionSideEnum,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('modifyIsolatedPositionMargin', 'symbol', symbol);
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('modifyIsolatedPositionMargin', 'amount', amount);
            // verify required parameter 'type' is not null or undefined
            assertParamExists('modifyIsolatedPositionMargin', 'type', type);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (positionSide !== undefined && positionSide !== null) {
                localVarQueryParameter['positionSide'] = positionSide;
            }

            if (amount !== undefined && amount !== null) {
                localVarQueryParameter['amount'] = amount;
            }

            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/positionMargin',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Modify Multiple Orders (TRADE)
         *
         * Parameter rules are same with `Modify Order`
         * Batch modify orders are processed concurrently, and the order of matching is not guaranteed.
         * The order of returned contents for batch modify orders is the same as the order of the order list.
         * One order can only be modfied for less than 10000 times
         *
         * Weight: 5 on 10s order rate limit(X-MBX-ORDER-COUNT-10S);
         * 1 on 1min order rate limit(X-MBX-ORDER-COUNT-1M);
         * 5 on IP rate limit(x-mbx-used-weight-1m);
         *
         * @summary Modify Multiple Orders(TRADE)
         * @param {Array<ModifyMultipleOrdersBatchOrdersParameterInner>} batchOrders order list. Max 5 orders
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        modifyMultipleOrders: async (
            batchOrders: Array<ModifyMultipleOrdersBatchOrdersParameterInner>,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'batchOrders' is not null or undefined
            assertParamExists('modifyMultipleOrders', 'batchOrders', batchOrders);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (batchOrders) {
                localVarQueryParameter['batchOrders'] = batchOrders;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/batchOrders',
                method: 'PUT',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         *
         *
         * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
         * Both `quantity` and `price` must be sent, which is different from dapi modify order endpoint.
         * When the new `quantity` or `price` doesn't satisfy PRICE_FILTER / PERCENT_FILTER / LOT_SIZE, amendment will be rejected and the order will stay as it is.
         * However the order will be cancelled by the amendment in the following situations:
         * when the order is in partially filled status and the new `quantity` <= `executedQty`
         * When the order is `GTX` and the new price will cause it to be executed immediately
         * One order can only be modfied for less than 10000 times
         * Modify order will set `selfTradePreventionMode` to `NONE`
         *
         * Weight: 1 on 10s order rate limit(X-MBX-ORDER-COUNT-10S);
         * 1 on 1min order rate limit(X-MBX-ORDER-COUNT-1M);
         * 1 on IP rate limit(x-mbx-used-weight-1m)
         *
         * @summary Modify Order (TRADE)
         * @param {string} symbol
         * @param {ModifyOrderSideEnum} side `SELL`, `BUY`
         * @param {number} quantity Order quantity, cannot be sent with `closePosition=true`
         * @param {number} price
         * @param {number} [orderId]
         * @param {string} [origClientOrderId]
         * @param {ModifyOrderPriceMatchEnum} [priceMatch] only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        modifyOrder: async (
            symbol: string,
            side: ModifyOrderSideEnum,
            quantity: number,
            price: number,
            orderId?: number,
            origClientOrderId?: string,
            priceMatch?: ModifyOrderPriceMatchEnum,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('modifyOrder', 'symbol', symbol);
            // verify required parameter 'side' is not null or undefined
            assertParamExists('modifyOrder', 'side', side);
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('modifyOrder', 'quantity', quantity);
            // verify required parameter 'price' is not null or undefined
            assertParamExists('modifyOrder', 'price', price);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }

            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }

            if (priceMatch !== undefined && priceMatch !== null) {
                localVarQueryParameter['priceMatch'] = priceMatch;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/order',
                method: 'PUT',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Send in a new order.
         *
         * Order with type `STOP`,  parameter `timeInForce` can be sent ( default `GTC`).
         * Order with type `TAKE_PROFIT`,  parameter `timeInForce` can be sent ( default `GTC`).
         * Condition orders will be triggered when:
         *
         * If parameter`priceProtect`is sent as true:
         * when price reaches the `stopPrice` ，the difference rate between "MARK_PRICE" and "CONTRACT_PRICE" cannot be larger than the "triggerProtect" of the symbol
         * "triggerProtect" of a symbol can be got from `GET /fapi/v1/exchangeInfo`
         *
         * `STOP`, `STOP_MARKET`:
         * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
         * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
         * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
         * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
         * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
         * `TRAILING_STOP_MARKET`:
         * BUY: the lowest price after order placed `<= `activationPrice`, and the latest price >`= the lowest price * (1 + `callbackRate`)
         * SELL: the highest price after order placed >= `activationPrice`, and the latest price <= the highest price * (1 - `callbackRate`)
         *
         * For `TRAILING_STOP_MARKET`, if you got such error code.
         * ``{"code": -2021, "msg": "Order would immediately trigger."}``
         * means that the parameters you send do not meet the following requirements:
         * BUY: `activationPrice` should be smaller than latest price.
         * SELL: `activationPrice` should be larger than latest price.
         *
         * If `newOrderRespType ` is sent as `RESULT` :
         * `MARKET` order: the final FILLED result of the order will be return directly.
         * `LIMIT` order with special `timeInForce`: the final status result of the order(FILLED or EXPIRED) will be returned directly.
         *
         * `STOP_MARKET`, `TAKE_PROFIT_MARKET` with `closePosition`=`true`:
         * Follow the same rules for condition orders.
         * If triggered，**close all** current long position( if `SELL`) or current short position( if `BUY`).
         * Cannot be used with `quantity` paremeter
         * Cannot be used with `reduceOnly` parameter
         * In Hedge Mode,cannot be used with `BUY` orders in `LONG` position side. and cannot be used with `SELL` orders in `SHORT` position side
         * `selfTradePreventionMode` is only effective when `timeInForce` set to `IOC` or `GTC` or `GTD`.
         * In extreme market conditions, timeInForce `GTD` order auto cancel time might be delayed comparing to `goodTillDate`
         *
         * Weight: 1 on 10s order rate limit(X-MBX-ORDER-COUNT-10S);
         * 1 on 1min order rate limit(X-MBX-ORDER-COUNT-1M);
         * 0 on IP rate limit(x-mbx-used-weight-1m)
         *
         * @summary New Order(TRADE)
         * @param {string} symbol
         * @param {NewOrderSideEnum} side `SELL`, `BUY`
         * @param {string} type
         * @param {NewOrderPositionSideEnum} [positionSide] Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent with Hedge Mode.
         * @param {NewOrderTimeInForceEnum} [timeInForce]
         * @param {number} [quantity] Cannot be sent with `closePosition`=`true`(Close-All)
         * @param {string} [reduceOnly] "true" or "false". default "false". Cannot be sent in Hedge Mode; cannot be sent with `closePosition`=`true`
         * @param {number} [price]
         * @param {string} [newClientOrderId] A unique id among open orders. Automatically generated if not sent. Can only be string following the rule: `^[\.A-Z\:/a-z0-9_-]{1,36}$`
         * @param {number} [stopPrice] Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
         * @param {string} [closePosition] `true`, `false`；Close-All，used with `STOP_MARKET` or `TAKE_PROFIT_MARKET`.
         * @param {number} [activationPrice] Used with `TRAILING_STOP_MARKET` orders, default as the latest price(supporting different `workingType`)
         * @param {number} [callbackRate] Used with `TRAILING_STOP_MARKET` orders, min 0.1, max 5 where 1 for 1%
         * @param {NewOrderWorkingTypeEnum} [workingType] stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
         * @param {string} [priceProtect] "TRUE" or "FALSE", default "FALSE". Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
         * @param {NewOrderNewOrderRespTypeEnum} [newOrderRespType] "ACK", "RESULT", default "ACK"
         * @param {NewOrderPriceMatchEnum} [priceMatch] only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
         * @param {NewOrderSelfTradePreventionModeEnum} [selfTradePreventionMode] `NONE`:No STP / `EXPIRE_TAKER`:expire taker order when STP triggers/ `EXPIRE_MAKER`:expire taker order when STP triggers/ `EXPIRE_BOTH`:expire both orders when STP triggers; default `NONE`
         * @param {number} [goodTillDate] order cancel time for timeInForce `GTD`, mandatory when `timeInforce` set to `GTD`; order the timestamp only retains second-level precision, ms part will be ignored; The goodTillDate timestamp must be greater than the current time plus 600 seconds and smaller than 253402300799000
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        newOrder: async (
            symbol: string,
            side: NewOrderSideEnum,
            type: string,
            positionSide?: NewOrderPositionSideEnum,
            timeInForce?: NewOrderTimeInForceEnum,
            quantity?: number,
            reduceOnly?: string,
            price?: number,
            newClientOrderId?: string,
            stopPrice?: number,
            closePosition?: string,
            activationPrice?: number,
            callbackRate?: number,
            workingType?: NewOrderWorkingTypeEnum,
            priceProtect?: string,
            newOrderRespType?: NewOrderNewOrderRespTypeEnum,
            priceMatch?: NewOrderPriceMatchEnum,
            selfTradePreventionMode?: NewOrderSelfTradePreventionModeEnum,
            goodTillDate?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('newOrder', 'symbol', symbol);
            // verify required parameter 'side' is not null or undefined
            assertParamExists('newOrder', 'side', side);
            // verify required parameter 'type' is not null or undefined
            assertParamExists('newOrder', 'type', type);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }

            if (positionSide !== undefined && positionSide !== null) {
                localVarQueryParameter['positionSide'] = positionSide;
            }

            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }

            if (timeInForce !== undefined && timeInForce !== null) {
                localVarQueryParameter['timeInForce'] = timeInForce;
            }

            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (reduceOnly !== undefined && reduceOnly !== null) {
                localVarQueryParameter['reduceOnly'] = reduceOnly;
            }

            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }

            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (stopPrice !== undefined && stopPrice !== null) {
                localVarQueryParameter['stopPrice'] = stopPrice;
            }

            if (closePosition !== undefined && closePosition !== null) {
                localVarQueryParameter['closePosition'] = closePosition;
            }

            if (activationPrice !== undefined && activationPrice !== null) {
                localVarQueryParameter['activationPrice'] = activationPrice;
            }

            if (callbackRate !== undefined && callbackRate !== null) {
                localVarQueryParameter['callbackRate'] = callbackRate;
            }

            if (workingType !== undefined && workingType !== null) {
                localVarQueryParameter['workingType'] = workingType;
            }

            if (priceProtect !== undefined && priceProtect !== null) {
                localVarQueryParameter['priceProtect'] = priceProtect;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (priceMatch !== undefined && priceMatch !== null) {
                localVarQueryParameter['priceMatch'] = priceMatch;
            }

            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }

            if (goodTillDate !== undefined && goodTillDate !== null) {
                localVarQueryParameter['goodTillDate'] = goodTillDate;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/order',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Place Multiple Orders
         *
         * Paremeter rules are same with `New Order`
         * Batch orders are processed concurrently, and the order of matching is not guaranteed.
         * The order of returned contents for batch orders is the same as the order of the order list.
         *
         * Weight: 5 on 10s order rate limit(X-MBX-ORDER-COUNT-10S);
         * 1 on 1min order rate limit(X-MBX-ORDER-COUNT-1M);
         * 5 on IP rate limit(x-mbx-used-weight-1m);
         *
         * @summary Place Multiple Orders(TRADE)
         * @param {Array<ModifyMultipleOrdersBatchOrdersParameterInner>} batchOrders order list. Max 5 orders
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        placeMultipleOrders: async (
            batchOrders: Array<ModifyMultipleOrdersBatchOrdersParameterInner>,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'batchOrders' is not null or undefined
            assertParamExists('placeMultipleOrders', 'batchOrders', batchOrders);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (batchOrders) {
                localVarQueryParameter['batchOrders'] = batchOrders;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/batchOrders',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Position ADL Quantile Estimation
         *
         * Values update every 30s.
         * Values 0, 1, 2, 3, 4 shows the queue position and possibility of ADL from low to high.
         * For positions of the symbol are in One-way Mode or isolated margined in Hedge Mode, "LONG", "SHORT", and "BOTH" will be returned to show the positions' adl quantiles of different position sides.
         * If the positions of the symbol are crossed margined in Hedge Mode:
         * "HEDGE" as a sign will be returned instead of "BOTH";
         * A same value caculated on unrealized pnls on long and short sides' positions will be shown for "LONG" and "SHORT" when there are positions in both of long and short sides.
         *
         * Weight: 5
         *
         * @summary Position ADL Quantile Estimation(USER_DATA)
         * @param {string} [symbol]
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        positionAdlQuantileEstimation: async (
            symbol?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/adlQuantile',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get current position information.
         *
         * Please use with user data stream `ACCOUNT_UPDATE` to meet your timeliness and accuracy needs.
         *
         * Weight: 5
         *
         * @summary Position Information V2 (USER_DATA)
         * @param {string} [symbol]
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        positionInformationV2: async (
            symbol?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v2/positionRisk',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get current position information(only symbol that has position or open orders will be returned).
         *
         * Please use with user data stream `ACCOUNT_UPDATE` to meet your timeliness and accuracy needs.
         *
         * Weight: 5
         *
         * @summary Position Information V3 (USER_DATA)
         * @param {string} [symbol]
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        positionInformationV3: async (
            symbol?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v3/positionRisk',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query open order
         *
         *
         * Either`orderId` or `origClientOrderId` must be sent
         * If the queried order has been filled or cancelled, the error message "Order does not exist" will be returned.
         *
         * Weight: 1
         *
         * @summary Query Current Open Order (USER_DATA)
         * @param {string} symbol
         * @param {number} [orderId]
         * @param {string} [origClientOrderId]
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryCurrentOpenOrder: async (
            symbol: string,
            orderId?: number,
            origClientOrderId?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryCurrentOpenOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/openOrder',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Check an order's status.
         *
         * These orders will not be found:
         * order status is `CANCELED` or `EXPIRED` **AND** order has NO filled trade **AND** created time + 3 days < current time
         * order create time + 90 days < current time
         *
         * Either `orderId` or `origClientOrderId` must be sent.
         * `orderId` is self-increment for each specific `symbol`
         *
         * Weight: 1
         *
         * @summary Query Order (USER_DATA)
         * @param {string} symbol
         * @param {number} [orderId]
         * @param {string} [origClientOrderId]
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryOrder: async (
            symbol: string,
            orderId?: number,
            origClientOrderId?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/order',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Testing order request, this order will not be submitted to matching engine
         *
         * Order with type `STOP`,  parameter `timeInForce` can be sent ( default `GTC`).
         * Order with type `TAKE_PROFIT`,  parameter `timeInForce` can be sent ( default `GTC`).
         * Condition orders will be triggered when:
         *
         * If parameter`priceProtect`is sent as true:
         * when price reaches the `stopPrice` ，the difference rate between "MARK_PRICE" and "CONTRACT_PRICE" cannot be larger than the "triggerProtect" of the symbol
         * "triggerProtect" of a symbol can be got from `GET /fapi/v1/exchangeInfo`
         *
         * `STOP`, `STOP_MARKET`:
         * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
         * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
         * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
         * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
         * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
         * `TRAILING_STOP_MARKET`:
         * BUY: the lowest price after order placed `<= `activationPrice`, and the latest price >`= the lowest price * (1 + `callbackRate`)
         * SELL: the highest price after order placed >= `activationPrice`, and the latest price <= the highest price * (1 - `callbackRate`)
         *
         * For `TRAILING_STOP_MARKET`, if you got such error code.
         * ``{"code": -2021, "msg": "Order would immediately trigger."}``
         * means that the parameters you send do not meet the following requirements:
         * BUY: `activationPrice` should be smaller than latest price.
         * SELL: `activationPrice` should be larger than latest price.
         *
         * If `newOrderRespType ` is sent as `RESULT` :
         * `MARKET` order: the final FILLED result of the order will be return directly.
         * `LIMIT` order with special `timeInForce`: the final status result of the order(FILLED or EXPIRED) will be returned directly.
         *
         * `STOP_MARKET`, `TAKE_PROFIT_MARKET` with `closePosition`=`true`:
         * Follow the same rules for condition orders.
         * If triggered，**close all** current long position( if `SELL`) or current short position( if `BUY`).
         * Cannot be used with `quantity` paremeter
         * Cannot be used with `reduceOnly` parameter
         * In Hedge Mode,cannot be used with `BUY` orders in `LONG` position side. and cannot be used with `SELL` orders in `SHORT` position side
         * `selfTradePreventionMode` is only effective when `timeInForce` set to `IOC` or `GTC` or `GTD`.
         * In extreme market conditions, timeInForce `GTD` order auto cancel time might be delayed comparing to `goodTillDate`
         *
         * Weight: 0
         *
         * @summary Test Order(TRADE)
         * @param {string} symbol
         * @param {TestOrderSideEnum} side `SELL`, `BUY`
         * @param {string} type
         * @param {TestOrderPositionSideEnum} [positionSide] Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent with Hedge Mode.
         * @param {TestOrderTimeInForceEnum} [timeInForce]
         * @param {number} [quantity] Cannot be sent with `closePosition`=`true`(Close-All)
         * @param {string} [reduceOnly] "true" or "false". default "false". Cannot be sent in Hedge Mode; cannot be sent with `closePosition`=`true`
         * @param {number} [price]
         * @param {string} [newClientOrderId] A unique id among open orders. Automatically generated if not sent. Can only be string following the rule: `^[\.A-Z\:/a-z0-9_-]{1,36}$`
         * @param {number} [stopPrice] Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
         * @param {string} [closePosition] `true`, `false`；Close-All，used with `STOP_MARKET` or `TAKE_PROFIT_MARKET`.
         * @param {number} [activationPrice] Used with `TRAILING_STOP_MARKET` orders, default as the latest price(supporting different `workingType`)
         * @param {number} [callbackRate] Used with `TRAILING_STOP_MARKET` orders, min 0.1, max 5 where 1 for 1%
         * @param {TestOrderWorkingTypeEnum} [workingType] stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
         * @param {string} [priceProtect] "TRUE" or "FALSE", default "FALSE". Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
         * @param {TestOrderNewOrderRespTypeEnum} [newOrderRespType] "ACK", "RESULT", default "ACK"
         * @param {TestOrderPriceMatchEnum} [priceMatch] only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
         * @param {TestOrderSelfTradePreventionModeEnum} [selfTradePreventionMode] `NONE`:No STP / `EXPIRE_TAKER`:expire taker order when STP triggers/ `EXPIRE_MAKER`:expire taker order when STP triggers/ `EXPIRE_BOTH`:expire both orders when STP triggers; default `NONE`
         * @param {number} [goodTillDate] order cancel time for timeInForce `GTD`, mandatory when `timeInforce` set to `GTD`; order the timestamp only retains second-level precision, ms part will be ignored; The goodTillDate timestamp must be greater than the current time plus 600 seconds and smaller than 253402300799000
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        testOrder: async (
            symbol: string,
            side: TestOrderSideEnum,
            type: string,
            positionSide?: TestOrderPositionSideEnum,
            timeInForce?: TestOrderTimeInForceEnum,
            quantity?: number,
            reduceOnly?: string,
            price?: number,
            newClientOrderId?: string,
            stopPrice?: number,
            closePosition?: string,
            activationPrice?: number,
            callbackRate?: number,
            workingType?: TestOrderWorkingTypeEnum,
            priceProtect?: string,
            newOrderRespType?: TestOrderNewOrderRespTypeEnum,
            priceMatch?: TestOrderPriceMatchEnum,
            selfTradePreventionMode?: TestOrderSelfTradePreventionModeEnum,
            goodTillDate?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('testOrder', 'symbol', symbol);
            // verify required parameter 'side' is not null or undefined
            assertParamExists('testOrder', 'side', side);
            // verify required parameter 'type' is not null or undefined
            assertParamExists('testOrder', 'type', type);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }

            if (positionSide !== undefined && positionSide !== null) {
                localVarQueryParameter['positionSide'] = positionSide;
            }

            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }

            if (timeInForce !== undefined && timeInForce !== null) {
                localVarQueryParameter['timeInForce'] = timeInForce;
            }

            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (reduceOnly !== undefined && reduceOnly !== null) {
                localVarQueryParameter['reduceOnly'] = reduceOnly;
            }

            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }

            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (stopPrice !== undefined && stopPrice !== null) {
                localVarQueryParameter['stopPrice'] = stopPrice;
            }

            if (closePosition !== undefined && closePosition !== null) {
                localVarQueryParameter['closePosition'] = closePosition;
            }

            if (activationPrice !== undefined && activationPrice !== null) {
                localVarQueryParameter['activationPrice'] = activationPrice;
            }

            if (callbackRate !== undefined && callbackRate !== null) {
                localVarQueryParameter['callbackRate'] = callbackRate;
            }

            if (workingType !== undefined && workingType !== null) {
                localVarQueryParameter['workingType'] = workingType;
            }

            if (priceProtect !== undefined && priceProtect !== null) {
                localVarQueryParameter['priceProtect'] = priceProtect;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (priceMatch !== undefined && priceMatch !== null) {
                localVarQueryParameter['priceMatch'] = priceMatch;
            }

            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }

            if (goodTillDate !== undefined && goodTillDate !== null) {
                localVarQueryParameter['goodTillDate'] = goodTillDate;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/order/test',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query user's Force Orders
         *
         * If "autoCloseType" is not sent, orders with both of the types will be returned
         * If "startTime" is not sent, data within 7 days before "endTime" can be queried
         *
         * Weight: 20 with symbol, 50 without symbol
         *
         * @summary User\'s Force Orders (USER_DATA)
         * @param {string} [symbol]
         * @param {UsersForceOrdersAutoCloseTypeEnum} [autoCloseType] "LIQUIDATION" for liquidation orders, "ADL" for ADL orders.
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        usersForceOrders: async (
            symbol?: string,
            autoCloseType?: UsersForceOrdersAutoCloseTypeEnum,
            startTime?: number,
            endTime?: number,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (autoCloseType !== undefined && autoCloseType !== null) {
                localVarQueryParameter['autoCloseType'] = autoCloseType;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/forceOrders',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
    };
};

/**
 * TradeApi - interface
 * @interface TradeApi
 */
export interface TradeApiInterface {
    /**
     * Get trades for a specific account and symbol.
     *
     * If `startTime` and `endTime` are both not sent, then the last 7 days' data will be returned.
     * The time between `startTime` and `endTime` cannot be longer than 7 days.
     * The parameter `fromId` cannot be sent with `startTime` or `endTime`.
     * Only support querying trade in the past 6 months
     *
     * Weight: 5
     *
     * @summary Account Trade List (USER_DATA)
     * @param {AccountTradeListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    accountTradeList(
        requestParameters: AccountTradeListRequest
    ): Promise<RestApiResponse<AccountTradeListResponse>>;
    /**
     * Get all account orders; active, canceled, or filled.
     *
     * These orders will not be found:
     * order status is `CANCELED` or `EXPIRED` **AND** order has NO filled trade **AND** created time + 3 days < current time
     * order create time + 90 days < current time
     *
     * If `orderId` is set, it will get orders >= that `orderId`. Otherwise most recent orders are returned.
     * The query time period must be less then 7 days( default as the recent 7 days).
     *
     * Weight: 5
     *
     * @summary All Orders (USER_DATA)
     * @param {AllOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    allOrders(requestParameters: AllOrdersRequest): Promise<RestApiResponse<AllOrdersResponse>>;
    /**
     * Cancel all open orders of the specified symbol at the end of the specified countdown.
     * The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and replaced by a new one.
     *
     * Example usage:
     * Call this endpoint at 30s intervals with an countdownTime of 120000 (120s).
     * If this endpoint is not called within 120 seconds, all your orders of the specified symbol will be automatically canceled.
     * If this endpoint is called with an countdownTime of 0, the countdown timer will be stopped.
     *
     * The system will check all countdowns **approximately every 10 milliseconds**, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.
     *
     * Weight: 10
     *
     * @summary Auto-Cancel All Open Orders (TRADE)
     * @param {AutoCancelAllOpenOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    autoCancelAllOpenOrders(
        requestParameters: AutoCancelAllOpenOrdersRequest
    ): Promise<RestApiResponse<AutoCancelAllOpenOrdersResponse>>;
    /**
     * Cancel All Open Orders
     *
     * Weight: 1
     *
     * @summary Cancel All Open Orders (TRADE)
     * @param {CancelAllOpenOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cancelAllOpenOrders(
        requestParameters: CancelAllOpenOrdersRequest
    ): Promise<RestApiResponse<CancelAllOpenOrdersResponse>>;
    /**
     * Cancel Multiple Orders
     *
     * Either `orderIdList` or `origClientOrderIdList ` must be sent.
     *
     * Weight: 1
     *
     * @summary Cancel Multiple Orders (TRADE)
     * @param {CancelMultipleOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cancelMultipleOrders(
        requestParameters: CancelMultipleOrdersRequest
    ): Promise<RestApiResponse<CancelMultipleOrdersResponse>>;
    /**
     * Cancel an active order.
     *
     * Either `orderId` or `origClientOrderId` must be sent.
     *
     * Weight: 1
     *
     * @summary Cancel Order (TRADE)
     * @param {CancelOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cancelOrder(
        requestParameters: CancelOrderRequest
    ): Promise<RestApiResponse<CancelOrderResponse>>;
    /**
     * Change user's initial leverage of specific symbol market.
     *
     * Weight: 1
     *
     * @summary Change Initial Leverage(TRADE)
     * @param {ChangeInitialLeverageRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    changeInitialLeverage(
        requestParameters: ChangeInitialLeverageRequest
    ): Promise<RestApiResponse<ChangeInitialLeverageResponse>>;
    /**
     * Change symbol level margin type
     *
     * Weight: 1
     *
     * @summary Change Margin Type(TRADE)
     * @param {ChangeMarginTypeRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    changeMarginType(
        requestParameters: ChangeMarginTypeRequest
    ): Promise<RestApiResponse<ChangeMarginTypeResponse>>;
    /**
     * Change user's Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on ***Every symbol***
     *
     * Weight: 1
     *
     * @summary Change Multi-Assets Mode (TRADE)
     * @param {ChangeMultiAssetsModeRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    changeMultiAssetsMode(
        requestParameters: ChangeMultiAssetsModeRequest
    ): Promise<RestApiResponse<ChangeMultiAssetsModeResponse>>;
    /**
     * Change user's position mode (Hedge Mode or One-way Mode ) on ***EVERY symbol***
     *
     * Weight: 1
     *
     * @summary Change Position Mode(TRADE)
     * @param {ChangePositionModeRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    changePositionMode(
        requestParameters: ChangePositionModeRequest
    ): Promise<RestApiResponse<ChangePositionModeResponse>>;
    /**
     * Get all open orders on a symbol.
     *
     * If the symbol is not sent, orders for all symbols will be returned in an array.
     *
     * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
     * Careful when accessing this with no symbol.
     *
     * @summary Current All Open Orders (USER_DATA)
     * @param {CurrentAllOpenOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    currentAllOpenOrders(
        requestParameters?: CurrentAllOpenOrdersRequest
    ): Promise<RestApiResponse<CurrentAllOpenOrdersResponse>>;
    /**
     * Get order modification history
     *
     * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
     * Order modify history longer than 3 month is not avaliable
     *
     * Weight: 1
     *
     * @summary Get Order Modify History (USER_DATA)
     * @param {GetOrderModifyHistoryRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    getOrderModifyHistory(
        requestParameters: GetOrderModifyHistoryRequest
    ): Promise<RestApiResponse<GetOrderModifyHistoryResponse>>;
    /**
     * Get Position Margin Change History
     *
     * Support querying future histories that are not older than 30 days
     * The time between `startTime` and `endTime`can't be more than 30 days
     *
     * Weight: 1
     *
     * @summary Get Position Margin Change History (TRADE)
     * @param {GetPositionMarginChangeHistoryRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    getPositionMarginChangeHistory(
        requestParameters: GetPositionMarginChangeHistoryRequest
    ): Promise<RestApiResponse<GetPositionMarginChangeHistoryResponse>>;
    /**
     * Modify Isolated Position Margin
     *
     *
     * Only for isolated symbol
     *
     * Weight: 1
     *
     * @summary Modify Isolated Position Margin(TRADE)
     * @param {ModifyIsolatedPositionMarginRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    modifyIsolatedPositionMargin(
        requestParameters: ModifyIsolatedPositionMarginRequest
    ): Promise<RestApiResponse<ModifyIsolatedPositionMarginResponse>>;
    /**
     * Modify Multiple Orders (TRADE)
     *
     * Parameter rules are same with `Modify Order`
     * Batch modify orders are processed concurrently, and the order of matching is not guaranteed.
     * The order of returned contents for batch modify orders is the same as the order of the order list.
     * One order can only be modfied for less than 10000 times
     *
     * Weight: 5 on 10s order rate limit(X-MBX-ORDER-COUNT-10S);
     * 1 on 1min order rate limit(X-MBX-ORDER-COUNT-1M);
     * 5 on IP rate limit(x-mbx-used-weight-1m);
     *
     * @summary Modify Multiple Orders(TRADE)
     * @param {ModifyMultipleOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    modifyMultipleOrders(
        requestParameters: ModifyMultipleOrdersRequest
    ): Promise<RestApiResponse<ModifyMultipleOrdersResponse>>;
    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     *
     *
     * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
     * Both `quantity` and `price` must be sent, which is different from dapi modify order endpoint.
     * When the new `quantity` or `price` doesn't satisfy PRICE_FILTER / PERCENT_FILTER / LOT_SIZE, amendment will be rejected and the order will stay as it is.
     * However the order will be cancelled by the amendment in the following situations:
     * when the order is in partially filled status and the new `quantity` <= `executedQty`
     * When the order is `GTX` and the new price will cause it to be executed immediately
     * One order can only be modfied for less than 10000 times
     * Modify order will set `selfTradePreventionMode` to `NONE`
     *
     * Weight: 1 on 10s order rate limit(X-MBX-ORDER-COUNT-10S);
     * 1 on 1min order rate limit(X-MBX-ORDER-COUNT-1M);
     * 1 on IP rate limit(x-mbx-used-weight-1m)
     *
     * @summary Modify Order (TRADE)
     * @param {ModifyOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    modifyOrder(
        requestParameters: ModifyOrderRequest
    ): Promise<RestApiResponse<ModifyOrderResponse>>;
    /**
     * Send in a new order.
     *
     * Order with type `STOP`,  parameter `timeInForce` can be sent ( default `GTC`).
     * Order with type `TAKE_PROFIT`,  parameter `timeInForce` can be sent ( default `GTC`).
     * Condition orders will be triggered when:
     *
     * If parameter`priceProtect`is sent as true:
     * when price reaches the `stopPrice` ，the difference rate between "MARK_PRICE" and "CONTRACT_PRICE" cannot be larger than the "triggerProtect" of the symbol
     * "triggerProtect" of a symbol can be got from `GET /fapi/v1/exchangeInfo`
     *
     * `STOP`, `STOP_MARKET`:
     * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
     * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
     * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
     * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
     * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
     * `TRAILING_STOP_MARKET`:
     * BUY: the lowest price after order placed `<= `activationPrice`, and the latest price >`= the lowest price * (1 + `callbackRate`)
     * SELL: the highest price after order placed >= `activationPrice`, and the latest price <= the highest price * (1 - `callbackRate`)
     *
     * For `TRAILING_STOP_MARKET`, if you got such error code.
     * ``{"code": -2021, "msg": "Order would immediately trigger."}``
     * means that the parameters you send do not meet the following requirements:
     * BUY: `activationPrice` should be smaller than latest price.
     * SELL: `activationPrice` should be larger than latest price.
     *
     * If `newOrderRespType ` is sent as `RESULT` :
     * `MARKET` order: the final FILLED result of the order will be return directly.
     * `LIMIT` order with special `timeInForce`: the final status result of the order(FILLED or EXPIRED) will be returned directly.
     *
     * `STOP_MARKET`, `TAKE_PROFIT_MARKET` with `closePosition`=`true`:
     * Follow the same rules for condition orders.
     * If triggered，**close all** current long position( if `SELL`) or current short position( if `BUY`).
     * Cannot be used with `quantity` paremeter
     * Cannot be used with `reduceOnly` parameter
     * In Hedge Mode,cannot be used with `BUY` orders in `LONG` position side. and cannot be used with `SELL` orders in `SHORT` position side
     * `selfTradePreventionMode` is only effective when `timeInForce` set to `IOC` or `GTC` or `GTD`.
     * In extreme market conditions, timeInForce `GTD` order auto cancel time might be delayed comparing to `goodTillDate`
     *
     * Weight: 1 on 10s order rate limit(X-MBX-ORDER-COUNT-10S);
     * 1 on 1min order rate limit(X-MBX-ORDER-COUNT-1M);
     * 0 on IP rate limit(x-mbx-used-weight-1m)
     *
     * @summary New Order(TRADE)
     * @param {NewOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    newOrder(requestParameters: NewOrderRequest): Promise<RestApiResponse<NewOrderResponse>>;
    /**
     * Place Multiple Orders
     *
     * Paremeter rules are same with `New Order`
     * Batch orders are processed concurrently, and the order of matching is not guaranteed.
     * The order of returned contents for batch orders is the same as the order of the order list.
     *
     * Weight: 5 on 10s order rate limit(X-MBX-ORDER-COUNT-10S);
     * 1 on 1min order rate limit(X-MBX-ORDER-COUNT-1M);
     * 5 on IP rate limit(x-mbx-used-weight-1m);
     *
     * @summary Place Multiple Orders(TRADE)
     * @param {PlaceMultipleOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    placeMultipleOrders(
        requestParameters: PlaceMultipleOrdersRequest
    ): Promise<RestApiResponse<PlaceMultipleOrdersResponse>>;
    /**
     * Position ADL Quantile Estimation
     *
     * Values update every 30s.
     * Values 0, 1, 2, 3, 4 shows the queue position and possibility of ADL from low to high.
     * For positions of the symbol are in One-way Mode or isolated margined in Hedge Mode, "LONG", "SHORT", and "BOTH" will be returned to show the positions' adl quantiles of different position sides.
     * If the positions of the symbol are crossed margined in Hedge Mode:
     * "HEDGE" as a sign will be returned instead of "BOTH";
     * A same value caculated on unrealized pnls on long and short sides' positions will be shown for "LONG" and "SHORT" when there are positions in both of long and short sides.
     *
     * Weight: 5
     *
     * @summary Position ADL Quantile Estimation(USER_DATA)
     * @param {PositionAdlQuantileEstimationRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    positionAdlQuantileEstimation(
        requestParameters?: PositionAdlQuantileEstimationRequest
    ): Promise<RestApiResponse<PositionAdlQuantileEstimationResponse>>;
    /**
     * Get current position information.
     *
     * Please use with user data stream `ACCOUNT_UPDATE` to meet your timeliness and accuracy needs.
     *
     * Weight: 5
     *
     * @summary Position Information V2 (USER_DATA)
     * @param {PositionInformationV2Request} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    positionInformationV2(
        requestParameters?: PositionInformationV2Request
    ): Promise<RestApiResponse<PositionInformationV2Response>>;
    /**
     * Get current position information(only symbol that has position or open orders will be returned).
     *
     * Please use with user data stream `ACCOUNT_UPDATE` to meet your timeliness and accuracy needs.
     *
     * Weight: 5
     *
     * @summary Position Information V3 (USER_DATA)
     * @param {PositionInformationV3Request} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    positionInformationV3(
        requestParameters?: PositionInformationV3Request
    ): Promise<RestApiResponse<PositionInformationV3Response>>;
    /**
     * Query open order
     *
     *
     * Either`orderId` or `origClientOrderId` must be sent
     * If the queried order has been filled or cancelled, the error message "Order does not exist" will be returned.
     *
     * Weight: 1
     *
     * @summary Query Current Open Order (USER_DATA)
     * @param {QueryCurrentOpenOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryCurrentOpenOrder(
        requestParameters: QueryCurrentOpenOrderRequest
    ): Promise<RestApiResponse<QueryCurrentOpenOrderResponse>>;
    /**
     * Check an order's status.
     *
     * These orders will not be found:
     * order status is `CANCELED` or `EXPIRED` **AND** order has NO filled trade **AND** created time + 3 days < current time
     * order create time + 90 days < current time
     *
     * Either `orderId` or `origClientOrderId` must be sent.
     * `orderId` is self-increment for each specific `symbol`
     *
     * Weight: 1
     *
     * @summary Query Order (USER_DATA)
     * @param {QueryOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryOrder(requestParameters: QueryOrderRequest): Promise<RestApiResponse<QueryOrderResponse>>;
    /**
     * Testing order request, this order will not be submitted to matching engine
     *
     * Order with type `STOP`,  parameter `timeInForce` can be sent ( default `GTC`).
     * Order with type `TAKE_PROFIT`,  parameter `timeInForce` can be sent ( default `GTC`).
     * Condition orders will be triggered when:
     *
     * If parameter`priceProtect`is sent as true:
     * when price reaches the `stopPrice` ，the difference rate between "MARK_PRICE" and "CONTRACT_PRICE" cannot be larger than the "triggerProtect" of the symbol
     * "triggerProtect" of a symbol can be got from `GET /fapi/v1/exchangeInfo`
     *
     * `STOP`, `STOP_MARKET`:
     * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
     * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
     * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
     * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
     * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
     * `TRAILING_STOP_MARKET`:
     * BUY: the lowest price after order placed `<= `activationPrice`, and the latest price >`= the lowest price * (1 + `callbackRate`)
     * SELL: the highest price after order placed >= `activationPrice`, and the latest price <= the highest price * (1 - `callbackRate`)
     *
     * For `TRAILING_STOP_MARKET`, if you got such error code.
     * ``{"code": -2021, "msg": "Order would immediately trigger."}``
     * means that the parameters you send do not meet the following requirements:
     * BUY: `activationPrice` should be smaller than latest price.
     * SELL: `activationPrice` should be larger than latest price.
     *
     * If `newOrderRespType ` is sent as `RESULT` :
     * `MARKET` order: the final FILLED result of the order will be return directly.
     * `LIMIT` order with special `timeInForce`: the final status result of the order(FILLED or EXPIRED) will be returned directly.
     *
     * `STOP_MARKET`, `TAKE_PROFIT_MARKET` with `closePosition`=`true`:
     * Follow the same rules for condition orders.
     * If triggered，**close all** current long position( if `SELL`) or current short position( if `BUY`).
     * Cannot be used with `quantity` paremeter
     * Cannot be used with `reduceOnly` parameter
     * In Hedge Mode,cannot be used with `BUY` orders in `LONG` position side. and cannot be used with `SELL` orders in `SHORT` position side
     * `selfTradePreventionMode` is only effective when `timeInForce` set to `IOC` or `GTC` or `GTD`.
     * In extreme market conditions, timeInForce `GTD` order auto cancel time might be delayed comparing to `goodTillDate`
     *
     * Weight: 0
     *
     * @summary Test Order(TRADE)
     * @param {TestOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    testOrder(requestParameters: TestOrderRequest): Promise<RestApiResponse<TestOrderResponse>>;
    /**
     * Query user's Force Orders
     *
     * If "autoCloseType" is not sent, orders with both of the types will be returned
     * If "startTime" is not sent, data within 7 days before "endTime" can be queried
     *
     * Weight: 20 with symbol, 50 without symbol
     *
     * @summary User\'s Force Orders (USER_DATA)
     * @param {UsersForceOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    usersForceOrders(
        requestParameters?: UsersForceOrdersRequest
    ): Promise<RestApiResponse<UsersForceOrdersResponse>>;
}

/**
 * Request parameters for accountTradeList operation in TradeApi.
 * @interface AccountTradeListRequest
 */
export interface AccountTradeListRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiAccountTradeList
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiAccountTradeList
     */
    readonly orderId?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiAccountTradeList
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiAccountTradeList
     */
    readonly endTime?: number;

    /**
     * ID to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof TradeApiAccountTradeList
     */
    readonly fromId?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof TradeApiAccountTradeList
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiAccountTradeList
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for allOrders operation in TradeApi.
 * @interface AllOrdersRequest
 */
export interface AllOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiAllOrders
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiAllOrders
     */
    readonly orderId?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiAllOrders
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiAllOrders
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof TradeApiAllOrders
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiAllOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for autoCancelAllOpenOrders operation in TradeApi.
 * @interface AutoCancelAllOpenOrdersRequest
 */
export interface AutoCancelAllOpenOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiAutoCancelAllOpenOrders
     */
    readonly symbol: string;

    /**
     * countdown time, 1000 for 1 second. 0 to cancel the timer
     * @type {number}
     * @memberof TradeApiAutoCancelAllOpenOrders
     */
    readonly countdownTime: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiAutoCancelAllOpenOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for cancelAllOpenOrders operation in TradeApi.
 * @interface CancelAllOpenOrdersRequest
 */
export interface CancelAllOpenOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiCancelAllOpenOrders
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiCancelAllOpenOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for cancelMultipleOrders operation in TradeApi.
 * @interface CancelMultipleOrdersRequest
 */
export interface CancelMultipleOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiCancelMultipleOrders
     */
    readonly symbol: string;

    /**
     * max length 10 <br /> e.g. [1234567,2345678]
     * @type {Array<number>}
     * @memberof TradeApiCancelMultipleOrders
     */
    readonly orderIdList?: Array<number>;

    /**
     * max length 10<br /> e.g. ["my_id_1","my_id_2"], encode the double quotes. No space after comma.
     * @type {Array<string>}
     * @memberof TradeApiCancelMultipleOrders
     */
    readonly origClientOrderIdList?: Array<string>;

    /**
     *
     * @type {number}
     * @memberof TradeApiCancelMultipleOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for cancelOrder operation in TradeApi.
 * @interface CancelOrderRequest
 */
export interface CancelOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiCancelOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiCancelOrder
     */
    readonly orderId?: number;

    /**
     *
     * @type {string}
     * @memberof TradeApiCancelOrder
     */
    readonly origClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiCancelOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for changeInitialLeverage operation in TradeApi.
 * @interface ChangeInitialLeverageRequest
 */
export interface ChangeInitialLeverageRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiChangeInitialLeverage
     */
    readonly symbol: string;

    /**
     * target initial leverage: int from 1 to 125
     * @type {number}
     * @memberof TradeApiChangeInitialLeverage
     */
    readonly leverage: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiChangeInitialLeverage
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for changeMarginType operation in TradeApi.
 * @interface ChangeMarginTypeRequest
 */
export interface ChangeMarginTypeRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiChangeMarginType
     */
    readonly symbol: string;

    /**
     * ISOLATED, CROSSED
     * @type {'ISOLATED' | 'CROSSED'}
     * @memberof TradeApiChangeMarginType
     */
    readonly marginType: ChangeMarginTypeMarginTypeEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiChangeMarginType
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for changeMultiAssetsMode operation in TradeApi.
 * @interface ChangeMultiAssetsModeRequest
 */
export interface ChangeMultiAssetsModeRequest {
    /**
     * "true": Multi-Assets Mode; "false": Single-Asset Mode
     * @type {string}
     * @memberof TradeApiChangeMultiAssetsMode
     */
    readonly multiAssetsMargin: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiChangeMultiAssetsMode
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for changePositionMode operation in TradeApi.
 * @interface ChangePositionModeRequest
 */
export interface ChangePositionModeRequest {
    /**
     * "true": Hedge Mode; "false": One-way Mode
     * @type {string}
     * @memberof TradeApiChangePositionMode
     */
    readonly dualSidePosition: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiChangePositionMode
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for currentAllOpenOrders operation in TradeApi.
 * @interface CurrentAllOpenOrdersRequest
 */
export interface CurrentAllOpenOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiCurrentAllOpenOrders
     */
    readonly symbol?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiCurrentAllOpenOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for getOrderModifyHistory operation in TradeApi.
 * @interface GetOrderModifyHistoryRequest
 */
export interface GetOrderModifyHistoryRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiGetOrderModifyHistory
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiGetOrderModifyHistory
     */
    readonly orderId?: number;

    /**
     *
     * @type {string}
     * @memberof TradeApiGetOrderModifyHistory
     */
    readonly origClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiGetOrderModifyHistory
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiGetOrderModifyHistory
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof TradeApiGetOrderModifyHistory
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiGetOrderModifyHistory
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for getPositionMarginChangeHistory operation in TradeApi.
 * @interface GetPositionMarginChangeHistoryRequest
 */
export interface GetPositionMarginChangeHistoryRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiGetPositionMarginChangeHistory
     */
    readonly symbol: string;

    /**
     * 1: Add position margin，2: Reduce position margin
     * @type {number}
     * @memberof TradeApiGetPositionMarginChangeHistory
     */
    readonly type?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiGetPositionMarginChangeHistory
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiGetPositionMarginChangeHistory
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof TradeApiGetPositionMarginChangeHistory
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiGetPositionMarginChangeHistory
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for modifyIsolatedPositionMargin operation in TradeApi.
 * @interface ModifyIsolatedPositionMarginRequest
 */
export interface ModifyIsolatedPositionMarginRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiModifyIsolatedPositionMargin
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiModifyIsolatedPositionMargin
     */
    readonly amount: number;

    /**
     *
     * @type {string}
     * @memberof TradeApiModifyIsolatedPositionMargin
     */
    readonly type: string;

    /**
     * Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent with Hedge Mode.
     * @type {'BOTH' | 'LONG' | 'SHORT'}
     * @memberof TradeApiModifyIsolatedPositionMargin
     */
    readonly positionSide?: ModifyIsolatedPositionMarginPositionSideEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiModifyIsolatedPositionMargin
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for modifyMultipleOrders operation in TradeApi.
 * @interface ModifyMultipleOrdersRequest
 */
export interface ModifyMultipleOrdersRequest {
    /**
     * order list. Max 5 orders
     * @type {Array<ModifyMultipleOrdersBatchOrdersParameterInner>}
     * @memberof TradeApiModifyMultipleOrders
     */
    readonly batchOrders: Array<ModifyMultipleOrdersBatchOrdersParameterInner>;

    /**
     *
     * @type {number}
     * @memberof TradeApiModifyMultipleOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for modifyOrder operation in TradeApi.
 * @interface ModifyOrderRequest
 */
export interface ModifyOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiModifyOrder
     */
    readonly symbol: string;

    /**
     * `SELL`, `BUY`
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiModifyOrder
     */
    readonly side: ModifyOrderSideEnum;

    /**
     * Order quantity, cannot be sent with `closePosition=true`
     * @type {number}
     * @memberof TradeApiModifyOrder
     */
    readonly quantity: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiModifyOrder
     */
    readonly price: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiModifyOrder
     */
    readonly orderId?: number;

    /**
     *
     * @type {string}
     * @memberof TradeApiModifyOrder
     */
    readonly origClientOrderId?: string;

    /**
     * only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
     * @type {'NONE' | 'OPPONENT' | 'OPPONENT_5' | 'OPPONENT_10' | 'OPPONENT_20' | 'QUEUE' | 'QUEUE_5' | 'QUEUE_10' | 'QUEUE_20'}
     * @memberof TradeApiModifyOrder
     */
    readonly priceMatch?: ModifyOrderPriceMatchEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiModifyOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for newOrder operation in TradeApi.
 * @interface NewOrderRequest
 */
export interface NewOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiNewOrder
     */
    readonly symbol: string;

    /**
     * `SELL`, `BUY`
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiNewOrder
     */
    readonly side: NewOrderSideEnum;

    /**
     *
     * @type {string}
     * @memberof TradeApiNewOrder
     */
    readonly type: string;

    /**
     * Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent with Hedge Mode.
     * @type {'BOTH' | 'LONG' | 'SHORT'}
     * @memberof TradeApiNewOrder
     */
    readonly positionSide?: NewOrderPositionSideEnum;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK' | 'GTX' | 'GTD'}
     * @memberof TradeApiNewOrder
     */
    readonly timeInForce?: NewOrderTimeInForceEnum;

    /**
     * Cannot be sent with `closePosition`=`true`(Close-All)
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly quantity?: number;

    /**
     * "true" or "false". default "false". Cannot be sent in Hedge Mode; cannot be sent with `closePosition`=`true`
     * @type {string}
     * @memberof TradeApiNewOrder
     */
    readonly reduceOnly?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly price?: number;

    /**
     * A unique id among open orders. Automatically generated if not sent. Can only be string following the rule: `^[\.A-Z\:/a-z0-9_-]{1,36}$`
     * @type {string}
     * @memberof TradeApiNewOrder
     */
    readonly newClientOrderId?: string;

    /**
     * Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly stopPrice?: number;

    /**
     * `true`, `false`；Close-All，used with `STOP_MARKET` or `TAKE_PROFIT_MARKET`.
     * @type {string}
     * @memberof TradeApiNewOrder
     */
    readonly closePosition?: string;

    /**
     * Used with `TRAILING_STOP_MARKET` orders, default as the latest price(supporting different `workingType`)
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly activationPrice?: number;

    /**
     * Used with `TRAILING_STOP_MARKET` orders, min 0.1, max 5 where 1 for 1%
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly callbackRate?: number;

    /**
     * stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
     * @type {'MARK_PRICE' | 'CONTRACT_PRICE'}
     * @memberof TradeApiNewOrder
     */
    readonly workingType?: NewOrderWorkingTypeEnum;

    /**
     * "TRUE" or "FALSE", default "FALSE". Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
     * @type {string}
     * @memberof TradeApiNewOrder
     */
    readonly priceProtect?: string;

    /**
     * "ACK", "RESULT", default "ACK"
     * @type {'ACK' | 'RESULT'}
     * @memberof TradeApiNewOrder
     */
    readonly newOrderRespType?: NewOrderNewOrderRespTypeEnum;

    /**
     * only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
     * @type {'NONE' | 'OPPONENT' | 'OPPONENT_5' | 'OPPONENT_10' | 'OPPONENT_20' | 'QUEUE' | 'QUEUE_5' | 'QUEUE_10' | 'QUEUE_20'}
     * @memberof TradeApiNewOrder
     */
    readonly priceMatch?: NewOrderPriceMatchEnum;

    /**
     * `NONE`:No STP / `EXPIRE_TAKER`:expire taker order when STP triggers/ `EXPIRE_MAKER`:expire taker order when STP triggers/ `EXPIRE_BOTH`:expire both orders when STP triggers; default `NONE`
     * @type {'EXPIRE_TAKER' | 'EXPIRE_BOTH' | 'EXPIRE_MAKER'}
     * @memberof TradeApiNewOrder
     */
    readonly selfTradePreventionMode?: NewOrderSelfTradePreventionModeEnum;

    /**
     * order cancel time for timeInForce `GTD`, mandatory when `timeInforce` set to `GTD`; order the timestamp only retains second-level precision, ms part will be ignored; The goodTillDate timestamp must be greater than the current time plus 600 seconds and smaller than 253402300799000
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly goodTillDate?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for placeMultipleOrders operation in TradeApi.
 * @interface PlaceMultipleOrdersRequest
 */
export interface PlaceMultipleOrdersRequest {
    /**
     * order list. Max 5 orders
     * @type {Array<ModifyMultipleOrdersBatchOrdersParameterInner>}
     * @memberof TradeApiPlaceMultipleOrders
     */
    readonly batchOrders: Array<ModifyMultipleOrdersBatchOrdersParameterInner>;

    /**
     *
     * @type {number}
     * @memberof TradeApiPlaceMultipleOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for positionAdlQuantileEstimation operation in TradeApi.
 * @interface PositionAdlQuantileEstimationRequest
 */
export interface PositionAdlQuantileEstimationRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiPositionAdlQuantileEstimation
     */
    readonly symbol?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiPositionAdlQuantileEstimation
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for positionInformationV2 operation in TradeApi.
 * @interface PositionInformationV2Request
 */
export interface PositionInformationV2Request {
    /**
     *
     * @type {string}
     * @memberof TradeApiPositionInformationV2
     */
    readonly symbol?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiPositionInformationV2
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for positionInformationV3 operation in TradeApi.
 * @interface PositionInformationV3Request
 */
export interface PositionInformationV3Request {
    /**
     *
     * @type {string}
     * @memberof TradeApiPositionInformationV3
     */
    readonly symbol?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiPositionInformationV3
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for queryCurrentOpenOrder operation in TradeApi.
 * @interface QueryCurrentOpenOrderRequest
 */
export interface QueryCurrentOpenOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryCurrentOpenOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiQueryCurrentOpenOrder
     */
    readonly orderId?: number;

    /**
     *
     * @type {string}
     * @memberof TradeApiQueryCurrentOpenOrder
     */
    readonly origClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiQueryCurrentOpenOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for queryOrder operation in TradeApi.
 * @interface QueryOrderRequest
 */
export interface QueryOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiQueryOrder
     */
    readonly orderId?: number;

    /**
     *
     * @type {string}
     * @memberof TradeApiQueryOrder
     */
    readonly origClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiQueryOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for testOrder operation in TradeApi.
 * @interface TestOrderRequest
 */
export interface TestOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiTestOrder
     */
    readonly symbol: string;

    /**
     * `SELL`, `BUY`
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiTestOrder
     */
    readonly side: TestOrderSideEnum;

    /**
     *
     * @type {string}
     * @memberof TradeApiTestOrder
     */
    readonly type: string;

    /**
     * Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent with Hedge Mode.
     * @type {'BOTH' | 'LONG' | 'SHORT'}
     * @memberof TradeApiTestOrder
     */
    readonly positionSide?: TestOrderPositionSideEnum;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK' | 'GTX' | 'GTD'}
     * @memberof TradeApiTestOrder
     */
    readonly timeInForce?: TestOrderTimeInForceEnum;

    /**
     * Cannot be sent with `closePosition`=`true`(Close-All)
     * @type {number}
     * @memberof TradeApiTestOrder
     */
    readonly quantity?: number;

    /**
     * "true" or "false". default "false". Cannot be sent in Hedge Mode; cannot be sent with `closePosition`=`true`
     * @type {string}
     * @memberof TradeApiTestOrder
     */
    readonly reduceOnly?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiTestOrder
     */
    readonly price?: number;

    /**
     * A unique id among open orders. Automatically generated if not sent. Can only be string following the rule: `^[\.A-Z\:/a-z0-9_-]{1,36}$`
     * @type {string}
     * @memberof TradeApiTestOrder
     */
    readonly newClientOrderId?: string;

    /**
     * Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
     * @type {number}
     * @memberof TradeApiTestOrder
     */
    readonly stopPrice?: number;

    /**
     * `true`, `false`；Close-All，used with `STOP_MARKET` or `TAKE_PROFIT_MARKET`.
     * @type {string}
     * @memberof TradeApiTestOrder
     */
    readonly closePosition?: string;

    /**
     * Used with `TRAILING_STOP_MARKET` orders, default as the latest price(supporting different `workingType`)
     * @type {number}
     * @memberof TradeApiTestOrder
     */
    readonly activationPrice?: number;

    /**
     * Used with `TRAILING_STOP_MARKET` orders, min 0.1, max 5 where 1 for 1%
     * @type {number}
     * @memberof TradeApiTestOrder
     */
    readonly callbackRate?: number;

    /**
     * stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
     * @type {'MARK_PRICE' | 'CONTRACT_PRICE'}
     * @memberof TradeApiTestOrder
     */
    readonly workingType?: TestOrderWorkingTypeEnum;

    /**
     * "TRUE" or "FALSE", default "FALSE". Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
     * @type {string}
     * @memberof TradeApiTestOrder
     */
    readonly priceProtect?: string;

    /**
     * "ACK", "RESULT", default "ACK"
     * @type {'ACK' | 'RESULT'}
     * @memberof TradeApiTestOrder
     */
    readonly newOrderRespType?: TestOrderNewOrderRespTypeEnum;

    /**
     * only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
     * @type {'NONE' | 'OPPONENT' | 'OPPONENT_5' | 'OPPONENT_10' | 'OPPONENT_20' | 'QUEUE' | 'QUEUE_5' | 'QUEUE_10' | 'QUEUE_20'}
     * @memberof TradeApiTestOrder
     */
    readonly priceMatch?: TestOrderPriceMatchEnum;

    /**
     * `NONE`:No STP / `EXPIRE_TAKER`:expire taker order when STP triggers/ `EXPIRE_MAKER`:expire taker order when STP triggers/ `EXPIRE_BOTH`:expire both orders when STP triggers; default `NONE`
     * @type {'EXPIRE_TAKER' | 'EXPIRE_BOTH' | 'EXPIRE_MAKER'}
     * @memberof TradeApiTestOrder
     */
    readonly selfTradePreventionMode?: TestOrderSelfTradePreventionModeEnum;

    /**
     * order cancel time for timeInForce `GTD`, mandatory when `timeInforce` set to `GTD`; order the timestamp only retains second-level precision, ms part will be ignored; The goodTillDate timestamp must be greater than the current time plus 600 seconds and smaller than 253402300799000
     * @type {number}
     * @memberof TradeApiTestOrder
     */
    readonly goodTillDate?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiTestOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for usersForceOrders operation in TradeApi.
 * @interface UsersForceOrdersRequest
 */
export interface UsersForceOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiUsersForceOrders
     */
    readonly symbol?: string;

    /**
     * "LIQUIDATION" for liquidation orders, "ADL" for ADL orders.
     * @type {'LIQUIDATION' | 'ADL'}
     * @memberof TradeApiUsersForceOrders
     */
    readonly autoCloseType?: UsersForceOrdersAutoCloseTypeEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiUsersForceOrders
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiUsersForceOrders
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof TradeApiUsersForceOrders
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiUsersForceOrders
     */
    readonly recvWindow?: number;
}

/**
 * TradeApi - object-oriented interface
 * @class TradeApi
 */
export class TradeApi implements TradeApiInterface {
    private readonly configuration: ConfigurationRestAPI;
    private localVarAxiosParamCreator;

    constructor(configuration: ConfigurationRestAPI) {
        this.configuration = configuration;
        this.localVarAxiosParamCreator = TradeApiAxiosParamCreator(configuration);
    }

    /**
     * Get trades for a specific account and symbol.
     *
     * If `startTime` and `endTime` are both not sent, then the last 7 days' data will be returned.
     * The time between `startTime` and `endTime` cannot be longer than 7 days.
     * The parameter `fromId` cannot be sent with `startTime` or `endTime`.
     * Only support querying trade in the past 6 months
     *
     * Weight: 5
     *
     * @summary Account Trade List (USER_DATA)
     * @param {AccountTradeListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<AccountTradeListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Account-Trade-List Binance API Documentation}
     */
    public async accountTradeList(
        requestParameters: AccountTradeListRequest
    ): Promise<RestApiResponse<AccountTradeListResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.accountTradeList(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.fromId,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<AccountTradeListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get all account orders; active, canceled, or filled.
     *
     * These orders will not be found:
     * order status is `CANCELED` or `EXPIRED` **AND** order has NO filled trade **AND** created time + 3 days < current time
     * order create time + 90 days < current time
     *
     * If `orderId` is set, it will get orders >= that `orderId`. Otherwise most recent orders are returned.
     * The query time period must be less then 7 days( default as the recent 7 days).
     *
     * Weight: 5
     *
     * @summary All Orders (USER_DATA)
     * @param {AllOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<AllOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/All-Orders Binance API Documentation}
     */
    public async allOrders(
        requestParameters: AllOrdersRequest
    ): Promise<RestApiResponse<AllOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.allOrders(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<AllOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel all open orders of the specified symbol at the end of the specified countdown.
     * The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and replaced by a new one.
     *
     * Example usage:
     * Call this endpoint at 30s intervals with an countdownTime of 120000 (120s).
     * If this endpoint is not called within 120 seconds, all your orders of the specified symbol will be automatically canceled.
     * If this endpoint is called with an countdownTime of 0, the countdown timer will be stopped.
     *
     * The system will check all countdowns **approximately every 10 milliseconds**, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.
     *
     * Weight: 10
     *
     * @summary Auto-Cancel All Open Orders (TRADE)
     * @param {AutoCancelAllOpenOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<AutoCancelAllOpenOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Auto-Cancel-All-Open-Orders Binance API Documentation}
     */
    public async autoCancelAllOpenOrders(
        requestParameters: AutoCancelAllOpenOrdersRequest
    ): Promise<RestApiResponse<AutoCancelAllOpenOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.autoCancelAllOpenOrders(
            requestParameters?.symbol,
            requestParameters?.countdownTime,
            requestParameters?.recvWindow
        );
        return sendRequest<AutoCancelAllOpenOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel All Open Orders
     *
     * Weight: 1
     *
     * @summary Cancel All Open Orders (TRADE)
     * @param {CancelAllOpenOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CancelAllOpenOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Cancel-All-Open-Orders Binance API Documentation}
     */
    public async cancelAllOpenOrders(
        requestParameters: CancelAllOpenOrdersRequest
    ): Promise<RestApiResponse<CancelAllOpenOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.cancelAllOpenOrders(
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<CancelAllOpenOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel Multiple Orders
     *
     * Either `orderIdList` or `origClientOrderIdList ` must be sent.
     *
     * Weight: 1
     *
     * @summary Cancel Multiple Orders (TRADE)
     * @param {CancelMultipleOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CancelMultipleOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Cancel-Multiple-Orders Binance API Documentation}
     */
    public async cancelMultipleOrders(
        requestParameters: CancelMultipleOrdersRequest
    ): Promise<RestApiResponse<CancelMultipleOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.cancelMultipleOrders(
            requestParameters?.symbol,
            requestParameters?.orderIdList,
            requestParameters?.origClientOrderIdList,
            requestParameters?.recvWindow
        );
        return sendRequest<CancelMultipleOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel an active order.
     *
     * Either `orderId` or `origClientOrderId` must be sent.
     *
     * Weight: 1
     *
     * @summary Cancel Order (TRADE)
     * @param {CancelOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CancelOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Cancel-Order Binance API Documentation}
     */
    public async cancelOrder(
        requestParameters: CancelOrderRequest
    ): Promise<RestApiResponse<CancelOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.cancelOrder(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<CancelOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Change user's initial leverage of specific symbol market.
     *
     * Weight: 1
     *
     * @summary Change Initial Leverage(TRADE)
     * @param {ChangeInitialLeverageRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ChangeInitialLeverageResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Change-Initial-Leverage Binance API Documentation}
     */
    public async changeInitialLeverage(
        requestParameters: ChangeInitialLeverageRequest
    ): Promise<RestApiResponse<ChangeInitialLeverageResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.changeInitialLeverage(
            requestParameters?.symbol,
            requestParameters?.leverage,
            requestParameters?.recvWindow
        );
        return sendRequest<ChangeInitialLeverageResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Change symbol level margin type
     *
     * Weight: 1
     *
     * @summary Change Margin Type(TRADE)
     * @param {ChangeMarginTypeRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ChangeMarginTypeResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Change-Margin-Type Binance API Documentation}
     */
    public async changeMarginType(
        requestParameters: ChangeMarginTypeRequest
    ): Promise<RestApiResponse<ChangeMarginTypeResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.changeMarginType(
            requestParameters?.symbol,
            requestParameters?.marginType,
            requestParameters?.recvWindow
        );
        return sendRequest<ChangeMarginTypeResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Change user's Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on ***Every symbol***
     *
     * Weight: 1
     *
     * @summary Change Multi-Assets Mode (TRADE)
     * @param {ChangeMultiAssetsModeRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ChangeMultiAssetsModeResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Change-Multi-Assets-Mode Binance API Documentation}
     */
    public async changeMultiAssetsMode(
        requestParameters: ChangeMultiAssetsModeRequest
    ): Promise<RestApiResponse<ChangeMultiAssetsModeResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.changeMultiAssetsMode(
            requestParameters?.multiAssetsMargin,
            requestParameters?.recvWindow
        );
        return sendRequest<ChangeMultiAssetsModeResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Change user's position mode (Hedge Mode or One-way Mode ) on ***EVERY symbol***
     *
     * Weight: 1
     *
     * @summary Change Position Mode(TRADE)
     * @param {ChangePositionModeRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ChangePositionModeResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Change-Position-Mode Binance API Documentation}
     */
    public async changePositionMode(
        requestParameters: ChangePositionModeRequest
    ): Promise<RestApiResponse<ChangePositionModeResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.changePositionMode(
            requestParameters?.dualSidePosition,
            requestParameters?.recvWindow
        );
        return sendRequest<ChangePositionModeResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get all open orders on a symbol.
     *
     * If the symbol is not sent, orders for all symbols will be returned in an array.
     *
     * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
     * Careful when accessing this with no symbol.
     *
     * @summary Current All Open Orders (USER_DATA)
     * @param {CurrentAllOpenOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CurrentAllOpenOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Current-All-Open-Orders Binance API Documentation}
     */
    public async currentAllOpenOrders(
        requestParameters: CurrentAllOpenOrdersRequest = {}
    ): Promise<RestApiResponse<CurrentAllOpenOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.currentAllOpenOrders(
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<CurrentAllOpenOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get order modification history
     *
     * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
     * Order modify history longer than 3 month is not avaliable
     *
     * Weight: 1
     *
     * @summary Get Order Modify History (USER_DATA)
     * @param {GetOrderModifyHistoryRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetOrderModifyHistoryResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Get-Order-Modify-History Binance API Documentation}
     */
    public async getOrderModifyHistory(
        requestParameters: GetOrderModifyHistoryRequest
    ): Promise<RestApiResponse<GetOrderModifyHistoryResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getOrderModifyHistory(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<GetOrderModifyHistoryResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get Position Margin Change History
     *
     * Support querying future histories that are not older than 30 days
     * The time between `startTime` and `endTime`can't be more than 30 days
     *
     * Weight: 1
     *
     * @summary Get Position Margin Change History (TRADE)
     * @param {GetPositionMarginChangeHistoryRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetPositionMarginChangeHistoryResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Get-Position-Margin-Change-History Binance API Documentation}
     */
    public async getPositionMarginChangeHistory(
        requestParameters: GetPositionMarginChangeHistoryRequest
    ): Promise<RestApiResponse<GetPositionMarginChangeHistoryResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.getPositionMarginChangeHistory(
                requestParameters?.symbol,
                requestParameters?.type,
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.limit,
                requestParameters?.recvWindow
            );
        return sendRequest<GetPositionMarginChangeHistoryResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Modify Isolated Position Margin
     *
     *
     * Only for isolated symbol
     *
     * Weight: 1
     *
     * @summary Modify Isolated Position Margin(TRADE)
     * @param {ModifyIsolatedPositionMarginRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ModifyIsolatedPositionMarginResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Modify-Isolated-Position-Margin Binance API Documentation}
     */
    public async modifyIsolatedPositionMargin(
        requestParameters: ModifyIsolatedPositionMarginRequest
    ): Promise<RestApiResponse<ModifyIsolatedPositionMarginResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.modifyIsolatedPositionMargin(
            requestParameters?.symbol,
            requestParameters?.amount,
            requestParameters?.type,
            requestParameters?.positionSide,
            requestParameters?.recvWindow
        );
        return sendRequest<ModifyIsolatedPositionMarginResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Modify Multiple Orders (TRADE)
     *
     * Parameter rules are same with `Modify Order`
     * Batch modify orders are processed concurrently, and the order of matching is not guaranteed.
     * The order of returned contents for batch modify orders is the same as the order of the order list.
     * One order can only be modfied for less than 10000 times
     *
     * Weight: 5 on 10s order rate limit(X-MBX-ORDER-COUNT-10S);
     * 1 on 1min order rate limit(X-MBX-ORDER-COUNT-1M);
     * 5 on IP rate limit(x-mbx-used-weight-1m);
     *
     * @summary Modify Multiple Orders(TRADE)
     * @param {ModifyMultipleOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ModifyMultipleOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Modify-Multiple-Orders Binance API Documentation}
     */
    public async modifyMultipleOrders(
        requestParameters: ModifyMultipleOrdersRequest
    ): Promise<RestApiResponse<ModifyMultipleOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.modifyMultipleOrders(
            requestParameters?.batchOrders,
            requestParameters?.recvWindow
        );
        return sendRequest<ModifyMultipleOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     *
     *
     * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
     * Both `quantity` and `price` must be sent, which is different from dapi modify order endpoint.
     * When the new `quantity` or `price` doesn't satisfy PRICE_FILTER / PERCENT_FILTER / LOT_SIZE, amendment will be rejected and the order will stay as it is.
     * However the order will be cancelled by the amendment in the following situations:
     * when the order is in partially filled status and the new `quantity` <= `executedQty`
     * When the order is `GTX` and the new price will cause it to be executed immediately
     * One order can only be modfied for less than 10000 times
     * Modify order will set `selfTradePreventionMode` to `NONE`
     *
     * Weight: 1 on 10s order rate limit(X-MBX-ORDER-COUNT-10S);
     * 1 on 1min order rate limit(X-MBX-ORDER-COUNT-1M);
     * 1 on IP rate limit(x-mbx-used-weight-1m)
     *
     * @summary Modify Order (TRADE)
     * @param {ModifyOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ModifyOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Modify-Order Binance API Documentation}
     */
    public async modifyOrder(
        requestParameters: ModifyOrderRequest
    ): Promise<RestApiResponse<ModifyOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.modifyOrder(
            requestParameters?.symbol,
            requestParameters?.side,
            requestParameters?.quantity,
            requestParameters?.price,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.priceMatch,
            requestParameters?.recvWindow
        );
        return sendRequest<ModifyOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Send in a new order.
     *
     * Order with type `STOP`,  parameter `timeInForce` can be sent ( default `GTC`).
     * Order with type `TAKE_PROFIT`,  parameter `timeInForce` can be sent ( default `GTC`).
     * Condition orders will be triggered when:
     *
     * If parameter`priceProtect`is sent as true:
     * when price reaches the `stopPrice` ，the difference rate between "MARK_PRICE" and "CONTRACT_PRICE" cannot be larger than the "triggerProtect" of the symbol
     * "triggerProtect" of a symbol can be got from `GET /fapi/v1/exchangeInfo`
     *
     * `STOP`, `STOP_MARKET`:
     * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
     * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
     * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
     * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
     * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
     * `TRAILING_STOP_MARKET`:
     * BUY: the lowest price after order placed `<= `activationPrice`, and the latest price >`= the lowest price * (1 + `callbackRate`)
     * SELL: the highest price after order placed >= `activationPrice`, and the latest price <= the highest price * (1 - `callbackRate`)
     *
     * For `TRAILING_STOP_MARKET`, if you got such error code.
     * ``{"code": -2021, "msg": "Order would immediately trigger."}``
     * means that the parameters you send do not meet the following requirements:
     * BUY: `activationPrice` should be smaller than latest price.
     * SELL: `activationPrice` should be larger than latest price.
     *
     * If `newOrderRespType ` is sent as `RESULT` :
     * `MARKET` order: the final FILLED result of the order will be return directly.
     * `LIMIT` order with special `timeInForce`: the final status result of the order(FILLED or EXPIRED) will be returned directly.
     *
     * `STOP_MARKET`, `TAKE_PROFIT_MARKET` with `closePosition`=`true`:
     * Follow the same rules for condition orders.
     * If triggered，**close all** current long position( if `SELL`) or current short position( if `BUY`).
     * Cannot be used with `quantity` paremeter
     * Cannot be used with `reduceOnly` parameter
     * In Hedge Mode,cannot be used with `BUY` orders in `LONG` position side. and cannot be used with `SELL` orders in `SHORT` position side
     * `selfTradePreventionMode` is only effective when `timeInForce` set to `IOC` or `GTC` or `GTD`.
     * In extreme market conditions, timeInForce `GTD` order auto cancel time might be delayed comparing to `goodTillDate`
     *
     * Weight: 1 on 10s order rate limit(X-MBX-ORDER-COUNT-10S);
     * 1 on 1min order rate limit(X-MBX-ORDER-COUNT-1M);
     * 0 on IP rate limit(x-mbx-used-weight-1m)
     *
     * @summary New Order(TRADE)
     * @param {NewOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<NewOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/New-Order Binance API Documentation}
     */
    public async newOrder(
        requestParameters: NewOrderRequest
    ): Promise<RestApiResponse<NewOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.newOrder(
            requestParameters?.symbol,
            requestParameters?.side,
            requestParameters?.type,
            requestParameters?.positionSide,
            requestParameters?.timeInForce,
            requestParameters?.quantity,
            requestParameters?.reduceOnly,
            requestParameters?.price,
            requestParameters?.newClientOrderId,
            requestParameters?.stopPrice,
            requestParameters?.closePosition,
            requestParameters?.activationPrice,
            requestParameters?.callbackRate,
            requestParameters?.workingType,
            requestParameters?.priceProtect,
            requestParameters?.newOrderRespType,
            requestParameters?.priceMatch,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.goodTillDate,
            requestParameters?.recvWindow
        );
        return sendRequest<NewOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Place Multiple Orders
     *
     * Paremeter rules are same with `New Order`
     * Batch orders are processed concurrently, and the order of matching is not guaranteed.
     * The order of returned contents for batch orders is the same as the order of the order list.
     *
     * Weight: 5 on 10s order rate limit(X-MBX-ORDER-COUNT-10S);
     * 1 on 1min order rate limit(X-MBX-ORDER-COUNT-1M);
     * 5 on IP rate limit(x-mbx-used-weight-1m);
     *
     * @summary Place Multiple Orders(TRADE)
     * @param {PlaceMultipleOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<PlaceMultipleOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Place-Multiple-Orders Binance API Documentation}
     */
    public async placeMultipleOrders(
        requestParameters: PlaceMultipleOrdersRequest
    ): Promise<RestApiResponse<PlaceMultipleOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.placeMultipleOrders(
            requestParameters?.batchOrders,
            requestParameters?.recvWindow
        );
        return sendRequest<PlaceMultipleOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Position ADL Quantile Estimation
     *
     * Values update every 30s.
     * Values 0, 1, 2, 3, 4 shows the queue position and possibility of ADL from low to high.
     * For positions of the symbol are in One-way Mode or isolated margined in Hedge Mode, "LONG", "SHORT", and "BOTH" will be returned to show the positions' adl quantiles of different position sides.
     * If the positions of the symbol are crossed margined in Hedge Mode:
     * "HEDGE" as a sign will be returned instead of "BOTH";
     * A same value caculated on unrealized pnls on long and short sides' positions will be shown for "LONG" and "SHORT" when there are positions in both of long and short sides.
     *
     * Weight: 5
     *
     * @summary Position ADL Quantile Estimation(USER_DATA)
     * @param {PositionAdlQuantileEstimationRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<PositionAdlQuantileEstimationResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-ADL-Quantile-Estimation Binance API Documentation}
     */
    public async positionAdlQuantileEstimation(
        requestParameters: PositionAdlQuantileEstimationRequest = {}
    ): Promise<RestApiResponse<PositionAdlQuantileEstimationResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.positionAdlQuantileEstimation(
                requestParameters?.symbol,
                requestParameters?.recvWindow
            );
        return sendRequest<PositionAdlQuantileEstimationResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get current position information.
     *
     * Please use with user data stream `ACCOUNT_UPDATE` to meet your timeliness and accuracy needs.
     *
     * Weight: 5
     *
     * @summary Position Information V2 (USER_DATA)
     * @param {PositionInformationV2Request} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<PositionInformationV2Response>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-Information-V2 Binance API Documentation}
     */
    public async positionInformationV2(
        requestParameters: PositionInformationV2Request = {}
    ): Promise<RestApiResponse<PositionInformationV2Response>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.positionInformationV2(
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<PositionInformationV2Response>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get current position information(only symbol that has position or open orders will be returned).
     *
     * Please use with user data stream `ACCOUNT_UPDATE` to meet your timeliness and accuracy needs.
     *
     * Weight: 5
     *
     * @summary Position Information V3 (USER_DATA)
     * @param {PositionInformationV3Request} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<PositionInformationV3Response>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-Information-V3 Binance API Documentation}
     */
    public async positionInformationV3(
        requestParameters: PositionInformationV3Request = {}
    ): Promise<RestApiResponse<PositionInformationV3Response>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.positionInformationV3(
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<PositionInformationV3Response>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query open order
     *
     *
     * Either`orderId` or `origClientOrderId` must be sent
     * If the queried order has been filled or cancelled, the error message "Order does not exist" will be returned.
     *
     * Weight: 1
     *
     * @summary Query Current Open Order (USER_DATA)
     * @param {QueryCurrentOpenOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryCurrentOpenOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Query-Current-Open-Order Binance API Documentation}
     */
    public async queryCurrentOpenOrder(
        requestParameters: QueryCurrentOpenOrderRequest
    ): Promise<RestApiResponse<QueryCurrentOpenOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryCurrentOpenOrder(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryCurrentOpenOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Check an order's status.
     *
     * These orders will not be found:
     * order status is `CANCELED` or `EXPIRED` **AND** order has NO filled trade **AND** created time + 3 days < current time
     * order create time + 90 days < current time
     *
     * Either `orderId` or `origClientOrderId` must be sent.
     * `orderId` is self-increment for each specific `symbol`
     *
     * Weight: 1
     *
     * @summary Query Order (USER_DATA)
     * @param {QueryOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Query-Order Binance API Documentation}
     */
    public async queryOrder(
        requestParameters: QueryOrderRequest
    ): Promise<RestApiResponse<QueryOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryOrder(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Testing order request, this order will not be submitted to matching engine
     *
     * Order with type `STOP`,  parameter `timeInForce` can be sent ( default `GTC`).
     * Order with type `TAKE_PROFIT`,  parameter `timeInForce` can be sent ( default `GTC`).
     * Condition orders will be triggered when:
     *
     * If parameter`priceProtect`is sent as true:
     * when price reaches the `stopPrice` ，the difference rate between "MARK_PRICE" and "CONTRACT_PRICE" cannot be larger than the "triggerProtect" of the symbol
     * "triggerProtect" of a symbol can be got from `GET /fapi/v1/exchangeInfo`
     *
     * `STOP`, `STOP_MARKET`:
     * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
     * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
     * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
     * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
     * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
     * `TRAILING_STOP_MARKET`:
     * BUY: the lowest price after order placed `<= `activationPrice`, and the latest price >`= the lowest price * (1 + `callbackRate`)
     * SELL: the highest price after order placed >= `activationPrice`, and the latest price <= the highest price * (1 - `callbackRate`)
     *
     * For `TRAILING_STOP_MARKET`, if you got such error code.
     * ``{"code": -2021, "msg": "Order would immediately trigger."}``
     * means that the parameters you send do not meet the following requirements:
     * BUY: `activationPrice` should be smaller than latest price.
     * SELL: `activationPrice` should be larger than latest price.
     *
     * If `newOrderRespType ` is sent as `RESULT` :
     * `MARKET` order: the final FILLED result of the order will be return directly.
     * `LIMIT` order with special `timeInForce`: the final status result of the order(FILLED or EXPIRED) will be returned directly.
     *
     * `STOP_MARKET`, `TAKE_PROFIT_MARKET` with `closePosition`=`true`:
     * Follow the same rules for condition orders.
     * If triggered，**close all** current long position( if `SELL`) or current short position( if `BUY`).
     * Cannot be used with `quantity` paremeter
     * Cannot be used with `reduceOnly` parameter
     * In Hedge Mode,cannot be used with `BUY` orders in `LONG` position side. and cannot be used with `SELL` orders in `SHORT` position side
     * `selfTradePreventionMode` is only effective when `timeInForce` set to `IOC` or `GTC` or `GTD`.
     * In extreme market conditions, timeInForce `GTD` order auto cancel time might be delayed comparing to `goodTillDate`
     *
     * Weight: 0
     *
     * @summary Test Order(TRADE)
     * @param {TestOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<TestOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/New-Order-Test Binance API Documentation}
     */
    public async testOrder(
        requestParameters: TestOrderRequest
    ): Promise<RestApiResponse<TestOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.testOrder(
            requestParameters?.symbol,
            requestParameters?.side,
            requestParameters?.type,
            requestParameters?.positionSide,
            requestParameters?.timeInForce,
            requestParameters?.quantity,
            requestParameters?.reduceOnly,
            requestParameters?.price,
            requestParameters?.newClientOrderId,
            requestParameters?.stopPrice,
            requestParameters?.closePosition,
            requestParameters?.activationPrice,
            requestParameters?.callbackRate,
            requestParameters?.workingType,
            requestParameters?.priceProtect,
            requestParameters?.newOrderRespType,
            requestParameters?.priceMatch,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.goodTillDate,
            requestParameters?.recvWindow
        );
        return sendRequest<TestOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query user's Force Orders
     *
     * If "autoCloseType" is not sent, orders with both of the types will be returned
     * If "startTime" is not sent, data within 7 days before "endTime" can be queried
     *
     * Weight: 20 with symbol, 50 without symbol
     *
     * @summary User\'s Force Orders (USER_DATA)
     * @param {UsersForceOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<UsersForceOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Users-Force-Orders Binance API Documentation}
     */
    public async usersForceOrders(
        requestParameters: UsersForceOrdersRequest = {}
    ): Promise<RestApiResponse<UsersForceOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.usersForceOrders(
            requestParameters?.symbol,
            requestParameters?.autoCloseType,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<UsersForceOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }
}

export const ChangeMarginTypeMarginTypeEnum = {
    ISOLATED: 'ISOLATED',
    CROSSED: 'CROSSED',
} as const;
export type ChangeMarginTypeMarginTypeEnum =
    (typeof ChangeMarginTypeMarginTypeEnum)[keyof typeof ChangeMarginTypeMarginTypeEnum];

export const ModifyIsolatedPositionMarginPositionSideEnum = {
    BOTH: 'BOTH',
    LONG: 'LONG',
    SHORT: 'SHORT',
} as const;
export type ModifyIsolatedPositionMarginPositionSideEnum =
    (typeof ModifyIsolatedPositionMarginPositionSideEnum)[keyof typeof ModifyIsolatedPositionMarginPositionSideEnum];

export const ModifyOrderSideEnum = {
    BUY: 'BUY',
    SELL: 'SELL',
} as const;
export type ModifyOrderSideEnum = (typeof ModifyOrderSideEnum)[keyof typeof ModifyOrderSideEnum];

export const ModifyOrderPriceMatchEnum = {
    NONE: 'NONE',
    OPPONENT: 'OPPONENT',
    OPPONENT_5: 'OPPONENT_5',
    OPPONENT_10: 'OPPONENT_10',
    OPPONENT_20: 'OPPONENT_20',
    QUEUE: 'QUEUE',
    QUEUE_5: 'QUEUE_5',
    QUEUE_10: 'QUEUE_10',
    QUEUE_20: 'QUEUE_20',
} as const;
export type ModifyOrderPriceMatchEnum =
    (typeof ModifyOrderPriceMatchEnum)[keyof typeof ModifyOrderPriceMatchEnum];

export const NewOrderSideEnum = {
    BUY: 'BUY',
    SELL: 'SELL',
} as const;
export type NewOrderSideEnum = (typeof NewOrderSideEnum)[keyof typeof NewOrderSideEnum];

export const NewOrderPositionSideEnum = {
    BOTH: 'BOTH',
    LONG: 'LONG',
    SHORT: 'SHORT',
} as const;
export type NewOrderPositionSideEnum =
    (typeof NewOrderPositionSideEnum)[keyof typeof NewOrderPositionSideEnum];

export const NewOrderTimeInForceEnum = {
    GTC: 'GTC',
    IOC: 'IOC',
    FOK: 'FOK',
    GTX: 'GTX',
    GTD: 'GTD',
} as const;
export type NewOrderTimeInForceEnum =
    (typeof NewOrderTimeInForceEnum)[keyof typeof NewOrderTimeInForceEnum];

export const NewOrderWorkingTypeEnum = {
    MARK_PRICE: 'MARK_PRICE',
    CONTRACT_PRICE: 'CONTRACT_PRICE',
} as const;
export type NewOrderWorkingTypeEnum =
    (typeof NewOrderWorkingTypeEnum)[keyof typeof NewOrderWorkingTypeEnum];

export const NewOrderNewOrderRespTypeEnum = {
    ACK: 'ACK',
    RESULT: 'RESULT',
} as const;
export type NewOrderNewOrderRespTypeEnum =
    (typeof NewOrderNewOrderRespTypeEnum)[keyof typeof NewOrderNewOrderRespTypeEnum];

export const NewOrderPriceMatchEnum = {
    NONE: 'NONE',
    OPPONENT: 'OPPONENT',
    OPPONENT_5: 'OPPONENT_5',
    OPPONENT_10: 'OPPONENT_10',
    OPPONENT_20: 'OPPONENT_20',
    QUEUE: 'QUEUE',
    QUEUE_5: 'QUEUE_5',
    QUEUE_10: 'QUEUE_10',
    QUEUE_20: 'QUEUE_20',
} as const;
export type NewOrderPriceMatchEnum =
    (typeof NewOrderPriceMatchEnum)[keyof typeof NewOrderPriceMatchEnum];

export const NewOrderSelfTradePreventionModeEnum = {
    EXPIRE_TAKER: 'EXPIRE_TAKER',
    EXPIRE_BOTH: 'EXPIRE_BOTH',
    EXPIRE_MAKER: 'EXPIRE_MAKER',
} as const;
export type NewOrderSelfTradePreventionModeEnum =
    (typeof NewOrderSelfTradePreventionModeEnum)[keyof typeof NewOrderSelfTradePreventionModeEnum];

export const TestOrderSideEnum = {
    BUY: 'BUY',
    SELL: 'SELL',
} as const;
export type TestOrderSideEnum = (typeof TestOrderSideEnum)[keyof typeof TestOrderSideEnum];

export const TestOrderPositionSideEnum = {
    BOTH: 'BOTH',
    LONG: 'LONG',
    SHORT: 'SHORT',
} as const;
export type TestOrderPositionSideEnum =
    (typeof TestOrderPositionSideEnum)[keyof typeof TestOrderPositionSideEnum];

export const TestOrderTimeInForceEnum = {
    GTC: 'GTC',
    IOC: 'IOC',
    FOK: 'FOK',
    GTX: 'GTX',
    GTD: 'GTD',
} as const;
export type TestOrderTimeInForceEnum =
    (typeof TestOrderTimeInForceEnum)[keyof typeof TestOrderTimeInForceEnum];

export const TestOrderWorkingTypeEnum = {
    MARK_PRICE: 'MARK_PRICE',
    CONTRACT_PRICE: 'CONTRACT_PRICE',
} as const;
export type TestOrderWorkingTypeEnum =
    (typeof TestOrderWorkingTypeEnum)[keyof typeof TestOrderWorkingTypeEnum];

export const TestOrderNewOrderRespTypeEnum = {
    ACK: 'ACK',
    RESULT: 'RESULT',
} as const;
export type TestOrderNewOrderRespTypeEnum =
    (typeof TestOrderNewOrderRespTypeEnum)[keyof typeof TestOrderNewOrderRespTypeEnum];

export const TestOrderPriceMatchEnum = {
    NONE: 'NONE',
    OPPONENT: 'OPPONENT',
    OPPONENT_5: 'OPPONENT_5',
    OPPONENT_10: 'OPPONENT_10',
    OPPONENT_20: 'OPPONENT_20',
    QUEUE: 'QUEUE',
    QUEUE_5: 'QUEUE_5',
    QUEUE_10: 'QUEUE_10',
    QUEUE_20: 'QUEUE_20',
} as const;
export type TestOrderPriceMatchEnum =
    (typeof TestOrderPriceMatchEnum)[keyof typeof TestOrderPriceMatchEnum];

export const TestOrderSelfTradePreventionModeEnum = {
    EXPIRE_TAKER: 'EXPIRE_TAKER',
    EXPIRE_BOTH: 'EXPIRE_BOTH',
    EXPIRE_MAKER: 'EXPIRE_MAKER',
} as const;
export type TestOrderSelfTradePreventionModeEnum =
    (typeof TestOrderSelfTradePreventionModeEnum)[keyof typeof TestOrderSelfTradePreventionModeEnum];

export const UsersForceOrdersAutoCloseTypeEnum = {
    LIQUIDATION: 'LIQUIDATION',
    ADL: 'ADL',
} as const;
export type UsersForceOrdersAutoCloseTypeEnum =
    (typeof UsersForceOrdersAutoCloseTypeEnum)[keyof typeof UsersForceOrdersAutoCloseTypeEnum];
