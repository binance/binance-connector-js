/**
 * Binance Derivatives Trading USDS Futures REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading USDS Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
    ConfigurationRestAPI,
    TimeUnit,
    RestApiResponse,
    assertParamExists,
    sendRequest,
    type RequestArgs,
} from '@binance/common';
import type {
    BasisResponse,
    CheckServerTimeResponse,
    CompositeIndexSymbolInformationResponse,
    CompressedAggregateTradesListResponse,
    ContinuousContractKlineCandlestickDataResponse,
    ExchangeInformationResponse,
    GetFundingRateHistoryResponse,
    GetFundingRateInfoResponse,
    HistoricalBlvtNavKlineCandlestickResponse,
    IndexPriceKlineCandlestickDataResponse,
    KlineCandlestickDataResponse,
    LongShortRatioResponse,
    MarkPriceKlineCandlestickDataResponse,
    MarkPriceResponse,
    MultiAssetsModeAssetIndexResponse,
    OldTradesLookupResponse,
    OpenInterestResponse,
    OpenInterestStatisticsResponse,
    OrderBookResponse,
    PremiumIndexKlineDataResponse,
    QuarterlyContractSettlementPriceResponse,
    QueryIndexPriceConstituentsResponse,
    RecentTradesListResponse,
    SymbolOrderBookTickerResponse,
    SymbolPriceTickerResponse,
    SymbolPriceTickerV2Response,
    TakerBuySellVolumeResponse,
    Ticker24hrPriceChangeStatisticsResponse,
    TopTraderLongShortRatioAccountsResponse,
    TopTraderLongShortRatioPositionsResponse,
} from '../types';

/**
 * MarketDataApi - axios parameter creator
 */
const MarketDataApiAxiosParamCreator = function (configuration: ConfigurationRestAPI) {
    return {
        /**
         * Query future basis
         *
         * If startTime and endTime are not sent, the most recent data is returned.
         * Only the data of the latest 30 days is available.
         *
         * Weight: 0
         *
         * @summary Basis
         * @param {string} pair
         * @param {BasisContractTypeEnum} contractType
         * @param {BasisPeriodEnum} period "5m","15m","30m","1h","2h","4h","6h","12h","1d"
         * @param {number} limit Default 30,Max 500
         * @param {number} [startTime]
         * @param {number} [endTime]
         *
         * @throws {RequiredError}
         */
        basis: async (
            pair: string,
            contractType: BasisContractTypeEnum,
            period: BasisPeriodEnum,
            limit: number,
            startTime?: number,
            endTime?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('basis', 'pair', pair);
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('basis', 'contractType', contractType);
            // verify required parameter 'period' is not null or undefined
            assertParamExists('basis', 'period', period);
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('basis', 'limit', limit);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined && contractType !== null) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (period !== undefined && period !== null) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/futures/data/basis',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         *
         * Weight: 1
         *
         * @summary Check Server Time
         *
         * @throws {RequiredError}
         */
        checkServerTime: async (): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/time',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query composite index symbol information
         *
         * Only for composite index symbols
         *
         * Weight: 1
         *
         * @summary Composite Index Symbol Information
         * @param {string} [symbol]
         *
         * @throws {RequiredError}
         */
        compositeIndexSymbolInformation: async (symbol?: string): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/indexInfo',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
         *
         *
         * support querying futures trade histories that are not older than one year
         * If both `startTime` and `endTime` are sent, time between `startTime` and `endTime` must be less than 1 hour.
         * If `fromId`, `startTime`, and `endTime` are not sent, the most recent aggregate trades will be returned.
         * Only market trades will be aggregated and returned, which means the insurance fund trades and ADL trades won't be aggregated.
         * Sending both `startTime`/`endTime` and `fromId` might cause response timeout, please send either `fromId` or `startTime`/`endTime`
         *
         * Weight: 20
         *
         * @summary Compressed/Aggregate Trades List
         * @param {string} symbol
         * @param {number} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        compressedAggregateTradesList: async (
            symbol: string,
            fromId?: number,
            startTime?: number,
            endTime?: number,
            limit?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('compressedAggregateTradesList', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (fromId !== undefined && fromId !== null) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/aggTrades',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Kline/candlestick bars for a specific contract type.
         * Klines are uniquely identified by their open time.
         *
         * If startTime and endTime are not sent, the most recent klines are returned.
         * Contract type:
         * PERPETUAL
         * CURRENT_QUARTER
         * NEXT_QUARTER
         *
         * Weight: based on parameter LIMIT
         * | LIMIT       | weight |
         * | ----------- | ------ |
         * | [1,100)     | 1      |
         * | [100, 500)  | 2      |
         * | [500, 1000] | 5      |
         * | > 1000      | 10     |
         *
         * @summary Continuous Contract Kline/Candlestick Data
         * @param {string} pair
         * @param {ContinuousContractKlineCandlestickDataContractTypeEnum} contractType
         * @param {ContinuousContractKlineCandlestickDataIntervalEnum} interval
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        continuousContractKlineCandlestickData: async (
            pair: string,
            contractType: ContinuousContractKlineCandlestickDataContractTypeEnum,
            interval: ContinuousContractKlineCandlestickDataIntervalEnum,
            startTime?: number,
            endTime?: number,
            limit?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('continuousContractKlineCandlestickData', 'pair', pair);
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists(
                'continuousContractKlineCandlestickData',
                'contractType',
                contractType
            );
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('continuousContractKlineCandlestickData', 'interval', interval);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined && contractType !== null) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (interval !== undefined && interval !== null) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/continuousKlines',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Current exchange trading rules and symbol information
         *
         * Weight: 1
         *
         * @summary Exchange Information
         *
         * @throws {RequiredError}
         */
        exchangeInformation: async (): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/exchangeInfo',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get Funding Rate History
         *
         *
         * If `startTime` and `endTime` are not sent, the most recent `limit` datas are returned.
         * If the number of data between `startTime` and `endTime` is larger than `limit`, return as `startTime` + `limit`.
         * In ascending order.
         *
         * Weight: share 500/5min/IP rate limit with GET /fapi/v1/fundingInfo
         *
         * @summary Get Funding Rate History
         * @param {string} [symbol]
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        getFundingRateHistory: async (
            symbol?: string,
            startTime?: number,
            endTime?: number,
            limit?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/fundingRate',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
         *
         * Weight: 0
         * share 500/5min/IP rate limit with GET /fapi/v1/fundingInfo
         *
         * @summary Get Funding Rate Info
         *
         * @throws {RequiredError}
         */
        getFundingRateInfo: async (): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/fundingInfo',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * The BLVT NAV system is based on Binance Futures, so the endpoint is based on fapi
         *
         * Weight: 1
         *
         * @summary Historical BLVT NAV Kline/Candlestick
         * @param {string} symbol
         * @param {HistoricalBlvtNavKlineCandlestickIntervalEnum} interval
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        historicalBlvtNavKlineCandlestick: async (
            symbol: string,
            interval: HistoricalBlvtNavKlineCandlestickIntervalEnum,
            startTime?: number,
            endTime?: number,
            limit?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('historicalBlvtNavKlineCandlestick', 'symbol', symbol);
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('historicalBlvtNavKlineCandlestick', 'interval', interval);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined && interval !== null) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/lvtKlines',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Kline/candlestick bars for the index price of a pair.
         * Klines are uniquely identified by their open time.
         *
         *
         * If startTime and endTime are not sent, the most recent klines are returned.
         *
         * Weight: based on parameter LIMIT
         * | LIMIT       | weight |
         * | ----------- | ------ |
         * | [1,100)     | 1      |
         * | [100, 500)  | 2      |
         * | [500, 1000] | 5      |
         * | > 1000      | 10     |
         *
         * @summary Index Price Kline/Candlestick Data
         * @param {string} pair
         * @param {IndexPriceKlineCandlestickDataIntervalEnum} interval
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        indexPriceKlineCandlestickData: async (
            pair: string,
            interval: IndexPriceKlineCandlestickDataIntervalEnum,
            startTime?: number,
            endTime?: number,
            limit?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('indexPriceKlineCandlestickData', 'pair', pair);
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('indexPriceKlineCandlestickData', 'interval', interval);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }

            if (interval !== undefined && interval !== null) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/indexPriceKlines',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Kline/candlestick bars for a symbol.
         * Klines are uniquely identified by their open time.
         *
         * If startTime and endTime are not sent, the most recent klines are returned.
         *
         * Weight: based on parameter LIMIT
         * | LIMIT       | weight |
         * | ----------- | ------ |
         * | [1,100)     | 1      |
         * | [100, 500)  | 2      |
         * | [500, 1000] | 5      |
         * | > 1000      | 10     |
         *
         * @summary Kline/Candlestick Data
         * @param {string} symbol
         * @param {KlineCandlestickDataIntervalEnum} interval
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        klineCandlestickData: async (
            symbol: string,
            interval: KlineCandlestickDataIntervalEnum,
            startTime?: number,
            endTime?: number,
            limit?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('klineCandlestickData', 'symbol', symbol);
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('klineCandlestickData', 'interval', interval);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined && interval !== null) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/klines',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query symbol Long/Short Ratio
         *
         * If startTime and endTime are not sent, the most recent data is returned.
         * Only the data of the latest 30 days is available.
         * IP rate limit 1000 requests/5min
         *
         * Weight: 0
         *
         * @summary Long/Short Ratio
         * @param {string} symbol
         * @param {LongShortRatioPeriodEnum} period "5m","15m","30m","1h","2h","4h","6h","12h","1d"
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [startTime]
         * @param {number} [endTime]
         *
         * @throws {RequiredError}
         */
        longShortRatio: async (
            symbol: string,
            period: LongShortRatioPeriodEnum,
            limit?: number,
            startTime?: number,
            endTime?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('longShortRatio', 'symbol', symbol);
            // verify required parameter 'period' is not null or undefined
            assertParamExists('longShortRatio', 'period', period);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined && period !== null) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/futures/data/globalLongShortAccountRatio',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Mark Price and Funding Rate
         *
         * Weight: 1
         *
         * @summary Mark Price
         * @param {string} [symbol]
         *
         * @throws {RequiredError}
         */
        markPrice: async (symbol?: string): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/premiumIndex',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Kline/candlestick bars for the mark price of a symbol.
         * Klines are uniquely identified by their open time.
         *
         * If startTime and endTime are not sent, the most recent klines are returned.
         *
         * Weight: based on parameter LIMIT
         * | LIMIT       | weight |
         * | ----------- | ------ |
         * | [1,100)     | 1      |
         * | [100, 500)  | 2      |
         * | [500, 1000] | 5      |
         * | > 1000      | 10     |
         *
         * @summary Mark Price Kline/Candlestick Data
         * @param {string} symbol
         * @param {MarkPriceKlineCandlestickDataIntervalEnum} interval
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        markPriceKlineCandlestickData: async (
            symbol: string,
            interval: MarkPriceKlineCandlestickDataIntervalEnum,
            startTime?: number,
            endTime?: number,
            limit?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('markPriceKlineCandlestickData', 'symbol', symbol);
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('markPriceKlineCandlestickData', 'interval', interval);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined && interval !== null) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/markPriceKlines',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * asset index for Multi-Assets mode
         *
         * Weight: 1 for a single symbol; 10 when the symbol parameter is omitted
         *
         * @summary Multi-Assets Mode Asset Index
         * @param {string} [symbol]
         *
         * @throws {RequiredError}
         */
        multiAssetsModeAssetIndex: async (symbol?: string): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/assetIndex',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get older market historical trades.
         *
         * Market trades means trades filled in the order book. Only market trades will be returned, which means the insurance fund trades and ADL trades won't be returned.
         * Only supports data from within the last three months
         *
         * Weight: 20
         *
         * @summary Old Trades Lookup (MARKET_DATA)
         * @param {string} symbol
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [fromId] ID to get aggregate trades from INCLUSIVE.
         *
         * @throws {RequiredError}
         */
        oldTradesLookup: async (
            symbol: string,
            limit?: number,
            fromId?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('oldTradesLookup', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fromId !== undefined && fromId !== null) {
                localVarQueryParameter['fromId'] = fromId;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/historicalTrades',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get present open interest of a specific symbol.
         *
         * Weight: 1
         *
         * @summary Open Interest
         * @param {string} symbol
         *
         * @throws {RequiredError}
         */
        openInterest: async (symbol: string): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('openInterest', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/openInterest',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Open Interest Statistics
         *
         * If startTime and endTime are not sent, the most recent data is returned.
         * Only the data of the latest 1 month is available.
         * IP rate limit 1000 requests/5min
         *
         * Weight: 0
         *
         * @summary Open Interest Statistics
         * @param {string} symbol
         * @param {OpenInterestStatisticsPeriodEnum} period "5m","15m","30m","1h","2h","4h","6h","12h","1d"
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [startTime]
         * @param {number} [endTime]
         *
         * @throws {RequiredError}
         */
        openInterestStatistics: async (
            symbol: string,
            period: OpenInterestStatisticsPeriodEnum,
            limit?: number,
            startTime?: number,
            endTime?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('openInterestStatistics', 'symbol', symbol);
            // verify required parameter 'period' is not null or undefined
            assertParamExists('openInterestStatistics', 'period', period);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined && period !== null) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/futures/data/openInterestHist',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query symbol orderbook
         *
         * Weight: Adjusted based on the limit:
         * | Limit         | Weight |
         * | ------------- | ------ |
         * | 5, 10, 20, 50 | 2      |
         * | 100           | 5      |
         * | 500           | 10     |
         * | 1000          | 20     |
         *
         * @summary Order Book
         * @param {string} symbol
         * @param {number} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        orderBook: async (symbol: string, limit?: number): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('orderBook', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/depth',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
         *
         *
         * If startTime and endTime are not sent, the most recent klines are returned.
         *
         * Weight: based on parameter LIMIT
         * | LIMIT       | weight |
         * | ----------- | ------ |
         * | [1,100)     | 1      |
         * | [100, 500)  | 2      |
         * | [500, 1000] | 5      |
         * | > 1000      | 10     |
         *
         * @summary Premium index Kline Data
         * @param {string} symbol
         * @param {PremiumIndexKlineDataIntervalEnum} interval
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        premiumIndexKlineData: async (
            symbol: string,
            interval: PremiumIndexKlineDataIntervalEnum,
            startTime?: number,
            endTime?: number,
            limit?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('premiumIndexKlineData', 'symbol', symbol);
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('premiumIndexKlineData', 'interval', interval);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined && interval !== null) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/premiumIndexKlines',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Latest price for a symbol or symbols.
         *
         * Weight: 0
         *
         * @summary Quarterly Contract Settlement Price
         * @param {string} pair
         *
         * @throws {RequiredError}
         */
        quarterlyContractSettlementPrice: async (pair: string): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('quarterlyContractSettlementPrice', 'pair', pair);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/futures/data/delivery-price',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query index price constituents
         *
         * Weight: 2
         *
         * @summary Query Index Price Constituents
         * @param {string} symbol
         *
         * @throws {RequiredError}
         */
        queryIndexPriceConstituents: async (symbol: string): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryIndexPriceConstituents', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/constituents',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get recent market trades
         *
         * Market trades means trades filled in the order book. Only market trades will be returned, which means the insurance fund trades and ADL trades won't be returned.
         *
         * Weight: 5
         *
         * @summary Recent Trades List
         * @param {string} symbol
         * @param {number} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        recentTradesList: async (symbol: string, limit?: number): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('recentTradesList', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/trades',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         *
         * If the symbol is not sent, bookTickers for all symbols will be returned in an array.
         * The field `X-MBX-USED-WEIGHT-1M` in response header is not accurate from this endpoint, please ignore.
         *
         * Weight: 2 for a single symbol;
         * 5 when the symbol parameter is omitted
         *
         * @summary Symbol Order Book Ticker
         * @param {string} [symbol]
         *
         * @throws {RequiredError}
         */
        symbolOrderBookTicker: async (symbol?: string): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/ticker/bookTicker',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Latest price for a symbol or symbols.
         *
         * If the symbol is not sent, prices for all symbols will be returned in an array.
         *
         * Weight: 1 for a single symbol;
         * 2 when the symbol parameter is omitted
         *
         * @summary Symbol Price Ticker
         * @param {string} [symbol]
         *
         * @throws {RequiredError}
         */
        symbolPriceTicker: async (symbol?: string): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/ticker/price',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Latest price for a symbol or symbols.
         *
         * If the symbol is not sent, prices for all symbols will be returned in an array.
         * The field `X-MBX-USED-WEIGHT-1M` in response header is not accurate from this endpoint, please ignore.
         *
         * Weight: 1 for a single symbol;
         * 2 when the symbol parameter is omitted
         *
         * @summary Symbol Price Ticker V2
         * @param {string} [symbol]
         *
         * @throws {RequiredError}
         */
        symbolPriceTickerV2: async (symbol?: string): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v2/ticker/price',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Taker Buy/Sell Volume
         *
         * If startTime and endTime are not sent, the most recent data is returned.
         * Only the data of the latest 30 days is available.
         * IP rate limit 1000 requests/5min
         *
         * Weight: 0
         *
         * @summary Taker Buy/Sell Volume
         * @param {string} symbol
         * @param {TakerBuySellVolumePeriodEnum} period "5m","15m","30m","1h","2h","4h","6h","12h","1d"
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [startTime]
         * @param {number} [endTime]
         *
         * @throws {RequiredError}
         */
        takerBuySellVolume: async (
            symbol: string,
            period: TakerBuySellVolumePeriodEnum,
            limit?: number,
            startTime?: number,
            endTime?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('takerBuySellVolume', 'symbol', symbol);
            // verify required parameter 'period' is not null or undefined
            assertParamExists('takerBuySellVolume', 'period', period);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined && period !== null) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/futures/data/takerlongshortRatio',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Test connectivity to the Rest API.
         *
         * Weight: 1
         *
         * @summary Test Connectivity
         *
         * @throws {RequiredError}
         */
        testConnectivity: async (): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/ping',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * 24 hour rolling window price change statistics.
         **Careful** when accessing this with no symbol.
         *
         * If the symbol is not sent, tickers for all symbols will be returned in an array.
         *
         * Weight: 1 for a single symbol;
         * 40 when the symbol parameter is omitted
         *
         * @summary 24hr Ticker Price Change Statistics
         * @param {string} [symbol]
         *
         * @throws {RequiredError}
         */
        ticker24hrPriceChangeStatistics: async (symbol?: string): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/fapi/v1/ticker/24hr',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only.
         * Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions
         * Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions
         * Long/Short Ratio (Accounts) = Long Account % / Short Account %
         *
         * If startTime and endTime are not sent, the most recent data is returned.
         * Only the data of the latest 30 days is available.
         * IP rate limit 1000 requests/5min
         *
         * Weight: 0
         *
         * @summary Top Trader Long/Short Ratio (Accounts)
         * @param {string} symbol
         * @param {TopTraderLongShortRatioAccountsPeriodEnum} period "5m","15m","30m","1h","2h","4h","6h","12h","1d"
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [startTime]
         * @param {number} [endTime]
         *
         * @throws {RequiredError}
         */
        topTraderLongShortRatioAccounts: async (
            symbol: string,
            period: TopTraderLongShortRatioAccountsPeriodEnum,
            limit?: number,
            startTime?: number,
            endTime?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('topTraderLongShortRatioAccounts', 'symbol', symbol);
            // verify required parameter 'period' is not null or undefined
            assertParamExists('topTraderLongShortRatioAccounts', 'period', period);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined && period !== null) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/futures/data/topLongShortAccountRatio',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance.
         * Long Position % = Long positions of top traders / Total open positions of top traders
         * Short Position % = Short positions of top traders / Total open positions of top traders
         * Long/Short Ratio (Positions) = Long Position % / Short Position %
         *
         * If startTime and endTime are not sent, the most recent data is returned.
         * Only the data of the latest 30 days is available.
         * IP rate limit 1000 requests/5min
         *
         * Weight: 0
         *
         * @summary Top Trader Long/Short Ratio (Positions)
         * @param {string} symbol
         * @param {TopTraderLongShortRatioPositionsPeriodEnum} period "5m","15m","30m","1h","2h","4h","6h","12h","1d"
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [startTime]
         * @param {number} [endTime]
         *
         * @throws {RequiredError}
         */
        topTraderLongShortRatioPositions: async (
            symbol: string,
            period: TopTraderLongShortRatioPositionsPeriodEnum,
            limit?: number,
            startTime?: number,
            endTime?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('topTraderLongShortRatioPositions', 'symbol', symbol);
            // verify required parameter 'period' is not null or undefined
            assertParamExists('topTraderLongShortRatioPositions', 'period', period);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined && period !== null) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/futures/data/topLongShortPositionRatio',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
    };
};

/**
 * MarketDataApi - interface
 * @interface MarketDataApi
 */
export interface MarketDataApiInterface {
    /**
     * Query future basis
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     *
     * Weight: 0
     *
     * @summary Basis
     * @param {BasisRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    basis(requestParameters: BasisRequest): Promise<RestApiResponse<BasisResponse>>;
    /**
     * Test connectivity to the Rest API and get the current server time.
     *
     * Weight: 1
     *
     * @summary Check Server Time
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    checkServerTime(): Promise<RestApiResponse<CheckServerTimeResponse>>;
    /**
     * Query composite index symbol information
     *
     * Only for composite index symbols
     *
     * Weight: 1
     *
     * @summary Composite Index Symbol Information
     * @param {CompositeIndexSymbolInformationRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    compositeIndexSymbolInformation(
        requestParameters?: CompositeIndexSymbolInformationRequest
    ): Promise<RestApiResponse<CompositeIndexSymbolInformationResponse>>;
    /**
     * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
     *
     *
     * support querying futures trade histories that are not older than one year
     * If both `startTime` and `endTime` are sent, time between `startTime` and `endTime` must be less than 1 hour.
     * If `fromId`, `startTime`, and `endTime` are not sent, the most recent aggregate trades will be returned.
     * Only market trades will be aggregated and returned, which means the insurance fund trades and ADL trades won't be aggregated.
     * Sending both `startTime`/`endTime` and `fromId` might cause response timeout, please send either `fromId` or `startTime`/`endTime`
     *
     * Weight: 20
     *
     * @summary Compressed/Aggregate Trades List
     * @param {CompressedAggregateTradesListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    compressedAggregateTradesList(
        requestParameters: CompressedAggregateTradesListRequest
    ): Promise<RestApiResponse<CompressedAggregateTradesListResponse>>;
    /**
     * Kline/candlestick bars for a specific contract type.
     * Klines are uniquely identified by their open time.
     *
     * If startTime and endTime are not sent, the most recent klines are returned.
     * Contract type:
     * PERPETUAL
     * CURRENT_QUARTER
     * NEXT_QUARTER
     *
     * Weight: based on parameter LIMIT
     * | LIMIT       | weight |
     * | ----------- | ------ |
     * | [1,100)     | 1      |
     * | [100, 500)  | 2      |
     * | [500, 1000] | 5      |
     * | > 1000      | 10     |
     *
     * @summary Continuous Contract Kline/Candlestick Data
     * @param {ContinuousContractKlineCandlestickDataRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    continuousContractKlineCandlestickData(
        requestParameters: ContinuousContractKlineCandlestickDataRequest
    ): Promise<RestApiResponse<ContinuousContractKlineCandlestickDataResponse>>;
    /**
     * Current exchange trading rules and symbol information
     *
     * Weight: 1
     *
     * @summary Exchange Information
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    exchangeInformation(): Promise<RestApiResponse<ExchangeInformationResponse>>;
    /**
     * Get Funding Rate History
     *
     *
     * If `startTime` and `endTime` are not sent, the most recent `limit` datas are returned.
     * If the number of data between `startTime` and `endTime` is larger than `limit`, return as `startTime` + `limit`.
     * In ascending order.
     *
     * Weight: share 500/5min/IP rate limit with GET /fapi/v1/fundingInfo
     *
     * @summary Get Funding Rate History
     * @param {GetFundingRateHistoryRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    getFundingRateHistory(
        requestParameters?: GetFundingRateHistoryRequest
    ): Promise<RestApiResponse<GetFundingRateHistoryResponse>>;
    /**
     * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
     *
     * Weight: 0
     * share 500/5min/IP rate limit with GET /fapi/v1/fundingInfo
     *
     * @summary Get Funding Rate Info
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    getFundingRateInfo(): Promise<RestApiResponse<GetFundingRateInfoResponse>>;
    /**
     * The BLVT NAV system is based on Binance Futures, so the endpoint is based on fapi
     *
     * Weight: 1
     *
     * @summary Historical BLVT NAV Kline/Candlestick
     * @param {HistoricalBlvtNavKlineCandlestickRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    historicalBlvtNavKlineCandlestick(
        requestParameters: HistoricalBlvtNavKlineCandlestickRequest
    ): Promise<RestApiResponse<HistoricalBlvtNavKlineCandlestickResponse>>;
    /**
     * Kline/candlestick bars for the index price of a pair.
     * Klines are uniquely identified by their open time.
     *
     *
     * If startTime and endTime are not sent, the most recent klines are returned.
     *
     * Weight: based on parameter LIMIT
     * | LIMIT       | weight |
     * | ----------- | ------ |
     * | [1,100)     | 1      |
     * | [100, 500)  | 2      |
     * | [500, 1000] | 5      |
     * | > 1000      | 10     |
     *
     * @summary Index Price Kline/Candlestick Data
     * @param {IndexPriceKlineCandlestickDataRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    indexPriceKlineCandlestickData(
        requestParameters: IndexPriceKlineCandlestickDataRequest
    ): Promise<RestApiResponse<IndexPriceKlineCandlestickDataResponse>>;
    /**
     * Kline/candlestick bars for a symbol.
     * Klines are uniquely identified by their open time.
     *
     * If startTime and endTime are not sent, the most recent klines are returned.
     *
     * Weight: based on parameter LIMIT
     * | LIMIT       | weight |
     * | ----------- | ------ |
     * | [1,100)     | 1      |
     * | [100, 500)  | 2      |
     * | [500, 1000] | 5      |
     * | > 1000      | 10     |
     *
     * @summary Kline/Candlestick Data
     * @param {KlineCandlestickDataRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    klineCandlestickData(
        requestParameters: KlineCandlestickDataRequest
    ): Promise<RestApiResponse<KlineCandlestickDataResponse>>;
    /**
     * Query symbol Long/Short Ratio
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     * IP rate limit 1000 requests/5min
     *
     * Weight: 0
     *
     * @summary Long/Short Ratio
     * @param {LongShortRatioRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    longShortRatio(
        requestParameters: LongShortRatioRequest
    ): Promise<RestApiResponse<LongShortRatioResponse>>;
    /**
     * Mark Price and Funding Rate
     *
     * Weight: 1
     *
     * @summary Mark Price
     * @param {MarkPriceRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    markPrice(requestParameters?: MarkPriceRequest): Promise<RestApiResponse<MarkPriceResponse>>;
    /**
     * Kline/candlestick bars for the mark price of a symbol.
     * Klines are uniquely identified by their open time.
     *
     * If startTime and endTime are not sent, the most recent klines are returned.
     *
     * Weight: based on parameter LIMIT
     * | LIMIT       | weight |
     * | ----------- | ------ |
     * | [1,100)     | 1      |
     * | [100, 500)  | 2      |
     * | [500, 1000] | 5      |
     * | > 1000      | 10     |
     *
     * @summary Mark Price Kline/Candlestick Data
     * @param {MarkPriceKlineCandlestickDataRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    markPriceKlineCandlestickData(
        requestParameters: MarkPriceKlineCandlestickDataRequest
    ): Promise<RestApiResponse<MarkPriceKlineCandlestickDataResponse>>;
    /**
     * asset index for Multi-Assets mode
     *
     * Weight: 1 for a single symbol; 10 when the symbol parameter is omitted
     *
     * @summary Multi-Assets Mode Asset Index
     * @param {MultiAssetsModeAssetIndexRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    multiAssetsModeAssetIndex(
        requestParameters?: MultiAssetsModeAssetIndexRequest
    ): Promise<RestApiResponse<MultiAssetsModeAssetIndexResponse>>;
    /**
     * Get older market historical trades.
     *
     * Market trades means trades filled in the order book. Only market trades will be returned, which means the insurance fund trades and ADL trades won't be returned.
     * Only supports data from within the last three months
     *
     * Weight: 20
     *
     * @summary Old Trades Lookup (MARKET_DATA)
     * @param {OldTradesLookupRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    oldTradesLookup(
        requestParameters: OldTradesLookupRequest
    ): Promise<RestApiResponse<OldTradesLookupResponse>>;
    /**
     * Get present open interest of a specific symbol.
     *
     * Weight: 1
     *
     * @summary Open Interest
     * @param {OpenInterestRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    openInterest(
        requestParameters: OpenInterestRequest
    ): Promise<RestApiResponse<OpenInterestResponse>>;
    /**
     * Open Interest Statistics
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 1 month is available.
     * IP rate limit 1000 requests/5min
     *
     * Weight: 0
     *
     * @summary Open Interest Statistics
     * @param {OpenInterestStatisticsRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    openInterestStatistics(
        requestParameters: OpenInterestStatisticsRequest
    ): Promise<RestApiResponse<OpenInterestStatisticsResponse>>;
    /**
     * Query symbol orderbook
     *
     * Weight: Adjusted based on the limit:
     * | Limit         | Weight |
     * | ------------- | ------ |
     * | 5, 10, 20, 50 | 2      |
     * | 100           | 5      |
     * | 500           | 10     |
     * | 1000          | 20     |
     *
     * @summary Order Book
     * @param {OrderBookRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    orderBook(requestParameters: OrderBookRequest): Promise<RestApiResponse<OrderBookResponse>>;
    /**
     * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
     *
     *
     * If startTime and endTime are not sent, the most recent klines are returned.
     *
     * Weight: based on parameter LIMIT
     * | LIMIT       | weight |
     * | ----------- | ------ |
     * | [1,100)     | 1      |
     * | [100, 500)  | 2      |
     * | [500, 1000] | 5      |
     * | > 1000      | 10     |
     *
     * @summary Premium index Kline Data
     * @param {PremiumIndexKlineDataRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    premiumIndexKlineData(
        requestParameters: PremiumIndexKlineDataRequest
    ): Promise<RestApiResponse<PremiumIndexKlineDataResponse>>;
    /**
     * Latest price for a symbol or symbols.
     *
     * Weight: 0
     *
     * @summary Quarterly Contract Settlement Price
     * @param {QuarterlyContractSettlementPriceRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    quarterlyContractSettlementPrice(
        requestParameters: QuarterlyContractSettlementPriceRequest
    ): Promise<RestApiResponse<QuarterlyContractSettlementPriceResponse>>;
    /**
     * Query index price constituents
     *
     * Weight: 2
     *
     * @summary Query Index Price Constituents
     * @param {QueryIndexPriceConstituentsRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    queryIndexPriceConstituents(
        requestParameters: QueryIndexPriceConstituentsRequest
    ): Promise<RestApiResponse<QueryIndexPriceConstituentsResponse>>;
    /**
     * Get recent market trades
     *
     * Market trades means trades filled in the order book. Only market trades will be returned, which means the insurance fund trades and ADL trades won't be returned.
     *
     * Weight: 5
     *
     * @summary Recent Trades List
     * @param {RecentTradesListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    recentTradesList(
        requestParameters: RecentTradesListRequest
    ): Promise<RestApiResponse<RecentTradesListResponse>>;
    /**
     * Best price/qty on the order book for a symbol or symbols.
     *
     * If the symbol is not sent, bookTickers for all symbols will be returned in an array.
     * The field `X-MBX-USED-WEIGHT-1M` in response header is not accurate from this endpoint, please ignore.
     *
     * Weight: 2 for a single symbol;
     * 5 when the symbol parameter is omitted
     *
     * @summary Symbol Order Book Ticker
     * @param {SymbolOrderBookTickerRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    symbolOrderBookTicker(
        requestParameters?: SymbolOrderBookTickerRequest
    ): Promise<RestApiResponse<SymbolOrderBookTickerResponse>>;
    /**
     * Latest price for a symbol or symbols.
     *
     * If the symbol is not sent, prices for all symbols will be returned in an array.
     *
     * Weight: 1 for a single symbol;
     * 2 when the symbol parameter is omitted
     *
     * @summary Symbol Price Ticker
     * @param {SymbolPriceTickerRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    symbolPriceTicker(
        requestParameters?: SymbolPriceTickerRequest
    ): Promise<RestApiResponse<SymbolPriceTickerResponse>>;
    /**
     * Latest price for a symbol or symbols.
     *
     * If the symbol is not sent, prices for all symbols will be returned in an array.
     * The field `X-MBX-USED-WEIGHT-1M` in response header is not accurate from this endpoint, please ignore.
     *
     * Weight: 1 for a single symbol;
     * 2 when the symbol parameter is omitted
     *
     * @summary Symbol Price Ticker V2
     * @param {SymbolPriceTickerV2Request} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    symbolPriceTickerV2(
        requestParameters?: SymbolPriceTickerV2Request
    ): Promise<RestApiResponse<SymbolPriceTickerV2Response>>;
    /**
     * Taker Buy/Sell Volume
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     * IP rate limit 1000 requests/5min
     *
     * Weight: 0
     *
     * @summary Taker Buy/Sell Volume
     * @param {TakerBuySellVolumeRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    takerBuySellVolume(
        requestParameters: TakerBuySellVolumeRequest
    ): Promise<RestApiResponse<TakerBuySellVolumeResponse>>;
    /**
     * Test connectivity to the Rest API.
     *
     * Weight: 1
     *
     * @summary Test Connectivity
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    testConnectivity(): Promise<RestApiResponse<void>>;
    /**
     * 24 hour rolling window price change statistics.
     **Careful** when accessing this with no symbol.
     *
     * If the symbol is not sent, tickers for all symbols will be returned in an array.
     *
     * Weight: 1 for a single symbol;
     * 40 when the symbol parameter is omitted
     *
     * @summary 24hr Ticker Price Change Statistics
     * @param {Ticker24hrPriceChangeStatisticsRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    ticker24hrPriceChangeStatistics(
        requestParameters?: Ticker24hrPriceChangeStatisticsRequest
    ): Promise<RestApiResponse<Ticker24hrPriceChangeStatisticsResponse>>;
    /**
     * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only.
     * Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions
     * Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions
     * Long/Short Ratio (Accounts) = Long Account % / Short Account %
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     * IP rate limit 1000 requests/5min
     *
     * Weight: 0
     *
     * @summary Top Trader Long/Short Ratio (Accounts)
     * @param {TopTraderLongShortRatioAccountsRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    topTraderLongShortRatioAccounts(
        requestParameters: TopTraderLongShortRatioAccountsRequest
    ): Promise<RestApiResponse<TopTraderLongShortRatioAccountsResponse>>;
    /**
     * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance.
     * Long Position % = Long positions of top traders / Total open positions of top traders
     * Short Position % = Short positions of top traders / Total open positions of top traders
     * Long/Short Ratio (Positions) = Long Position % / Short Position %
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     * IP rate limit 1000 requests/5min
     *
     * Weight: 0
     *
     * @summary Top Trader Long/Short Ratio (Positions)
     * @param {TopTraderLongShortRatioPositionsRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    topTraderLongShortRatioPositions(
        requestParameters: TopTraderLongShortRatioPositionsRequest
    ): Promise<RestApiResponse<TopTraderLongShortRatioPositionsResponse>>;
}

/**
 * Request parameters for basis operation in MarketDataApi.
 * @interface BasisRequest
 */
export interface BasisRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiBasis
     */
    readonly pair: string;

    /**
     *
     * @type {'PERPETUAL' | 'CURRENT_MONTH' | 'NEXT_MONTH' | 'CURRENT_QUARTER' | 'NEXT_QUARTER' | 'PERPETUAL_DELIVERING'}
     * @memberof MarketDataApiBasis
     */
    readonly contractType: BasisContractTypeEnum;

    /**
     * "5m","15m","30m","1h","2h","4h","6h","12h","1d"
     * @type {'5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '12h' | '1d'}
     * @memberof MarketDataApiBasis
     */
    readonly period: BasisPeriodEnum;

    /**
     * Default 30,Max 500
     * @type {number}
     * @memberof MarketDataApiBasis
     */
    readonly limit: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiBasis
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiBasis
     */
    readonly endTime?: number;
}

/**
 * Request parameters for compositeIndexSymbolInformation operation in MarketDataApi.
 * @interface CompositeIndexSymbolInformationRequest
 */
export interface CompositeIndexSymbolInformationRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiCompositeIndexSymbolInformation
     */
    readonly symbol?: string;
}

/**
 * Request parameters for compressedAggregateTradesList operation in MarketDataApi.
 * @interface CompressedAggregateTradesListRequest
 */
export interface CompressedAggregateTradesListRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiCompressedAggregateTradesList
     */
    readonly symbol: string;

    /**
     * ID to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof MarketDataApiCompressedAggregateTradesList
     */
    readonly fromId?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiCompressedAggregateTradesList
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiCompressedAggregateTradesList
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiCompressedAggregateTradesList
     */
    readonly limit?: number;
}

/**
 * Request parameters for continuousContractKlineCandlestickData operation in MarketDataApi.
 * @interface ContinuousContractKlineCandlestickDataRequest
 */
export interface ContinuousContractKlineCandlestickDataRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiContinuousContractKlineCandlestickData
     */
    readonly pair: string;

    /**
     *
     * @type {'PERPETUAL' | 'CURRENT_MONTH' | 'NEXT_MONTH' | 'CURRENT_QUARTER' | 'NEXT_QUARTER' | 'PERPETUAL_DELIVERING'}
     * @memberof MarketDataApiContinuousContractKlineCandlestickData
     */
    readonly contractType: ContinuousContractKlineCandlestickDataContractTypeEnum;

    /**
     *
     * @type {'1m' | '3m' | '5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '8h' | '12h' | '1d' | '3d' | '1w' | '1M'}
     * @memberof MarketDataApiContinuousContractKlineCandlestickData
     */
    readonly interval: ContinuousContractKlineCandlestickDataIntervalEnum;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiContinuousContractKlineCandlestickData
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiContinuousContractKlineCandlestickData
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiContinuousContractKlineCandlestickData
     */
    readonly limit?: number;
}

/**
 * Request parameters for getFundingRateHistory operation in MarketDataApi.
 * @interface GetFundingRateHistoryRequest
 */
export interface GetFundingRateHistoryRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiGetFundingRateHistory
     */
    readonly symbol?: string;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiGetFundingRateHistory
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiGetFundingRateHistory
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiGetFundingRateHistory
     */
    readonly limit?: number;
}

/**
 * Request parameters for historicalBlvtNavKlineCandlestick operation in MarketDataApi.
 * @interface HistoricalBlvtNavKlineCandlestickRequest
 */
export interface HistoricalBlvtNavKlineCandlestickRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiHistoricalBlvtNavKlineCandlestick
     */
    readonly symbol: string;

    /**
     *
     * @type {'1m' | '3m' | '5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '8h' | '12h' | '1d' | '3d' | '1w' | '1M'}
     * @memberof MarketDataApiHistoricalBlvtNavKlineCandlestick
     */
    readonly interval: HistoricalBlvtNavKlineCandlestickIntervalEnum;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiHistoricalBlvtNavKlineCandlestick
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiHistoricalBlvtNavKlineCandlestick
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiHistoricalBlvtNavKlineCandlestick
     */
    readonly limit?: number;
}

/**
 * Request parameters for indexPriceKlineCandlestickData operation in MarketDataApi.
 * @interface IndexPriceKlineCandlestickDataRequest
 */
export interface IndexPriceKlineCandlestickDataRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiIndexPriceKlineCandlestickData
     */
    readonly pair: string;

    /**
     *
     * @type {'1m' | '3m' | '5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '8h' | '12h' | '1d' | '3d' | '1w' | '1M'}
     * @memberof MarketDataApiIndexPriceKlineCandlestickData
     */
    readonly interval: IndexPriceKlineCandlestickDataIntervalEnum;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiIndexPriceKlineCandlestickData
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiIndexPriceKlineCandlestickData
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiIndexPriceKlineCandlestickData
     */
    readonly limit?: number;
}

/**
 * Request parameters for klineCandlestickData operation in MarketDataApi.
 * @interface KlineCandlestickDataRequest
 */
export interface KlineCandlestickDataRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiKlineCandlestickData
     */
    readonly symbol: string;

    /**
     *
     * @type {'1m' | '3m' | '5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '8h' | '12h' | '1d' | '3d' | '1w' | '1M'}
     * @memberof MarketDataApiKlineCandlestickData
     */
    readonly interval: KlineCandlestickDataIntervalEnum;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiKlineCandlestickData
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiKlineCandlestickData
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiKlineCandlestickData
     */
    readonly limit?: number;
}

/**
 * Request parameters for longShortRatio operation in MarketDataApi.
 * @interface LongShortRatioRequest
 */
export interface LongShortRatioRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiLongShortRatio
     */
    readonly symbol: string;

    /**
     * "5m","15m","30m","1h","2h","4h","6h","12h","1d"
     * @type {'5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '12h' | '1d'}
     * @memberof MarketDataApiLongShortRatio
     */
    readonly period: LongShortRatioPeriodEnum;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiLongShortRatio
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiLongShortRatio
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiLongShortRatio
     */
    readonly endTime?: number;
}

/**
 * Request parameters for markPrice operation in MarketDataApi.
 * @interface MarkPriceRequest
 */
export interface MarkPriceRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiMarkPrice
     */
    readonly symbol?: string;
}

/**
 * Request parameters for markPriceKlineCandlestickData operation in MarketDataApi.
 * @interface MarkPriceKlineCandlestickDataRequest
 */
export interface MarkPriceKlineCandlestickDataRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiMarkPriceKlineCandlestickData
     */
    readonly symbol: string;

    /**
     *
     * @type {'1m' | '3m' | '5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '8h' | '12h' | '1d' | '3d' | '1w' | '1M'}
     * @memberof MarketDataApiMarkPriceKlineCandlestickData
     */
    readonly interval: MarkPriceKlineCandlestickDataIntervalEnum;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiMarkPriceKlineCandlestickData
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiMarkPriceKlineCandlestickData
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiMarkPriceKlineCandlestickData
     */
    readonly limit?: number;
}

/**
 * Request parameters for multiAssetsModeAssetIndex operation in MarketDataApi.
 * @interface MultiAssetsModeAssetIndexRequest
 */
export interface MultiAssetsModeAssetIndexRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiMultiAssetsModeAssetIndex
     */
    readonly symbol?: string;
}

/**
 * Request parameters for oldTradesLookup operation in MarketDataApi.
 * @interface OldTradesLookupRequest
 */
export interface OldTradesLookupRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiOldTradesLookup
     */
    readonly symbol: string;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiOldTradesLookup
     */
    readonly limit?: number;

    /**
     * ID to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof MarketDataApiOldTradesLookup
     */
    readonly fromId?: number;
}

/**
 * Request parameters for openInterest operation in MarketDataApi.
 * @interface OpenInterestRequest
 */
export interface OpenInterestRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiOpenInterest
     */
    readonly symbol: string;
}

/**
 * Request parameters for openInterestStatistics operation in MarketDataApi.
 * @interface OpenInterestStatisticsRequest
 */
export interface OpenInterestStatisticsRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiOpenInterestStatistics
     */
    readonly symbol: string;

    /**
     * "5m","15m","30m","1h","2h","4h","6h","12h","1d"
     * @type {'5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '12h' | '1d'}
     * @memberof MarketDataApiOpenInterestStatistics
     */
    readonly period: OpenInterestStatisticsPeriodEnum;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiOpenInterestStatistics
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiOpenInterestStatistics
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiOpenInterestStatistics
     */
    readonly endTime?: number;
}

/**
 * Request parameters for orderBook operation in MarketDataApi.
 * @interface OrderBookRequest
 */
export interface OrderBookRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiOrderBook
     */
    readonly symbol: string;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiOrderBook
     */
    readonly limit?: number;
}

/**
 * Request parameters for premiumIndexKlineData operation in MarketDataApi.
 * @interface PremiumIndexKlineDataRequest
 */
export interface PremiumIndexKlineDataRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiPremiumIndexKlineData
     */
    readonly symbol: string;

    /**
     *
     * @type {'1m' | '3m' | '5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '8h' | '12h' | '1d' | '3d' | '1w' | '1M'}
     * @memberof MarketDataApiPremiumIndexKlineData
     */
    readonly interval: PremiumIndexKlineDataIntervalEnum;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiPremiumIndexKlineData
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiPremiumIndexKlineData
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiPremiumIndexKlineData
     */
    readonly limit?: number;
}

/**
 * Request parameters for quarterlyContractSettlementPrice operation in MarketDataApi.
 * @interface QuarterlyContractSettlementPriceRequest
 */
export interface QuarterlyContractSettlementPriceRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiQuarterlyContractSettlementPrice
     */
    readonly pair: string;
}

/**
 * Request parameters for queryIndexPriceConstituents operation in MarketDataApi.
 * @interface QueryIndexPriceConstituentsRequest
 */
export interface QueryIndexPriceConstituentsRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiQueryIndexPriceConstituents
     */
    readonly symbol: string;
}

/**
 * Request parameters for recentTradesList operation in MarketDataApi.
 * @interface RecentTradesListRequest
 */
export interface RecentTradesListRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiRecentTradesList
     */
    readonly symbol: string;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiRecentTradesList
     */
    readonly limit?: number;
}

/**
 * Request parameters for symbolOrderBookTicker operation in MarketDataApi.
 * @interface SymbolOrderBookTickerRequest
 */
export interface SymbolOrderBookTickerRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiSymbolOrderBookTicker
     */
    readonly symbol?: string;
}

/**
 * Request parameters for symbolPriceTicker operation in MarketDataApi.
 * @interface SymbolPriceTickerRequest
 */
export interface SymbolPriceTickerRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiSymbolPriceTicker
     */
    readonly symbol?: string;
}

/**
 * Request parameters for symbolPriceTickerV2 operation in MarketDataApi.
 * @interface SymbolPriceTickerV2Request
 */
export interface SymbolPriceTickerV2Request {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiSymbolPriceTickerV2
     */
    readonly symbol?: string;
}

/**
 * Request parameters for takerBuySellVolume operation in MarketDataApi.
 * @interface TakerBuySellVolumeRequest
 */
export interface TakerBuySellVolumeRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiTakerBuySellVolume
     */
    readonly symbol: string;

    /**
     * "5m","15m","30m","1h","2h","4h","6h","12h","1d"
     * @type {'5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '12h' | '1d'}
     * @memberof MarketDataApiTakerBuySellVolume
     */
    readonly period: TakerBuySellVolumePeriodEnum;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiTakerBuySellVolume
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiTakerBuySellVolume
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiTakerBuySellVolume
     */
    readonly endTime?: number;
}

/**
 * Request parameters for ticker24hrPriceChangeStatistics operation in MarketDataApi.
 * @interface Ticker24hrPriceChangeStatisticsRequest
 */
export interface Ticker24hrPriceChangeStatisticsRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiTicker24hrPriceChangeStatistics
     */
    readonly symbol?: string;
}

/**
 * Request parameters for topTraderLongShortRatioAccounts operation in MarketDataApi.
 * @interface TopTraderLongShortRatioAccountsRequest
 */
export interface TopTraderLongShortRatioAccountsRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiTopTraderLongShortRatioAccounts
     */
    readonly symbol: string;

    /**
     * "5m","15m","30m","1h","2h","4h","6h","12h","1d"
     * @type {'5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '12h' | '1d'}
     * @memberof MarketDataApiTopTraderLongShortRatioAccounts
     */
    readonly period: TopTraderLongShortRatioAccountsPeriodEnum;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiTopTraderLongShortRatioAccounts
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiTopTraderLongShortRatioAccounts
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiTopTraderLongShortRatioAccounts
     */
    readonly endTime?: number;
}

/**
 * Request parameters for topTraderLongShortRatioPositions operation in MarketDataApi.
 * @interface TopTraderLongShortRatioPositionsRequest
 */
export interface TopTraderLongShortRatioPositionsRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiTopTraderLongShortRatioPositions
     */
    readonly symbol: string;

    /**
     * "5m","15m","30m","1h","2h","4h","6h","12h","1d"
     * @type {'5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '12h' | '1d'}
     * @memberof MarketDataApiTopTraderLongShortRatioPositions
     */
    readonly period: TopTraderLongShortRatioPositionsPeriodEnum;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiTopTraderLongShortRatioPositions
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiTopTraderLongShortRatioPositions
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiTopTraderLongShortRatioPositions
     */
    readonly endTime?: number;
}

/**
 * MarketDataApi - object-oriented interface
 * @class MarketDataApi
 */
export class MarketDataApi implements MarketDataApiInterface {
    private readonly configuration: ConfigurationRestAPI;
    private localVarAxiosParamCreator;

    constructor(configuration: ConfigurationRestAPI) {
        this.configuration = configuration;
        this.localVarAxiosParamCreator = MarketDataApiAxiosParamCreator(configuration);
    }

    /**
     * Query future basis
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     *
     * Weight: 0
     *
     * @summary Basis
     * @param {BasisRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<BasisResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Basis Binance API Documentation}
     */
    public async basis(requestParameters: BasisRequest): Promise<RestApiResponse<BasisResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.basis(
            requestParameters?.pair,
            requestParameters?.contractType,
            requestParameters?.period,
            requestParameters?.limit,
            requestParameters?.startTime,
            requestParameters?.endTime
        );
        return sendRequest<BasisResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Test connectivity to the Rest API and get the current server time.
     *
     * Weight: 1
     *
     * @summary Check Server Time
     * @returns {Promise<RestApiResponse<CheckServerTimeResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Check-Server-Time Binance API Documentation}
     */
    public async checkServerTime(): Promise<RestApiResponse<CheckServerTimeResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.checkServerTime();
        return sendRequest<CheckServerTimeResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Query composite index symbol information
     *
     * Only for composite index symbols
     *
     * Weight: 1
     *
     * @summary Composite Index Symbol Information
     * @param {CompositeIndexSymbolInformationRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CompositeIndexSymbolInformationResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Composite-Index-Symbol-Information Binance API Documentation}
     */
    public async compositeIndexSymbolInformation(
        requestParameters: CompositeIndexSymbolInformationRequest = {}
    ): Promise<RestApiResponse<CompositeIndexSymbolInformationResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.compositeIndexSymbolInformation(
                requestParameters?.symbol
            );
        return sendRequest<CompositeIndexSymbolInformationResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Get compressed, aggregate market trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
     *
     *
     * support querying futures trade histories that are not older than one year
     * If both `startTime` and `endTime` are sent, time between `startTime` and `endTime` must be less than 1 hour.
     * If `fromId`, `startTime`, and `endTime` are not sent, the most recent aggregate trades will be returned.
     * Only market trades will be aggregated and returned, which means the insurance fund trades and ADL trades won't be aggregated.
     * Sending both `startTime`/`endTime` and `fromId` might cause response timeout, please send either `fromId` or `startTime`/`endTime`
     *
     * Weight: 20
     *
     * @summary Compressed/Aggregate Trades List
     * @param {CompressedAggregateTradesListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CompressedAggregateTradesListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Compressed-Aggregate-Trades-List Binance API Documentation}
     */
    public async compressedAggregateTradesList(
        requestParameters: CompressedAggregateTradesListRequest
    ): Promise<RestApiResponse<CompressedAggregateTradesListResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.compressedAggregateTradesList(
                requestParameters?.symbol,
                requestParameters?.fromId,
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.limit
            );
        return sendRequest<CompressedAggregateTradesListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Kline/candlestick bars for a specific contract type.
     * Klines are uniquely identified by their open time.
     *
     * If startTime and endTime are not sent, the most recent klines are returned.
     * Contract type:
     * PERPETUAL
     * CURRENT_QUARTER
     * NEXT_QUARTER
     *
     * Weight: based on parameter LIMIT
     * | LIMIT       | weight |
     * | ----------- | ------ |
     * | [1,100)     | 1      |
     * | [100, 500)  | 2      |
     * | [500, 1000] | 5      |
     * | > 1000      | 10     |
     *
     * @summary Continuous Contract Kline/Candlestick Data
     * @param {ContinuousContractKlineCandlestickDataRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ContinuousContractKlineCandlestickDataResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Continuous-Contract-Kline-Candlestick-Data Binance API Documentation}
     */
    public async continuousContractKlineCandlestickData(
        requestParameters: ContinuousContractKlineCandlestickDataRequest
    ): Promise<RestApiResponse<ContinuousContractKlineCandlestickDataResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.continuousContractKlineCandlestickData(
                requestParameters?.pair,
                requestParameters?.contractType,
                requestParameters?.interval,
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.limit
            );
        return sendRequest<ContinuousContractKlineCandlestickDataResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Current exchange trading rules and symbol information
     *
     * Weight: 1
     *
     * @summary Exchange Information
     * @returns {Promise<RestApiResponse<ExchangeInformationResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Exchange-Information Binance API Documentation}
     */
    public async exchangeInformation(): Promise<RestApiResponse<ExchangeInformationResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.exchangeInformation();
        return sendRequest<ExchangeInformationResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Get Funding Rate History
     *
     *
     * If `startTime` and `endTime` are not sent, the most recent `limit` datas are returned.
     * If the number of data between `startTime` and `endTime` is larger than `limit`, return as `startTime` + `limit`.
     * In ascending order.
     *
     * Weight: share 500/5min/IP rate limit with GET /fapi/v1/fundingInfo
     *
     * @summary Get Funding Rate History
     * @param {GetFundingRateHistoryRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetFundingRateHistoryResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Get-Funding-Rate-History Binance API Documentation}
     */
    public async getFundingRateHistory(
        requestParameters: GetFundingRateHistoryRequest = {}
    ): Promise<RestApiResponse<GetFundingRateHistoryResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getFundingRateHistory(
            requestParameters?.symbol,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit
        );
        return sendRequest<GetFundingRateHistoryResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
     *
     * Weight: 0
     * share 500/5min/IP rate limit with GET /fapi/v1/fundingInfo
     *
     * @summary Get Funding Rate Info
     * @returns {Promise<RestApiResponse<GetFundingRateInfoResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Get-Funding-Rate-Info Binance API Documentation}
     */
    public async getFundingRateInfo(): Promise<RestApiResponse<GetFundingRateInfoResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getFundingRateInfo();
        return sendRequest<GetFundingRateInfoResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * The BLVT NAV system is based on Binance Futures, so the endpoint is based on fapi
     *
     * Weight: 1
     *
     * @summary Historical BLVT NAV Kline/Candlestick
     * @param {HistoricalBlvtNavKlineCandlestickRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<HistoricalBlvtNavKlineCandlestickResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Historical-BLVT-NAV-Kline-Candlestick Binance API Documentation}
     */
    public async historicalBlvtNavKlineCandlestick(
        requestParameters: HistoricalBlvtNavKlineCandlestickRequest
    ): Promise<RestApiResponse<HistoricalBlvtNavKlineCandlestickResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.historicalBlvtNavKlineCandlestick(
                requestParameters?.symbol,
                requestParameters?.interval,
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.limit
            );
        return sendRequest<HistoricalBlvtNavKlineCandlestickResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Kline/candlestick bars for the index price of a pair.
     * Klines are uniquely identified by their open time.
     *
     *
     * If startTime and endTime are not sent, the most recent klines are returned.
     *
     * Weight: based on parameter LIMIT
     * | LIMIT       | weight |
     * | ----------- | ------ |
     * | [1,100)     | 1      |
     * | [100, 500)  | 2      |
     * | [500, 1000] | 5      |
     * | > 1000      | 10     |
     *
     * @summary Index Price Kline/Candlestick Data
     * @param {IndexPriceKlineCandlestickDataRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<IndexPriceKlineCandlestickDataResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Index-Price-Kline-Candlestick-Data Binance API Documentation}
     */
    public async indexPriceKlineCandlestickData(
        requestParameters: IndexPriceKlineCandlestickDataRequest
    ): Promise<RestApiResponse<IndexPriceKlineCandlestickDataResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.indexPriceKlineCandlestickData(
                requestParameters?.pair,
                requestParameters?.interval,
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.limit
            );
        return sendRequest<IndexPriceKlineCandlestickDataResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Kline/candlestick bars for a symbol.
     * Klines are uniquely identified by their open time.
     *
     * If startTime and endTime are not sent, the most recent klines are returned.
     *
     * Weight: based on parameter LIMIT
     * | LIMIT       | weight |
     * | ----------- | ------ |
     * | [1,100)     | 1      |
     * | [100, 500)  | 2      |
     * | [500, 1000] | 5      |
     * | > 1000      | 10     |
     *
     * @summary Kline/Candlestick Data
     * @param {KlineCandlestickDataRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<KlineCandlestickDataResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Kline-Candlestick-Data Binance API Documentation}
     */
    public async klineCandlestickData(
        requestParameters: KlineCandlestickDataRequest
    ): Promise<RestApiResponse<KlineCandlestickDataResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.klineCandlestickData(
            requestParameters?.symbol,
            requestParameters?.interval,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit
        );
        return sendRequest<KlineCandlestickDataResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Query symbol Long/Short Ratio
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     * IP rate limit 1000 requests/5min
     *
     * Weight: 0
     *
     * @summary Long/Short Ratio
     * @param {LongShortRatioRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<LongShortRatioResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Long-Short-Ratio Binance API Documentation}
     */
    public async longShortRatio(
        requestParameters: LongShortRatioRequest
    ): Promise<RestApiResponse<LongShortRatioResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.longShortRatio(
            requestParameters?.symbol,
            requestParameters?.period,
            requestParameters?.limit,
            requestParameters?.startTime,
            requestParameters?.endTime
        );
        return sendRequest<LongShortRatioResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Mark Price and Funding Rate
     *
     * Weight: 1
     *
     * @summary Mark Price
     * @param {MarkPriceRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MarkPriceResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Mark-Price Binance API Documentation}
     */
    public async markPrice(
        requestParameters: MarkPriceRequest = {}
    ): Promise<RestApiResponse<MarkPriceResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.markPrice(
            requestParameters?.symbol
        );
        return sendRequest<MarkPriceResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Kline/candlestick bars for the mark price of a symbol.
     * Klines are uniquely identified by their open time.
     *
     * If startTime and endTime are not sent, the most recent klines are returned.
     *
     * Weight: based on parameter LIMIT
     * | LIMIT       | weight |
     * | ----------- | ------ |
     * | [1,100)     | 1      |
     * | [100, 500)  | 2      |
     * | [500, 1000] | 5      |
     * | > 1000      | 10     |
     *
     * @summary Mark Price Kline/Candlestick Data
     * @param {MarkPriceKlineCandlestickDataRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MarkPriceKlineCandlestickDataResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Mark-Price-Kline-Candlestick-Data Binance API Documentation}
     */
    public async markPriceKlineCandlestickData(
        requestParameters: MarkPriceKlineCandlestickDataRequest
    ): Promise<RestApiResponse<MarkPriceKlineCandlestickDataResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.markPriceKlineCandlestickData(
                requestParameters?.symbol,
                requestParameters?.interval,
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.limit
            );
        return sendRequest<MarkPriceKlineCandlestickDataResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * asset index for Multi-Assets mode
     *
     * Weight: 1 for a single symbol; 10 when the symbol parameter is omitted
     *
     * @summary Multi-Assets Mode Asset Index
     * @param {MultiAssetsModeAssetIndexRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MultiAssetsModeAssetIndexResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Multi-Assets-Mode-Asset-Index Binance API Documentation}
     */
    public async multiAssetsModeAssetIndex(
        requestParameters: MultiAssetsModeAssetIndexRequest = {}
    ): Promise<RestApiResponse<MultiAssetsModeAssetIndexResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.multiAssetsModeAssetIndex(
            requestParameters?.symbol
        );
        return sendRequest<MultiAssetsModeAssetIndexResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Get older market historical trades.
     *
     * Market trades means trades filled in the order book. Only market trades will be returned, which means the insurance fund trades and ADL trades won't be returned.
     * Only supports data from within the last three months
     *
     * Weight: 20
     *
     * @summary Old Trades Lookup (MARKET_DATA)
     * @param {OldTradesLookupRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OldTradesLookupResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Old-Trades-Lookup Binance API Documentation}
     */
    public async oldTradesLookup(
        requestParameters: OldTradesLookupRequest
    ): Promise<RestApiResponse<OldTradesLookupResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.oldTradesLookup(
            requestParameters?.symbol,
            requestParameters?.limit,
            requestParameters?.fromId
        );
        return sendRequest<OldTradesLookupResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Get present open interest of a specific symbol.
     *
     * Weight: 1
     *
     * @summary Open Interest
     * @param {OpenInterestRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OpenInterestResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Open-Interest Binance API Documentation}
     */
    public async openInterest(
        requestParameters: OpenInterestRequest
    ): Promise<RestApiResponse<OpenInterestResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.openInterest(
            requestParameters?.symbol
        );
        return sendRequest<OpenInterestResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Open Interest Statistics
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 1 month is available.
     * IP rate limit 1000 requests/5min
     *
     * Weight: 0
     *
     * @summary Open Interest Statistics
     * @param {OpenInterestStatisticsRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OpenInterestStatisticsResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Open-Interest-Statistics Binance API Documentation}
     */
    public async openInterestStatistics(
        requestParameters: OpenInterestStatisticsRequest
    ): Promise<RestApiResponse<OpenInterestStatisticsResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.openInterestStatistics(
            requestParameters?.symbol,
            requestParameters?.period,
            requestParameters?.limit,
            requestParameters?.startTime,
            requestParameters?.endTime
        );
        return sendRequest<OpenInterestStatisticsResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Query symbol orderbook
     *
     * Weight: Adjusted based on the limit:
     * | Limit         | Weight |
     * | ------------- | ------ |
     * | 5, 10, 20, 50 | 2      |
     * | 100           | 5      |
     * | 500           | 10     |
     * | 1000          | 20     |
     *
     * @summary Order Book
     * @param {OrderBookRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OrderBookResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Order-Book Binance API Documentation}
     */
    public async orderBook(
        requestParameters: OrderBookRequest
    ): Promise<RestApiResponse<OrderBookResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderBook(
            requestParameters?.symbol,
            requestParameters?.limit
        );
        return sendRequest<OrderBookResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
     *
     *
     * If startTime and endTime are not sent, the most recent klines are returned.
     *
     * Weight: based on parameter LIMIT
     * | LIMIT       | weight |
     * | ----------- | ------ |
     * | [1,100)     | 1      |
     * | [100, 500)  | 2      |
     * | [500, 1000] | 5      |
     * | > 1000      | 10     |
     *
     * @summary Premium index Kline Data
     * @param {PremiumIndexKlineDataRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<PremiumIndexKlineDataResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Premium-index-Kline-Data Binance API Documentation}
     */
    public async premiumIndexKlineData(
        requestParameters: PremiumIndexKlineDataRequest
    ): Promise<RestApiResponse<PremiumIndexKlineDataResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.premiumIndexKlineData(
            requestParameters?.symbol,
            requestParameters?.interval,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit
        );
        return sendRequest<PremiumIndexKlineDataResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Latest price for a symbol or symbols.
     *
     * Weight: 0
     *
     * @summary Quarterly Contract Settlement Price
     * @param {QuarterlyContractSettlementPriceRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QuarterlyContractSettlementPriceResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Delivery-Price Binance API Documentation}
     */
    public async quarterlyContractSettlementPrice(
        requestParameters: QuarterlyContractSettlementPriceRequest
    ): Promise<RestApiResponse<QuarterlyContractSettlementPriceResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.quarterlyContractSettlementPrice(
                requestParameters?.pair
            );
        return sendRequest<QuarterlyContractSettlementPriceResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Query index price constituents
     *
     * Weight: 2
     *
     * @summary Query Index Price Constituents
     * @param {QueryIndexPriceConstituentsRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryIndexPriceConstituentsResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Index-Constituents Binance API Documentation}
     */
    public async queryIndexPriceConstituents(
        requestParameters: QueryIndexPriceConstituentsRequest
    ): Promise<RestApiResponse<QueryIndexPriceConstituentsResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryIndexPriceConstituents(
            requestParameters?.symbol
        );
        return sendRequest<QueryIndexPriceConstituentsResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Get recent market trades
     *
     * Market trades means trades filled in the order book. Only market trades will be returned, which means the insurance fund trades and ADL trades won't be returned.
     *
     * Weight: 5
     *
     * @summary Recent Trades List
     * @param {RecentTradesListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<RecentTradesListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Recent-Trades-List Binance API Documentation}
     */
    public async recentTradesList(
        requestParameters: RecentTradesListRequest
    ): Promise<RestApiResponse<RecentTradesListResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.recentTradesList(
            requestParameters?.symbol,
            requestParameters?.limit
        );
        return sendRequest<RecentTradesListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Best price/qty on the order book for a symbol or symbols.
     *
     * If the symbol is not sent, bookTickers for all symbols will be returned in an array.
     * The field `X-MBX-USED-WEIGHT-1M` in response header is not accurate from this endpoint, please ignore.
     *
     * Weight: 2 for a single symbol;
     * 5 when the symbol parameter is omitted
     *
     * @summary Symbol Order Book Ticker
     * @param {SymbolOrderBookTickerRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<SymbolOrderBookTickerResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Symbol-Order-Book-Ticker Binance API Documentation}
     */
    public async symbolOrderBookTicker(
        requestParameters: SymbolOrderBookTickerRequest = {}
    ): Promise<RestApiResponse<SymbolOrderBookTickerResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.symbolOrderBookTicker(
            requestParameters?.symbol
        );
        return sendRequest<SymbolOrderBookTickerResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Latest price for a symbol or symbols.
     *
     * If the symbol is not sent, prices for all symbols will be returned in an array.
     *
     * Weight: 1 for a single symbol;
     * 2 when the symbol parameter is omitted
     *
     * @summary Symbol Price Ticker
     * @param {SymbolPriceTickerRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<SymbolPriceTickerResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Symbol-Price-Ticker Binance API Documentation}
     */
    public async symbolPriceTicker(
        requestParameters: SymbolPriceTickerRequest = {}
    ): Promise<RestApiResponse<SymbolPriceTickerResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.symbolPriceTicker(
            requestParameters?.symbol
        );
        return sendRequest<SymbolPriceTickerResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Latest price for a symbol or symbols.
     *
     * If the symbol is not sent, prices for all symbols will be returned in an array.
     * The field `X-MBX-USED-WEIGHT-1M` in response header is not accurate from this endpoint, please ignore.
     *
     * Weight: 1 for a single symbol;
     * 2 when the symbol parameter is omitted
     *
     * @summary Symbol Price Ticker V2
     * @param {SymbolPriceTickerV2Request} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<SymbolPriceTickerV2Response>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Symbol-Price-Ticker-V2 Binance API Documentation}
     */
    public async symbolPriceTickerV2(
        requestParameters: SymbolPriceTickerV2Request = {}
    ): Promise<RestApiResponse<SymbolPriceTickerV2Response>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.symbolPriceTickerV2(
            requestParameters?.symbol
        );
        return sendRequest<SymbolPriceTickerV2Response>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Taker Buy/Sell Volume
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     * IP rate limit 1000 requests/5min
     *
     * Weight: 0
     *
     * @summary Taker Buy/Sell Volume
     * @param {TakerBuySellVolumeRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<TakerBuySellVolumeResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Taker-BuySell-Volume Binance API Documentation}
     */
    public async takerBuySellVolume(
        requestParameters: TakerBuySellVolumeRequest
    ): Promise<RestApiResponse<TakerBuySellVolumeResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.takerBuySellVolume(
            requestParameters?.symbol,
            requestParameters?.period,
            requestParameters?.limit,
            requestParameters?.startTime,
            requestParameters?.endTime
        );
        return sendRequest<TakerBuySellVolumeResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Test connectivity to the Rest API.
     *
     * Weight: 1
     *
     * @summary Test Connectivity
     * @returns {Promise<RestApiResponse<void>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Test-Connectivity Binance API Documentation}
     */
    public async testConnectivity(): Promise<RestApiResponse<void>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.testConnectivity();
        return sendRequest<void>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * 24 hour rolling window price change statistics.
     **Careful** when accessing this with no symbol.
     *
     * If the symbol is not sent, tickers for all symbols will be returned in an array.
     *
     * Weight: 1 for a single symbol;
     * 40 when the symbol parameter is omitted
     *
     * @summary 24hr Ticker Price Change Statistics
     * @param {Ticker24hrPriceChangeStatisticsRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<Ticker24hrPriceChangeStatisticsResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/24hr-Ticker-Price-Change-Statistics Binance API Documentation}
     */
    public async ticker24hrPriceChangeStatistics(
        requestParameters: Ticker24hrPriceChangeStatisticsRequest = {}
    ): Promise<RestApiResponse<Ticker24hrPriceChangeStatisticsResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.ticker24hrPriceChangeStatistics(
                requestParameters?.symbol
            );
        return sendRequest<Ticker24hrPriceChangeStatisticsResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only.
     * Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions
     * Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions
     * Long/Short Ratio (Accounts) = Long Account % / Short Account %
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     * IP rate limit 1000 requests/5min
     *
     * Weight: 0
     *
     * @summary Top Trader Long/Short Ratio (Accounts)
     * @param {TopTraderLongShortRatioAccountsRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<TopTraderLongShortRatioAccountsResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Top-Long-Short-Account-Ratio Binance API Documentation}
     */
    public async topTraderLongShortRatioAccounts(
        requestParameters: TopTraderLongShortRatioAccountsRequest
    ): Promise<RestApiResponse<TopTraderLongShortRatioAccountsResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.topTraderLongShortRatioAccounts(
                requestParameters?.symbol,
                requestParameters?.period,
                requestParameters?.limit,
                requestParameters?.startTime,
                requestParameters?.endTime
            );
        return sendRequest<TopTraderLongShortRatioAccountsResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance.
     * Long Position % = Long positions of top traders / Total open positions of top traders
     * Short Position % = Short positions of top traders / Total open positions of top traders
     * Long/Short Ratio (Positions) = Long Position % / Short Position %
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     * IP rate limit 1000 requests/5min
     *
     * Weight: 0
     *
     * @summary Top Trader Long/Short Ratio (Positions)
     * @param {TopTraderLongShortRatioPositionsRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<TopTraderLongShortRatioPositionsResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Top-Trader-Long-Short-Ratio Binance API Documentation}
     */
    public async topTraderLongShortRatioPositions(
        requestParameters: TopTraderLongShortRatioPositionsRequest
    ): Promise<RestApiResponse<TopTraderLongShortRatioPositionsResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.topTraderLongShortRatioPositions(
                requestParameters?.symbol,
                requestParameters?.period,
                requestParameters?.limit,
                requestParameters?.startTime,
                requestParameters?.endTime
            );
        return sendRequest<TopTraderLongShortRatioPositionsResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }
}

export const BasisContractTypeEnum = {
    PERPETUAL: 'PERPETUAL',
    CURRENT_MONTH: 'CURRENT_MONTH',
    NEXT_MONTH: 'NEXT_MONTH',
    CURRENT_QUARTER: 'CURRENT_QUARTER',
    NEXT_QUARTER: 'NEXT_QUARTER',
    PERPETUAL_DELIVERING: 'PERPETUAL_DELIVERING',
} as const;
export type BasisContractTypeEnum =
    (typeof BasisContractTypeEnum)[keyof typeof BasisContractTypeEnum];

export const BasisPeriodEnum = {
    PERIOD_5m: '5m',
    PERIOD_15m: '15m',
    PERIOD_30m: '30m',
    PERIOD_1h: '1h',
    PERIOD_2h: '2h',
    PERIOD_4h: '4h',
    PERIOD_6h: '6h',
    PERIOD_12h: '12h',
    PERIOD_1d: '1d',
} as const;
export type BasisPeriodEnum = (typeof BasisPeriodEnum)[keyof typeof BasisPeriodEnum];

export const ContinuousContractKlineCandlestickDataContractTypeEnum = {
    PERPETUAL: 'PERPETUAL',
    CURRENT_MONTH: 'CURRENT_MONTH',
    NEXT_MONTH: 'NEXT_MONTH',
    CURRENT_QUARTER: 'CURRENT_QUARTER',
    NEXT_QUARTER: 'NEXT_QUARTER',
    PERPETUAL_DELIVERING: 'PERPETUAL_DELIVERING',
} as const;
export type ContinuousContractKlineCandlestickDataContractTypeEnum =
    (typeof ContinuousContractKlineCandlestickDataContractTypeEnum)[keyof typeof ContinuousContractKlineCandlestickDataContractTypeEnum];

export const ContinuousContractKlineCandlestickDataIntervalEnum = {
    INTERVAL_1m: '1m',
    INTERVAL_3m: '3m',
    INTERVAL_5m: '5m',
    INTERVAL_15m: '15m',
    INTERVAL_30m: '30m',
    INTERVAL_1h: '1h',
    INTERVAL_2h: '2h',
    INTERVAL_4h: '4h',
    INTERVAL_6h: '6h',
    INTERVAL_8h: '8h',
    INTERVAL_12h: '12h',
    INTERVAL_1d: '1d',
    INTERVAL_3d: '3d',
    INTERVAL_1w: '1w',
    INTERVAL_1M: '1M',
} as const;
export type ContinuousContractKlineCandlestickDataIntervalEnum =
    (typeof ContinuousContractKlineCandlestickDataIntervalEnum)[keyof typeof ContinuousContractKlineCandlestickDataIntervalEnum];

export const HistoricalBlvtNavKlineCandlestickIntervalEnum = {
    INTERVAL_1m: '1m',
    INTERVAL_3m: '3m',
    INTERVAL_5m: '5m',
    INTERVAL_15m: '15m',
    INTERVAL_30m: '30m',
    INTERVAL_1h: '1h',
    INTERVAL_2h: '2h',
    INTERVAL_4h: '4h',
    INTERVAL_6h: '6h',
    INTERVAL_8h: '8h',
    INTERVAL_12h: '12h',
    INTERVAL_1d: '1d',
    INTERVAL_3d: '3d',
    INTERVAL_1w: '1w',
    INTERVAL_1M: '1M',
} as const;
export type HistoricalBlvtNavKlineCandlestickIntervalEnum =
    (typeof HistoricalBlvtNavKlineCandlestickIntervalEnum)[keyof typeof HistoricalBlvtNavKlineCandlestickIntervalEnum];

export const IndexPriceKlineCandlestickDataIntervalEnum = {
    INTERVAL_1m: '1m',
    INTERVAL_3m: '3m',
    INTERVAL_5m: '5m',
    INTERVAL_15m: '15m',
    INTERVAL_30m: '30m',
    INTERVAL_1h: '1h',
    INTERVAL_2h: '2h',
    INTERVAL_4h: '4h',
    INTERVAL_6h: '6h',
    INTERVAL_8h: '8h',
    INTERVAL_12h: '12h',
    INTERVAL_1d: '1d',
    INTERVAL_3d: '3d',
    INTERVAL_1w: '1w',
    INTERVAL_1M: '1M',
} as const;
export type IndexPriceKlineCandlestickDataIntervalEnum =
    (typeof IndexPriceKlineCandlestickDataIntervalEnum)[keyof typeof IndexPriceKlineCandlestickDataIntervalEnum];

export const KlineCandlestickDataIntervalEnum = {
    INTERVAL_1m: '1m',
    INTERVAL_3m: '3m',
    INTERVAL_5m: '5m',
    INTERVAL_15m: '15m',
    INTERVAL_30m: '30m',
    INTERVAL_1h: '1h',
    INTERVAL_2h: '2h',
    INTERVAL_4h: '4h',
    INTERVAL_6h: '6h',
    INTERVAL_8h: '8h',
    INTERVAL_12h: '12h',
    INTERVAL_1d: '1d',
    INTERVAL_3d: '3d',
    INTERVAL_1w: '1w',
    INTERVAL_1M: '1M',
} as const;
export type KlineCandlestickDataIntervalEnum =
    (typeof KlineCandlestickDataIntervalEnum)[keyof typeof KlineCandlestickDataIntervalEnum];

export const LongShortRatioPeriodEnum = {
    PERIOD_5m: '5m',
    PERIOD_15m: '15m',
    PERIOD_30m: '30m',
    PERIOD_1h: '1h',
    PERIOD_2h: '2h',
    PERIOD_4h: '4h',
    PERIOD_6h: '6h',
    PERIOD_12h: '12h',
    PERIOD_1d: '1d',
} as const;
export type LongShortRatioPeriodEnum =
    (typeof LongShortRatioPeriodEnum)[keyof typeof LongShortRatioPeriodEnum];

export const MarkPriceKlineCandlestickDataIntervalEnum = {
    INTERVAL_1m: '1m',
    INTERVAL_3m: '3m',
    INTERVAL_5m: '5m',
    INTERVAL_15m: '15m',
    INTERVAL_30m: '30m',
    INTERVAL_1h: '1h',
    INTERVAL_2h: '2h',
    INTERVAL_4h: '4h',
    INTERVAL_6h: '6h',
    INTERVAL_8h: '8h',
    INTERVAL_12h: '12h',
    INTERVAL_1d: '1d',
    INTERVAL_3d: '3d',
    INTERVAL_1w: '1w',
    INTERVAL_1M: '1M',
} as const;
export type MarkPriceKlineCandlestickDataIntervalEnum =
    (typeof MarkPriceKlineCandlestickDataIntervalEnum)[keyof typeof MarkPriceKlineCandlestickDataIntervalEnum];

export const OpenInterestStatisticsPeriodEnum = {
    PERIOD_5m: '5m',
    PERIOD_15m: '15m',
    PERIOD_30m: '30m',
    PERIOD_1h: '1h',
    PERIOD_2h: '2h',
    PERIOD_4h: '4h',
    PERIOD_6h: '6h',
    PERIOD_12h: '12h',
    PERIOD_1d: '1d',
} as const;
export type OpenInterestStatisticsPeriodEnum =
    (typeof OpenInterestStatisticsPeriodEnum)[keyof typeof OpenInterestStatisticsPeriodEnum];

export const PremiumIndexKlineDataIntervalEnum = {
    INTERVAL_1m: '1m',
    INTERVAL_3m: '3m',
    INTERVAL_5m: '5m',
    INTERVAL_15m: '15m',
    INTERVAL_30m: '30m',
    INTERVAL_1h: '1h',
    INTERVAL_2h: '2h',
    INTERVAL_4h: '4h',
    INTERVAL_6h: '6h',
    INTERVAL_8h: '8h',
    INTERVAL_12h: '12h',
    INTERVAL_1d: '1d',
    INTERVAL_3d: '3d',
    INTERVAL_1w: '1w',
    INTERVAL_1M: '1M',
} as const;
export type PremiumIndexKlineDataIntervalEnum =
    (typeof PremiumIndexKlineDataIntervalEnum)[keyof typeof PremiumIndexKlineDataIntervalEnum];

export const TakerBuySellVolumePeriodEnum = {
    PERIOD_5m: '5m',
    PERIOD_15m: '15m',
    PERIOD_30m: '30m',
    PERIOD_1h: '1h',
    PERIOD_2h: '2h',
    PERIOD_4h: '4h',
    PERIOD_6h: '6h',
    PERIOD_12h: '12h',
    PERIOD_1d: '1d',
} as const;
export type TakerBuySellVolumePeriodEnum =
    (typeof TakerBuySellVolumePeriodEnum)[keyof typeof TakerBuySellVolumePeriodEnum];

export const TopTraderLongShortRatioAccountsPeriodEnum = {
    PERIOD_5m: '5m',
    PERIOD_15m: '15m',
    PERIOD_30m: '30m',
    PERIOD_1h: '1h',
    PERIOD_2h: '2h',
    PERIOD_4h: '4h',
    PERIOD_6h: '6h',
    PERIOD_12h: '12h',
    PERIOD_1d: '1d',
} as const;
export type TopTraderLongShortRatioAccountsPeriodEnum =
    (typeof TopTraderLongShortRatioAccountsPeriodEnum)[keyof typeof TopTraderLongShortRatioAccountsPeriodEnum];

export const TopTraderLongShortRatioPositionsPeriodEnum = {
    PERIOD_5m: '5m',
    PERIOD_15m: '15m',
    PERIOD_30m: '30m',
    PERIOD_1h: '1h',
    PERIOD_2h: '2h',
    PERIOD_4h: '4h',
    PERIOD_6h: '6h',
    PERIOD_12h: '12h',
    PERIOD_1d: '1d',
} as const;
export type TopTraderLongShortRatioPositionsPeriodEnum =
    (typeof TopTraderLongShortRatioPositionsPeriodEnum)[keyof typeof TopTraderLongShortRatioPositionsPeriodEnum];
