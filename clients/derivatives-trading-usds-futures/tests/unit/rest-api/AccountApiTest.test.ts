/**
 * Binance Public Derivatives Trading USDS Futures REST API
 *
 * OpenAPI Specification for the Binance Public Derivatives Trading USDS Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { AccountApi } from '../../../src/rest-api';
import {
    AccountInformationV2Request,
    AccountInformationV3Request,
    FuturesAccountBalanceV2Request,
    FuturesAccountBalanceV3Request,
    FuturesAccountConfigurationRequest,
    FuturesTradingQuantitativeRulesIndicatorsRequest,
    GetBnbBurnStatusRequest,
    GetCurrentMultiAssetsModeRequest,
    GetCurrentPositionModeRequest,
    GetDownloadIdForFuturesOrderHistoryRequest,
    GetDownloadIdForFuturesTradeHistoryRequest,
    GetDownloadIdForFuturesTransactionHistoryRequest,
    GetFuturesOrderHistoryDownloadLinkByIdRequest,
    GetFuturesTradeDownloadLinkByIdRequest,
    GetFuturesTransactionHistoryDownloadLinkByIdRequest,
    GetIncomeHistoryRequest,
    NotionalAndLeverageBracketsRequest,
    QueryUserRateLimitRequest,
    SymbolConfigurationRequest,
    ToggleBnbBurnOnFuturesTradeRequest,
    UserCommissionRateRequest,
} from '../../../src/rest-api';
import type {
    AccountInformationV2Response,
    AccountInformationV3Response,
    FuturesAccountBalanceV2Response,
    FuturesAccountBalanceV3Response,
    FuturesAccountConfigurationResponse,
    FuturesTradingQuantitativeRulesIndicatorsResponse,
    GetBnbBurnStatusResponse,
    GetCurrentMultiAssetsModeResponse,
    GetCurrentPositionModeResponse,
    GetDownloadIdForFuturesOrderHistoryResponse,
    GetDownloadIdForFuturesTradeHistoryResponse,
    GetDownloadIdForFuturesTransactionHistoryResponse,
    GetFuturesOrderHistoryDownloadLinkByIdResponse,
    GetFuturesTradeDownloadLinkByIdResponse,
    GetFuturesTransactionHistoryDownloadLinkByIdResponse,
    GetIncomeHistoryResponse,
    NotionalAndLeverageBracketsResponse,
    QueryUserRateLimitResponse,
    SymbolConfigurationResponse,
    ToggleBnbBurnOnFuturesTradeResponse,
    UserCommissionRateResponse,
} from '../../../src/rest-api/types';

describe('AccountApi', () => {
    let client: AccountApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new AccountApi(config);
    });

    describe('accountInformationV2()', () => {
        it('should execute accountInformationV2() successfully with required parameters only', async () => {
            mockResponse = {
                feeTier: 0,
                feeBurn: true,
                canDeposit: true,
                canWithdraw: true,
                updateTime: 0,
                multiAssetsMargin: false,
                tradeGroupId: -1,
                totalInitialMargin: '0.00000000',
                totalMaintMargin: '0.00000000',
                totalWalletBalance: '23.72469206',
                totalUnrealizedProfit: '0.00000000',
                totalMarginBalance: '23.72469206',
                totalPositionInitialMargin: '0.00000000',
                totalOpenOrderInitialMargin: '0.00000000',
                totalCrossWalletBalance: '23.72469206',
                totalCrossUnPnl: '0.00000000',
                availableBalance: '23.72469206',
                maxWithdrawAmount: '23.72469206',
                assets: [
                    {
                        asset: 'USDT',
                        walletBalance: '23.72469206',
                        unrealizedProfit: '0.00000000',
                        marginBalance: '23.72469206',
                        maintMargin: '0.00000000',
                        initialMargin: '0.00000000',
                        positionInitialMargin: '0.00000000',
                        openOrderInitialMargin: '0.00000000',
                        crossWalletBalance: '23.72469206',
                        crossUnPnl: '0.00000000',
                        availableBalance: '23.72469206',
                        maxWithdrawAmount: '23.72469206',
                        marginAvailable: true,
                        updateTime: 1625474304765,
                    },
                    {
                        asset: 'BUSD',
                        walletBalance: '103.12345678',
                        unrealizedProfit: '0.00000000',
                        marginBalance: '103.12345678',
                        maintMargin: '0.00000000',
                        initialMargin: '0.00000000',
                        positionInitialMargin: '0.00000000',
                        openOrderInitialMargin: '0.00000000',
                        crossWalletBalance: '103.12345678',
                        crossUnPnl: '0.00000000',
                        availableBalance: '103.12345678',
                        maxWithdrawAmount: '103.12345678',
                        marginAvailable: true,
                        updateTime: 1625474304765,
                    },
                ],
                positions: [
                    {
                        symbol: 'BTCUSDT',
                        initialMargin: '0',
                        maintMargin: '0',
                        unrealizedProfit: '0.00000000',
                        positionInitialMargin: '0',
                        openOrderInitialMargin: '0',
                        leverage: '100',
                        isolated: true,
                        entryPrice: '0.00000',
                        maxNotional: '250000',
                        bidNotional: '0',
                        askNotional: '0',
                        positionSide: 'BOTH',
                        positionAmt: '0',
                        updateTime: 0,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'accountInformationV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountInformationV2Response>)
            );
            const response = await client.accountInformationV2();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute accountInformationV2() successfully with optional parameters', async () => {
            const params: AccountInformationV2Request = {
                recvWindow: 5000,
            };

            mockResponse = {
                feeTier: 0,
                feeBurn: true,
                canDeposit: true,
                canWithdraw: true,
                updateTime: 0,
                multiAssetsMargin: false,
                tradeGroupId: -1,
                totalInitialMargin: '0.00000000',
                totalMaintMargin: '0.00000000',
                totalWalletBalance: '23.72469206',
                totalUnrealizedProfit: '0.00000000',
                totalMarginBalance: '23.72469206',
                totalPositionInitialMargin: '0.00000000',
                totalOpenOrderInitialMargin: '0.00000000',
                totalCrossWalletBalance: '23.72469206',
                totalCrossUnPnl: '0.00000000',
                availableBalance: '23.72469206',
                maxWithdrawAmount: '23.72469206',
                assets: [
                    {
                        asset: 'USDT',
                        walletBalance: '23.72469206',
                        unrealizedProfit: '0.00000000',
                        marginBalance: '23.72469206',
                        maintMargin: '0.00000000',
                        initialMargin: '0.00000000',
                        positionInitialMargin: '0.00000000',
                        openOrderInitialMargin: '0.00000000',
                        crossWalletBalance: '23.72469206',
                        crossUnPnl: '0.00000000',
                        availableBalance: '23.72469206',
                        maxWithdrawAmount: '23.72469206',
                        marginAvailable: true,
                        updateTime: 1625474304765,
                    },
                    {
                        asset: 'BUSD',
                        walletBalance: '103.12345678',
                        unrealizedProfit: '0.00000000',
                        marginBalance: '103.12345678',
                        maintMargin: '0.00000000',
                        initialMargin: '0.00000000',
                        positionInitialMargin: '0.00000000',
                        openOrderInitialMargin: '0.00000000',
                        crossWalletBalance: '103.12345678',
                        crossUnPnl: '0.00000000',
                        availableBalance: '103.12345678',
                        maxWithdrawAmount: '103.12345678',
                        marginAvailable: true,
                        updateTime: 1625474304765,
                    },
                ],
                positions: [
                    {
                        symbol: 'BTCUSDT',
                        initialMargin: '0',
                        maintMargin: '0',
                        unrealizedProfit: '0.00000000',
                        positionInitialMargin: '0',
                        openOrderInitialMargin: '0',
                        leverage: '100',
                        isolated: true,
                        entryPrice: '0.00000',
                        maxNotional: '250000',
                        bidNotional: '0',
                        askNotional: '0',
                        positionSide: 'BOTH',
                        positionAmt: '0',
                        updateTime: 0,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'accountInformationV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountInformationV2Response>)
            );
            const response = await client.accountInformationV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'accountInformationV2').mockRejectedValueOnce(mockError);
            await expect(client.accountInformationV2()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('accountInformationV3()', () => {
        it('should execute accountInformationV3() successfully with required parameters only', async () => {
            mockResponse = {
                totalInitialMargin: '0.00000000',
                totalMaintMargin: '0.00000000',
                totalWalletBalance: '103.12345678',
                totalUnrealizedProfit: '0.00000000',
                totalMarginBalance: '103.12345678',
                totalPositionInitialMargin: '0.00000000',
                totalOpenOrderInitialMargin: '0.00000000',
                totalCrossWalletBalance: '103.12345678',
                totalCrossUnPnl: '0.00000000',
                availableBalance: '103.12345678',
                maxWithdrawAmount: '103.12345678',
                assets: [
                    {
                        asset: 'USDT',
                        walletBalance: '23.72469206',
                        unrealizedProfit: '0.00000000',
                        marginBalance: '23.72469206',
                        maintMargin: '0.00000000',
                        initialMargin: '0.00000000',
                        positionInitialMargin: '0.00000000',
                        openOrderInitialMargin: '0.00000000',
                        crossWalletBalance: '23.72469206',
                        crossUnPnl: '0.00000000',
                        availableBalance: '23.72469206',
                        maxWithdrawAmount: '23.72469206',
                        updateTime: 1625474304765,
                    },
                    {
                        asset: 'USDC',
                        walletBalance: '103.12345678',
                        unrealizedProfit: '0.00000000',
                        marginBalance: '103.12345678',
                        maintMargin: '0.00000000',
                        initialMargin: '0.00000000',
                        positionInitialMargin: '0.00000000',
                        openOrderInitialMargin: '0.00000000',
                        crossWalletBalance: '103.12345678',
                        crossUnPnl: '0.00000000',
                        availableBalance: '126.72469206',
                        maxWithdrawAmount: '103.12345678',
                        updateTime: 1625474304765,
                    },
                ],
                positions: [
                    {
                        symbol: 'BTCUSDT',
                        positionSide: 'BOTH',
                        positionAmt: '1.000',
                        unrealizedProfit: '0.00000000',
                        isolatedMargin: '0.00000000',
                        notional: '0',
                        isolatedWallet: '0',
                        initialMargin: '0',
                        maintMargin: '0',
                        updateTime: 0,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'accountInformationV3').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountInformationV3Response>)
            );
            const response = await client.accountInformationV3();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute accountInformationV3() successfully with optional parameters', async () => {
            const params: AccountInformationV3Request = {
                recvWindow: 5000,
            };

            mockResponse = {
                totalInitialMargin: '0.00000000',
                totalMaintMargin: '0.00000000',
                totalWalletBalance: '103.12345678',
                totalUnrealizedProfit: '0.00000000',
                totalMarginBalance: '103.12345678',
                totalPositionInitialMargin: '0.00000000',
                totalOpenOrderInitialMargin: '0.00000000',
                totalCrossWalletBalance: '103.12345678',
                totalCrossUnPnl: '0.00000000',
                availableBalance: '103.12345678',
                maxWithdrawAmount: '103.12345678',
                assets: [
                    {
                        asset: 'USDT',
                        walletBalance: '23.72469206',
                        unrealizedProfit: '0.00000000',
                        marginBalance: '23.72469206',
                        maintMargin: '0.00000000',
                        initialMargin: '0.00000000',
                        positionInitialMargin: '0.00000000',
                        openOrderInitialMargin: '0.00000000',
                        crossWalletBalance: '23.72469206',
                        crossUnPnl: '0.00000000',
                        availableBalance: '23.72469206',
                        maxWithdrawAmount: '23.72469206',
                        updateTime: 1625474304765,
                    },
                    {
                        asset: 'USDC',
                        walletBalance: '103.12345678',
                        unrealizedProfit: '0.00000000',
                        marginBalance: '103.12345678',
                        maintMargin: '0.00000000',
                        initialMargin: '0.00000000',
                        positionInitialMargin: '0.00000000',
                        openOrderInitialMargin: '0.00000000',
                        crossWalletBalance: '103.12345678',
                        crossUnPnl: '0.00000000',
                        availableBalance: '126.72469206',
                        maxWithdrawAmount: '103.12345678',
                        updateTime: 1625474304765,
                    },
                ],
                positions: [
                    {
                        symbol: 'BTCUSDT',
                        positionSide: 'BOTH',
                        positionAmt: '1.000',
                        unrealizedProfit: '0.00000000',
                        isolatedMargin: '0.00000000',
                        notional: '0',
                        isolatedWallet: '0',
                        initialMargin: '0',
                        maintMargin: '0',
                        updateTime: 0,
                    },
                ],
            };

            const spy = jest.spyOn(client, 'accountInformationV3').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountInformationV3Response>)
            );
            const response = await client.accountInformationV3(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'accountInformationV3').mockRejectedValueOnce(mockError);
            await expect(client.accountInformationV3()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('futuresAccountBalanceV2()', () => {
        it('should execute futuresAccountBalanceV2() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    accountAlias: 'SgsR',
                    asset: 'USDT',
                    balance: '122607.35137903',
                    crossWalletBalance: '23.72469206',
                    crossUnPnl: '0.00000000',
                    availableBalance: '23.72469206',
                    maxWithdrawAmount: '23.72469206',
                    marginAvailable: true,
                    updateTime: 1617939110373,
                },
            ];

            const spy = jest.spyOn(client, 'futuresAccountBalanceV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FuturesAccountBalanceV2Response>)
            );
            const response = await client.futuresAccountBalanceV2();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute futuresAccountBalanceV2() successfully with optional parameters', async () => {
            const params: FuturesAccountBalanceV2Request = {
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    accountAlias: 'SgsR',
                    asset: 'USDT',
                    balance: '122607.35137903',
                    crossWalletBalance: '23.72469206',
                    crossUnPnl: '0.00000000',
                    availableBalance: '23.72469206',
                    maxWithdrawAmount: '23.72469206',
                    marginAvailable: true,
                    updateTime: 1617939110373,
                },
            ];

            const spy = jest.spyOn(client, 'futuresAccountBalanceV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FuturesAccountBalanceV2Response>)
            );
            const response = await client.futuresAccountBalanceV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'futuresAccountBalanceV2')
                .mockRejectedValueOnce(mockError);
            await expect(client.futuresAccountBalanceV2()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('futuresAccountBalanceV3()', () => {
        it('should execute futuresAccountBalanceV3() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    accountAlias: 'SgsR',
                    asset: 'USDT',
                    balance: '122607.35137903',
                    crossWalletBalance: '23.72469206',
                    crossUnPnl: '0.00000000',
                    availableBalance: '23.72469206',
                    maxWithdrawAmount: '23.72469206',
                    marginAvailable: true,
                    updateTime: 1617939110373,
                },
            ];

            const spy = jest.spyOn(client, 'futuresAccountBalanceV3').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FuturesAccountBalanceV3Response>)
            );
            const response = await client.futuresAccountBalanceV3();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute futuresAccountBalanceV3() successfully with optional parameters', async () => {
            const params: FuturesAccountBalanceV3Request = {
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    accountAlias: 'SgsR',
                    asset: 'USDT',
                    balance: '122607.35137903',
                    crossWalletBalance: '23.72469206',
                    crossUnPnl: '0.00000000',
                    availableBalance: '23.72469206',
                    maxWithdrawAmount: '23.72469206',
                    marginAvailable: true,
                    updateTime: 1617939110373,
                },
            ];

            const spy = jest.spyOn(client, 'futuresAccountBalanceV3').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FuturesAccountBalanceV3Response>)
            );
            const response = await client.futuresAccountBalanceV3(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'futuresAccountBalanceV3')
                .mockRejectedValueOnce(mockError);
            await expect(client.futuresAccountBalanceV3()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('futuresAccountConfiguration()', () => {
        it('should execute futuresAccountConfiguration() successfully with required parameters only', async () => {
            mockResponse = {
                feeTier: 0,
                canTrade: true,
                canDeposit: true,
                canWithdraw: true,
                dualSidePosition: true,
                updateTime: 0,
                multiAssetsMargin: false,
                tradeGroupId: -1,
            };

            const spy = jest.spyOn(client, 'futuresAccountConfiguration').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FuturesAccountConfigurationResponse>)
            );
            const response = await client.futuresAccountConfiguration();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute futuresAccountConfiguration() successfully with optional parameters', async () => {
            const params: FuturesAccountConfigurationRequest = {
                recvWindow: 5000,
            };

            mockResponse = {
                feeTier: 0,
                canTrade: true,
                canDeposit: true,
                canWithdraw: true,
                dualSidePosition: true,
                updateTime: 0,
                multiAssetsMargin: false,
                tradeGroupId: -1,
            };

            const spy = jest.spyOn(client, 'futuresAccountConfiguration').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FuturesAccountConfigurationResponse>)
            );
            const response = await client.futuresAccountConfiguration(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'futuresAccountConfiguration')
                .mockRejectedValueOnce(mockError);
            await expect(client.futuresAccountConfiguration()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('futuresTradingQuantitativeRulesIndicators()', () => {
        it('should execute futuresTradingQuantitativeRulesIndicators() successfully with required parameters only', async () => {
            mockResponse = {
                indicators: {
                    BTCUSDT: [
                        {
                            isLocked: true,
                            plannedRecoverTime: 1545741270000,
                            indicator: 'UFR',
                            value: 0.05,
                            triggerValue: 0.995,
                        },
                        {
                            isLocked: true,
                            plannedRecoverTime: 1545741270000,
                            indicator: 'IFER',
                            value: 0.99,
                            triggerValue: 0.99,
                        },
                        {
                            isLocked: true,
                            plannedRecoverTime: 1545741270000,
                            indicator: 'GCR',
                            value: 0.99,
                            triggerValue: 0.99,
                        },
                        {
                            isLocked: true,
                            plannedRecoverTime: 1545741270000,
                            indicator: 'DR',
                            value: 0.99,
                            triggerValue: 0.99,
                        },
                    ],
                    ETHUSDT: [
                        {
                            isLocked: true,
                            plannedRecoverTime: 1545741270000,
                            indicator: 'UFR',
                            value: 0.05,
                            triggerValue: 0.995,
                        },
                        {
                            isLocked: true,
                            plannedRecoverTime: 1545741270000,
                            indicator: 'IFER',
                            value: 0.99,
                            triggerValue: 0.99,
                        },
                        {
                            isLocked: true,
                            plannedRecoverTime: 1545741270000,
                            indicator: 'GCR',
                            value: 0.99,
                            triggerValue: 0.99,
                        },
                        {
                            isLocked: true,
                            plannedRecoverTime: 1545741270000,
                            indicator: 'DR',
                            value: 0.99,
                            triggerValue: 0.99,
                        },
                    ],
                },
                updateTime: 1545741270000,
            };

            const spy = jest
                .spyOn(client, 'futuresTradingQuantitativeRulesIndicators')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<FuturesTradingQuantitativeRulesIndicatorsResponse>)
                );
            const response = await client.futuresTradingQuantitativeRulesIndicators();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute futuresTradingQuantitativeRulesIndicators() successfully with optional parameters', async () => {
            const params: FuturesTradingQuantitativeRulesIndicatorsRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = {
                indicators: {
                    BTCUSDT: [
                        {
                            isLocked: true,
                            plannedRecoverTime: 1545741270000,
                            indicator: 'UFR',
                            value: 0.05,
                            triggerValue: 0.995,
                        },
                        {
                            isLocked: true,
                            plannedRecoverTime: 1545741270000,
                            indicator: 'IFER',
                            value: 0.99,
                            triggerValue: 0.99,
                        },
                        {
                            isLocked: true,
                            plannedRecoverTime: 1545741270000,
                            indicator: 'GCR',
                            value: 0.99,
                            triggerValue: 0.99,
                        },
                        {
                            isLocked: true,
                            plannedRecoverTime: 1545741270000,
                            indicator: 'DR',
                            value: 0.99,
                            triggerValue: 0.99,
                        },
                    ],
                    ETHUSDT: [
                        {
                            isLocked: true,
                            plannedRecoverTime: 1545741270000,
                            indicator: 'UFR',
                            value: 0.05,
                            triggerValue: 0.995,
                        },
                        {
                            isLocked: true,
                            plannedRecoverTime: 1545741270000,
                            indicator: 'IFER',
                            value: 0.99,
                            triggerValue: 0.99,
                        },
                        {
                            isLocked: true,
                            plannedRecoverTime: 1545741270000,
                            indicator: 'GCR',
                            value: 0.99,
                            triggerValue: 0.99,
                        },
                        {
                            isLocked: true,
                            plannedRecoverTime: 1545741270000,
                            indicator: 'DR',
                            value: 0.99,
                            triggerValue: 0.99,
                        },
                    ],
                },
                updateTime: 1545741270000,
            };

            const spy = jest
                .spyOn(client, 'futuresTradingQuantitativeRulesIndicators')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<FuturesTradingQuantitativeRulesIndicatorsResponse>)
                );
            const response = await client.futuresTradingQuantitativeRulesIndicators(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'futuresTradingQuantitativeRulesIndicators')
                .mockRejectedValueOnce(mockError);
            await expect(client.futuresTradingQuantitativeRulesIndicators()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getBnbBurnStatus()', () => {
        it('should execute getBnbBurnStatus() successfully with required parameters only', async () => {
            mockResponse = { feeBurn: true };

            const spy = jest.spyOn(client, 'getBnbBurnStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetBnbBurnStatusResponse>)
            );
            const response = await client.getBnbBurnStatus();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getBnbBurnStatus() successfully with optional parameters', async () => {
            const params: GetBnbBurnStatusRequest = {
                recvWindow: 5000,
            };

            mockResponse = { feeBurn: true };

            const spy = jest.spyOn(client, 'getBnbBurnStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetBnbBurnStatusResponse>)
            );
            const response = await client.getBnbBurnStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getBnbBurnStatus').mockRejectedValueOnce(mockError);
            await expect(client.getBnbBurnStatus()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getCurrentMultiAssetsMode()', () => {
        it('should execute getCurrentMultiAssetsMode() successfully with required parameters only', async () => {
            mockResponse = { multiAssetsMargin: true };

            const spy = jest.spyOn(client, 'getCurrentMultiAssetsMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCurrentMultiAssetsModeResponse>)
            );
            const response = await client.getCurrentMultiAssetsMode();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getCurrentMultiAssetsMode() successfully with optional parameters', async () => {
            const params: GetCurrentMultiAssetsModeRequest = {
                recvWindow: 5000,
            };

            mockResponse = { multiAssetsMargin: true };

            const spy = jest.spyOn(client, 'getCurrentMultiAssetsMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCurrentMultiAssetsModeResponse>)
            );
            const response = await client.getCurrentMultiAssetsMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getCurrentMultiAssetsMode')
                .mockRejectedValueOnce(mockError);
            await expect(client.getCurrentMultiAssetsMode()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getCurrentPositionMode()', () => {
        it('should execute getCurrentPositionMode() successfully with required parameters only', async () => {
            mockResponse = { dualSidePosition: true };

            const spy = jest.spyOn(client, 'getCurrentPositionMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCurrentPositionModeResponse>)
            );
            const response = await client.getCurrentPositionMode();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getCurrentPositionMode() successfully with optional parameters', async () => {
            const params: GetCurrentPositionModeRequest = {
                recvWindow: 5000,
            };

            mockResponse = { dualSidePosition: true };

            const spy = jest.spyOn(client, 'getCurrentPositionMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCurrentPositionModeResponse>)
            );
            const response = await client.getCurrentPositionMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getCurrentPositionMode')
                .mockRejectedValueOnce(mockError);
            await expect(client.getCurrentPositionMode()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getDownloadIdForFuturesOrderHistory()', () => {
        it('should execute getDownloadIdForFuturesOrderHistory() successfully with required parameters only', async () => {
            const params: GetDownloadIdForFuturesOrderHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = { avgCostTimestampOfLast30d: 7241837, downloadId: '546975389218332672' };

            const spy = jest.spyOn(client, 'getDownloadIdForFuturesOrderHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDownloadIdForFuturesOrderHistoryResponse>)
            );
            const response = await client.getDownloadIdForFuturesOrderHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getDownloadIdForFuturesOrderHistory() successfully with optional parameters', async () => {
            const params: GetDownloadIdForFuturesOrderHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = { avgCostTimestampOfLast30d: 7241837, downloadId: '546975389218332672' };

            const spy = jest.spyOn(client, 'getDownloadIdForFuturesOrderHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDownloadIdForFuturesOrderHistoryResponse>)
            );
            const response = await client.getDownloadIdForFuturesOrderHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: GetDownloadIdForFuturesOrderHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(client.getDownloadIdForFuturesOrderHistory(params)).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling getDownloadIdForFuturesOrderHistory.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: GetDownloadIdForFuturesOrderHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(client.getDownloadIdForFuturesOrderHistory(params)).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling getDownloadIdForFuturesOrderHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetDownloadIdForFuturesOrderHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getDownloadIdForFuturesOrderHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getDownloadIdForFuturesOrderHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getDownloadIdForFuturesTradeHistory()', () => {
        it('should execute getDownloadIdForFuturesTradeHistory() successfully with required parameters only', async () => {
            const params: GetDownloadIdForFuturesTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = { avgCostTimestampOfLast30d: 7241837, downloadId: '546975389218332672' };

            const spy = jest.spyOn(client, 'getDownloadIdForFuturesTradeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDownloadIdForFuturesTradeHistoryResponse>)
            );
            const response = await client.getDownloadIdForFuturesTradeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getDownloadIdForFuturesTradeHistory() successfully with optional parameters', async () => {
            const params: GetDownloadIdForFuturesTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = { avgCostTimestampOfLast30d: 7241837, downloadId: '546975389218332672' };

            const spy = jest.spyOn(client, 'getDownloadIdForFuturesTradeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDownloadIdForFuturesTradeHistoryResponse>)
            );
            const response = await client.getDownloadIdForFuturesTradeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: GetDownloadIdForFuturesTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(client.getDownloadIdForFuturesTradeHistory(params)).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling getDownloadIdForFuturesTradeHistory.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: GetDownloadIdForFuturesTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(client.getDownloadIdForFuturesTradeHistory(params)).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling getDownloadIdForFuturesTradeHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetDownloadIdForFuturesTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getDownloadIdForFuturesTradeHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getDownloadIdForFuturesTradeHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getDownloadIdForFuturesTransactionHistory()', () => {
        it('should execute getDownloadIdForFuturesTransactionHistory() successfully with required parameters only', async () => {
            const params: GetDownloadIdForFuturesTransactionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = { avgCostTimestampOfLast30d: 7241837, downloadId: '546975389218332672' };

            const spy = jest
                .spyOn(client, 'getDownloadIdForFuturesTransactionHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetDownloadIdForFuturesTransactionHistoryResponse>)
                );
            const response = await client.getDownloadIdForFuturesTransactionHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getDownloadIdForFuturesTransactionHistory() successfully with optional parameters', async () => {
            const params: GetDownloadIdForFuturesTransactionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = { avgCostTimestampOfLast30d: 7241837, downloadId: '546975389218332672' };

            const spy = jest
                .spyOn(client, 'getDownloadIdForFuturesTransactionHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetDownloadIdForFuturesTransactionHistoryResponse>)
                );
            const response = await client.getDownloadIdForFuturesTransactionHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: GetDownloadIdForFuturesTransactionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(client.getDownloadIdForFuturesTransactionHistory(params)).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling getDownloadIdForFuturesTransactionHistory.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: GetDownloadIdForFuturesTransactionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(client.getDownloadIdForFuturesTransactionHistory(params)).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling getDownloadIdForFuturesTransactionHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetDownloadIdForFuturesTransactionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getDownloadIdForFuturesTransactionHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getDownloadIdForFuturesTransactionHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getFuturesOrderHistoryDownloadLinkById()', () => {
        it('should execute getFuturesOrderHistoryDownloadLinkById() successfully with required parameters only', async () => {
            const params: GetFuturesOrderHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            mockResponse = {
                downloadId: '545923594199212032',
                status: 'completed',
                url: 'www.binance.com',
                notified: true,
                expirationTimestamp: 1645009771000,
                isExpired: null,
            };

            const spy = jest
                .spyOn(client, 'getFuturesOrderHistoryDownloadLinkById')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetFuturesOrderHistoryDownloadLinkByIdResponse>)
                );
            const response = await client.getFuturesOrderHistoryDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFuturesOrderHistoryDownloadLinkById() successfully with optional parameters', async () => {
            const params: GetFuturesOrderHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                downloadId: '545923594199212032',
                status: 'completed',
                url: 'www.binance.com',
                notified: true,
                expirationTimestamp: 1645009771000,
                isExpired: null,
            };

            const spy = jest
                .spyOn(client, 'getFuturesOrderHistoryDownloadLinkById')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetFuturesOrderHistoryDownloadLinkByIdResponse>)
                );
            const response = await client.getFuturesOrderHistoryDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when downloadId is missing', async () => {
            const _params: GetFuturesOrderHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.downloadId;

            await expect(client.getFuturesOrderHistoryDownloadLinkById(params)).rejects.toThrow(
                'Required parameter downloadId was null or undefined when calling getFuturesOrderHistoryDownloadLinkById.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFuturesOrderHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFuturesOrderHistoryDownloadLinkById')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFuturesOrderHistoryDownloadLinkById(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getFuturesTradeDownloadLinkById()', () => {
        it('should execute getFuturesTradeDownloadLinkById() successfully with required parameters only', async () => {
            const params: GetFuturesTradeDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            mockResponse = {
                downloadId: '545923594199212032',
                status: 'completed',
                url: 'www.binance.com',
                notified: true,
                expirationTimestamp: 1645009771000,
                isExpired: null,
            };

            const spy = jest.spyOn(client, 'getFuturesTradeDownloadLinkById').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFuturesTradeDownloadLinkByIdResponse>)
            );
            const response = await client.getFuturesTradeDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFuturesTradeDownloadLinkById() successfully with optional parameters', async () => {
            const params: GetFuturesTradeDownloadLinkByIdRequest = {
                downloadId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                downloadId: '545923594199212032',
                status: 'completed',
                url: 'www.binance.com',
                notified: true,
                expirationTimestamp: 1645009771000,
                isExpired: null,
            };

            const spy = jest.spyOn(client, 'getFuturesTradeDownloadLinkById').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFuturesTradeDownloadLinkByIdResponse>)
            );
            const response = await client.getFuturesTradeDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when downloadId is missing', async () => {
            const _params: GetFuturesTradeDownloadLinkByIdRequest = {
                downloadId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.downloadId;

            await expect(client.getFuturesTradeDownloadLinkById(params)).rejects.toThrow(
                'Required parameter downloadId was null or undefined when calling getFuturesTradeDownloadLinkById.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFuturesTradeDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFuturesTradeDownloadLinkById')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFuturesTradeDownloadLinkById(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getFuturesTransactionHistoryDownloadLinkById()', () => {
        it('should execute getFuturesTransactionHistoryDownloadLinkById() successfully with required parameters only', async () => {
            const params: GetFuturesTransactionHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            mockResponse = {
                downloadId: '545923594199212032',
                status: 'completed',
                url: 'www.binance.com',
                notified: true,
                expirationTimestamp: 1645009771000,
                isExpired: null,
            };

            const spy = jest
                .spyOn(client, 'getFuturesTransactionHistoryDownloadLinkById')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetFuturesTransactionHistoryDownloadLinkByIdResponse>)
                );
            const response = await client.getFuturesTransactionHistoryDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFuturesTransactionHistoryDownloadLinkById() successfully with optional parameters', async () => {
            const params: GetFuturesTransactionHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                downloadId: '545923594199212032',
                status: 'completed',
                url: 'www.binance.com',
                notified: true,
                expirationTimestamp: 1645009771000,
                isExpired: null,
            };

            const spy = jest
                .spyOn(client, 'getFuturesTransactionHistoryDownloadLinkById')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetFuturesTransactionHistoryDownloadLinkByIdResponse>)
                );
            const response = await client.getFuturesTransactionHistoryDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when downloadId is missing', async () => {
            const _params: GetFuturesTransactionHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.downloadId;

            await expect(
                client.getFuturesTransactionHistoryDownloadLinkById(params)
            ).rejects.toThrow(
                'Required parameter downloadId was null or undefined when calling getFuturesTransactionHistoryDownloadLinkById.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFuturesTransactionHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFuturesTransactionHistoryDownloadLinkById')
                .mockRejectedValueOnce(mockError);
            await expect(
                client.getFuturesTransactionHistoryDownloadLinkById(params)
            ).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getIncomeHistory()', () => {
        it('should execute getIncomeHistory() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    symbol: '',
                    incomeType: 'TRANSFER',
                    income: '-0.37500000',
                    asset: 'USDT',
                    info: 'TRANSFER',
                    time: 1570608000000,
                    tranId: 9689322392,
                    tradeId: '',
                },
                {
                    symbol: 'BTCUSDT',
                    incomeType: 'COMMISSION',
                    income: '-0.01000000',
                    asset: 'USDT',
                    info: 'COMMISSION',
                    time: 1570636800000,
                    tranId: 9689322392,
                    tradeId: '2059192',
                },
            ];

            const spy = jest.spyOn(client, 'getIncomeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetIncomeHistoryResponse>)
            );
            const response = await client.getIncomeHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getIncomeHistory() successfully with optional parameters', async () => {
            const params: GetIncomeHistoryRequest = {
                symbol: 'symbol_example',
                incomeType: 'incomeType_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: '',
                    incomeType: 'TRANSFER',
                    income: '-0.37500000',
                    asset: 'USDT',
                    info: 'TRANSFER',
                    time: 1570608000000,
                    tranId: 9689322392,
                    tradeId: '',
                },
                {
                    symbol: 'BTCUSDT',
                    incomeType: 'COMMISSION',
                    income: '-0.01000000',
                    asset: 'USDT',
                    info: 'COMMISSION',
                    time: 1570636800000,
                    tranId: 9689322392,
                    tradeId: '2059192',
                },
            ];

            const spy = jest.spyOn(client, 'getIncomeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetIncomeHistoryResponse>)
            );
            const response = await client.getIncomeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getIncomeHistory').mockRejectedValueOnce(mockError);
            await expect(client.getIncomeHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('notionalAndLeverageBrackets()', () => {
        it('should execute notionalAndLeverageBrackets() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    symbol: 'ETHUSDT',
                    notionalCoef: 1.5,
                    brackets: [
                        {
                            bracket: 1,
                            initialLeverage: 75,
                            notionalCap: 10000,
                            notionalFloor: 0,
                            maintMarginRatio: 0.0065,
                            cum: 0,
                        },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'notionalAndLeverageBrackets').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NotionalAndLeverageBracketsResponse>)
            );
            const response = await client.notionalAndLeverageBrackets();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute notionalAndLeverageBrackets() successfully with optional parameters', async () => {
            const params: NotionalAndLeverageBracketsRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'ETHUSDT',
                    notionalCoef: 1.5,
                    brackets: [
                        {
                            bracket: 1,
                            initialLeverage: 75,
                            notionalCap: 10000,
                            notionalFloor: 0,
                            maintMarginRatio: 0.0065,
                            cum: 0,
                        },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'notionalAndLeverageBrackets').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NotionalAndLeverageBracketsResponse>)
            );
            const response = await client.notionalAndLeverageBrackets(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'notionalAndLeverageBrackets')
                .mockRejectedValueOnce(mockError);
            await expect(client.notionalAndLeverageBrackets()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryUserRateLimit()', () => {
        it('should execute queryUserRateLimit() successfully with required parameters only', async () => {
            mockResponse = [
                { rateLimitType: 'ORDERS', interval: 'SECOND', intervalNum: 10, limit: 10000 },
                { rateLimitType: 'ORDERS', interval: 'MINUTE', intervalNum: 1, limit: 20000 },
            ];

            const spy = jest.spyOn(client, 'queryUserRateLimit').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUserRateLimitResponse>)
            );
            const response = await client.queryUserRateLimit();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryUserRateLimit() successfully with optional parameters', async () => {
            const params: QueryUserRateLimitRequest = {
                recvWindow: 5000,
            };

            mockResponse = [
                { rateLimitType: 'ORDERS', interval: 'SECOND', intervalNum: 10, limit: 10000 },
                { rateLimitType: 'ORDERS', interval: 'MINUTE', intervalNum: 1, limit: 20000 },
            ];

            const spy = jest.spyOn(client, 'queryUserRateLimit').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUserRateLimitResponse>)
            );
            const response = await client.queryUserRateLimit(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'queryUserRateLimit').mockRejectedValueOnce(mockError);
            await expect(client.queryUserRateLimit()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('symbolConfiguration()', () => {
        it('should execute symbolConfiguration() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    marginType: 'CROSSED',
                    isAutoAddMargin: 'false',
                    leverage: 21,
                    maxNotionalValue: '1000000',
                },
            ];

            const spy = jest.spyOn(client, 'symbolConfiguration').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolConfigurationResponse>)
            );
            const response = await client.symbolConfiguration();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute symbolConfiguration() successfully with optional parameters', async () => {
            const params: SymbolConfigurationRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    marginType: 'CROSSED',
                    isAutoAddMargin: 'false',
                    leverage: 21,
                    maxNotionalValue: '1000000',
                },
            ];

            const spy = jest.spyOn(client, 'symbolConfiguration').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolConfigurationResponse>)
            );
            const response = await client.symbolConfiguration(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'symbolConfiguration').mockRejectedValueOnce(mockError);
            await expect(client.symbolConfiguration()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('toggleBnbBurnOnFuturesTrade()', () => {
        it('should execute toggleBnbBurnOnFuturesTrade() successfully with required parameters only', async () => {
            const params: ToggleBnbBurnOnFuturesTradeRequest = {
                feeBurn: 'feeBurn_example',
            };

            mockResponse = { code: 200, msg: 'success' };

            const spy = jest.spyOn(client, 'toggleBnbBurnOnFuturesTrade').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ToggleBnbBurnOnFuturesTradeResponse>)
            );
            const response = await client.toggleBnbBurnOnFuturesTrade(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute toggleBnbBurnOnFuturesTrade() successfully with optional parameters', async () => {
            const params: ToggleBnbBurnOnFuturesTradeRequest = {
                feeBurn: 'feeBurn_example',
                recvWindow: 5000,
            };

            mockResponse = { code: 200, msg: 'success' };

            const spy = jest.spyOn(client, 'toggleBnbBurnOnFuturesTrade').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ToggleBnbBurnOnFuturesTradeResponse>)
            );
            const response = await client.toggleBnbBurnOnFuturesTrade(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when feeBurn is missing', async () => {
            const _params: ToggleBnbBurnOnFuturesTradeRequest = {
                feeBurn: 'feeBurn_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.feeBurn;

            await expect(client.toggleBnbBurnOnFuturesTrade(params)).rejects.toThrow(
                'Required parameter feeBurn was null or undefined when calling toggleBnbBurnOnFuturesTrade.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ToggleBnbBurnOnFuturesTradeRequest = {
                feeBurn: 'feeBurn_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'toggleBnbBurnOnFuturesTrade')
                .mockRejectedValueOnce(mockError);
            await expect(client.toggleBnbBurnOnFuturesTrade(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('userCommissionRate()', () => {
        it('should execute userCommissionRate() successfully with required parameters only', async () => {
            const params: UserCommissionRateRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                makerCommissionRate: '0.0002',
                takerCommissionRate: '0.0004',
            };

            const spy = jest.spyOn(client, 'userCommissionRate').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UserCommissionRateResponse>)
            );
            const response = await client.userCommissionRate(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute userCommissionRate() successfully with optional parameters', async () => {
            const params: UserCommissionRateRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                makerCommissionRate: '0.0002',
                takerCommissionRate: '0.0004',
            };

            const spy = jest.spyOn(client, 'userCommissionRate').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UserCommissionRateResponse>)
            );
            const response = await client.userCommissionRate(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: UserCommissionRateRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.userCommissionRate(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling userCommissionRate.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: UserCommissionRateRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'userCommissionRate').mockRejectedValueOnce(mockError);
            await expect(client.userCommissionRate(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
