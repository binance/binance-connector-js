/**
 * Binance Public Derivatives Trading USDS Futures REST API
 *
 * OpenAPI Specification for the Binance Public Derivatives Trading USDS Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import {
    TradeApi,
    ChangeMarginTypeMarginTypeEnum,
    ModifyIsolatedPositionMarginPositionSideEnum,
    ModifyOrderSideEnum,
    ModifyOrderPriceMatchEnum,
    NewOrderSideEnum,
    NewOrderPositionSideEnum,
    NewOrderTimeInForceEnum,
    NewOrderWorkingTypeEnum,
    NewOrderNewOrderRespTypeEnum,
    NewOrderPriceMatchEnum,
    NewOrderSelfTradePreventionModeEnum,
    TestOrderSideEnum,
    TestOrderPositionSideEnum,
    TestOrderTimeInForceEnum,
    TestOrderWorkingTypeEnum,
    TestOrderNewOrderRespTypeEnum,
    TestOrderPriceMatchEnum,
    TestOrderSelfTradePreventionModeEnum,
    UsersForceOrdersAutoCloseTypeEnum,
} from '../../../src/rest-api';
import {
    AccountTradeListRequest,
    AllOrdersRequest,
    AutoCancelAllOpenOrdersRequest,
    CancelAllOpenOrdersRequest,
    CancelMultipleOrdersRequest,
    CancelOrderRequest,
    ChangeInitialLeverageRequest,
    ChangeMarginTypeRequest,
    ChangeMultiAssetsModeRequest,
    ChangePositionModeRequest,
    CurrentAllOpenOrdersRequest,
    GetOrderModifyHistoryRequest,
    GetPositionMarginChangeHistoryRequest,
    ModifyIsolatedPositionMarginRequest,
    ModifyMultipleOrdersRequest,
    ModifyOrderRequest,
    NewOrderRequest,
    PlaceMultipleOrdersRequest,
    PositionAdlQuantileEstimationRequest,
    PositionInformationV2Request,
    PositionInformationV3Request,
    QueryCurrentOpenOrderRequest,
    QueryOrderRequest,
    TestOrderRequest,
    UsersForceOrdersRequest,
} from '../../../src/rest-api';
import type {
    AccountTradeListResponse,
    AllOrdersResponse,
    AutoCancelAllOpenOrdersResponse,
    CancelAllOpenOrdersResponse,
    CancelMultipleOrdersResponse,
    CancelOrderResponse,
    ChangeInitialLeverageResponse,
    ChangeMarginTypeResponse,
    ChangeMultiAssetsModeResponse,
    ChangePositionModeResponse,
    CurrentAllOpenOrdersResponse,
    GetOrderModifyHistoryResponse,
    GetPositionMarginChangeHistoryResponse,
    ModifyIsolatedPositionMarginResponse,
    ModifyMultipleOrdersResponse,
    ModifyOrderResponse,
    NewOrderResponse,
    PlaceMultipleOrdersResponse,
    PositionAdlQuantileEstimationResponse,
    PositionInformationV2Response,
    PositionInformationV3Response,
    QueryCurrentOpenOrderResponse,
    QueryOrderResponse,
    TestOrderResponse,
    UsersForceOrdersResponse,
} from '../../../src/rest-api/types';

describe('TradeApi', () => {
    let client: TradeApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new TradeApi(config);
    });

    describe('accountTradeList()', () => {
        it('should execute accountTradeList() successfully with required parameters only', async () => {
            const params: AccountTradeListRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    buyer: false,
                    commission: '-0.07819010',
                    commissionAsset: 'USDT',
                    id: 698759,
                    maker: false,
                    orderId: 25851813,
                    price: '7819.01',
                    qty: '0.002',
                    quoteQty: '15.63802',
                    realizedPnl: '-0.91539999',
                    side: 'SELL',
                    positionSide: 'SHORT',
                    symbol: 'BTCUSDT',
                    time: 1569514978020,
                },
            ];

            const spy = jest.spyOn(client, 'accountTradeList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountTradeListResponse>)
            );
            const response = await client.accountTradeList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute accountTradeList() successfully with optional parameters', async () => {
            const params: AccountTradeListRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                fromId: 1,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    buyer: false,
                    commission: '-0.07819010',
                    commissionAsset: 'USDT',
                    id: 698759,
                    maker: false,
                    orderId: 25851813,
                    price: '7819.01',
                    qty: '0.002',
                    quoteQty: '15.63802',
                    realizedPnl: '-0.91539999',
                    side: 'SELL',
                    positionSide: 'SHORT',
                    symbol: 'BTCUSDT',
                    time: 1569514978020,
                },
            ];

            const spy = jest.spyOn(client, 'accountTradeList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountTradeListResponse>)
            );
            const response = await client.accountTradeList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: AccountTradeListRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.accountTradeList(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling accountTradeList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AccountTradeListRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'accountTradeList').mockRejectedValueOnce(mockError);
            await expect(client.accountTradeList(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('allOrders()', () => {
        it('should execute allOrders() successfully with required parameters only', async () => {
            const params: AllOrdersRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    avgPrice: '0.00000',
                    clientOrderId: 'abc',
                    cumQuote: '0',
                    executedQty: '0',
                    orderId: 1917641,
                    origQty: '0.40',
                    origType: 'TRAILING_STOP_MARKET',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSDT',
                    time: 1579276756075,
                    timeInForce: 'GTC',
                    type: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1579276756075,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 0,
                },
            ];

            const spy = jest.spyOn(client, 'allOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AllOrdersResponse>)
            );
            const response = await client.allOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute allOrders() successfully with optional parameters', async () => {
            const params: AllOrdersRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    avgPrice: '0.00000',
                    clientOrderId: 'abc',
                    cumQuote: '0',
                    executedQty: '0',
                    orderId: 1917641,
                    origQty: '0.40',
                    origType: 'TRAILING_STOP_MARKET',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSDT',
                    time: 1579276756075,
                    timeInForce: 'GTC',
                    type: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1579276756075,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 0,
                },
            ];

            const spy = jest.spyOn(client, 'allOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AllOrdersResponse>)
            );
            const response = await client.allOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: AllOrdersRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.allOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling allOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AllOrdersRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'allOrders').mockRejectedValueOnce(mockError);
            await expect(client.allOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('autoCancelAllOpenOrders()', () => {
        it('should execute autoCancelAllOpenOrders() successfully with required parameters only', async () => {
            const params: AutoCancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
                countdownTime: 789,
            };

            mockResponse = { symbol: 'BTCUSDT', countdownTime: '100000' };

            const spy = jest.spyOn(client, 'autoCancelAllOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AutoCancelAllOpenOrdersResponse>)
            );
            const response = await client.autoCancelAllOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute autoCancelAllOpenOrders() successfully with optional parameters', async () => {
            const params: AutoCancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
                countdownTime: 789,
                recvWindow: 5000,
            };

            mockResponse = { symbol: 'BTCUSDT', countdownTime: '100000' };

            const spy = jest.spyOn(client, 'autoCancelAllOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AutoCancelAllOpenOrdersResponse>)
            );
            const response = await client.autoCancelAllOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: AutoCancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
                countdownTime: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.autoCancelAllOpenOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling autoCancelAllOpenOrders.'
            );
        });

        it('should throw RequiredError when countdownTime is missing', async () => {
            const _params: AutoCancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
                countdownTime: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.countdownTime;

            await expect(client.autoCancelAllOpenOrders(params)).rejects.toThrow(
                'Required parameter countdownTime was null or undefined when calling autoCancelAllOpenOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: AutoCancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
                countdownTime: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'autoCancelAllOpenOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.autoCancelAllOpenOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cancelAllOpenOrders()', () => {
        it('should execute cancelAllOpenOrders() successfully with required parameters only', async () => {
            const params: CancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = { code: 200, msg: 'The operation of cancel all open order is done.' };

            const spy = jest.spyOn(client, 'cancelAllOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelAllOpenOrdersResponse>)
            );
            const response = await client.cancelAllOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelAllOpenOrders() successfully with optional parameters', async () => {
            const params: CancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = { code: 200, msg: 'The operation of cancel all open order is done.' };

            const spy = jest.spyOn(client, 'cancelAllOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelAllOpenOrdersResponse>)
            );
            const response = await client.cancelAllOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelAllOpenOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelAllOpenOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelAllOpenOrdersRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'cancelAllOpenOrders').mockRejectedValueOnce(mockError);
            await expect(client.cancelAllOpenOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cancelMultipleOrders()', () => {
        it('should execute cancelMultipleOrders() successfully with required parameters only', async () => {
            const params: CancelMultipleOrdersRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    clientOrderId: 'myOrder1',
                    cumQty: '0',
                    cumQuote: '0',
                    executedQty: '0',
                    orderId: 283194212,
                    origQty: '11',
                    origType: 'TRAILING_STOP_MARKET',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'CANCELED',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSDT',
                    timeInForce: 'GTC',
                    type: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1571110484038,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 1693207680000,
                },
                { code: -2011, msg: 'Unknown order sent.' },
            ];

            const spy = jest.spyOn(client, 'cancelMultipleOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelMultipleOrdersResponse>)
            );
            const response = await client.cancelMultipleOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelMultipleOrders() successfully with optional parameters', async () => {
            const params: CancelMultipleOrdersRequest = {
                symbol: 'symbol_example',
                orderIdList: [1234567],
                origClientOrderIdList: ['my_id_1'],
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    clientOrderId: 'myOrder1',
                    cumQty: '0',
                    cumQuote: '0',
                    executedQty: '0',
                    orderId: 283194212,
                    origQty: '11',
                    origType: 'TRAILING_STOP_MARKET',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'CANCELED',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSDT',
                    timeInForce: 'GTC',
                    type: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1571110484038,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 1693207680000,
                },
                { code: -2011, msg: 'Unknown order sent.' },
            ];

            const spy = jest.spyOn(client, 'cancelMultipleOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelMultipleOrdersResponse>)
            );
            const response = await client.cancelMultipleOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelMultipleOrdersRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelMultipleOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelMultipleOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelMultipleOrdersRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'cancelMultipleOrders').mockRejectedValueOnce(mockError);
            await expect(client.cancelMultipleOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cancelOrder()', () => {
        it('should execute cancelOrder() successfully with required parameters only', async () => {
            const params: CancelOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                clientOrderId: 'myOrder1',
                cumQty: '0',
                cumQuote: '0',
                executedQty: '0',
                orderId: 283194212,
                origQty: '11',
                origType: 'TRAILING_STOP_MARKET',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'CANCELED',
                stopPrice: '9300',
                closePosition: false,
                symbol: 'BTCUSDT',
                timeInForce: 'GTC',
                type: 'TRAILING_STOP_MARKET',
                activatePrice: '9020',
                priceRate: '0.3',
                updateTime: 1571110484038,
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
                priceMatch: 'NONE',
                selfTradePreventionMode: 'NONE',
                goodTillDate: 1693207680000,
            };

            const spy = jest.spyOn(client, 'cancelOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelOrderResponse>)
            );
            const response = await client.cancelOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelOrder() successfully with optional parameters', async () => {
            const params: CancelOrderRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                origClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                clientOrderId: 'myOrder1',
                cumQty: '0',
                cumQuote: '0',
                executedQty: '0',
                orderId: 283194212,
                origQty: '11',
                origType: 'TRAILING_STOP_MARKET',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'CANCELED',
                stopPrice: '9300',
                closePosition: false,
                symbol: 'BTCUSDT',
                timeInForce: 'GTC',
                type: 'TRAILING_STOP_MARKET',
                activatePrice: '9020',
                priceRate: '0.3',
                updateTime: 1571110484038,
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
                priceMatch: 'NONE',
                selfTradePreventionMode: 'NONE',
                goodTillDate: 1693207680000,
            };

            const spy = jest.spyOn(client, 'cancelOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelOrderResponse>)
            );
            const response = await client.cancelOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'cancelOrder').mockRejectedValueOnce(mockError);
            await expect(client.cancelOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('changeInitialLeverage()', () => {
        it('should execute changeInitialLeverage() successfully with required parameters only', async () => {
            const params: ChangeInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
            };

            mockResponse = { leverage: 21, maxNotionalValue: '1000000', symbol: 'BTCUSDT' };

            const spy = jest.spyOn(client, 'changeInitialLeverage').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeInitialLeverageResponse>)
            );
            const response = await client.changeInitialLeverage(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute changeInitialLeverage() successfully with optional parameters', async () => {
            const params: ChangeInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
                recvWindow: 5000,
            };

            mockResponse = { leverage: 21, maxNotionalValue: '1000000', symbol: 'BTCUSDT' };

            const spy = jest.spyOn(client, 'changeInitialLeverage').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeInitialLeverageResponse>)
            );
            const response = await client.changeInitialLeverage(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: ChangeInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.changeInitialLeverage(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling changeInitialLeverage.'
            );
        });

        it('should throw RequiredError when leverage is missing', async () => {
            const _params: ChangeInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
            };
            const params = Object.assign({ ..._params });
            delete params?.leverage;

            await expect(client.changeInitialLeverage(params)).rejects.toThrow(
                'Required parameter leverage was null or undefined when calling changeInitialLeverage.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ChangeInitialLeverageRequest = {
                symbol: 'symbol_example',
                leverage: 789,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'changeInitialLeverage')
                .mockRejectedValueOnce(mockError);
            await expect(client.changeInitialLeverage(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('changeMarginType()', () => {
        it('should execute changeMarginType() successfully with required parameters only', async () => {
            const params: ChangeMarginTypeRequest = {
                symbol: 'symbol_example',
                marginType: ChangeMarginTypeMarginTypeEnum.ISOLATED,
            };

            mockResponse = { code: 200, msg: 'success' };

            const spy = jest.spyOn(client, 'changeMarginType').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeMarginTypeResponse>)
            );
            const response = await client.changeMarginType(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute changeMarginType() successfully with optional parameters', async () => {
            const params: ChangeMarginTypeRequest = {
                symbol: 'symbol_example',
                marginType: ChangeMarginTypeMarginTypeEnum.ISOLATED,
                recvWindow: 5000,
            };

            mockResponse = { code: 200, msg: 'success' };

            const spy = jest.spyOn(client, 'changeMarginType').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeMarginTypeResponse>)
            );
            const response = await client.changeMarginType(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: ChangeMarginTypeRequest = {
                symbol: 'symbol_example',
                marginType: ChangeMarginTypeMarginTypeEnum.ISOLATED,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.changeMarginType(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling changeMarginType.'
            );
        });

        it('should throw RequiredError when marginType is missing', async () => {
            const _params: ChangeMarginTypeRequest = {
                symbol: 'symbol_example',
                marginType: ChangeMarginTypeMarginTypeEnum.ISOLATED,
            };
            const params = Object.assign({ ..._params });
            delete params?.marginType;

            await expect(client.changeMarginType(params)).rejects.toThrow(
                'Required parameter marginType was null or undefined when calling changeMarginType.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ChangeMarginTypeRequest = {
                symbol: 'symbol_example',
                marginType: ChangeMarginTypeMarginTypeEnum.ISOLATED,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'changeMarginType').mockRejectedValueOnce(mockError);
            await expect(client.changeMarginType(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('changeMultiAssetsMode()', () => {
        it('should execute changeMultiAssetsMode() successfully with required parameters only', async () => {
            const params: ChangeMultiAssetsModeRequest = {
                multiAssetsMargin: 'multiAssetsMargin_example',
            };

            mockResponse = { code: 200, msg: 'success' };

            const spy = jest.spyOn(client, 'changeMultiAssetsMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeMultiAssetsModeResponse>)
            );
            const response = await client.changeMultiAssetsMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute changeMultiAssetsMode() successfully with optional parameters', async () => {
            const params: ChangeMultiAssetsModeRequest = {
                multiAssetsMargin: 'multiAssetsMargin_example',
                recvWindow: 5000,
            };

            mockResponse = { code: 200, msg: 'success' };

            const spy = jest.spyOn(client, 'changeMultiAssetsMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeMultiAssetsModeResponse>)
            );
            const response = await client.changeMultiAssetsMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when multiAssetsMargin is missing', async () => {
            const _params: ChangeMultiAssetsModeRequest = {
                multiAssetsMargin: 'multiAssetsMargin_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.multiAssetsMargin;

            await expect(client.changeMultiAssetsMode(params)).rejects.toThrow(
                'Required parameter multiAssetsMargin was null or undefined when calling changeMultiAssetsMode.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ChangeMultiAssetsModeRequest = {
                multiAssetsMargin: 'multiAssetsMargin_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'changeMultiAssetsMode')
                .mockRejectedValueOnce(mockError);
            await expect(client.changeMultiAssetsMode(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('changePositionMode()', () => {
        it('should execute changePositionMode() successfully with required parameters only', async () => {
            const params: ChangePositionModeRequest = {
                dualSidePosition: 'dualSidePosition_example',
            };

            mockResponse = { code: 200, msg: 'success' };

            const spy = jest.spyOn(client, 'changePositionMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangePositionModeResponse>)
            );
            const response = await client.changePositionMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute changePositionMode() successfully with optional parameters', async () => {
            const params: ChangePositionModeRequest = {
                dualSidePosition: 'dualSidePosition_example',
                recvWindow: 5000,
            };

            mockResponse = { code: 200, msg: 'success' };

            const spy = jest.spyOn(client, 'changePositionMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangePositionModeResponse>)
            );
            const response = await client.changePositionMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when dualSidePosition is missing', async () => {
            const _params: ChangePositionModeRequest = {
                dualSidePosition: 'dualSidePosition_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.dualSidePosition;

            await expect(client.changePositionMode(params)).rejects.toThrow(
                'Required parameter dualSidePosition was null or undefined when calling changePositionMode.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ChangePositionModeRequest = {
                dualSidePosition: 'dualSidePosition_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'changePositionMode').mockRejectedValueOnce(mockError);
            await expect(client.changePositionMode(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('currentAllOpenOrders()', () => {
        it('should execute currentAllOpenOrders() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    avgPrice: '0.00000',
                    clientOrderId: 'abc',
                    cumQuote: '0',
                    executedQty: '0',
                    orderId: 1917641,
                    origQty: '0.40',
                    origType: 'TRAILING_STOP_MARKET',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSDT',
                    time: 1579276756075,
                    timeInForce: 'GTC',
                    type: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1579276756075,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 0,
                },
            ];

            const spy = jest.spyOn(client, 'currentAllOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CurrentAllOpenOrdersResponse>)
            );
            const response = await client.currentAllOpenOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute currentAllOpenOrders() successfully with optional parameters', async () => {
            const params: CurrentAllOpenOrdersRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    avgPrice: '0.00000',
                    clientOrderId: 'abc',
                    cumQuote: '0',
                    executedQty: '0',
                    orderId: 1917641,
                    origQty: '0.40',
                    origType: 'TRAILING_STOP_MARKET',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    stopPrice: '9300',
                    closePosition: false,
                    symbol: 'BTCUSDT',
                    time: 1579276756075,
                    timeInForce: 'GTC',
                    type: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1579276756075,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 0,
                },
            ];

            const spy = jest.spyOn(client, 'currentAllOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CurrentAllOpenOrdersResponse>)
            );
            const response = await client.currentAllOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'currentAllOpenOrders').mockRejectedValueOnce(mockError);
            await expect(client.currentAllOpenOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getOrderModifyHistory()', () => {
        it('should execute getOrderModifyHistory() successfully with required parameters only', async () => {
            const params: GetOrderModifyHistoryRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    amendmentId: 5363,
                    symbol: 'BTCUSDT',
                    pair: 'BTCUSDT',
                    orderId: 20072994037,
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    time: 1629184560899,
                    amendment: {
                        price: { before: '30004', after: '30003.2' },
                        origQty: { before: '1', after: '1' },
                        count: 3,
                    },
                },
                {
                    amendmentId: 5361,
                    symbol: 'BTCUSDT',
                    pair: 'BTCUSDT',
                    orderId: 20072994037,
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    time: 1629184533946,
                    amendment: {
                        price: { before: '30005', after: '30004' },
                        origQty: { before: '1', after: '1' },
                        count: 2,
                    },
                },
                {
                    amendmentId: 5325,
                    symbol: 'BTCUSDT',
                    pair: 'BTCUSDT',
                    orderId: 20072994037,
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    time: 1629182711787,
                    amendment: {
                        price: { before: '30002', after: '30005' },
                        origQty: { before: '1', after: '1' },
                        count: 1,
                    },
                },
            ];

            const spy = jest.spyOn(client, 'getOrderModifyHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOrderModifyHistoryResponse>)
            );
            const response = await client.getOrderModifyHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getOrderModifyHistory() successfully with optional parameters', async () => {
            const params: GetOrderModifyHistoryRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                origClientOrderId: '1',
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    amendmentId: 5363,
                    symbol: 'BTCUSDT',
                    pair: 'BTCUSDT',
                    orderId: 20072994037,
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    time: 1629184560899,
                    amendment: {
                        price: { before: '30004', after: '30003.2' },
                        origQty: { before: '1', after: '1' },
                        count: 3,
                    },
                },
                {
                    amendmentId: 5361,
                    symbol: 'BTCUSDT',
                    pair: 'BTCUSDT',
                    orderId: 20072994037,
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    time: 1629184533946,
                    amendment: {
                        price: { before: '30005', after: '30004' },
                        origQty: { before: '1', after: '1' },
                        count: 2,
                    },
                },
                {
                    amendmentId: 5325,
                    symbol: 'BTCUSDT',
                    pair: 'BTCUSDT',
                    orderId: 20072994037,
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    time: 1629182711787,
                    amendment: {
                        price: { before: '30002', after: '30005' },
                        origQty: { before: '1', after: '1' },
                        count: 1,
                    },
                },
            ];

            const spy = jest.spyOn(client, 'getOrderModifyHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetOrderModifyHistoryResponse>)
            );
            const response = await client.getOrderModifyHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: GetOrderModifyHistoryRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.getOrderModifyHistory(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling getOrderModifyHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetOrderModifyHistoryRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getOrderModifyHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getOrderModifyHistory(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getPositionMarginChangeHistory()', () => {
        it('should execute getPositionMarginChangeHistory() successfully with required parameters only', async () => {
            const params: GetPositionMarginChangeHistoryRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    type: 1,
                    deltaType: 'USER_ADJUST',
                    amount: '23.36332311',
                    asset: 'USDT',
                    time: 1578047897183,
                    positionSide: 'BOTH',
                },
                {
                    symbol: 'BTCUSDT',
                    type: 1,
                    deltaType: 'USER_ADJUST',
                    amount: '100',
                    asset: 'USDT',
                    time: 1578047900425,
                    positionSide: 'LONG',
                },
            ];

            const spy = jest.spyOn(client, 'getPositionMarginChangeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetPositionMarginChangeHistoryResponse>)
            );
            const response = await client.getPositionMarginChangeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getPositionMarginChangeHistory() successfully with optional parameters', async () => {
            const params: GetPositionMarginChangeHistoryRequest = {
                symbol: 'symbol_example',
                type: 789,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    type: 1,
                    deltaType: 'USER_ADJUST',
                    amount: '23.36332311',
                    asset: 'USDT',
                    time: 1578047897183,
                    positionSide: 'BOTH',
                },
                {
                    symbol: 'BTCUSDT',
                    type: 1,
                    deltaType: 'USER_ADJUST',
                    amount: '100',
                    asset: 'USDT',
                    time: 1578047900425,
                    positionSide: 'LONG',
                },
            ];

            const spy = jest.spyOn(client, 'getPositionMarginChangeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetPositionMarginChangeHistoryResponse>)
            );
            const response = await client.getPositionMarginChangeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: GetPositionMarginChangeHistoryRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.getPositionMarginChangeHistory(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling getPositionMarginChangeHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetPositionMarginChangeHistoryRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getPositionMarginChangeHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getPositionMarginChangeHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('modifyIsolatedPositionMargin()', () => {
        it('should execute modifyIsolatedPositionMargin() successfully with required parameters only', async () => {
            const params: ModifyIsolatedPositionMarginRequest = {
                symbol: 'symbol_example',
                amount: 1,
                type: 'type_example',
            };

            mockResponse = {
                amount: 100,
                code: 200,
                msg: 'Successfully modify position margin.',
                type: 1,
            };

            const spy = jest.spyOn(client, 'modifyIsolatedPositionMargin').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ModifyIsolatedPositionMarginResponse>)
            );
            const response = await client.modifyIsolatedPositionMargin(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute modifyIsolatedPositionMargin() successfully with optional parameters', async () => {
            const params: ModifyIsolatedPositionMarginRequest = {
                symbol: 'symbol_example',
                amount: 1,
                type: 'type_example',
                positionSide: ModifyIsolatedPositionMarginPositionSideEnum.BOTH,
                recvWindow: 5000,
            };

            mockResponse = {
                amount: 100,
                code: 200,
                msg: 'Successfully modify position margin.',
                type: 1,
            };

            const spy = jest.spyOn(client, 'modifyIsolatedPositionMargin').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ModifyIsolatedPositionMarginResponse>)
            );
            const response = await client.modifyIsolatedPositionMargin(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: ModifyIsolatedPositionMarginRequest = {
                symbol: 'symbol_example',
                amount: 1,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.modifyIsolatedPositionMargin(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling modifyIsolatedPositionMargin.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: ModifyIsolatedPositionMarginRequest = {
                symbol: 'symbol_example',
                amount: 1,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.modifyIsolatedPositionMargin(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling modifyIsolatedPositionMargin.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: ModifyIsolatedPositionMarginRequest = {
                symbol: 'symbol_example',
                amount: 1,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.modifyIsolatedPositionMargin(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling modifyIsolatedPositionMargin.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ModifyIsolatedPositionMarginRequest = {
                symbol: 'symbol_example',
                amount: 1,
                type: 'type_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'modifyIsolatedPositionMargin')
                .mockRejectedValueOnce(mockError);
            await expect(client.modifyIsolatedPositionMargin(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('modifyMultipleOrders()', () => {
        it('should execute modifyMultipleOrders() successfully with required parameters only', async () => {
            const params: ModifyMultipleOrdersRequest = {
                batchOrders: [],
            };

            mockResponse = [
                {
                    orderId: 20072994037,
                    symbol: 'BTCUSDT',
                    pair: 'BTCUSDT',
                    status: 'NEW',
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    price: '30005',
                    avgPrice: '0.0',
                    origQty: '1',
                    executedQty: '0',
                    cumQty: '0',
                    cumBase: '0',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    reduceOnly: false,
                    closePosition: false,
                    side: 'BUY',
                    positionSide: 'LONG',
                    stopPrice: '0',
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    origType: 'LIMIT',
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 0,
                    updateTime: 1629182711600,
                },
                { code: -2022, msg: 'ReduceOnly Order is rejected.' },
            ];

            const spy = jest.spyOn(client, 'modifyMultipleOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ModifyMultipleOrdersResponse>)
            );
            const response = await client.modifyMultipleOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute modifyMultipleOrders() successfully with optional parameters', async () => {
            const params: ModifyMultipleOrdersRequest = {
                batchOrders: [],
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    orderId: 20072994037,
                    symbol: 'BTCUSDT',
                    pair: 'BTCUSDT',
                    status: 'NEW',
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    price: '30005',
                    avgPrice: '0.0',
                    origQty: '1',
                    executedQty: '0',
                    cumQty: '0',
                    cumBase: '0',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    reduceOnly: false,
                    closePosition: false,
                    side: 'BUY',
                    positionSide: 'LONG',
                    stopPrice: '0',
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    origType: 'LIMIT',
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 0,
                    updateTime: 1629182711600,
                },
                { code: -2022, msg: 'ReduceOnly Order is rejected.' },
            ];

            const spy = jest.spyOn(client, 'modifyMultipleOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ModifyMultipleOrdersResponse>)
            );
            const response = await client.modifyMultipleOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when batchOrders is missing', async () => {
            const _params: ModifyMultipleOrdersRequest = {
                batchOrders: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.batchOrders;

            await expect(client.modifyMultipleOrders(params)).rejects.toThrow(
                'Required parameter batchOrders was null or undefined when calling modifyMultipleOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ModifyMultipleOrdersRequest = {
                batchOrders: [],
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'modifyMultipleOrders').mockRejectedValueOnce(mockError);
            await expect(client.modifyMultipleOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('modifyOrder()', () => {
        it('should execute modifyOrder() successfully with required parameters only', async () => {
            const params: ModifyOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyOrderSideEnum.BUY,
                quantity: 1,
                price: 1,
            };

            mockResponse = {
                orderId: 20072994037,
                symbol: 'BTCUSDT',
                pair: 'BTCUSDT',
                status: 'NEW',
                clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                price: '30005',
                avgPrice: '0.0',
                origQty: '1',
                executedQty: '0',
                cumQty: '0',
                cumBase: '0',
                timeInForce: 'GTC',
                type: 'LIMIT',
                reduceOnly: false,
                closePosition: false,
                side: 'BUY',
                positionSide: 'LONG',
                stopPrice: '0',
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
                origType: 'LIMIT',
                priceMatch: 'NONE',
                selfTradePreventionMode: 'NONE',
                goodTillDate: 0,
                updateTime: 1629182711600,
            };

            const spy = jest.spyOn(client, 'modifyOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ModifyOrderResponse>)
            );
            const response = await client.modifyOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute modifyOrder() successfully with optional parameters', async () => {
            const params: ModifyOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyOrderSideEnum.BUY,
                quantity: 1,
                price: 1,
                orderId: 1,
                origClientOrderId: '1',
                priceMatch: ModifyOrderPriceMatchEnum.NONE,
                recvWindow: 5000,
            };

            mockResponse = {
                orderId: 20072994037,
                symbol: 'BTCUSDT',
                pair: 'BTCUSDT',
                status: 'NEW',
                clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                price: '30005',
                avgPrice: '0.0',
                origQty: '1',
                executedQty: '0',
                cumQty: '0',
                cumBase: '0',
                timeInForce: 'GTC',
                type: 'LIMIT',
                reduceOnly: false,
                closePosition: false,
                side: 'BUY',
                positionSide: 'LONG',
                stopPrice: '0',
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
                origType: 'LIMIT',
                priceMatch: 'NONE',
                selfTradePreventionMode: 'NONE',
                goodTillDate: 0,
                updateTime: 1629182711600,
            };

            const spy = jest.spyOn(client, 'modifyOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ModifyOrderResponse>)
            );
            const response = await client.modifyOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: ModifyOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyOrderSideEnum.BUY,
                quantity: 1,
                price: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.modifyOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling modifyOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: ModifyOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyOrderSideEnum.BUY,
                quantity: 1,
                price: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.modifyOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling modifyOrder.'
            );
        });

        it('should throw RequiredError when quantity is missing', async () => {
            const _params: ModifyOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyOrderSideEnum.BUY,
                quantity: 1,
                price: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.quantity;

            await expect(client.modifyOrder(params)).rejects.toThrow(
                'Required parameter quantity was null or undefined when calling modifyOrder.'
            );
        });

        it('should throw RequiredError when price is missing', async () => {
            const _params: ModifyOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyOrderSideEnum.BUY,
                quantity: 1,
                price: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.price;

            await expect(client.modifyOrder(params)).rejects.toThrow(
                'Required parameter price was null or undefined when calling modifyOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ModifyOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyOrderSideEnum.BUY,
                quantity: 1,
                price: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'modifyOrder').mockRejectedValueOnce(mockError);
            await expect(client.modifyOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('newOrder()', () => {
        it('should execute newOrder() successfully with required parameters only', async () => {
            const params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: 'type_example',
            };

            mockResponse = {
                clientOrderId: 'testOrder',
                cumQty: '0',
                cumQuote: '0',
                executedQty: '0',
                orderId: 22542179,
                avgPrice: '0.00000',
                origQty: '10',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'NEW',
                stopPrice: '9300',
                closePosition: false,
                symbol: 'BTCUSDT',
                timeInForce: 'GTD',
                type: 'TRAILING_STOP_MARKET',
                origType: 'TRAILING_STOP_MARKET',
                activatePrice: '9020',
                priceRate: '0.3',
                updateTime: 1566818724722,
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
                priceMatch: 'NONE',
                selfTradePreventionMode: 'NONE',
                goodTillDate: 1693207680000,
            };

            const spy = jest.spyOn(client, 'newOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewOrderResponse>)
            );
            const response = await client.newOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute newOrder() successfully with optional parameters', async () => {
            const params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: 'type_example',
                positionSide: NewOrderPositionSideEnum.BOTH,
                timeInForce: NewOrderTimeInForceEnum.GTC,
                quantity: 1,
                reduceOnly: 'false',
                price: 1,
                newClientOrderId: '1',
                stopPrice: 1,
                closePosition: 'closePosition_example',
                activationPrice: 1,
                callbackRate: 1,
                workingType: NewOrderWorkingTypeEnum.MARK_PRICE,
                priceProtect: 'false',
                newOrderRespType: NewOrderNewOrderRespTypeEnum.ACK,
                priceMatch: NewOrderPriceMatchEnum.NONE,
                selfTradePreventionMode: NewOrderSelfTradePreventionModeEnum.EXPIRE_TAKER,
                goodTillDate: 789,
                recvWindow: 5000,
            };

            mockResponse = {
                clientOrderId: 'testOrder',
                cumQty: '0',
                cumQuote: '0',
                executedQty: '0',
                orderId: 22542179,
                avgPrice: '0.00000',
                origQty: '10',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'NEW',
                stopPrice: '9300',
                closePosition: false,
                symbol: 'BTCUSDT',
                timeInForce: 'GTD',
                type: 'TRAILING_STOP_MARKET',
                origType: 'TRAILING_STOP_MARKET',
                activatePrice: '9020',
                priceRate: '0.3',
                updateTime: 1566818724722,
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
                priceMatch: 'NONE',
                selfTradePreventionMode: 'NONE',
                goodTillDate: 1693207680000,
            };

            const spy = jest.spyOn(client, 'newOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewOrderResponse>)
            );
            const response = await client.newOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.newOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling newOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.newOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling newOrder.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.newOrder(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling newOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: NewOrderRequest = {
                symbol: 'symbol_example',
                side: NewOrderSideEnum.BUY,
                type: 'type_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'newOrder').mockRejectedValueOnce(mockError);
            await expect(client.newOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('placeMultipleOrders()', () => {
        it('should execute placeMultipleOrders() successfully with required parameters only', async () => {
            const params: PlaceMultipleOrdersRequest = {
                batchOrders: [],
            };

            mockResponse = [
                {
                    clientOrderId: 'testOrder',
                    cumQty: '0',
                    cumQuote: '0',
                    executedQty: '0',
                    orderId: 22542179,
                    avgPrice: '0.00000',
                    origQty: '10',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    stopPrice: '9300',
                    symbol: 'BTCUSDT',
                    timeInForce: 'GTC',
                    type: 'TRAILING_STOP_MARKET',
                    origType: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1566818724722,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 1693207680000,
                },
                { code: -2022, msg: 'ReduceOnly Order is rejected.' },
            ];

            const spy = jest.spyOn(client, 'placeMultipleOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PlaceMultipleOrdersResponse>)
            );
            const response = await client.placeMultipleOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute placeMultipleOrders() successfully with optional parameters', async () => {
            const params: PlaceMultipleOrdersRequest = {
                batchOrders: [],
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    clientOrderId: 'testOrder',
                    cumQty: '0',
                    cumQuote: '0',
                    executedQty: '0',
                    orderId: 22542179,
                    avgPrice: '0.00000',
                    origQty: '10',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    stopPrice: '9300',
                    symbol: 'BTCUSDT',
                    timeInForce: 'GTC',
                    type: 'TRAILING_STOP_MARKET',
                    origType: 'TRAILING_STOP_MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    updateTime: 1566818724722,
                    workingType: 'CONTRACT_PRICE',
                    priceProtect: false,
                    priceMatch: 'NONE',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 1693207680000,
                },
                { code: -2022, msg: 'ReduceOnly Order is rejected.' },
            ];

            const spy = jest.spyOn(client, 'placeMultipleOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PlaceMultipleOrdersResponse>)
            );
            const response = await client.placeMultipleOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when batchOrders is missing', async () => {
            const _params: PlaceMultipleOrdersRequest = {
                batchOrders: [],
            };
            const params = Object.assign({ ..._params });
            delete params?.batchOrders;

            await expect(client.placeMultipleOrders(params)).rejects.toThrow(
                'Required parameter batchOrders was null or undefined when calling placeMultipleOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: PlaceMultipleOrdersRequest = {
                batchOrders: [],
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'placeMultipleOrders').mockRejectedValueOnce(mockError);
            await expect(client.placeMultipleOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('positionAdlQuantileEstimation()', () => {
        it('should execute positionAdlQuantileEstimation() successfully with required parameters only', async () => {
            mockResponse = [
                { symbol: 'ETHUSDT', adlQuantile: { LONG: 3, SHORT: 3, HEDGE: 0 } },
                { symbol: 'BTCUSDT', adlQuantile: { LONG: 1, SHORT: 2, BOTH: 0 } },
            ];

            const spy = jest.spyOn(client, 'positionAdlQuantileEstimation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PositionAdlQuantileEstimationResponse>)
            );
            const response = await client.positionAdlQuantileEstimation();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute positionAdlQuantileEstimation() successfully with optional parameters', async () => {
            const params: PositionAdlQuantileEstimationRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = [
                { symbol: 'ETHUSDT', adlQuantile: { LONG: 3, SHORT: 3, HEDGE: 0 } },
                { symbol: 'BTCUSDT', adlQuantile: { LONG: 1, SHORT: 2, BOTH: 0 } },
            ];

            const spy = jest.spyOn(client, 'positionAdlQuantileEstimation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PositionAdlQuantileEstimationResponse>)
            );
            const response = await client.positionAdlQuantileEstimation(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'positionAdlQuantileEstimation')
                .mockRejectedValueOnce(mockError);
            await expect(client.positionAdlQuantileEstimation()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('positionInformationV2()', () => {
        it('should execute positionInformationV2() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    entryPrice: '0.00000',
                    breakEvenPrice: '0.0',
                    marginType: 'isolated',
                    isAutoAddMargin: 'false',
                    isolatedMargin: '0.00000000',
                    leverage: '10',
                    liquidationPrice: '0',
                    markPrice: '6679.50671178',
                    maxNotionalValue: '20000000',
                    positionAmt: '0.000',
                    notional: '0',
                    isolatedWallet: '0',
                    symbol: 'BTCUSDT',
                    unRealizedProfit: '0.00000000',
                    positionSide: 'BOTH',
                    updateTime: 0,
                },
            ];

            const spy = jest.spyOn(client, 'positionInformationV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PositionInformationV2Response>)
            );
            const response = await client.positionInformationV2();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute positionInformationV2() successfully with optional parameters', async () => {
            const params: PositionInformationV2Request = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    entryPrice: '0.00000',
                    breakEvenPrice: '0.0',
                    marginType: 'isolated',
                    isAutoAddMargin: 'false',
                    isolatedMargin: '0.00000000',
                    leverage: '10',
                    liquidationPrice: '0',
                    markPrice: '6679.50671178',
                    maxNotionalValue: '20000000',
                    positionAmt: '0.000',
                    notional: '0',
                    isolatedWallet: '0',
                    symbol: 'BTCUSDT',
                    unRealizedProfit: '0.00000000',
                    positionSide: 'BOTH',
                    updateTime: 0,
                },
            ];

            const spy = jest.spyOn(client, 'positionInformationV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PositionInformationV2Response>)
            );
            const response = await client.positionInformationV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'positionInformationV2')
                .mockRejectedValueOnce(mockError);
            await expect(client.positionInformationV2()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('positionInformationV3()', () => {
        it('should execute positionInformationV3() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    symbol: 'ADAUSDT',
                    positionSide: 'BOTH',
                    positionAmt: '30',
                    entryPrice: '0.385',
                    breakEvenPrice: '0.385077',
                    markPrice: '0.41047590',
                    unRealizedProfit: '0.76427700',
                    liquidationPrice: '0',
                    isolatedMargin: '0',
                    notional: '12.31427700',
                    marginAsset: 'USDT',
                    isolatedWallet: '0',
                    initialMargin: '0.61571385',
                    maintMargin: '0.08004280',
                    positionInitialMargin: '0.61571385',
                    openOrderInitialMargin: '0',
                    adl: 2,
                    bidNotional: '0',
                    askNotional: '0',
                    updateTime: 1720736417660,
                },
            ];

            const spy = jest.spyOn(client, 'positionInformationV3').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PositionInformationV3Response>)
            );
            const response = await client.positionInformationV3();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute positionInformationV3() successfully with optional parameters', async () => {
            const params: PositionInformationV3Request = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'ADAUSDT',
                    positionSide: 'BOTH',
                    positionAmt: '30',
                    entryPrice: '0.385',
                    breakEvenPrice: '0.385077',
                    markPrice: '0.41047590',
                    unRealizedProfit: '0.76427700',
                    liquidationPrice: '0',
                    isolatedMargin: '0',
                    notional: '12.31427700',
                    marginAsset: 'USDT',
                    isolatedWallet: '0',
                    initialMargin: '0.61571385',
                    maintMargin: '0.08004280',
                    positionInitialMargin: '0.61571385',
                    openOrderInitialMargin: '0',
                    adl: 2,
                    bidNotional: '0',
                    askNotional: '0',
                    updateTime: 1720736417660,
                },
            ];

            const spy = jest.spyOn(client, 'positionInformationV3').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PositionInformationV3Response>)
            );
            const response = await client.positionInformationV3(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'positionInformationV3')
                .mockRejectedValueOnce(mockError);
            await expect(client.positionInformationV3()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryCurrentOpenOrder()', () => {
        it('should execute queryCurrentOpenOrder() successfully with required parameters only', async () => {
            const params: QueryCurrentOpenOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                avgPrice: '0.00000',
                clientOrderId: 'abc',
                cumQuote: '0',
                executedQty: '0',
                orderId: 1917641,
                origQty: '0.40',
                origType: 'TRAILING_STOP_MARKET',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'NEW',
                stopPrice: '9300',
                closePosition: false,
                symbol: 'BTCUSDT',
                time: 1579276756075,
                timeInForce: 'GTC',
                type: 'TRAILING_STOP_MARKET',
                activatePrice: '9020',
                priceRate: '0.3',
                updateTime: 1579276756075,
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
                priceMatch: 'NONE',
                selfTradePreventionMode: 'NONE',
                goodTillDate: 0,
            };

            const spy = jest.spyOn(client, 'queryCurrentOpenOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCurrentOpenOrderResponse>)
            );
            const response = await client.queryCurrentOpenOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryCurrentOpenOrder() successfully with optional parameters', async () => {
            const params: QueryCurrentOpenOrderRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                origClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                avgPrice: '0.00000',
                clientOrderId: 'abc',
                cumQuote: '0',
                executedQty: '0',
                orderId: 1917641,
                origQty: '0.40',
                origType: 'TRAILING_STOP_MARKET',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'NEW',
                stopPrice: '9300',
                closePosition: false,
                symbol: 'BTCUSDT',
                time: 1579276756075,
                timeInForce: 'GTC',
                type: 'TRAILING_STOP_MARKET',
                activatePrice: '9020',
                priceRate: '0.3',
                updateTime: 1579276756075,
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
                priceMatch: 'NONE',
                selfTradePreventionMode: 'NONE',
                goodTillDate: 0,
            };

            const spy = jest.spyOn(client, 'queryCurrentOpenOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCurrentOpenOrderResponse>)
            );
            const response = await client.queryCurrentOpenOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryCurrentOpenOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryCurrentOpenOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryCurrentOpenOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryCurrentOpenOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryCurrentOpenOrder')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryCurrentOpenOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryOrder()', () => {
        it('should execute queryOrder() successfully with required parameters only', async () => {
            const params: QueryOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                avgPrice: '0.00000',
                clientOrderId: 'abc',
                cumQuote: '0',
                executedQty: '0',
                orderId: 1917641,
                origQty: '0.40',
                origType: 'TRAILING_STOP_MARKET',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'NEW',
                stopPrice: '9300',
                closePosition: false,
                symbol: 'BTCUSDT',
                time: 1579276756075,
                timeInForce: 'GTC',
                type: 'TRAILING_STOP_MARKET',
                activatePrice: '9020',
                priceRate: '0.3',
                updateTime: 1579276756075,
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
                priceMatch: 'NONE',
                selfTradePreventionMode: 'NONE',
                goodTillDate: 0,
            };

            const spy = jest.spyOn(client, 'queryOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryOrderResponse>)
            );
            const response = await client.queryOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryOrder() successfully with optional parameters', async () => {
            const params: QueryOrderRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                origClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                avgPrice: '0.00000',
                clientOrderId: 'abc',
                cumQuote: '0',
                executedQty: '0',
                orderId: 1917641,
                origQty: '0.40',
                origType: 'TRAILING_STOP_MARKET',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'NEW',
                stopPrice: '9300',
                closePosition: false,
                symbol: 'BTCUSDT',
                time: 1579276756075,
                timeInForce: 'GTC',
                type: 'TRAILING_STOP_MARKET',
                activatePrice: '9020',
                priceRate: '0.3',
                updateTime: 1579276756075,
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
                priceMatch: 'NONE',
                selfTradePreventionMode: 'NONE',
                goodTillDate: 0,
            };

            const spy = jest.spyOn(client, 'queryOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryOrderResponse>)
            );
            const response = await client.queryOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'queryOrder').mockRejectedValueOnce(mockError);
            await expect(client.queryOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('testOrder()', () => {
        it('should execute testOrder() successfully with required parameters only', async () => {
            const params: TestOrderRequest = {
                symbol: 'symbol_example',
                side: TestOrderSideEnum.BUY,
                type: 'type_example',
            };

            mockResponse = {
                clientOrderId: 'testOrder',
                cumQty: '0',
                cumQuote: '0',
                executedQty: '0',
                orderId: 22542179,
                avgPrice: '0.00000',
                origQty: '10',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'NEW',
                stopPrice: '9300',
                closePosition: false,
                symbol: 'BTCUSDT',
                timeInForce: 'GTD',
                type: 'TRAILING_STOP_MARKET',
                origType: 'TRAILING_STOP_MARKET',
                activatePrice: '9020',
                priceRate: '0.3',
                updateTime: 1566818724722,
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
                priceMatch: 'NONE',
                selfTradePreventionMode: 'NONE',
                goodTillDate: 1693207680000,
            };

            const spy = jest.spyOn(client, 'testOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TestOrderResponse>)
            );
            const response = await client.testOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute testOrder() successfully with optional parameters', async () => {
            const params: TestOrderRequest = {
                symbol: 'symbol_example',
                side: TestOrderSideEnum.BUY,
                type: 'type_example',
                positionSide: TestOrderPositionSideEnum.BOTH,
                timeInForce: TestOrderTimeInForceEnum.GTC,
                quantity: 1,
                reduceOnly: 'false',
                price: 1,
                newClientOrderId: '1',
                stopPrice: 1,
                closePosition: 'closePosition_example',
                activationPrice: 1,
                callbackRate: 1,
                workingType: TestOrderWorkingTypeEnum.MARK_PRICE,
                priceProtect: 'false',
                newOrderRespType: TestOrderNewOrderRespTypeEnum.ACK,
                priceMatch: TestOrderPriceMatchEnum.NONE,
                selfTradePreventionMode: TestOrderSelfTradePreventionModeEnum.EXPIRE_TAKER,
                goodTillDate: 789,
                recvWindow: 5000,
            };

            mockResponse = {
                clientOrderId: 'testOrder',
                cumQty: '0',
                cumQuote: '0',
                executedQty: '0',
                orderId: 22542179,
                avgPrice: '0.00000',
                origQty: '10',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'NEW',
                stopPrice: '9300',
                closePosition: false,
                symbol: 'BTCUSDT',
                timeInForce: 'GTD',
                type: 'TRAILING_STOP_MARKET',
                origType: 'TRAILING_STOP_MARKET',
                activatePrice: '9020',
                priceRate: '0.3',
                updateTime: 1566818724722,
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
                priceMatch: 'NONE',
                selfTradePreventionMode: 'NONE',
                goodTillDate: 1693207680000,
            };

            const spy = jest.spyOn(client, 'testOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TestOrderResponse>)
            );
            const response = await client.testOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: TestOrderRequest = {
                symbol: 'symbol_example',
                side: TestOrderSideEnum.BUY,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.testOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling testOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: TestOrderRequest = {
                symbol: 'symbol_example',
                side: TestOrderSideEnum.BUY,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.testOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling testOrder.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: TestOrderRequest = {
                symbol: 'symbol_example',
                side: TestOrderSideEnum.BUY,
                type: 'type_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.testOrder(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling testOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TestOrderRequest = {
                symbol: 'symbol_example',
                side: TestOrderSideEnum.BUY,
                type: 'type_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'testOrder').mockRejectedValueOnce(mockError);
            await expect(client.testOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('usersForceOrders()', () => {
        it('should execute usersForceOrders() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    orderId: 6071832819,
                    symbol: 'BTCUSDT',
                    status: 'FILLED',
                    clientOrderId: 'autoclose-1596107620040000020',
                    price: '10871.09',
                    avgPrice: '10913.21000',
                    origQty: '0.001',
                    executedQty: '0.001',
                    cumQuote: '10.91321',
                    timeInForce: 'IOC',
                    type: 'LIMIT',
                    reduceOnly: false,
                    closePosition: false,
                    side: 'SELL',
                    positionSide: 'BOTH',
                    stopPrice: '0',
                    workingType: 'CONTRACT_PRICE',
                    origType: 'LIMIT',
                    time: 1596107620044,
                    updateTime: 1596107620087,
                },
                {
                    orderId: 6072734303,
                    symbol: 'BTCUSDT',
                    status: 'FILLED',
                    clientOrderId: 'adl_autoclose',
                    price: '11023.14',
                    avgPrice: '10979.82000',
                    origQty: '0.001',
                    executedQty: '0.001',
                    cumQuote: '10.97982',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    reduceOnly: false,
                    closePosition: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    stopPrice: '0',
                    workingType: 'CONTRACT_PRICE',
                    origType: 'LIMIT',
                    time: 1596110725059,
                    updateTime: 1596110725071,
                },
            ];

            const spy = jest.spyOn(client, 'usersForceOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UsersForceOrdersResponse>)
            );
            const response = await client.usersForceOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute usersForceOrders() successfully with optional parameters', async () => {
            const params: UsersForceOrdersRequest = {
                symbol: 'symbol_example',
                autoCloseType: UsersForceOrdersAutoCloseTypeEnum.LIQUIDATION,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    orderId: 6071832819,
                    symbol: 'BTCUSDT',
                    status: 'FILLED',
                    clientOrderId: 'autoclose-1596107620040000020',
                    price: '10871.09',
                    avgPrice: '10913.21000',
                    origQty: '0.001',
                    executedQty: '0.001',
                    cumQuote: '10.91321',
                    timeInForce: 'IOC',
                    type: 'LIMIT',
                    reduceOnly: false,
                    closePosition: false,
                    side: 'SELL',
                    positionSide: 'BOTH',
                    stopPrice: '0',
                    workingType: 'CONTRACT_PRICE',
                    origType: 'LIMIT',
                    time: 1596107620044,
                    updateTime: 1596107620087,
                },
                {
                    orderId: 6072734303,
                    symbol: 'BTCUSDT',
                    status: 'FILLED',
                    clientOrderId: 'adl_autoclose',
                    price: '11023.14',
                    avgPrice: '10979.82000',
                    origQty: '0.001',
                    executedQty: '0.001',
                    cumQuote: '10.97982',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    reduceOnly: false,
                    closePosition: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    stopPrice: '0',
                    workingType: 'CONTRACT_PRICE',
                    origType: 'LIMIT',
                    time: 1596110725059,
                    updateTime: 1596110725071,
                },
            ];

            const spy = jest.spyOn(client, 'usersForceOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UsersForceOrdersResponse>)
            );
            const response = await client.usersForceOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'usersForceOrders').mockRejectedValueOnce(mockError);
            await expect(client.usersForceOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
