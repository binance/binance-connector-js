/**
 * Binance Public Derivatives Trading USDS Futures REST API
 *
 * OpenAPI Specification for the Binance Public Derivatives Trading USDS Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import {
    MarketDataApi,
    BasisContractTypeEnum,
    BasisPeriodEnum,
    ContinuousContractKlineCandlestickDataContractTypeEnum,
    ContinuousContractKlineCandlestickDataIntervalEnum,
    HistoricalBlvtNavKlineCandlestickIntervalEnum,
    IndexPriceKlineCandlestickDataIntervalEnum,
    KlineCandlestickDataIntervalEnum,
    LongShortRatioPeriodEnum,
    MarkPriceKlineCandlestickDataIntervalEnum,
    OpenInterestStatisticsPeriodEnum,
    PremiumIndexKlineDataIntervalEnum,
    TakerBuySellVolumePeriodEnum,
    TopTraderLongShortRatioAccountsPeriodEnum,
    TopTraderLongShortRatioPositionsPeriodEnum,
} from '../../../src/rest-api';
import {
    BasisRequest,
    CompositeIndexSymbolInformationRequest,
    CompressedAggregateTradesListRequest,
    ContinuousContractKlineCandlestickDataRequest,
    GetFundingRateHistoryRequest,
    HistoricalBlvtNavKlineCandlestickRequest,
    IndexPriceKlineCandlestickDataRequest,
    KlineCandlestickDataRequest,
    LongShortRatioRequest,
    MarkPriceRequest,
    MarkPriceKlineCandlestickDataRequest,
    MultiAssetsModeAssetIndexRequest,
    OldTradesLookupRequest,
    OpenInterestRequest,
    OpenInterestStatisticsRequest,
    OrderBookRequest,
    PremiumIndexKlineDataRequest,
    QuarterlyContractSettlementPriceRequest,
    QueryIndexPriceConstituentsRequest,
    RecentTradesListRequest,
    SymbolOrderBookTickerRequest,
    SymbolPriceTickerRequest,
    SymbolPriceTickerV2Request,
    TakerBuySellVolumeRequest,
    Ticker24hrPriceChangeStatisticsRequest,
    TopTraderLongShortRatioAccountsRequest,
    TopTraderLongShortRatioPositionsRequest,
} from '../../../src/rest-api';
import type {
    BasisResponse,
    CheckServerTimeResponse,
    CompositeIndexSymbolInformationResponse,
    CompressedAggregateTradesListResponse,
    ContinuousContractKlineCandlestickDataResponse,
    ExchangeInformationResponse,
    GetFundingRateHistoryResponse,
    GetFundingRateInfoResponse,
    HistoricalBlvtNavKlineCandlestickResponse,
    IndexPriceKlineCandlestickDataResponse,
    KlineCandlestickDataResponse,
    LongShortRatioResponse,
    MarkPriceKlineCandlestickDataResponse,
    MarkPriceResponse,
    MultiAssetsModeAssetIndexResponse,
    OldTradesLookupResponse,
    OpenInterestResponse,
    OpenInterestStatisticsResponse,
    OrderBookResponse,
    PremiumIndexKlineDataResponse,
    QuarterlyContractSettlementPriceResponse,
    QueryIndexPriceConstituentsResponse,
    RecentTradesListResponse,
    SymbolOrderBookTickerResponse,
    SymbolPriceTickerResponse,
    SymbolPriceTickerV2Response,
    TakerBuySellVolumeResponse,
    Ticker24hrPriceChangeStatisticsResponse,
    TopTraderLongShortRatioAccountsResponse,
    TopTraderLongShortRatioPositionsResponse,
} from '../../../src/rest-api/types';

describe('MarketDataApi', () => {
    let client: MarketDataApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new MarketDataApi(config);
    });

    describe('basis()', () => {
        it('should execute basis() successfully with required parameters only', async () => {
            const params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
                limit: 30,
            };

            mockResponse = [
                {
                    indexPrice: '34400.15945055',
                    contractType: 'PERPETUAL',
                    basisRate: '0.0004',
                    futuresPrice: '34414.10',
                    annualizedBasisRate: '',
                    basis: '13.94054945',
                    pair: 'BTCUSDT',
                    timestamp: 1698742800000,
                },
            ];

            const spy = jest.spyOn(client, 'basis').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<BasisResponse>)
            );
            const response = await client.basis(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute basis() successfully with optional parameters', async () => {
            const params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
                limit: 30,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = [
                {
                    indexPrice: '34400.15945055',
                    contractType: 'PERPETUAL',
                    basisRate: '0.0004',
                    futuresPrice: '34414.10',
                    annualizedBasisRate: '',
                    basis: '13.94054945',
                    pair: 'BTCUSDT',
                    timestamp: 1698742800000,
                },
            ];

            const spy = jest.spyOn(client, 'basis').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<BasisResponse>)
            );
            const response = await client.basis(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when pair is missing', async () => {
            const _params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
                limit: 30,
            };
            const params = Object.assign({ ..._params });
            delete params?.pair;

            await expect(client.basis(params)).rejects.toThrow(
                'Required parameter pair was null or undefined when calling basis.'
            );
        });

        it('should throw RequiredError when contractType is missing', async () => {
            const _params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
                limit: 30,
            };
            const params = Object.assign({ ..._params });
            delete params?.contractType;

            await expect(client.basis(params)).rejects.toThrow(
                'Required parameter contractType was null or undefined when calling basis.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
                limit: 30,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.basis(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling basis.'
            );
        });

        it('should throw RequiredError when limit is missing', async () => {
            const _params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
                limit: 30,
            };
            const params = Object.assign({ ..._params });
            delete params?.limit;

            await expect(client.basis(params)).rejects.toThrow(
                'Required parameter limit was null or undefined when calling basis.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
                limit: 30,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'basis').mockRejectedValueOnce(mockError);
            await expect(client.basis(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('checkServerTime()', () => {
        it('should execute checkServerTime() successfully with required parameters only', async () => {
            mockResponse = { serverTime: 1499827319559 };

            const spy = jest.spyOn(client, 'checkServerTime').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CheckServerTimeResponse>)
            );
            const response = await client.checkServerTime();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'checkServerTime').mockRejectedValueOnce(mockError);
            await expect(client.checkServerTime()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('compositeIndexSymbolInformation()', () => {
        it('should execute compositeIndexSymbolInformation() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    symbol: 'DEFIUSDT',
                    time: 1589437530011,
                    component: 'baseAsset',
                    baseAssetList: [
                        {
                            baseAsset: 'BAL',
                            quoteAsset: 'USDT',
                            weightInQuantity: '1.04406228',
                            weightInPercentage: '0.02783900',
                        },
                        {
                            baseAsset: 'BAND',
                            quoteAsset: 'USDT',
                            weightInQuantity: '3.53782729',
                            weightInPercentage: '0.03935200',
                        },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'compositeIndexSymbolInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CompositeIndexSymbolInformationResponse>)
            );
            const response = await client.compositeIndexSymbolInformation();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute compositeIndexSymbolInformation() successfully with optional parameters', async () => {
            const params: CompositeIndexSymbolInformationRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    symbol: 'DEFIUSDT',
                    time: 1589437530011,
                    component: 'baseAsset',
                    baseAssetList: [
                        {
                            baseAsset: 'BAL',
                            quoteAsset: 'USDT',
                            weightInQuantity: '1.04406228',
                            weightInPercentage: '0.02783900',
                        },
                        {
                            baseAsset: 'BAND',
                            quoteAsset: 'USDT',
                            weightInQuantity: '3.53782729',
                            weightInPercentage: '0.03935200',
                        },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'compositeIndexSymbolInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CompositeIndexSymbolInformationResponse>)
            );
            const response = await client.compositeIndexSymbolInformation(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'compositeIndexSymbolInformation')
                .mockRejectedValueOnce(mockError);
            await expect(client.compositeIndexSymbolInformation()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('compressedAggregateTradesList()', () => {
        it('should execute compressedAggregateTradesList() successfully with required parameters only', async () => {
            const params: CompressedAggregateTradesListRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    a: 26129,
                    p: '0.01633102',
                    q: '4.70443515',
                    f: 27781,
                    l: 27781,
                    T: 1498793709153,
                    m: true,
                },
            ];

            const spy = jest.spyOn(client, 'compressedAggregateTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CompressedAggregateTradesListResponse>)
            );
            const response = await client.compressedAggregateTradesList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute compressedAggregateTradesList() successfully with optional parameters', async () => {
            const params: CompressedAggregateTradesListRequest = {
                symbol: 'symbol_example',
                fromId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = [
                {
                    a: 26129,
                    p: '0.01633102',
                    q: '4.70443515',
                    f: 27781,
                    l: 27781,
                    T: 1498793709153,
                    m: true,
                },
            ];

            const spy = jest.spyOn(client, 'compressedAggregateTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CompressedAggregateTradesListResponse>)
            );
            const response = await client.compressedAggregateTradesList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CompressedAggregateTradesListRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.compressedAggregateTradesList(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling compressedAggregateTradesList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CompressedAggregateTradesListRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'compressedAggregateTradesList')
                .mockRejectedValueOnce(mockError);
            await expect(client.compressedAggregateTradesList(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('continuousContractKlineCandlestickData()', () => {
        it('should execute continuousContractKlineCandlestickData() successfully with required parameters only', async () => {
            const params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            mockResponse = [
                [
                    1607444700000,
                    '18879.99',
                    '18900.00',
                    '18878.98',
                    '18896.13',
                    '492.363',
                    1607444759999,
                    '9302145.66080',
                    1874,
                    '385.983',
                    '7292402.33267',
                    '0',
                ],
            ];

            const spy = jest
                .spyOn(client, 'continuousContractKlineCandlestickData')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<ContinuousContractKlineCandlestickDataResponse>)
                );
            const response = await client.continuousContractKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute continuousContractKlineCandlestickData() successfully with optional parameters', async () => {
            const params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = [
                [
                    1607444700000,
                    '18879.99',
                    '18900.00',
                    '18878.98',
                    '18896.13',
                    '492.363',
                    1607444759999,
                    '9302145.66080',
                    1874,
                    '385.983',
                    '7292402.33267',
                    '0',
                ],
            ];

            const spy = jest
                .spyOn(client, 'continuousContractKlineCandlestickData')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<ContinuousContractKlineCandlestickDataResponse>)
                );
            const response = await client.continuousContractKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when pair is missing', async () => {
            const _params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.pair;

            await expect(client.continuousContractKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter pair was null or undefined when calling continuousContractKlineCandlestickData.'
            );
        });

        it('should throw RequiredError when contractType is missing', async () => {
            const _params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.contractType;

            await expect(client.continuousContractKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter contractType was null or undefined when calling continuousContractKlineCandlestickData.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.continuousContractKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling continuousContractKlineCandlestickData.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'continuousContractKlineCandlestickData')
                .mockRejectedValueOnce(mockError);
            await expect(client.continuousContractKlineCandlestickData(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('exchangeInformation()', () => {
        it('should execute exchangeInformation() successfully with required parameters only', async () => {
            mockResponse = {
                exchangeFilters: [],
                rateLimits: [
                    {
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 2400,
                        rateLimitType: 'REQUEST_WEIGHT',
                    },
                    { interval: 'MINUTE', intervalNum: 1, limit: 1200, rateLimitType: 'ORDERS' },
                ],
                serverTime: 1565613908500,
                assets: [
                    { asset: 'BUSD', marginAvailable: true, autoAssetExchange: 0 },
                    { asset: 'USDT', marginAvailable: true, autoAssetExchange: 0 },
                    { asset: 'BNB', marginAvailable: false, autoAssetExchange: null },
                ],
                symbols: [
                    {
                        symbol: 'BLZUSDT',
                        pair: 'BLZUSDT',
                        contractType: 'PERPETUAL',
                        deliveryDate: 4133404800000,
                        onboardDate: 1598252400000,
                        status: 'TRADING',
                        maintMarginPercent: '2.5000',
                        requiredMarginPercent: '5.0000',
                        baseAsset: 'BLZ',
                        quoteAsset: 'USDT',
                        marginAsset: 'USDT',
                        pricePrecision: 5,
                        quantityPrecision: 0,
                        baseAssetPrecision: 8,
                        quotePrecision: 8,
                        underlyingType: 'COIN',
                        underlyingSubType: ['STORAGE'],
                        settlePlan: 0,
                        triggerProtect: '0.15',
                        filters: [
                            {
                                filterType: 'PRICE_FILTER',
                                maxPrice: '300',
                                minPrice: '0.0001',
                                tickSize: '0.0001',
                            },
                            {
                                filterType: 'LOT_SIZE',
                                maxQty: '10000000',
                                minQty: '1',
                                stepSize: '1',
                            },
                            {
                                filterType: 'MARKET_LOT_SIZE',
                                maxQty: '590119',
                                minQty: '1',
                                stepSize: '1',
                            },
                            { filterType: 'MAX_NUM_ORDERS', limit: 200 },
                            { filterType: 'MAX_NUM_ALGO_ORDERS', limit: 10 },
                            { filterType: 'MIN_NOTIONAL', notional: '5.0' },
                            {
                                filterType: 'PERCENT_PRICE',
                                multiplierUp: '1.1500',
                                multiplierDown: '0.8500',
                                multiplierDecimal: 4,
                            },
                        ],
                        OrderType: [
                            'LIMIT',
                            'MARKET',
                            'STOP',
                            'STOP_MARKET',
                            'TAKE_PROFIT',
                            'TAKE_PROFIT_MARKET',
                            'TRAILING_STOP_MARKET',
                        ],
                        timeInForce: ['GTC', 'IOC', 'FOK', 'GTX'],
                        liquidationFee: '0.010000',
                        marketTakeBound: '0.30',
                    },
                ],
                timezone: 'UTC',
            };

            const spy = jest.spyOn(client, 'exchangeInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ExchangeInformationResponse>)
            );
            const response = await client.exchangeInformation();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'exchangeInformation').mockRejectedValueOnce(mockError);
            await expect(client.exchangeInformation()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getFundingRateHistory()', () => {
        it('should execute getFundingRateHistory() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    fundingRate: '-0.03750000',
                    fundingTime: 1570608000000,
                    markPrice: '34287.54619963',
                },
                {
                    symbol: 'BTCUSDT',
                    fundingRate: '0.00010000',
                    fundingTime: 1570636800000,
                    markPrice: '34287.54619963',
                },
            ];

            const spy = jest.spyOn(client, 'getFundingRateHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFundingRateHistoryResponse>)
            );
            const response = await client.getFundingRateHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFundingRateHistory() successfully with optional parameters', async () => {
            const params: GetFundingRateHistoryRequest = {
                symbol: 'symbol_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    fundingRate: '-0.03750000',
                    fundingTime: 1570608000000,
                    markPrice: '34287.54619963',
                },
                {
                    symbol: 'BTCUSDT',
                    fundingRate: '0.00010000',
                    fundingTime: 1570636800000,
                    markPrice: '34287.54619963',
                },
            ];

            const spy = jest.spyOn(client, 'getFundingRateHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFundingRateHistoryResponse>)
            );
            const response = await client.getFundingRateHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFundingRateHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFundingRateHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getFundingRateInfo()', () => {
        it('should execute getFundingRateInfo() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    symbol: 'BLZUSDT',
                    adjustedFundingRateCap: '0.02500000',
                    adjustedFundingRateFloor: '-0.02500000',
                    fundingIntervalHours: 8,
                    disclaimer: false,
                },
            ];

            const spy = jest.spyOn(client, 'getFundingRateInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFundingRateInfoResponse>)
            );
            const response = await client.getFundingRateInfo();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getFundingRateInfo').mockRejectedValueOnce(mockError);
            await expect(client.getFundingRateInfo()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('historicalBlvtNavKlineCandlestick()', () => {
        it('should execute historicalBlvtNavKlineCandlestick() successfully with required parameters only', async () => {
            const params: HistoricalBlvtNavKlineCandlestickRequest = {
                symbol: 'symbol_example',
                interval: HistoricalBlvtNavKlineCandlestickIntervalEnum.INTERVAL_1m,
            };

            mockResponse = [
                [
                    1598371200000,
                    '5.88275270',
                    '6.03142087',
                    '5.85749741',
                    '5.99403551',
                    '2.28602984',
                    1598374799999,
                    '0',
                    6209,
                    '14517.64507907',
                    '0',
                    '0',
                ],
            ];

            const spy = jest.spyOn(client, 'historicalBlvtNavKlineCandlestick').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<HistoricalBlvtNavKlineCandlestickResponse>)
            );
            const response = await client.historicalBlvtNavKlineCandlestick(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute historicalBlvtNavKlineCandlestick() successfully with optional parameters', async () => {
            const params: HistoricalBlvtNavKlineCandlestickRequest = {
                symbol: 'symbol_example',
                interval: HistoricalBlvtNavKlineCandlestickIntervalEnum.INTERVAL_1m,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = [
                [
                    1598371200000,
                    '5.88275270',
                    '6.03142087',
                    '5.85749741',
                    '5.99403551',
                    '2.28602984',
                    1598374799999,
                    '0',
                    6209,
                    '14517.64507907',
                    '0',
                    '0',
                ],
            ];

            const spy = jest.spyOn(client, 'historicalBlvtNavKlineCandlestick').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<HistoricalBlvtNavKlineCandlestickResponse>)
            );
            const response = await client.historicalBlvtNavKlineCandlestick(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: HistoricalBlvtNavKlineCandlestickRequest = {
                symbol: 'symbol_example',
                interval: HistoricalBlvtNavKlineCandlestickIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.historicalBlvtNavKlineCandlestick(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling historicalBlvtNavKlineCandlestick.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: HistoricalBlvtNavKlineCandlestickRequest = {
                symbol: 'symbol_example',
                interval: HistoricalBlvtNavKlineCandlestickIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.historicalBlvtNavKlineCandlestick(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling historicalBlvtNavKlineCandlestick.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: HistoricalBlvtNavKlineCandlestickRequest = {
                symbol: 'symbol_example',
                interval: HistoricalBlvtNavKlineCandlestickIntervalEnum.INTERVAL_1m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'historicalBlvtNavKlineCandlestick')
                .mockRejectedValueOnce(mockError);
            await expect(client.historicalBlvtNavKlineCandlestick(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('indexPriceKlineCandlestickData()', () => {
        it('should execute indexPriceKlineCandlestickData() successfully with required parameters only', async () => {
            const params: IndexPriceKlineCandlestickDataRequest = {
                pair: 'pair_example',
                interval: IndexPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            mockResponse = [
                [
                    1591256400000,
                    '9653.69440000',
                    '9653.69640000',
                    '9651.38600000',
                    '9651.55200000',
                    '0',
                    1591256459999,
                    '0',
                    60,
                    '0',
                    '0',
                    '0',
                ],
            ];

            const spy = jest.spyOn(client, 'indexPriceKlineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<IndexPriceKlineCandlestickDataResponse>)
            );
            const response = await client.indexPriceKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute indexPriceKlineCandlestickData() successfully with optional parameters', async () => {
            const params: IndexPriceKlineCandlestickDataRequest = {
                pair: 'pair_example',
                interval: IndexPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = [
                [
                    1591256400000,
                    '9653.69440000',
                    '9653.69640000',
                    '9651.38600000',
                    '9651.55200000',
                    '0',
                    1591256459999,
                    '0',
                    60,
                    '0',
                    '0',
                    '0',
                ],
            ];

            const spy = jest.spyOn(client, 'indexPriceKlineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<IndexPriceKlineCandlestickDataResponse>)
            );
            const response = await client.indexPriceKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when pair is missing', async () => {
            const _params: IndexPriceKlineCandlestickDataRequest = {
                pair: 'pair_example',
                interval: IndexPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.pair;

            await expect(client.indexPriceKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter pair was null or undefined when calling indexPriceKlineCandlestickData.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: IndexPriceKlineCandlestickDataRequest = {
                pair: 'pair_example',
                interval: IndexPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.indexPriceKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling indexPriceKlineCandlestickData.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: IndexPriceKlineCandlestickDataRequest = {
                pair: 'pair_example',
                interval: IndexPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'indexPriceKlineCandlestickData')
                .mockRejectedValueOnce(mockError);
            await expect(client.indexPriceKlineCandlestickData(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('klineCandlestickData()', () => {
        it('should execute klineCandlestickData() successfully with required parameters only', async () => {
            const params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: KlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            mockResponse = [
                [
                    1499040000000,
                    '0.01634790',
                    '0.80000000',
                    '0.01575800',
                    '0.01577100',
                    '148976.11427815',
                    1499644799999,
                    '2434.19055334',
                    308,
                    '1756.87402397',
                    '28.46694368',
                    '17928899.62484339',
                ],
            ];

            const spy = jest.spyOn(client, 'klineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<KlineCandlestickDataResponse>)
            );
            const response = await client.klineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute klineCandlestickData() successfully with optional parameters', async () => {
            const params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: KlineCandlestickDataIntervalEnum.INTERVAL_1m,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = [
                [
                    1499040000000,
                    '0.01634790',
                    '0.80000000',
                    '0.01575800',
                    '0.01577100',
                    '148976.11427815',
                    1499644799999,
                    '2434.19055334',
                    308,
                    '1756.87402397',
                    '28.46694368',
                    '17928899.62484339',
                ],
            ];

            const spy = jest.spyOn(client, 'klineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<KlineCandlestickDataResponse>)
            );
            const response = await client.klineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: KlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.klineCandlestickData(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling klineCandlestickData.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: KlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.klineCandlestickData(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling klineCandlestickData.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: KlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'klineCandlestickData').mockRejectedValueOnce(mockError);
            await expect(client.klineCandlestickData(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('longShortRatio()', () => {
        it('should execute longShortRatio() successfully with required parameters only', async () => {
            const params: LongShortRatioRequest = {
                symbol: 'symbol_example',
                period: LongShortRatioPeriodEnum.PERIOD_5m,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    longShortRatio: '0.1960',
                    longAccount: '0.6622',
                    shortAccount: '0.3378',
                    timestamp: '1583139600000',
                },
                {
                    symbol: 'BTCUSDT',
                    longShortRatio: '1.9559',
                    longAccount: '0.6617',
                    shortAccount: '0.3382',
                    timestamp: '1583139900000',
                },
            ];

            const spy = jest.spyOn(client, 'longShortRatio').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<LongShortRatioResponse>)
            );
            const response = await client.longShortRatio(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute longShortRatio() successfully with optional parameters', async () => {
            const params: LongShortRatioRequest = {
                symbol: 'symbol_example',
                period: LongShortRatioPeriodEnum.PERIOD_5m,
                limit: 100,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    longShortRatio: '0.1960',
                    longAccount: '0.6622',
                    shortAccount: '0.3378',
                    timestamp: '1583139600000',
                },
                {
                    symbol: 'BTCUSDT',
                    longShortRatio: '1.9559',
                    longAccount: '0.6617',
                    shortAccount: '0.3382',
                    timestamp: '1583139900000',
                },
            ];

            const spy = jest.spyOn(client, 'longShortRatio').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<LongShortRatioResponse>)
            );
            const response = await client.longShortRatio(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: LongShortRatioRequest = {
                symbol: 'symbol_example',
                period: LongShortRatioPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.longShortRatio(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling longShortRatio.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: LongShortRatioRequest = {
                symbol: 'symbol_example',
                period: LongShortRatioPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.longShortRatio(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling longShortRatio.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: LongShortRatioRequest = {
                symbol: 'symbol_example',
                period: LongShortRatioPeriodEnum.PERIOD_5m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'longShortRatio').mockRejectedValueOnce(mockError);
            await expect(client.longShortRatio(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('markPrice()', () => {
        it('should execute markPrice() successfully with required parameters only', async () => {
            mockResponse = {
                symbol: 'BTCUSDT',
                markPrice: '11793.63104562',
                indexPrice: '11781.80495970',
                estimatedSettlePrice: '11781.16138815',
                lastFundingRate: '0.00038246',
                interestRate: '0.00010000',
                nextFundingTime: 1597392000000,
                time: 1597370495002,
            };

            const spy = jest.spyOn(client, 'markPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarkPriceResponse>)
            );
            const response = await client.markPrice();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute markPrice() successfully with optional parameters', async () => {
            const params: MarkPriceRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                markPrice: '11793.63104562',
                indexPrice: '11781.80495970',
                estimatedSettlePrice: '11781.16138815',
                lastFundingRate: '0.00038246',
                interestRate: '0.00010000',
                nextFundingTime: 1597392000000,
                time: 1597370495002,
            };

            const spy = jest.spyOn(client, 'markPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarkPriceResponse>)
            );
            const response = await client.markPrice(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'markPrice').mockRejectedValueOnce(mockError);
            await expect(client.markPrice()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('markPriceKlineCandlestickData()', () => {
        it('should execute markPriceKlineCandlestickData() successfully with required parameters only', async () => {
            const params: MarkPriceKlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: MarkPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            mockResponse = [
                [
                    1591256460000,
                    '9653.29201333',
                    '9654.56401333',
                    '9653.07367333',
                    '9653.07367333',
                    '0',
                    1591256519999,
                    '0',
                    60,
                    '0',
                    '0',
                    '0',
                ],
            ];

            const spy = jest.spyOn(client, 'markPriceKlineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarkPriceKlineCandlestickDataResponse>)
            );
            const response = await client.markPriceKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute markPriceKlineCandlestickData() successfully with optional parameters', async () => {
            const params: MarkPriceKlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: MarkPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = [
                [
                    1591256460000,
                    '9653.29201333',
                    '9654.56401333',
                    '9653.07367333',
                    '9653.07367333',
                    '0',
                    1591256519999,
                    '0',
                    60,
                    '0',
                    '0',
                    '0',
                ],
            ];

            const spy = jest.spyOn(client, 'markPriceKlineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarkPriceKlineCandlestickDataResponse>)
            );
            const response = await client.markPriceKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MarkPriceKlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: MarkPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.markPriceKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling markPriceKlineCandlestickData.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: MarkPriceKlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: MarkPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.markPriceKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling markPriceKlineCandlestickData.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MarkPriceKlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: MarkPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'markPriceKlineCandlestickData')
                .mockRejectedValueOnce(mockError);
            await expect(client.markPriceKlineCandlestickData(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('multiAssetsModeAssetIndex()', () => {
        it('should execute multiAssetsModeAssetIndex() successfully with required parameters only', async () => {
            mockResponse = {
                symbol: 'ADAUSD',
                time: 1635740268004,
                index: '1.92957370',
                bidBuffer: '0.10000000',
                askBuffer: '0.10000000',
                bidRate: '1.73661633',
                askRate: '2.12253107',
                autoExchangeBidBuffer: '0.05000000',
                autoExchangeAskBuffer: '0.05000000',
                autoExchangeBidRate: '1.83309501',
                autoExchangeAskRate: '2.02605238',
            };

            const spy = jest.spyOn(client, 'multiAssetsModeAssetIndex').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MultiAssetsModeAssetIndexResponse>)
            );
            const response = await client.multiAssetsModeAssetIndex();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute multiAssetsModeAssetIndex() successfully with optional parameters', async () => {
            const params: MultiAssetsModeAssetIndexRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                symbol: 'ADAUSD',
                time: 1635740268004,
                index: '1.92957370',
                bidBuffer: '0.10000000',
                askBuffer: '0.10000000',
                bidRate: '1.73661633',
                askRate: '2.12253107',
                autoExchangeBidBuffer: '0.05000000',
                autoExchangeAskBuffer: '0.05000000',
                autoExchangeBidRate: '1.83309501',
                autoExchangeAskRate: '2.02605238',
            };

            const spy = jest.spyOn(client, 'multiAssetsModeAssetIndex').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MultiAssetsModeAssetIndexResponse>)
            );
            const response = await client.multiAssetsModeAssetIndex(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'multiAssetsModeAssetIndex')
                .mockRejectedValueOnce(mockError);
            await expect(client.multiAssetsModeAssetIndex()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('oldTradesLookup()', () => {
        it('should execute oldTradesLookup() successfully with required parameters only', async () => {
            const params: OldTradesLookupRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    id: 28457,
                    price: '4.00000100',
                    qty: '12.00000000',
                    quoteQty: '8000.00',
                    time: 1499865549590,
                    isBuyerMaker: true,
                },
            ];

            const spy = jest.spyOn(client, 'oldTradesLookup').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OldTradesLookupResponse>)
            );
            const response = await client.oldTradesLookup(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute oldTradesLookup() successfully with optional parameters', async () => {
            const params: OldTradesLookupRequest = {
                symbol: 'symbol_example',
                limit: 100,
                fromId: 1,
            };

            mockResponse = [
                {
                    id: 28457,
                    price: '4.00000100',
                    qty: '12.00000000',
                    quoteQty: '8000.00',
                    time: 1499865549590,
                    isBuyerMaker: true,
                },
            ];

            const spy = jest.spyOn(client, 'oldTradesLookup').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OldTradesLookupResponse>)
            );
            const response = await client.oldTradesLookup(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OldTradesLookupRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.oldTradesLookup(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling oldTradesLookup.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OldTradesLookupRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'oldTradesLookup').mockRejectedValueOnce(mockError);
            await expect(client.oldTradesLookup(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('openInterest()', () => {
        it('should execute openInterest() successfully with required parameters only', async () => {
            const params: OpenInterestRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = { openInterest: '10659.509', symbol: 'BTCUSDT', time: 1589437530011 };

            const spy = jest.spyOn(client, 'openInterest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenInterestResponse>)
            );
            const response = await client.openInterest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute openInterest() successfully with optional parameters', async () => {
            const params: OpenInterestRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = { openInterest: '10659.509', symbol: 'BTCUSDT', time: 1589437530011 };

            const spy = jest.spyOn(client, 'openInterest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenInterestResponse>)
            );
            const response = await client.openInterest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OpenInterestRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.openInterest(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling openInterest.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OpenInterestRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'openInterest').mockRejectedValueOnce(mockError);
            await expect(client.openInterest(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('openInterestStatistics()', () => {
        it('should execute openInterestStatistics() successfully with required parameters only', async () => {
            const params: OpenInterestStatisticsRequest = {
                symbol: 'symbol_example',
                period: OpenInterestStatisticsPeriodEnum.PERIOD_5m,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    sumOpenInterest: '20403.63700000',
                    sumOpenInterestValue: '150570784.07809979',
                    timestamp: '1583127900000',
                },
                {
                    symbol: 'BTCUSDT',
                    sumOpenInterest: '20401.36700000',
                    sumOpenInterestValue: '149940752.14464448',
                    timestamp: '1583128200000',
                },
            ];

            const spy = jest.spyOn(client, 'openInterestStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenInterestStatisticsResponse>)
            );
            const response = await client.openInterestStatistics(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute openInterestStatistics() successfully with optional parameters', async () => {
            const params: OpenInterestStatisticsRequest = {
                symbol: 'symbol_example',
                period: OpenInterestStatisticsPeriodEnum.PERIOD_5m,
                limit: 100,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    sumOpenInterest: '20403.63700000',
                    sumOpenInterestValue: '150570784.07809979',
                    timestamp: '1583127900000',
                },
                {
                    symbol: 'BTCUSDT',
                    sumOpenInterest: '20401.36700000',
                    sumOpenInterestValue: '149940752.14464448',
                    timestamp: '1583128200000',
                },
            ];

            const spy = jest.spyOn(client, 'openInterestStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenInterestStatisticsResponse>)
            );
            const response = await client.openInterestStatistics(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OpenInterestStatisticsRequest = {
                symbol: 'symbol_example',
                period: OpenInterestStatisticsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.openInterestStatistics(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling openInterestStatistics.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: OpenInterestStatisticsRequest = {
                symbol: 'symbol_example',
                period: OpenInterestStatisticsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.openInterestStatistics(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling openInterestStatistics.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OpenInterestStatisticsRequest = {
                symbol: 'symbol_example',
                period: OpenInterestStatisticsPeriodEnum.PERIOD_5m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'openInterestStatistics')
                .mockRejectedValueOnce(mockError);
            await expect(client.openInterestStatistics(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderBook()', () => {
        it('should execute orderBook() successfully with required parameters only', async () => {
            const params: OrderBookRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                lastUpdateId: 1027024,
                E: 1589436922972,
                T: 1589436922959,
                bids: [['4.00000000', '431.00000000']],
                asks: [['4.00000200', '12.00000000']],
            };

            const spy = jest.spyOn(client, 'orderBook').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderBookResponse>)
            );
            const response = await client.orderBook(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderBook() successfully with optional parameters', async () => {
            const params: OrderBookRequest = {
                symbol: 'symbol_example',
                limit: 100,
            };

            mockResponse = {
                lastUpdateId: 1027024,
                E: 1589436922972,
                T: 1589436922959,
                bids: [['4.00000000', '431.00000000']],
                asks: [['4.00000200', '12.00000000']],
            };

            const spy = jest.spyOn(client, 'orderBook').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderBookResponse>)
            );
            const response = await client.orderBook(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderBookRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderBook(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderBook.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderBookRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderBook').mockRejectedValueOnce(mockError);
            await expect(client.orderBook(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('premiumIndexKlineData()', () => {
        it('should execute premiumIndexKlineData() successfully with required parameters only', async () => {
            const params: PremiumIndexKlineDataRequest = {
                symbol: 'symbol_example',
                interval: PremiumIndexKlineDataIntervalEnum.INTERVAL_1m,
            };

            mockResponse = [
                [
                    1691603820000,
                    '-0.00042931',
                    '-0.00023641',
                    '-0.00059406',
                    '-0.00043659',
                    '0',
                    1691603879999,
                    '0',
                    12,
                    '0',
                    '0',
                    '0',
                ],
            ];

            const spy = jest.spyOn(client, 'premiumIndexKlineData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PremiumIndexKlineDataResponse>)
            );
            const response = await client.premiumIndexKlineData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute premiumIndexKlineData() successfully with optional parameters', async () => {
            const params: PremiumIndexKlineDataRequest = {
                symbol: 'symbol_example',
                interval: PremiumIndexKlineDataIntervalEnum.INTERVAL_1m,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = [
                [
                    1691603820000,
                    '-0.00042931',
                    '-0.00023641',
                    '-0.00059406',
                    '-0.00043659',
                    '0',
                    1691603879999,
                    '0',
                    12,
                    '0',
                    '0',
                    '0',
                ],
            ];

            const spy = jest.spyOn(client, 'premiumIndexKlineData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PremiumIndexKlineDataResponse>)
            );
            const response = await client.premiumIndexKlineData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: PremiumIndexKlineDataRequest = {
                symbol: 'symbol_example',
                interval: PremiumIndexKlineDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.premiumIndexKlineData(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling premiumIndexKlineData.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: PremiumIndexKlineDataRequest = {
                symbol: 'symbol_example',
                interval: PremiumIndexKlineDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.premiumIndexKlineData(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling premiumIndexKlineData.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: PremiumIndexKlineDataRequest = {
                symbol: 'symbol_example',
                interval: PremiumIndexKlineDataIntervalEnum.INTERVAL_1m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'premiumIndexKlineData')
                .mockRejectedValueOnce(mockError);
            await expect(client.premiumIndexKlineData(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('quarterlyContractSettlementPrice()', () => {
        it('should execute quarterlyContractSettlementPrice() successfully with required parameters only', async () => {
            const params: QuarterlyContractSettlementPriceRequest = {
                pair: 'pair_example',
            };

            mockResponse = [
                { deliveryTime: 1695945600000, deliveryPrice: 27103 },
                { deliveryTime: 1688083200000, deliveryPrice: 30733.6 },
                { deliveryTime: 1680220800000, deliveryPrice: 27814.2 },
                { deliveryTime: 1648166400000, deliveryPrice: 44066.3 },
            ];

            const spy = jest.spyOn(client, 'quarterlyContractSettlementPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuarterlyContractSettlementPriceResponse>)
            );
            const response = await client.quarterlyContractSettlementPrice(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute quarterlyContractSettlementPrice() successfully with optional parameters', async () => {
            const params: QuarterlyContractSettlementPriceRequest = {
                pair: 'pair_example',
            };

            mockResponse = [
                { deliveryTime: 1695945600000, deliveryPrice: 27103 },
                { deliveryTime: 1688083200000, deliveryPrice: 30733.6 },
                { deliveryTime: 1680220800000, deliveryPrice: 27814.2 },
                { deliveryTime: 1648166400000, deliveryPrice: 44066.3 },
            ];

            const spy = jest.spyOn(client, 'quarterlyContractSettlementPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QuarterlyContractSettlementPriceResponse>)
            );
            const response = await client.quarterlyContractSettlementPrice(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when pair is missing', async () => {
            const _params: QuarterlyContractSettlementPriceRequest = {
                pair: 'pair_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.pair;

            await expect(client.quarterlyContractSettlementPrice(params)).rejects.toThrow(
                'Required parameter pair was null or undefined when calling quarterlyContractSettlementPrice.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QuarterlyContractSettlementPriceRequest = {
                pair: 'pair_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'quarterlyContractSettlementPrice')
                .mockRejectedValueOnce(mockError);
            await expect(client.quarterlyContractSettlementPrice(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryIndexPriceConstituents()', () => {
        it('should execute queryIndexPriceConstituents() successfully with required parameters only', async () => {
            const params: QueryIndexPriceConstituentsRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                time: 1697421272043,
                constituents: [
                    { exchange: 'binance', symbol: 'BTCUSDT' },
                    { exchange: 'okex', symbol: 'BTC-USDT' },
                    { exchange: 'huobi', symbol: 'btcusdt' },
                    { exchange: 'coinbase', symbol: 'BTC-USDT' },
                ],
            };

            const spy = jest.spyOn(client, 'queryIndexPriceConstituents').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryIndexPriceConstituentsResponse>)
            );
            const response = await client.queryIndexPriceConstituents(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryIndexPriceConstituents() successfully with optional parameters', async () => {
            const params: QueryIndexPriceConstituentsRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                time: 1697421272043,
                constituents: [
                    { exchange: 'binance', symbol: 'BTCUSDT' },
                    { exchange: 'okex', symbol: 'BTC-USDT' },
                    { exchange: 'huobi', symbol: 'btcusdt' },
                    { exchange: 'coinbase', symbol: 'BTC-USDT' },
                ],
            };

            const spy = jest.spyOn(client, 'queryIndexPriceConstituents').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryIndexPriceConstituentsResponse>)
            );
            const response = await client.queryIndexPriceConstituents(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryIndexPriceConstituentsRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryIndexPriceConstituents(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryIndexPriceConstituents.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryIndexPriceConstituentsRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryIndexPriceConstituents')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryIndexPriceConstituents(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('recentTradesList()', () => {
        it('should execute recentTradesList() successfully with required parameters only', async () => {
            const params: RecentTradesListRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    id: 28457,
                    price: '4.00000100',
                    qty: '12.00000000',
                    quoteQty: '48.00',
                    time: 1499865549590,
                    isBuyerMaker: true,
                },
            ];

            const spy = jest.spyOn(client, 'recentTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RecentTradesListResponse>)
            );
            const response = await client.recentTradesList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute recentTradesList() successfully with optional parameters', async () => {
            const params: RecentTradesListRequest = {
                symbol: 'symbol_example',
                limit: 100,
            };

            mockResponse = [
                {
                    id: 28457,
                    price: '4.00000100',
                    qty: '12.00000000',
                    quoteQty: '48.00',
                    time: 1499865549590,
                    isBuyerMaker: true,
                },
            ];

            const spy = jest.spyOn(client, 'recentTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RecentTradesListResponse>)
            );
            const response = await client.recentTradesList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: RecentTradesListRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.recentTradesList(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling recentTradesList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: RecentTradesListRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'recentTradesList').mockRejectedValueOnce(mockError);
            await expect(client.recentTradesList(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('symbolOrderBookTicker()', () => {
        it('should execute symbolOrderBookTicker() successfully with required parameters only', async () => {
            mockResponse = {
                symbol: 'BTCUSDT',
                bidPrice: '4.00000000',
                bidQty: '431.00000000',
                askPrice: '4.00000200',
                askQty: '9.00000000',
                time: 1589437530011,
            };

            const spy = jest.spyOn(client, 'symbolOrderBookTicker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolOrderBookTickerResponse>)
            );
            const response = await client.symbolOrderBookTicker();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute symbolOrderBookTicker() successfully with optional parameters', async () => {
            const params: SymbolOrderBookTickerRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                bidPrice: '4.00000000',
                bidQty: '431.00000000',
                askPrice: '4.00000200',
                askQty: '9.00000000',
                time: 1589437530011,
            };

            const spy = jest.spyOn(client, 'symbolOrderBookTicker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolOrderBookTickerResponse>)
            );
            const response = await client.symbolOrderBookTicker(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'symbolOrderBookTicker')
                .mockRejectedValueOnce(mockError);
            await expect(client.symbolOrderBookTicker()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('symbolPriceTicker()', () => {
        it('should execute symbolPriceTicker() successfully with required parameters only', async () => {
            mockResponse = { symbol: 'BTCUSDT', price: '6000.01', time: 1589437530011 };

            const spy = jest.spyOn(client, 'symbolPriceTicker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolPriceTickerResponse>)
            );
            const response = await client.symbolPriceTicker();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute symbolPriceTicker() successfully with optional parameters', async () => {
            const params: SymbolPriceTickerRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = { symbol: 'BTCUSDT', price: '6000.01', time: 1589437530011 };

            const spy = jest.spyOn(client, 'symbolPriceTicker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolPriceTickerResponse>)
            );
            const response = await client.symbolPriceTicker(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'symbolPriceTicker').mockRejectedValueOnce(mockError);
            await expect(client.symbolPriceTicker()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('symbolPriceTickerV2()', () => {
        it('should execute symbolPriceTickerV2() successfully with required parameters only', async () => {
            mockResponse = { symbol: 'BTCUSDT', price: '6000.01', time: 1589437530011 };

            const spy = jest.spyOn(client, 'symbolPriceTickerV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolPriceTickerV2Response>)
            );
            const response = await client.symbolPriceTickerV2();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute symbolPriceTickerV2() successfully with optional parameters', async () => {
            const params: SymbolPriceTickerV2Request = {
                symbol: 'symbol_example',
            };

            mockResponse = { symbol: 'BTCUSDT', price: '6000.01', time: 1589437530011 };

            const spy = jest.spyOn(client, 'symbolPriceTickerV2').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolPriceTickerV2Response>)
            );
            const response = await client.symbolPriceTickerV2(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'symbolPriceTickerV2').mockRejectedValueOnce(mockError);
            await expect(client.symbolPriceTickerV2()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('takerBuySellVolume()', () => {
        it('should execute takerBuySellVolume() successfully with required parameters only', async () => {
            const params: TakerBuySellVolumeRequest = {
                symbol: 'symbol_example',
                period: TakerBuySellVolumePeriodEnum.PERIOD_5m,
            };

            mockResponse = [
                {
                    buySellRatio: '1.5586',
                    buyVol: '387.3300',
                    sellVol: '248.5030',
                    timestamp: '1585614900000',
                },
                {
                    buySellRatio: '1.3104',
                    buyVol: '343.9290',
                    sellVol: '248.5030',
                    timestamp: '1583139900000',
                },
            ];

            const spy = jest.spyOn(client, 'takerBuySellVolume').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TakerBuySellVolumeResponse>)
            );
            const response = await client.takerBuySellVolume(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute takerBuySellVolume() successfully with optional parameters', async () => {
            const params: TakerBuySellVolumeRequest = {
                symbol: 'symbol_example',
                period: TakerBuySellVolumePeriodEnum.PERIOD_5m,
                limit: 100,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = [
                {
                    buySellRatio: '1.5586',
                    buyVol: '387.3300',
                    sellVol: '248.5030',
                    timestamp: '1585614900000',
                },
                {
                    buySellRatio: '1.3104',
                    buyVol: '343.9290',
                    sellVol: '248.5030',
                    timestamp: '1583139900000',
                },
            ];

            const spy = jest.spyOn(client, 'takerBuySellVolume').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TakerBuySellVolumeResponse>)
            );
            const response = await client.takerBuySellVolume(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: TakerBuySellVolumeRequest = {
                symbol: 'symbol_example',
                period: TakerBuySellVolumePeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.takerBuySellVolume(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling takerBuySellVolume.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: TakerBuySellVolumeRequest = {
                symbol: 'symbol_example',
                period: TakerBuySellVolumePeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.takerBuySellVolume(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling takerBuySellVolume.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TakerBuySellVolumeRequest = {
                symbol: 'symbol_example',
                period: TakerBuySellVolumePeriodEnum.PERIOD_5m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'takerBuySellVolume').mockRejectedValueOnce(mockError);
            await expect(client.takerBuySellVolume(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('testConnectivity()', () => {
        it('should execute testConnectivity() successfully with required parameters only', async () => {
            const spy = jest.spyOn(client, 'testConnectivity').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.testConnectivity();

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'testConnectivity').mockRejectedValueOnce(mockError);
            await expect(client.testConnectivity()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('ticker24hrPriceChangeStatistics()', () => {
        it('should execute ticker24hrPriceChangeStatistics() successfully with required parameters only', async () => {
            mockResponse = {
                symbol: 'BTCUSDT',
                priceChange: '-94.99999800',
                priceChangePercent: '-95.960',
                weightedAvgPrice: '0.29628482',
                lastPrice: '4.00000200',
                lastQty: '200.00000000',
                openPrice: '99.00000000',
                highPrice: '100.00000000',
                lowPrice: '0.10000000',
                volume: '8913.30000000',
                quoteVolume: '15.30000000',
                openTime: 1499783499040,
                closeTime: 1499869899040,
                firstId: 28385,
                lastId: 28460,
                count: 76,
            };

            const spy = jest.spyOn(client, 'ticker24hrPriceChangeStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<Ticker24hrPriceChangeStatisticsResponse>)
            );
            const response = await client.ticker24hrPriceChangeStatistics();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute ticker24hrPriceChangeStatistics() successfully with optional parameters', async () => {
            const params: Ticker24hrPriceChangeStatisticsRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                priceChange: '-94.99999800',
                priceChangePercent: '-95.960',
                weightedAvgPrice: '0.29628482',
                lastPrice: '4.00000200',
                lastQty: '200.00000000',
                openPrice: '99.00000000',
                highPrice: '100.00000000',
                lowPrice: '0.10000000',
                volume: '8913.30000000',
                quoteVolume: '15.30000000',
                openTime: 1499783499040,
                closeTime: 1499869899040,
                firstId: 28385,
                lastId: 28460,
                count: 76,
            };

            const spy = jest.spyOn(client, 'ticker24hrPriceChangeStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<Ticker24hrPriceChangeStatisticsResponse>)
            );
            const response = await client.ticker24hrPriceChangeStatistics(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'ticker24hrPriceChangeStatistics')
                .mockRejectedValueOnce(mockError);
            await expect(client.ticker24hrPriceChangeStatistics()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('topTraderLongShortRatioAccounts()', () => {
        it('should execute topTraderLongShortRatioAccounts() successfully with required parameters only', async () => {
            const params: TopTraderLongShortRatioAccountsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioAccountsPeriodEnum.PERIOD_5m,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    longShortRatio: '1.8105',
                    longAccount: '0.6442',
                    shortAccount: '0.3558',
                    timestamp: '1583139600000',
                },
                {
                    symbol: 'BTCUSDT',
                    longShortRatio: '0.5576',
                    longAccount: '0.3580',
                    shortAccount: '0.6420',
                    timestamp: '1583139900000',
                },
            ];

            const spy = jest.spyOn(client, 'topTraderLongShortRatioAccounts').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TopTraderLongShortRatioAccountsResponse>)
            );
            const response = await client.topTraderLongShortRatioAccounts(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute topTraderLongShortRatioAccounts() successfully with optional parameters', async () => {
            const params: TopTraderLongShortRatioAccountsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioAccountsPeriodEnum.PERIOD_5m,
                limit: 100,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    longShortRatio: '1.8105',
                    longAccount: '0.6442',
                    shortAccount: '0.3558',
                    timestamp: '1583139600000',
                },
                {
                    symbol: 'BTCUSDT',
                    longShortRatio: '0.5576',
                    longAccount: '0.3580',
                    shortAccount: '0.6420',
                    timestamp: '1583139900000',
                },
            ];

            const spy = jest.spyOn(client, 'topTraderLongShortRatioAccounts').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TopTraderLongShortRatioAccountsResponse>)
            );
            const response = await client.topTraderLongShortRatioAccounts(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: TopTraderLongShortRatioAccountsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioAccountsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.topTraderLongShortRatioAccounts(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling topTraderLongShortRatioAccounts.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: TopTraderLongShortRatioAccountsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioAccountsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.topTraderLongShortRatioAccounts(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling topTraderLongShortRatioAccounts.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TopTraderLongShortRatioAccountsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioAccountsPeriodEnum.PERIOD_5m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'topTraderLongShortRatioAccounts')
                .mockRejectedValueOnce(mockError);
            await expect(client.topTraderLongShortRatioAccounts(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('topTraderLongShortRatioPositions()', () => {
        it('should execute topTraderLongShortRatioPositions() successfully with required parameters only', async () => {
            const params: TopTraderLongShortRatioPositionsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioPositionsPeriodEnum.PERIOD_5m,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    longShortRatio: '1.4342',
                    longAccount: '0.5891',
                    shortAccount: '0.4108',
                    timestamp: '1583139600000',
                },
                {
                    symbol: 'BTCUSDT',
                    longShortRatio: '1.4337',
                    longAccount: '0.3583',
                    shortAccount: '0.6417',
                    timestamp: '1583139900000',
                },
            ];

            const spy = jest.spyOn(client, 'topTraderLongShortRatioPositions').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TopTraderLongShortRatioPositionsResponse>)
            );
            const response = await client.topTraderLongShortRatioPositions(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute topTraderLongShortRatioPositions() successfully with optional parameters', async () => {
            const params: TopTraderLongShortRatioPositionsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioPositionsPeriodEnum.PERIOD_5m,
                limit: 100,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    longShortRatio: '1.4342',
                    longAccount: '0.5891',
                    shortAccount: '0.4108',
                    timestamp: '1583139600000',
                },
                {
                    symbol: 'BTCUSDT',
                    longShortRatio: '1.4337',
                    longAccount: '0.3583',
                    shortAccount: '0.6417',
                    timestamp: '1583139900000',
                },
            ];

            const spy = jest.spyOn(client, 'topTraderLongShortRatioPositions').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TopTraderLongShortRatioPositionsResponse>)
            );
            const response = await client.topTraderLongShortRatioPositions(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: TopTraderLongShortRatioPositionsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioPositionsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.topTraderLongShortRatioPositions(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling topTraderLongShortRatioPositions.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: TopTraderLongShortRatioPositionsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioPositionsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.topTraderLongShortRatioPositions(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling topTraderLongShortRatioPositions.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TopTraderLongShortRatioPositionsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioPositionsPeriodEnum.PERIOD_5m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'topTraderLongShortRatioPositions')
                .mockRejectedValueOnce(mockError);
            await expect(client.topTraderLongShortRatioPositions(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });
});
