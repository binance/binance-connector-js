/**
 * Binance Derivatives Trading COIN Futures REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading COIN Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
    ConfigurationRestAPI,
    TimeUnit,
    RestApiResponse,
    assertParamExists,
    sendRequest,
    type RequestArgs,
} from '@binance/common';
import type {
    AccountTradeListResponse,
    AllOrdersResponse,
    CancelAllOpenOrdersResponse,
    CancelMultipleOrdersResponse,
    CancelOrderResponse,
    ChangeInitialLeverageResponse,
    ChangeMarginTypeResponse,
    ChangePositionModeResponse,
    CurrentAllOpenOrdersResponse,
    GetOrderModifyHistoryResponse,
    GetPositionMarginChangeHistoryResponse,
    ModifyIsolatedPositionMarginResponse,
    ModifyMultipleOrdersBatchOrdersParameterInner,
    ModifyMultipleOrdersResponse,
    ModifyOrderResponse,
    NewOrderResponse,
    PositionAdlQuantileEstimationResponse,
    PositionInformationResponse,
    QueryCurrentOpenOrderResponse,
    QueryOrderResponse,
    UsersForceOrdersResponse,
} from '../types';

/**
 * TradeApi - axios parameter creator
 */
const TradeApiAxiosParamCreator = function (configuration: ConfigurationRestAPI) {
    return {
        /**
         * Get trades for a specific account and symbol.
         *
         *
         * Either symbol or pair must be sent
         * Symbol and pair cannot be sent together
         * Pair and fromId cannot be sent together
         * OrderId can only be sent together with symbol
         * If a pair is sent,tickers for all symbols of the pair will be returned
         * The parameter `fromId` cannot be sent with `startTime` or `endTime`
         * If startTime and endTime are both not sent, then the last 7 days' data will be returned.
         * The time between startTime and endTime cannot be longer than 7 days.
         *
         * Weight: 20 with symbolï¼Œ40 with pair
         *
         * @summary Account Trade List (USER_DATA)
         * @param {string} [symbol]
         * @param {string} [pair]
         * @param {string} [orderId]
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        accountTradeList: async (
            symbol?: string,
            pair?: string,
            orderId?: string,
            startTime?: number,
            endTime?: number,
            fromId?: number,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (fromId !== undefined && fromId !== null) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/userTrades',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get all account orders; active, canceled, or filled.
         *
         * These orders will not be found:
         * order status is CANCELED or EXPIRED AND order has NO filled trade AND created time + 3 days < current time
         * order create time + 90 days < current time
         *
         *
         * Either `symbol` or `pair` must be sent.
         * `pair` can't be sent with `orderId`
         * If `orderId` is set, it will get orders >= that `orderId`. Otherwise most recent orders are returned.
         * If orderId is set, it will get orders >= that orderId. Otherwise most recent orders are returned.
         * The query time period must be less then 7 days( default as the recent 7 days).
         *
         * Weight: 20 with symbol, 40 with pair
         *
         * @summary All Orders (USER_DATA)
         * @param {string} [symbol]
         * @param {string} [pair]
         * @param {number} [orderId]
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        allOrders: async (
            symbol?: string,
            pair?: string,
            orderId?: number,
            startTime?: number,
            endTime?: number,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/allOrders',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel all open orders of the specified symbol at the end of the specified countdown. This rest endpoint means to ensure your open orders are canceled in case of an outage. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and repalced by a new one. The system will check all countdowns **approximately every 10 milliseconds**, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.
         *
         * Example usage:
         * Call this endpoint at 30s intervals with an countdownTime of 120000 (120s).
         * If this endpoint is not called within 120 seconds, all your orders of the specified symbol will be automatically canceled.
         * If this endpoint is called with an countdownTime of 0, the countdown timer will be stopped.
         *
         * Weight: 10
         *
         * @summary Auto-Cancel All Open Orders (TRADE)
         * @param {string} symbol
         * @param {number} countdownTime countdown time, 1000 for 1 second. 0 to cancel the timer
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        autoCancelAllOpenOrders: async (
            symbol: string,
            countdownTime: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('autoCancelAllOpenOrders', 'symbol', symbol);
            // verify required parameter 'countdownTime' is not null or undefined
            assertParamExists('autoCancelAllOpenOrders', 'countdownTime', countdownTime);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (countdownTime !== undefined && countdownTime !== null) {
                localVarQueryParameter['countdownTime'] = countdownTime;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/countdownCancelAll',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel All Open Orders
         *
         * Weight: 1
         *
         * @summary Cancel All Open Orders(TRADE)
         * @param {string} symbol
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cancelAllOpenOrders: async (symbol: string, recvWindow?: number): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cancelAllOpenOrders', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/allOpenOrders',
                method: 'DELETE',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel Multiple Orders
         *
         * Either `orderIdList` or `origClientOrderIdList ` must be sent.
         *
         * Weight: 1
         *
         * @summary Cancel Multiple Orders(TRADE)
         * @param {string} symbol
         * @param {Array<number>} [orderIdList] max length 10 <br /> e.g. [1234567,2345678]
         * @param {Array<string>} [origClientOrderIdList] max length 10<br /> e.g. ["my_id_1","my_id_2"], encode the double quotes. No space after comma.
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cancelMultipleOrders: async (
            symbol: string,
            orderIdList?: Array<number>,
            origClientOrderIdList?: Array<string>,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cancelMultipleOrders', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderIdList) {
                localVarQueryParameter['orderIdList'] = orderIdList;
            }

            if (origClientOrderIdList) {
                localVarQueryParameter['origClientOrderIdList'] = origClientOrderIdList;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/batchOrders',
                method: 'DELETE',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Cancel an active order.
         *
         *
         * Either `orderId` or `origClientOrderId` must be sent.
         *
         * Weight: 1
         *
         * @summary Cancel Order (TRADE)
         * @param {string} symbol
         * @param {number} [orderId]
         * @param {string} [origClientOrderId]
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        cancelOrder: async (
            symbol: string,
            orderId?: number,
            origClientOrderId?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('cancelOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/order',
                method: 'DELETE',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Change user's initial leverage in the specific symbol market.
         * For Hedge Mode, LONG and SHORT positions of one symbol use the same initial leverage and share a total notional value.
         *
         * Weight: 1
         *
         * @summary Change Initial Leverage (TRADE)
         * @param {string} symbol
         * @param {number} leverage target initial leverage: int from 1 to 125
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        changeInitialLeverage: async (
            symbol: string,
            leverage: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('changeInitialLeverage', 'symbol', symbol);
            // verify required parameter 'leverage' is not null or undefined
            assertParamExists('changeInitialLeverage', 'leverage', leverage);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (leverage !== undefined && leverage !== null) {
                localVarQueryParameter['leverage'] = leverage;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/leverage',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Change user's margin type in the specific symbol market.For Hedge Mode, LONG and SHORT positions of one symbol use the same margin type.
         * With ISOLATED margin type, margins of the LONG and SHORT positions are isolated from each other.
         *
         * Weight: 1
         *
         * @summary Change Margin Type (TRADE)
         * @param {string} symbol
         * @param {ChangeMarginTypeMarginTypeEnum} marginType ISOLATED, CROSSED
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        changeMarginType: async (
            symbol: string,
            marginType: ChangeMarginTypeMarginTypeEnum,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('changeMarginType', 'symbol', symbol);
            // verify required parameter 'marginType' is not null or undefined
            assertParamExists('changeMarginType', 'marginType', marginType);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (marginType !== undefined && marginType !== null) {
                localVarQueryParameter['marginType'] = marginType;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/marginType',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Change user's position mode (Hedge Mode or One-way Mode ) on ***EVERY symbol***
         *
         * Weight: 1
         *
         * @summary Change Position Mode(TRADE)
         * @param {string} dualSidePosition "true": Hedge Mode; "false": One-way Mode
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        changePositionMode: async (
            dualSidePosition: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'dualSidePosition' is not null or undefined
            assertParamExists('changePositionMode', 'dualSidePosition', dualSidePosition);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (dualSidePosition !== undefined && dualSidePosition !== null) {
                localVarQueryParameter['dualSidePosition'] = dualSidePosition;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/positionSide/dual',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get all open orders on a symbol. **Careful** when accessing this with no symbol.
         *
         * Weight: 1 for a single symbol, 40 for mutltiple symbols
         *
         * @summary Current All Open Orders (USER_DATA)
         * @param {string} [symbol]
         * @param {string} [pair]
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        currentAllOpenOrders: async (
            symbol?: string,
            pair?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/openOrders',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get order modification history
         *
         *
         * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
         * Order modify history longer than 3 month is not avaliable
         *
         * Weight: 1
         *
         * @summary Get Order Modify History (USER_DATA)
         * @param {string} symbol
         * @param {number} [orderId]
         * @param {string} [origClientOrderId]
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        getOrderModifyHistory: async (
            symbol: string,
            orderId?: number,
            origClientOrderId?: string,
            startTime?: number,
            endTime?: number,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOrderModifyHistory', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/orderAmendment',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get position margin change history
         *
         * Weight: 1
         *
         * @summary Get Position Margin Change History(TRADE)
         * @param {string} symbol
         * @param {number} [type] 1: Add position margin,2: Reduce position margin
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        getPositionMarginChangeHistory: async (
            symbol: string,
            type?: number,
            startTime?: number,
            endTime?: number,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getPositionMarginChangeHistory', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/positionMargin/history',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Modify Isolated Position Margin
         *
         * Only for isolated symbol
         *
         * Weight: 1
         *
         * @summary Modify Isolated Position Margin(TRADE)
         * @param {string} symbol
         * @param {number} amount
         * @param {ModifyIsolatedPositionMarginTypeEnum} type
         * @param {ModifyIsolatedPositionMarginPositionSideEnum} [positionSide] Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent with Hedge Mode.
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        modifyIsolatedPositionMargin: async (
            symbol: string,
            amount: number,
            type: ModifyIsolatedPositionMarginTypeEnum,
            positionSide?: ModifyIsolatedPositionMarginPositionSideEnum,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('modifyIsolatedPositionMargin', 'symbol', symbol);
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('modifyIsolatedPositionMargin', 'amount', amount);
            // verify required parameter 'type' is not null or undefined
            assertParamExists('modifyIsolatedPositionMargin', 'type', type);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (positionSide !== undefined && positionSide !== null) {
                localVarQueryParameter['positionSide'] = positionSide;
            }

            if (amount !== undefined && amount !== null) {
                localVarQueryParameter['amount'] = amount;
            }

            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/positionMargin',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Modify Multiple Orders
         *
         * Parameter rules are same with `Modify Order`
         * Batch modify orders are processed concurrently, and the order of matching is not guaranteed.
         * The order of returned contents for batch modify orders is the same as the order of the order list.
         * One order can only be modfied for less than 10000 times
         *
         * Weight: 5
         *
         * @summary Modify Multiple Orders(TRADE)
         * @param {Array<ModifyMultipleOrdersBatchOrdersParameterInner>} batchOrders order list. Max 5 orders
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        modifyMultipleOrders: async (
            batchOrders: Array<ModifyMultipleOrdersBatchOrdersParameterInner>,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'batchOrders' is not null or undefined
            assertParamExists('modifyMultipleOrders', 'batchOrders', batchOrders);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (batchOrders) {
                localVarQueryParameter['batchOrders'] = batchOrders;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/batchOrders',
                method: 'PUT',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
         *
         * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
         * Either `quantity` or `price` must be sent.
         * When the new `quantity` or `price` doesn't satisfy PRICE_FILTER / PERCENT_FILTER / LOT_SIZE, amendment will be rejected and the order will stay as it is.
         * However the order will be cancelled by the amendment in the following situations:
         * when the order is in partially filled status and the new `quantity` <= `executedQty`
         * When the order is `GTX` and the new price will cause it to be executed immediately
         * One order can only be modfied for less than 10000 times
         * Modify order will set `selfTradePreventionMode` to `NONE`
         *
         * Weight: 1
         *
         * @summary Modify Order (TRADE)
         * @param {string} symbol
         * @param {ModifyOrderSideEnum} side `SELL`, `BUY`
         * @param {number} [orderId]
         * @param {string} [origClientOrderId]
         * @param {number} [quantity] quantity measured by contract number, Cannot be sent with `closePosition`=`true`
         * @param {number} [price]
         * @param {ModifyOrderPriceMatchEnum} [priceMatch] only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        modifyOrder: async (
            symbol: string,
            side: ModifyOrderSideEnum,
            orderId?: number,
            origClientOrderId?: string,
            quantity?: number,
            price?: number,
            priceMatch?: ModifyOrderPriceMatchEnum,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('modifyOrder', 'symbol', symbol);
            // verify required parameter 'side' is not null or undefined
            assertParamExists('modifyOrder', 'side', side);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }

            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }

            if (priceMatch !== undefined && priceMatch !== null) {
                localVarQueryParameter['priceMatch'] = priceMatch;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/order',
                method: 'PUT',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Send in a new order.
         *
         *
         * Order with type `STOP`,  parameter `timeInForce` can be sent ( default `GTC`).
         * Order with type `TAKE_PROFIT`,  parameter `timeInForce` can be sent ( default `GTC`).
         * Condition orders will be triggered when:
         *
         * If parameter`priceProtect`is sent as true:
         * when price reaches the `stopPrice` ï¼Œthe difference rate between "MARK_PRICE" and "CONTRACT_PRICE" cannot be larger than the "triggerProtect" of the symbol
         * "triggerProtect" of a symbol can be got from `GET /dapi/v1/exchangeInfo`
         *
         * `STOP`, `STOP_MARKET`:
         * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
         * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
         * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
         * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
         * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
         * `TRAILING_STOP_MARKET`:
         * BUY: the lowest price after order placed `<= `activationPrice`, and the latest price >`= the lowest price * (1 + `callbackRate`)
         * SELL: the highest price after order placed >= `activationPrice`, and the latest price <= the highest price * (1 - `callbackRate`)
         *
         * For `TRAILING_STOP_MARKET`, if you got such error code.
         * ``{"code": -2021, "msg": "Order would immediately trigger."}``
         * means that the parameters you send do not meet the following requirements:
         * BUY: `activationPrice` should be smaller than latest price.
         * SELL: `activationPrice` should be larger than latest price.
         *
         * If `newOrderRespType ` is sent as `RESULT` :
         * `MARKET` order: the final FILLED result of the order will be return directly.
         * `LIMIT` order with special `timeInForce`: the final status result of the order(FILLED or EXPIRED) will be returned directly.
         *
         * `STOP_MARKET`, `TAKE_PROFIT_MARKET` with `closePosition`=`true`:
         * Follow the same rules for condition orders.
         * If triggered,**close all** current long position( if `SELL`) or current short position( if `BUY`).
         * Cannot be used with `quantity` parameter
         * Cannot be used with `reduceOnly` parameter
         * In Hedge Mode,cannot be used with `BUY` orders in `LONG` position side. and cannot be used with `SELL` orders in `SHORT` position side
         * `selfTradePreventionMode` is only effective when `timeInForce` set to `IOC` or `GTC`.
         *
         * Weight: 1 on 1min order rate limit(X-MBX-ORDER-COUNT-1M)\
         * 0 on IP rate limit(x-mbx-used-weight-1m)
         *
         * @summary New Order (TRADE)
         * @param {string} symbol
         * @param {NewOrderSideEnum} side `SELL`, `BUY`
         * @param {NewOrderTypeEnum} type
         * @param {NewOrderPositionSideEnum} [positionSide] Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent with Hedge Mode.
         * @param {NewOrderTimeInForceEnum} [timeInForce]
         * @param {number} [quantity] quantity measured by contract number, Cannot be sent with `closePosition`=`true`
         * @param {string} [reduceOnly] "true" or "false". default "false". Cannot be sent in Hedge Mode; cannot be sent with `closePosition`=`true`(Close-All)
         * @param {number} [price]
         * @param {string} [newClientOrderId] A unique id among open orders. Automatically generated if not sent. Can only be string following the rule: `^[\.A-Z\:/a-z0-9_-]{1,36}$`
         * @param {number} [stopPrice] Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
         * @param {string} [closePosition] `true`, `false`ï¼›Close-All,used with `STOP_MARKET` or `TAKE_PROFIT_MARKET`.
         * @param {number} [activationPrice] Used with `TRAILING_STOP_MARKET` orders, default as the latest price(supporting different `workingType`)
         * @param {number} [callbackRate] Used with `TRAILING_STOP_MARKET` orders, min 0.1, max 5 where 1 for 1%
         * @param {NewOrderWorkingTypeEnum} [workingType] stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
         * @param {string} [priceProtect] "TRUE" or "FALSE", default "FALSE". Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
         * @param {NewOrderNewOrderRespTypeEnum} [newOrderRespType] "ACK", "RESULT", default "ACK"
         * @param {NewOrderPriceMatchEnum} [priceMatch] only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
         * @param {NewOrderSelfTradePreventionModeEnum} [selfTradePreventionMode] `EXPIRE_TAKER`:expire taker order when STP triggers/ `EXPIRE_MAKER`:expire taker order when STP triggers/ `EXPIRE_BOTH`:expire both orders when STP triggers; default `EXPIRE_MAKER`
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        newOrder: async (
            symbol: string,
            side: NewOrderSideEnum,
            type: NewOrderTypeEnum,
            positionSide?: NewOrderPositionSideEnum,
            timeInForce?: NewOrderTimeInForceEnum,
            quantity?: number,
            reduceOnly?: string,
            price?: number,
            newClientOrderId?: string,
            stopPrice?: number,
            closePosition?: string,
            activationPrice?: number,
            callbackRate?: number,
            workingType?: NewOrderWorkingTypeEnum,
            priceProtect?: string,
            newOrderRespType?: NewOrderNewOrderRespTypeEnum,
            priceMatch?: NewOrderPriceMatchEnum,
            selfTradePreventionMode?: NewOrderSelfTradePreventionModeEnum,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('newOrder', 'symbol', symbol);
            // verify required parameter 'side' is not null or undefined
            assertParamExists('newOrder', 'side', side);
            // verify required parameter 'type' is not null or undefined
            assertParamExists('newOrder', 'type', type);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (side !== undefined && side !== null) {
                localVarQueryParameter['side'] = side;
            }

            if (positionSide !== undefined && positionSide !== null) {
                localVarQueryParameter['positionSide'] = positionSide;
            }

            if (type !== undefined && type !== null) {
                localVarQueryParameter['type'] = type;
            }

            if (timeInForce !== undefined && timeInForce !== null) {
                localVarQueryParameter['timeInForce'] = timeInForce;
            }

            if (quantity !== undefined && quantity !== null) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (reduceOnly !== undefined && reduceOnly !== null) {
                localVarQueryParameter['reduceOnly'] = reduceOnly;
            }

            if (price !== undefined && price !== null) {
                localVarQueryParameter['price'] = price;
            }

            if (newClientOrderId !== undefined && newClientOrderId !== null) {
                localVarQueryParameter['newClientOrderId'] = newClientOrderId;
            }

            if (stopPrice !== undefined && stopPrice !== null) {
                localVarQueryParameter['stopPrice'] = stopPrice;
            }

            if (closePosition !== undefined && closePosition !== null) {
                localVarQueryParameter['closePosition'] = closePosition;
            }

            if (activationPrice !== undefined && activationPrice !== null) {
                localVarQueryParameter['activationPrice'] = activationPrice;
            }

            if (callbackRate !== undefined && callbackRate !== null) {
                localVarQueryParameter['callbackRate'] = callbackRate;
            }

            if (workingType !== undefined && workingType !== null) {
                localVarQueryParameter['workingType'] = workingType;
            }

            if (priceProtect !== undefined && priceProtect !== null) {
                localVarQueryParameter['priceProtect'] = priceProtect;
            }

            if (newOrderRespType !== undefined && newOrderRespType !== null) {
                localVarQueryParameter['newOrderRespType'] = newOrderRespType;
            }

            if (priceMatch !== undefined && priceMatch !== null) {
                localVarQueryParameter['priceMatch'] = priceMatch;
            }

            if (selfTradePreventionMode !== undefined && selfTradePreventionMode !== null) {
                localVarQueryParameter['selfTradePreventionMode'] = selfTradePreventionMode;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/order',
                method: 'POST',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query position ADL quantile estimation
         *
         * Values update every 30s.
         * Values 0, 1, 2, 3, 4 shows the queue position and possibility of ADL from low to high.
         * For positions of the symbol are in One-way Mode or isolated margined in Hedge Mode, "LONG", "SHORT", and "BOTH" will be returned to show the positions' adl quantiles of different position sides.
         * If the positions of the symbol are crossed margined in Hedge Mode:
         * "HEDGE" as a sign will be returned instead of "BOTH";
         * A same value caculated on unrealized pnls on long and short sides' positions will be shown for "LONG" and "SHORT" when there are positions in both of long and short sides.
         *
         * Weight: 5
         *
         * @summary Position ADL Quantile Estimation(USER_DATA)
         * @param {string} [symbol]
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        positionAdlQuantileEstimation: async (
            symbol?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/adlQuantile',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get current account information.
         *
         * If neither `marginAsset` nor `pair` is sent, positions of all symbols with `TRADING` status will be returned.
         * for One-way Mode user, the response  will only show the "BOTH" positions
         * for Hedge Mode user, the response will show "BOTH", "LONG", and "SHORT" positions.
         * Please use with user data stream `ACCOUNT_UPDATE` to meet your timeliness and accuracy needs.
         *
         * Weight: 1
         *
         * @summary Position Information(USER_DATA)
         * @param {string} [marginAsset]
         * @param {string} [pair]
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        positionInformation: async (
            marginAsset?: string,
            pair?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (marginAsset !== undefined && marginAsset !== null) {
                localVarQueryParameter['marginAsset'] = marginAsset;
            }

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/positionRisk',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query Current Open Order
         *
         * Either`orderId` or `origClientOrderId` must be sent
         * If the queried order has been filled or cancelled, the error message "Order does not exist" will be returned.
         *
         * Weight: 1
         *
         * @summary Query Current Open Order(USER_DATA)
         * @param {string} symbol
         * @param {number} [orderId]
         * @param {string} [origClientOrderId]
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryCurrentOpenOrder: async (
            symbol: string,
            orderId?: number,
            origClientOrderId?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryCurrentOpenOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/openOrder',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Check an order's status.
         *
         * These orders will not be found:
         * order status is CANCELED or EXPIRED AND order has NO filled trade AND created time + 3 days < current time
         * order create time + 90 days < current time
         *
         *
         * Either `orderId` or `origClientOrderId` must be sent.
         *
         * Weight: 1
         *
         * @summary Query Order (USER_DATA)
         * @param {string} symbol
         * @param {number} [orderId]
         * @param {string} [origClientOrderId]
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        queryOrder: async (
            symbol: string,
            orderId?: number,
            origClientOrderId?: string,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryOrder', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (orderId !== undefined && orderId !== null) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (origClientOrderId !== undefined && origClientOrderId !== null) {
                localVarQueryParameter['origClientOrderId'] = origClientOrderId;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/order',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * User's Force Orders
         *
         * If "autoCloseType" is not sent, orders with both of the types will be returned
         * If "startTime" is not sent, data within 200 days before "endTime" can be queried
         *
         * Weight: 20 with symbol, 50 without symbol
         *
         * @summary User\'s Force Orders(USER_DATA)
         * @param {string} [symbol]
         * @param {UsersForceOrdersAutoCloseTypeEnum} [autoCloseType] "LIQUIDATION" for liquidation orders, "ADL" for ADL orders.
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [recvWindow]
         *
         * @throws {RequiredError}
         */
        usersForceOrders: async (
            symbol?: string,
            autoCloseType?: UsersForceOrdersAutoCloseTypeEnum,
            startTime?: number,
            endTime?: number,
            limit?: number,
            recvWindow?: number
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (autoCloseType !== undefined && autoCloseType !== null) {
                localVarQueryParameter['autoCloseType'] = autoCloseType;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recvWindow !== undefined && recvWindow !== null) {
                localVarQueryParameter['recvWindow'] = recvWindow;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/forceOrders',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
    };
};

/**
 * TradeApi - interface
 * @interface TradeApi
 */
export interface TradeApiInterface {
    /**
     * Get trades for a specific account and symbol.
     *
     *
     * Either symbol or pair must be sent
     * Symbol and pair cannot be sent together
     * Pair and fromId cannot be sent together
     * OrderId can only be sent together with symbol
     * If a pair is sent,tickers for all symbols of the pair will be returned
     * The parameter `fromId` cannot be sent with `startTime` or `endTime`
     * If startTime and endTime are both not sent, then the last 7 days' data will be returned.
     * The time between startTime and endTime cannot be longer than 7 days.
     *
     * Weight: 20 with symbolï¼Œ40 with pair
     *
     * @summary Account Trade List (USER_DATA)
     * @param {AccountTradeListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    accountTradeList(
        requestParameters?: AccountTradeListRequest
    ): Promise<RestApiResponse<AccountTradeListResponse>>;
    /**
     * Get all account orders; active, canceled, or filled.
     *
     * These orders will not be found:
     * order status is CANCELED or EXPIRED AND order has NO filled trade AND created time + 3 days < current time
     * order create time + 90 days < current time
     *
     *
     * Either `symbol` or `pair` must be sent.
     * `pair` can't be sent with `orderId`
     * If `orderId` is set, it will get orders >= that `orderId`. Otherwise most recent orders are returned.
     * If orderId is set, it will get orders >= that orderId. Otherwise most recent orders are returned.
     * The query time period must be less then 7 days( default as the recent 7 days).
     *
     * Weight: 20 with symbol, 40 with pair
     *
     * @summary All Orders (USER_DATA)
     * @param {AllOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    allOrders(requestParameters?: AllOrdersRequest): Promise<RestApiResponse<AllOrdersResponse>>;
    /**
     * Cancel all open orders of the specified symbol at the end of the specified countdown. This rest endpoint means to ensure your open orders are canceled in case of an outage. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and repalced by a new one. The system will check all countdowns **approximately every 10 milliseconds**, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.
     *
     * Example usage:
     * Call this endpoint at 30s intervals with an countdownTime of 120000 (120s).
     * If this endpoint is not called within 120 seconds, all your orders of the specified symbol will be automatically canceled.
     * If this endpoint is called with an countdownTime of 0, the countdown timer will be stopped.
     *
     * Weight: 10
     *
     * @summary Auto-Cancel All Open Orders (TRADE)
     * @param {AutoCancelAllOpenOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    autoCancelAllOpenOrders(
        requestParameters: AutoCancelAllOpenOrdersRequest
    ): Promise<RestApiResponse<void>>;
    /**
     * Cancel All Open Orders
     *
     * Weight: 1
     *
     * @summary Cancel All Open Orders(TRADE)
     * @param {CancelAllOpenOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cancelAllOpenOrders(
        requestParameters: CancelAllOpenOrdersRequest
    ): Promise<RestApiResponse<CancelAllOpenOrdersResponse>>;
    /**
     * Cancel Multiple Orders
     *
     * Either `orderIdList` or `origClientOrderIdList ` must be sent.
     *
     * Weight: 1
     *
     * @summary Cancel Multiple Orders(TRADE)
     * @param {CancelMultipleOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cancelMultipleOrders(
        requestParameters: CancelMultipleOrdersRequest
    ): Promise<RestApiResponse<CancelMultipleOrdersResponse>>;
    /**
     * Cancel an active order.
     *
     *
     * Either `orderId` or `origClientOrderId` must be sent.
     *
     * Weight: 1
     *
     * @summary Cancel Order (TRADE)
     * @param {CancelOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    cancelOrder(
        requestParameters: CancelOrderRequest
    ): Promise<RestApiResponse<CancelOrderResponse>>;
    /**
     * Change user's initial leverage in the specific symbol market.
     * For Hedge Mode, LONG and SHORT positions of one symbol use the same initial leverage and share a total notional value.
     *
     * Weight: 1
     *
     * @summary Change Initial Leverage (TRADE)
     * @param {ChangeInitialLeverageRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    changeInitialLeverage(
        requestParameters: ChangeInitialLeverageRequest
    ): Promise<RestApiResponse<ChangeInitialLeverageResponse>>;
    /**
     * Change user's margin type in the specific symbol market.For Hedge Mode, LONG and SHORT positions of one symbol use the same margin type.
     * With ISOLATED margin type, margins of the LONG and SHORT positions are isolated from each other.
     *
     * Weight: 1
     *
     * @summary Change Margin Type (TRADE)
     * @param {ChangeMarginTypeRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    changeMarginType(
        requestParameters: ChangeMarginTypeRequest
    ): Promise<RestApiResponse<ChangeMarginTypeResponse>>;
    /**
     * Change user's position mode (Hedge Mode or One-way Mode ) on ***EVERY symbol***
     *
     * Weight: 1
     *
     * @summary Change Position Mode(TRADE)
     * @param {ChangePositionModeRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    changePositionMode(
        requestParameters: ChangePositionModeRequest
    ): Promise<RestApiResponse<ChangePositionModeResponse>>;
    /**
     * Get all open orders on a symbol. **Careful** when accessing this with no symbol.
     *
     * Weight: 1 for a single symbol, 40 for mutltiple symbols
     *
     * @summary Current All Open Orders (USER_DATA)
     * @param {CurrentAllOpenOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    currentAllOpenOrders(
        requestParameters?: CurrentAllOpenOrdersRequest
    ): Promise<RestApiResponse<CurrentAllOpenOrdersResponse>>;
    /**
     * Get order modification history
     *
     *
     * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
     * Order modify history longer than 3 month is not avaliable
     *
     * Weight: 1
     *
     * @summary Get Order Modify History (USER_DATA)
     * @param {GetOrderModifyHistoryRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    getOrderModifyHistory(
        requestParameters: GetOrderModifyHistoryRequest
    ): Promise<RestApiResponse<GetOrderModifyHistoryResponse>>;
    /**
     * Get position margin change history
     *
     * Weight: 1
     *
     * @summary Get Position Margin Change History(TRADE)
     * @param {GetPositionMarginChangeHistoryRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    getPositionMarginChangeHistory(
        requestParameters: GetPositionMarginChangeHistoryRequest
    ): Promise<RestApiResponse<GetPositionMarginChangeHistoryResponse>>;
    /**
     * Modify Isolated Position Margin
     *
     * Only for isolated symbol
     *
     * Weight: 1
     *
     * @summary Modify Isolated Position Margin(TRADE)
     * @param {ModifyIsolatedPositionMarginRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    modifyIsolatedPositionMargin(
        requestParameters: ModifyIsolatedPositionMarginRequest
    ): Promise<RestApiResponse<ModifyIsolatedPositionMarginResponse>>;
    /**
     * Modify Multiple Orders
     *
     * Parameter rules are same with `Modify Order`
     * Batch modify orders are processed concurrently, and the order of matching is not guaranteed.
     * The order of returned contents for batch modify orders is the same as the order of the order list.
     * One order can only be modfied for less than 10000 times
     *
     * Weight: 5
     *
     * @summary Modify Multiple Orders(TRADE)
     * @param {ModifyMultipleOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    modifyMultipleOrders(
        requestParameters: ModifyMultipleOrdersRequest
    ): Promise<RestApiResponse<ModifyMultipleOrdersResponse>>;
    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     *
     * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
     * Either `quantity` or `price` must be sent.
     * When the new `quantity` or `price` doesn't satisfy PRICE_FILTER / PERCENT_FILTER / LOT_SIZE, amendment will be rejected and the order will stay as it is.
     * However the order will be cancelled by the amendment in the following situations:
     * when the order is in partially filled status and the new `quantity` <= `executedQty`
     * When the order is `GTX` and the new price will cause it to be executed immediately
     * One order can only be modfied for less than 10000 times
     * Modify order will set `selfTradePreventionMode` to `NONE`
     *
     * Weight: 1
     *
     * @summary Modify Order (TRADE)
     * @param {ModifyOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    modifyOrder(
        requestParameters: ModifyOrderRequest
    ): Promise<RestApiResponse<ModifyOrderResponse>>;
    /**
     * Send in a new order.
     *
     *
     * Order with type `STOP`,  parameter `timeInForce` can be sent ( default `GTC`).
     * Order with type `TAKE_PROFIT`,  parameter `timeInForce` can be sent ( default `GTC`).
     * Condition orders will be triggered when:
     *
     * If parameter`priceProtect`is sent as true:
     * when price reaches the `stopPrice` ï¼Œthe difference rate between "MARK_PRICE" and "CONTRACT_PRICE" cannot be larger than the "triggerProtect" of the symbol
     * "triggerProtect" of a symbol can be got from `GET /dapi/v1/exchangeInfo`
     *
     * `STOP`, `STOP_MARKET`:
     * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
     * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
     * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
     * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
     * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
     * `TRAILING_STOP_MARKET`:
     * BUY: the lowest price after order placed `<= `activationPrice`, and the latest price >`= the lowest price * (1 + `callbackRate`)
     * SELL: the highest price after order placed >= `activationPrice`, and the latest price <= the highest price * (1 - `callbackRate`)
     *
     * For `TRAILING_STOP_MARKET`, if you got such error code.
     * ``{"code": -2021, "msg": "Order would immediately trigger."}``
     * means that the parameters you send do not meet the following requirements:
     * BUY: `activationPrice` should be smaller than latest price.
     * SELL: `activationPrice` should be larger than latest price.
     *
     * If `newOrderRespType ` is sent as `RESULT` :
     * `MARKET` order: the final FILLED result of the order will be return directly.
     * `LIMIT` order with special `timeInForce`: the final status result of the order(FILLED or EXPIRED) will be returned directly.
     *
     * `STOP_MARKET`, `TAKE_PROFIT_MARKET` with `closePosition`=`true`:
     * Follow the same rules for condition orders.
     * If triggered,**close all** current long position( if `SELL`) or current short position( if `BUY`).
     * Cannot be used with `quantity` parameter
     * Cannot be used with `reduceOnly` parameter
     * In Hedge Mode,cannot be used with `BUY` orders in `LONG` position side. and cannot be used with `SELL` orders in `SHORT` position side
     * `selfTradePreventionMode` is only effective when `timeInForce` set to `IOC` or `GTC`.
     *
     * Weight: 1 on 1min order rate limit(X-MBX-ORDER-COUNT-1M)\
     * 0 on IP rate limit(x-mbx-used-weight-1m)
     *
     * @summary New Order (TRADE)
     * @param {NewOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    newOrder(requestParameters: NewOrderRequest): Promise<RestApiResponse<NewOrderResponse>>;
    /**
     * Query position ADL quantile estimation
     *
     * Values update every 30s.
     * Values 0, 1, 2, 3, 4 shows the queue position and possibility of ADL from low to high.
     * For positions of the symbol are in One-way Mode or isolated margined in Hedge Mode, "LONG", "SHORT", and "BOTH" will be returned to show the positions' adl quantiles of different position sides.
     * If the positions of the symbol are crossed margined in Hedge Mode:
     * "HEDGE" as a sign will be returned instead of "BOTH";
     * A same value caculated on unrealized pnls on long and short sides' positions will be shown for "LONG" and "SHORT" when there are positions in both of long and short sides.
     *
     * Weight: 5
     *
     * @summary Position ADL Quantile Estimation(USER_DATA)
     * @param {PositionAdlQuantileEstimationRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    positionAdlQuantileEstimation(
        requestParameters?: PositionAdlQuantileEstimationRequest
    ): Promise<RestApiResponse<PositionAdlQuantileEstimationResponse>>;
    /**
     * Get current account information.
     *
     * If neither `marginAsset` nor `pair` is sent, positions of all symbols with `TRADING` status will be returned.
     * for One-way Mode user, the response  will only show the "BOTH" positions
     * for Hedge Mode user, the response will show "BOTH", "LONG", and "SHORT" positions.
     * Please use with user data stream `ACCOUNT_UPDATE` to meet your timeliness and accuracy needs.
     *
     * Weight: 1
     *
     * @summary Position Information(USER_DATA)
     * @param {PositionInformationRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    positionInformation(
        requestParameters?: PositionInformationRequest
    ): Promise<RestApiResponse<PositionInformationResponse>>;
    /**
     * Query Current Open Order
     *
     * Either`orderId` or `origClientOrderId` must be sent
     * If the queried order has been filled or cancelled, the error message "Order does not exist" will be returned.
     *
     * Weight: 1
     *
     * @summary Query Current Open Order(USER_DATA)
     * @param {QueryCurrentOpenOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryCurrentOpenOrder(
        requestParameters: QueryCurrentOpenOrderRequest
    ): Promise<RestApiResponse<QueryCurrentOpenOrderResponse>>;
    /**
     * Check an order's status.
     *
     * These orders will not be found:
     * order status is CANCELED or EXPIRED AND order has NO filled trade AND created time + 3 days < current time
     * order create time + 90 days < current time
     *
     *
     * Either `orderId` or `origClientOrderId` must be sent.
     *
     * Weight: 1
     *
     * @summary Query Order (USER_DATA)
     * @param {QueryOrderRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    queryOrder(requestParameters: QueryOrderRequest): Promise<RestApiResponse<QueryOrderResponse>>;
    /**
     * User's Force Orders
     *
     * If "autoCloseType" is not sent, orders with both of the types will be returned
     * If "startTime" is not sent, data within 200 days before "endTime" can be queried
     *
     * Weight: 20 with symbol, 50 without symbol
     *
     * @summary User\'s Force Orders(USER_DATA)
     * @param {UsersForceOrdersRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApiInterface
     */
    usersForceOrders(
        requestParameters?: UsersForceOrdersRequest
    ): Promise<RestApiResponse<UsersForceOrdersResponse>>;
}

/**
 * Request parameters for accountTradeList operation in TradeApi.
 * @interface AccountTradeListRequest
 */
export interface AccountTradeListRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiAccountTradeList
     */
    readonly symbol?: string;

    /**
     *
     * @type {string}
     * @memberof TradeApiAccountTradeList
     */
    readonly pair?: string;

    /**
     *
     * @type {string}
     * @memberof TradeApiAccountTradeList
     */
    readonly orderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiAccountTradeList
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiAccountTradeList
     */
    readonly endTime?: number;

    /**
     * ID to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof TradeApiAccountTradeList
     */
    readonly fromId?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof TradeApiAccountTradeList
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiAccountTradeList
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for allOrders operation in TradeApi.
 * @interface AllOrdersRequest
 */
export interface AllOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiAllOrders
     */
    readonly symbol?: string;

    /**
     *
     * @type {string}
     * @memberof TradeApiAllOrders
     */
    readonly pair?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiAllOrders
     */
    readonly orderId?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiAllOrders
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiAllOrders
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof TradeApiAllOrders
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiAllOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for autoCancelAllOpenOrders operation in TradeApi.
 * @interface AutoCancelAllOpenOrdersRequest
 */
export interface AutoCancelAllOpenOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiAutoCancelAllOpenOrders
     */
    readonly symbol: string;

    /**
     * countdown time, 1000 for 1 second. 0 to cancel the timer
     * @type {number}
     * @memberof TradeApiAutoCancelAllOpenOrders
     */
    readonly countdownTime: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiAutoCancelAllOpenOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for cancelAllOpenOrders operation in TradeApi.
 * @interface CancelAllOpenOrdersRequest
 */
export interface CancelAllOpenOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiCancelAllOpenOrders
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiCancelAllOpenOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for cancelMultipleOrders operation in TradeApi.
 * @interface CancelMultipleOrdersRequest
 */
export interface CancelMultipleOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiCancelMultipleOrders
     */
    readonly symbol: string;

    /**
     * max length 10 <br /> e.g. [1234567,2345678]
     * @type {Array<number>}
     * @memberof TradeApiCancelMultipleOrders
     */
    readonly orderIdList?: Array<number>;

    /**
     * max length 10<br /> e.g. ["my_id_1","my_id_2"], encode the double quotes. No space after comma.
     * @type {Array<string>}
     * @memberof TradeApiCancelMultipleOrders
     */
    readonly origClientOrderIdList?: Array<string>;

    /**
     *
     * @type {number}
     * @memberof TradeApiCancelMultipleOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for cancelOrder operation in TradeApi.
 * @interface CancelOrderRequest
 */
export interface CancelOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiCancelOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiCancelOrder
     */
    readonly orderId?: number;

    /**
     *
     * @type {string}
     * @memberof TradeApiCancelOrder
     */
    readonly origClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiCancelOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for changeInitialLeverage operation in TradeApi.
 * @interface ChangeInitialLeverageRequest
 */
export interface ChangeInitialLeverageRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiChangeInitialLeverage
     */
    readonly symbol: string;

    /**
     * target initial leverage: int from 1 to 125
     * @type {number}
     * @memberof TradeApiChangeInitialLeverage
     */
    readonly leverage: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiChangeInitialLeverage
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for changeMarginType operation in TradeApi.
 * @interface ChangeMarginTypeRequest
 */
export interface ChangeMarginTypeRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiChangeMarginType
     */
    readonly symbol: string;

    /**
     * ISOLATED, CROSSED
     * @type {'ISOLATED' | 'CROSSED'}
     * @memberof TradeApiChangeMarginType
     */
    readonly marginType: ChangeMarginTypeMarginTypeEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiChangeMarginType
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for changePositionMode operation in TradeApi.
 * @interface ChangePositionModeRequest
 */
export interface ChangePositionModeRequest {
    /**
     * "true": Hedge Mode; "false": One-way Mode
     * @type {string}
     * @memberof TradeApiChangePositionMode
     */
    readonly dualSidePosition: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiChangePositionMode
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for currentAllOpenOrders operation in TradeApi.
 * @interface CurrentAllOpenOrdersRequest
 */
export interface CurrentAllOpenOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiCurrentAllOpenOrders
     */
    readonly symbol?: string;

    /**
     *
     * @type {string}
     * @memberof TradeApiCurrentAllOpenOrders
     */
    readonly pair?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiCurrentAllOpenOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for getOrderModifyHistory operation in TradeApi.
 * @interface GetOrderModifyHistoryRequest
 */
export interface GetOrderModifyHistoryRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiGetOrderModifyHistory
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiGetOrderModifyHistory
     */
    readonly orderId?: number;

    /**
     *
     * @type {string}
     * @memberof TradeApiGetOrderModifyHistory
     */
    readonly origClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiGetOrderModifyHistory
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiGetOrderModifyHistory
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof TradeApiGetOrderModifyHistory
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiGetOrderModifyHistory
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for getPositionMarginChangeHistory operation in TradeApi.
 * @interface GetPositionMarginChangeHistoryRequest
 */
export interface GetPositionMarginChangeHistoryRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiGetPositionMarginChangeHistory
     */
    readonly symbol: string;

    /**
     * 1: Add position margin,2: Reduce position margin
     * @type {number}
     * @memberof TradeApiGetPositionMarginChangeHistory
     */
    readonly type?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiGetPositionMarginChangeHistory
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiGetPositionMarginChangeHistory
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof TradeApiGetPositionMarginChangeHistory
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiGetPositionMarginChangeHistory
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for modifyIsolatedPositionMargin operation in TradeApi.
 * @interface ModifyIsolatedPositionMarginRequest
 */
export interface ModifyIsolatedPositionMarginRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiModifyIsolatedPositionMargin
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiModifyIsolatedPositionMargin
     */
    readonly amount: number;

    /**
     *
     * @type {'LIMIT' | 'MARKET' | 'STOP' | 'STOP_MARKET' | 'TAKE_PROFIT' | 'TAKE_PROFIT_MARKET' | 'TRAILING_STOP_MARKET'}
     * @memberof TradeApiModifyIsolatedPositionMargin
     */
    readonly type: ModifyIsolatedPositionMarginTypeEnum;

    /**
     * Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent with Hedge Mode.
     * @type {'BOTH' | 'LONG' | 'SHORT'}
     * @memberof TradeApiModifyIsolatedPositionMargin
     */
    readonly positionSide?: ModifyIsolatedPositionMarginPositionSideEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiModifyIsolatedPositionMargin
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for modifyMultipleOrders operation in TradeApi.
 * @interface ModifyMultipleOrdersRequest
 */
export interface ModifyMultipleOrdersRequest {
    /**
     * order list. Max 5 orders
     * @type {Array<ModifyMultipleOrdersBatchOrdersParameterInner>}
     * @memberof TradeApiModifyMultipleOrders
     */
    readonly batchOrders: Array<ModifyMultipleOrdersBatchOrdersParameterInner>;

    /**
     *
     * @type {number}
     * @memberof TradeApiModifyMultipleOrders
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for modifyOrder operation in TradeApi.
 * @interface ModifyOrderRequest
 */
export interface ModifyOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiModifyOrder
     */
    readonly symbol: string;

    /**
     * `SELL`, `BUY`
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiModifyOrder
     */
    readonly side: ModifyOrderSideEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiModifyOrder
     */
    readonly orderId?: number;

    /**
     *
     * @type {string}
     * @memberof TradeApiModifyOrder
     */
    readonly origClientOrderId?: string;

    /**
     * quantity measured by contract number, Cannot be sent with `closePosition`=`true`
     * @type {number}
     * @memberof TradeApiModifyOrder
     */
    readonly quantity?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiModifyOrder
     */
    readonly price?: number;

    /**
     * only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
     * @type {'NONE' | 'OPPONENT' | 'OPPONENT_5' | 'OPPONENT_10' | 'OPPONENT_20' | 'QUEUE' | 'QUEUE_5' | 'QUEUE_10' | 'QUEUE_20'}
     * @memberof TradeApiModifyOrder
     */
    readonly priceMatch?: ModifyOrderPriceMatchEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiModifyOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for newOrder operation in TradeApi.
 * @interface NewOrderRequest
 */
export interface NewOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiNewOrder
     */
    readonly symbol: string;

    /**
     * `SELL`, `BUY`
     * @type {'BUY' | 'SELL'}
     * @memberof TradeApiNewOrder
     */
    readonly side: NewOrderSideEnum;

    /**
     *
     * @type {'LIMIT' | 'MARKET' | 'STOP' | 'STOP_MARKET' | 'TAKE_PROFIT' | 'TAKE_PROFIT_MARKET' | 'TRAILING_STOP_MARKET'}
     * @memberof TradeApiNewOrder
     */
    readonly type: NewOrderTypeEnum;

    /**
     * Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent with Hedge Mode.
     * @type {'BOTH' | 'LONG' | 'SHORT'}
     * @memberof TradeApiNewOrder
     */
    readonly positionSide?: NewOrderPositionSideEnum;

    /**
     *
     * @type {'GTC' | 'IOC' | 'FOK' | 'GTX'}
     * @memberof TradeApiNewOrder
     */
    readonly timeInForce?: NewOrderTimeInForceEnum;

    /**
     * quantity measured by contract number, Cannot be sent with `closePosition`=`true`
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly quantity?: number;

    /**
     * "true" or "false". default "false". Cannot be sent in Hedge Mode; cannot be sent with `closePosition`=`true`(Close-All)
     * @type {string}
     * @memberof TradeApiNewOrder
     */
    readonly reduceOnly?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly price?: number;

    /**
     * A unique id among open orders. Automatically generated if not sent. Can only be string following the rule: `^[\.A-Z\:/a-z0-9_-]{1,36}$`
     * @type {string}
     * @memberof TradeApiNewOrder
     */
    readonly newClientOrderId?: string;

    /**
     * Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly stopPrice?: number;

    /**
     * `true`, `false`ï¼›Close-All,used with `STOP_MARKET` or `TAKE_PROFIT_MARKET`.
     * @type {string}
     * @memberof TradeApiNewOrder
     */
    readonly closePosition?: string;

    /**
     * Used with `TRAILING_STOP_MARKET` orders, default as the latest price(supporting different `workingType`)
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly activationPrice?: number;

    /**
     * Used with `TRAILING_STOP_MARKET` orders, min 0.1, max 5 where 1 for 1%
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly callbackRate?: number;

    /**
     * stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
     * @type {'MARK_PRICE' | 'CONTRACT_PRICE'}
     * @memberof TradeApiNewOrder
     */
    readonly workingType?: NewOrderWorkingTypeEnum;

    /**
     * "TRUE" or "FALSE", default "FALSE". Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
     * @type {string}
     * @memberof TradeApiNewOrder
     */
    readonly priceProtect?: string;

    /**
     * "ACK", "RESULT", default "ACK"
     * @type {'ACK' | 'RESULT'}
     * @memberof TradeApiNewOrder
     */
    readonly newOrderRespType?: NewOrderNewOrderRespTypeEnum;

    /**
     * only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
     * @type {'NONE' | 'OPPONENT' | 'OPPONENT_5' | 'OPPONENT_10' | 'OPPONENT_20' | 'QUEUE' | 'QUEUE_5' | 'QUEUE_10' | 'QUEUE_20'}
     * @memberof TradeApiNewOrder
     */
    readonly priceMatch?: NewOrderPriceMatchEnum;

    /**
     * `EXPIRE_TAKER`:expire taker order when STP triggers/ `EXPIRE_MAKER`:expire taker order when STP triggers/ `EXPIRE_BOTH`:expire both orders when STP triggers; default `EXPIRE_MAKER`
     * @type {'NONE' | 'EXPIRE_TAKER' | 'EXPIRE_BOTH' | 'EXPIRE_MAKER'}
     * @memberof TradeApiNewOrder
     */
    readonly selfTradePreventionMode?: NewOrderSelfTradePreventionModeEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiNewOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for positionAdlQuantileEstimation operation in TradeApi.
 * @interface PositionAdlQuantileEstimationRequest
 */
export interface PositionAdlQuantileEstimationRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiPositionAdlQuantileEstimation
     */
    readonly symbol?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiPositionAdlQuantileEstimation
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for positionInformation operation in TradeApi.
 * @interface PositionInformationRequest
 */
export interface PositionInformationRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiPositionInformation
     */
    readonly marginAsset?: string;

    /**
     *
     * @type {string}
     * @memberof TradeApiPositionInformation
     */
    readonly pair?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiPositionInformation
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for queryCurrentOpenOrder operation in TradeApi.
 * @interface QueryCurrentOpenOrderRequest
 */
export interface QueryCurrentOpenOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryCurrentOpenOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiQueryCurrentOpenOrder
     */
    readonly orderId?: number;

    /**
     *
     * @type {string}
     * @memberof TradeApiQueryCurrentOpenOrder
     */
    readonly origClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiQueryCurrentOpenOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for queryOrder operation in TradeApi.
 * @interface QueryOrderRequest
 */
export interface QueryOrderRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiQueryOrder
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiQueryOrder
     */
    readonly orderId?: number;

    /**
     *
     * @type {string}
     * @memberof TradeApiQueryOrder
     */
    readonly origClientOrderId?: string;

    /**
     *
     * @type {number}
     * @memberof TradeApiQueryOrder
     */
    readonly recvWindow?: number;
}

/**
 * Request parameters for usersForceOrders operation in TradeApi.
 * @interface UsersForceOrdersRequest
 */
export interface UsersForceOrdersRequest {
    /**
     *
     * @type {string}
     * @memberof TradeApiUsersForceOrders
     */
    readonly symbol?: string;

    /**
     * "LIQUIDATION" for liquidation orders, "ADL" for ADL orders.
     * @type {'LIQUIDATION' | 'ADL'}
     * @memberof TradeApiUsersForceOrders
     */
    readonly autoCloseType?: UsersForceOrdersAutoCloseTypeEnum;

    /**
     *
     * @type {number}
     * @memberof TradeApiUsersForceOrders
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiUsersForceOrders
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof TradeApiUsersForceOrders
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof TradeApiUsersForceOrders
     */
    readonly recvWindow?: number;
}

/**
 * TradeApi - object-oriented interface
 * @class TradeApi
 */
export class TradeApi implements TradeApiInterface {
    private readonly configuration: ConfigurationRestAPI;
    private localVarAxiosParamCreator;

    constructor(configuration: ConfigurationRestAPI) {
        this.configuration = configuration;
        this.localVarAxiosParamCreator = TradeApiAxiosParamCreator(configuration);
    }

    /**
     * Get trades for a specific account and symbol.
     *
     *
     * Either symbol or pair must be sent
     * Symbol and pair cannot be sent together
     * Pair and fromId cannot be sent together
     * OrderId can only be sent together with symbol
     * If a pair is sent,tickers for all symbols of the pair will be returned
     * The parameter `fromId` cannot be sent with `startTime` or `endTime`
     * If startTime and endTime are both not sent, then the last 7 days' data will be returned.
     * The time between startTime and endTime cannot be longer than 7 days.
     *
     * Weight: 20 with symbolï¼Œ40 with pair
     *
     * @summary Account Trade List (USER_DATA)
     * @param {AccountTradeListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<AccountTradeListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Account-Trade-List Binance API Documentation}
     */
    public async accountTradeList(
        requestParameters: AccountTradeListRequest = {}
    ): Promise<RestApiResponse<AccountTradeListResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.accountTradeList(
            requestParameters?.symbol,
            requestParameters?.pair,
            requestParameters?.orderId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.fromId,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<AccountTradeListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get all account orders; active, canceled, or filled.
     *
     * These orders will not be found:
     * order status is CANCELED or EXPIRED AND order has NO filled trade AND created time + 3 days < current time
     * order create time + 90 days < current time
     *
     *
     * Either `symbol` or `pair` must be sent.
     * `pair` can't be sent with `orderId`
     * If `orderId` is set, it will get orders >= that `orderId`. Otherwise most recent orders are returned.
     * If orderId is set, it will get orders >= that orderId. Otherwise most recent orders are returned.
     * The query time period must be less then 7 days( default as the recent 7 days).
     *
     * Weight: 20 with symbol, 40 with pair
     *
     * @summary All Orders (USER_DATA)
     * @param {AllOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<AllOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/All-Orders Binance API Documentation}
     */
    public async allOrders(
        requestParameters: AllOrdersRequest = {}
    ): Promise<RestApiResponse<AllOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.allOrders(
            requestParameters?.symbol,
            requestParameters?.pair,
            requestParameters?.orderId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<AllOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel all open orders of the specified symbol at the end of the specified countdown. This rest endpoint means to ensure your open orders are canceled in case of an outage. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and repalced by a new one. The system will check all countdowns **approximately every 10 milliseconds**, so please note that sufficient redundancy should be considered when using this function. We do not recommend setting the countdown time to be too precise or too small.
     *
     * Example usage:
     * Call this endpoint at 30s intervals with an countdownTime of 120000 (120s).
     * If this endpoint is not called within 120 seconds, all your orders of the specified symbol will be automatically canceled.
     * If this endpoint is called with an countdownTime of 0, the countdown timer will be stopped.
     *
     * Weight: 10
     *
     * @summary Auto-Cancel All Open Orders (TRADE)
     * @param {AutoCancelAllOpenOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<void>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Auto-Cancel-All-Open-Orders Binance API Documentation}
     */
    public async autoCancelAllOpenOrders(
        requestParameters: AutoCancelAllOpenOrdersRequest
    ): Promise<RestApiResponse<void>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.autoCancelAllOpenOrders(
            requestParameters?.symbol,
            requestParameters?.countdownTime,
            requestParameters?.recvWindow
        );
        return sendRequest<void>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel All Open Orders
     *
     * Weight: 1
     *
     * @summary Cancel All Open Orders(TRADE)
     * @param {CancelAllOpenOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CancelAllOpenOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Cancel-All-Open-Orders Binance API Documentation}
     */
    public async cancelAllOpenOrders(
        requestParameters: CancelAllOpenOrdersRequest
    ): Promise<RestApiResponse<CancelAllOpenOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.cancelAllOpenOrders(
            requestParameters?.symbol,
            requestParameters?.recvWindow
        );
        return sendRequest<CancelAllOpenOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel Multiple Orders
     *
     * Either `orderIdList` or `origClientOrderIdList ` must be sent.
     *
     * Weight: 1
     *
     * @summary Cancel Multiple Orders(TRADE)
     * @param {CancelMultipleOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CancelMultipleOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Cancel-Multiple-Orders Binance API Documentation}
     */
    public async cancelMultipleOrders(
        requestParameters: CancelMultipleOrdersRequest
    ): Promise<RestApiResponse<CancelMultipleOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.cancelMultipleOrders(
            requestParameters?.symbol,
            requestParameters?.orderIdList,
            requestParameters?.origClientOrderIdList,
            requestParameters?.recvWindow
        );
        return sendRequest<CancelMultipleOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Cancel an active order.
     *
     *
     * Either `orderId` or `origClientOrderId` must be sent.
     *
     * Weight: 1
     *
     * @summary Cancel Order (TRADE)
     * @param {CancelOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CancelOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Cancel-Order Binance API Documentation}
     */
    public async cancelOrder(
        requestParameters: CancelOrderRequest
    ): Promise<RestApiResponse<CancelOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.cancelOrder(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<CancelOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Change user's initial leverage in the specific symbol market.
     * For Hedge Mode, LONG and SHORT positions of one symbol use the same initial leverage and share a total notional value.
     *
     * Weight: 1
     *
     * @summary Change Initial Leverage (TRADE)
     * @param {ChangeInitialLeverageRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ChangeInitialLeverageResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Change-Initial-Leverage Binance API Documentation}
     */
    public async changeInitialLeverage(
        requestParameters: ChangeInitialLeverageRequest
    ): Promise<RestApiResponse<ChangeInitialLeverageResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.changeInitialLeverage(
            requestParameters?.symbol,
            requestParameters?.leverage,
            requestParameters?.recvWindow
        );
        return sendRequest<ChangeInitialLeverageResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Change user's margin type in the specific symbol market.For Hedge Mode, LONG and SHORT positions of one symbol use the same margin type.
     * With ISOLATED margin type, margins of the LONG and SHORT positions are isolated from each other.
     *
     * Weight: 1
     *
     * @summary Change Margin Type (TRADE)
     * @param {ChangeMarginTypeRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ChangeMarginTypeResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Change-Margin-Type Binance API Documentation}
     */
    public async changeMarginType(
        requestParameters: ChangeMarginTypeRequest
    ): Promise<RestApiResponse<ChangeMarginTypeResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.changeMarginType(
            requestParameters?.symbol,
            requestParameters?.marginType,
            requestParameters?.recvWindow
        );
        return sendRequest<ChangeMarginTypeResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Change user's position mode (Hedge Mode or One-way Mode ) on ***EVERY symbol***
     *
     * Weight: 1
     *
     * @summary Change Position Mode(TRADE)
     * @param {ChangePositionModeRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ChangePositionModeResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Change-Position-Mode Binance API Documentation}
     */
    public async changePositionMode(
        requestParameters: ChangePositionModeRequest
    ): Promise<RestApiResponse<ChangePositionModeResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.changePositionMode(
            requestParameters?.dualSidePosition,
            requestParameters?.recvWindow
        );
        return sendRequest<ChangePositionModeResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get all open orders on a symbol. **Careful** when accessing this with no symbol.
     *
     * Weight: 1 for a single symbol, 40 for mutltiple symbols
     *
     * @summary Current All Open Orders (USER_DATA)
     * @param {CurrentAllOpenOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CurrentAllOpenOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Current-All-Open-Orders Binance API Documentation}
     */
    public async currentAllOpenOrders(
        requestParameters: CurrentAllOpenOrdersRequest = {}
    ): Promise<RestApiResponse<CurrentAllOpenOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.currentAllOpenOrders(
            requestParameters?.symbol,
            requestParameters?.pair,
            requestParameters?.recvWindow
        );
        return sendRequest<CurrentAllOpenOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get order modification history
     *
     *
     * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
     * Order modify history longer than 3 month is not avaliable
     *
     * Weight: 1
     *
     * @summary Get Order Modify History (USER_DATA)
     * @param {GetOrderModifyHistoryRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetOrderModifyHistoryResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Get-Order-Modify-History Binance API Documentation}
     */
    public async getOrderModifyHistory(
        requestParameters: GetOrderModifyHistoryRequest
    ): Promise<RestApiResponse<GetOrderModifyHistoryResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getOrderModifyHistory(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<GetOrderModifyHistoryResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get position margin change history
     *
     * Weight: 1
     *
     * @summary Get Position Margin Change History(TRADE)
     * @param {GetPositionMarginChangeHistoryRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetPositionMarginChangeHistoryResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Get-Position-Margin-Change-History Binance API Documentation}
     */
    public async getPositionMarginChangeHistory(
        requestParameters: GetPositionMarginChangeHistoryRequest
    ): Promise<RestApiResponse<GetPositionMarginChangeHistoryResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.getPositionMarginChangeHistory(
                requestParameters?.symbol,
                requestParameters?.type,
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.limit,
                requestParameters?.recvWindow
            );
        return sendRequest<GetPositionMarginChangeHistoryResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Modify Isolated Position Margin
     *
     * Only for isolated symbol
     *
     * Weight: 1
     *
     * @summary Modify Isolated Position Margin(TRADE)
     * @param {ModifyIsolatedPositionMarginRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ModifyIsolatedPositionMarginResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Modify-Isolated-Position-Margin Binance API Documentation}
     */
    public async modifyIsolatedPositionMargin(
        requestParameters: ModifyIsolatedPositionMarginRequest
    ): Promise<RestApiResponse<ModifyIsolatedPositionMarginResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.modifyIsolatedPositionMargin(
            requestParameters?.symbol,
            requestParameters?.amount,
            requestParameters?.type,
            requestParameters?.positionSide,
            requestParameters?.recvWindow
        );
        return sendRequest<ModifyIsolatedPositionMarginResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Modify Multiple Orders
     *
     * Parameter rules are same with `Modify Order`
     * Batch modify orders are processed concurrently, and the order of matching is not guaranteed.
     * The order of returned contents for batch modify orders is the same as the order of the order list.
     * One order can only be modfied for less than 10000 times
     *
     * Weight: 5
     *
     * @summary Modify Multiple Orders(TRADE)
     * @param {ModifyMultipleOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ModifyMultipleOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Modify-Multiple-Orders Binance API Documentation}
     */
    public async modifyMultipleOrders(
        requestParameters: ModifyMultipleOrdersRequest
    ): Promise<RestApiResponse<ModifyMultipleOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.modifyMultipleOrders(
            requestParameters?.batchOrders,
            requestParameters?.recvWindow
        );
        return sendRequest<ModifyMultipleOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
     *
     * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
     * Either `quantity` or `price` must be sent.
     * When the new `quantity` or `price` doesn't satisfy PRICE_FILTER / PERCENT_FILTER / LOT_SIZE, amendment will be rejected and the order will stay as it is.
     * However the order will be cancelled by the amendment in the following situations:
     * when the order is in partially filled status and the new `quantity` <= `executedQty`
     * When the order is `GTX` and the new price will cause it to be executed immediately
     * One order can only be modfied for less than 10000 times
     * Modify order will set `selfTradePreventionMode` to `NONE`
     *
     * Weight: 1
     *
     * @summary Modify Order (TRADE)
     * @param {ModifyOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ModifyOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Modify-Order Binance API Documentation}
     */
    public async modifyOrder(
        requestParameters: ModifyOrderRequest
    ): Promise<RestApiResponse<ModifyOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.modifyOrder(
            requestParameters?.symbol,
            requestParameters?.side,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.quantity,
            requestParameters?.price,
            requestParameters?.priceMatch,
            requestParameters?.recvWindow
        );
        return sendRequest<ModifyOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Send in a new order.
     *
     *
     * Order with type `STOP`,  parameter `timeInForce` can be sent ( default `GTC`).
     * Order with type `TAKE_PROFIT`,  parameter `timeInForce` can be sent ( default `GTC`).
     * Condition orders will be triggered when:
     *
     * If parameter`priceProtect`is sent as true:
     * when price reaches the `stopPrice` ï¼Œthe difference rate between "MARK_PRICE" and "CONTRACT_PRICE" cannot be larger than the "triggerProtect" of the symbol
     * "triggerProtect" of a symbol can be got from `GET /dapi/v1/exchangeInfo`
     *
     * `STOP`, `STOP_MARKET`:
     * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
     * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
     * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
     * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
     * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
     * `TRAILING_STOP_MARKET`:
     * BUY: the lowest price after order placed `<= `activationPrice`, and the latest price >`= the lowest price * (1 + `callbackRate`)
     * SELL: the highest price after order placed >= `activationPrice`, and the latest price <= the highest price * (1 - `callbackRate`)
     *
     * For `TRAILING_STOP_MARKET`, if you got such error code.
     * ``{"code": -2021, "msg": "Order would immediately trigger."}``
     * means that the parameters you send do not meet the following requirements:
     * BUY: `activationPrice` should be smaller than latest price.
     * SELL: `activationPrice` should be larger than latest price.
     *
     * If `newOrderRespType ` is sent as `RESULT` :
     * `MARKET` order: the final FILLED result of the order will be return directly.
     * `LIMIT` order with special `timeInForce`: the final status result of the order(FILLED or EXPIRED) will be returned directly.
     *
     * `STOP_MARKET`, `TAKE_PROFIT_MARKET` with `closePosition`=`true`:
     * Follow the same rules for condition orders.
     * If triggered,**close all** current long position( if `SELL`) or current short position( if `BUY`).
     * Cannot be used with `quantity` parameter
     * Cannot be used with `reduceOnly` parameter
     * In Hedge Mode,cannot be used with `BUY` orders in `LONG` position side. and cannot be used with `SELL` orders in `SHORT` position side
     * `selfTradePreventionMode` is only effective when `timeInForce` set to `IOC` or `GTC`.
     *
     * Weight: 1 on 1min order rate limit(X-MBX-ORDER-COUNT-1M)\
     * 0 on IP rate limit(x-mbx-used-weight-1m)
     *
     * @summary New Order (TRADE)
     * @param {NewOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<NewOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/New-Order Binance API Documentation}
     */
    public async newOrder(
        requestParameters: NewOrderRequest
    ): Promise<RestApiResponse<NewOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.newOrder(
            requestParameters?.symbol,
            requestParameters?.side,
            requestParameters?.type,
            requestParameters?.positionSide,
            requestParameters?.timeInForce,
            requestParameters?.quantity,
            requestParameters?.reduceOnly,
            requestParameters?.price,
            requestParameters?.newClientOrderId,
            requestParameters?.stopPrice,
            requestParameters?.closePosition,
            requestParameters?.activationPrice,
            requestParameters?.callbackRate,
            requestParameters?.workingType,
            requestParameters?.priceProtect,
            requestParameters?.newOrderRespType,
            requestParameters?.priceMatch,
            requestParameters?.selfTradePreventionMode,
            requestParameters?.recvWindow
        );
        return sendRequest<NewOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query position ADL quantile estimation
     *
     * Values update every 30s.
     * Values 0, 1, 2, 3, 4 shows the queue position and possibility of ADL from low to high.
     * For positions of the symbol are in One-way Mode or isolated margined in Hedge Mode, "LONG", "SHORT", and "BOTH" will be returned to show the positions' adl quantiles of different position sides.
     * If the positions of the symbol are crossed margined in Hedge Mode:
     * "HEDGE" as a sign will be returned instead of "BOTH";
     * A same value caculated on unrealized pnls on long and short sides' positions will be shown for "LONG" and "SHORT" when there are positions in both of long and short sides.
     *
     * Weight: 5
     *
     * @summary Position ADL Quantile Estimation(USER_DATA)
     * @param {PositionAdlQuantileEstimationRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<PositionAdlQuantileEstimationResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Position-ADL-Quantile-Estimation Binance API Documentation}
     */
    public async positionAdlQuantileEstimation(
        requestParameters: PositionAdlQuantileEstimationRequest = {}
    ): Promise<RestApiResponse<PositionAdlQuantileEstimationResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.positionAdlQuantileEstimation(
                requestParameters?.symbol,
                requestParameters?.recvWindow
            );
        return sendRequest<PositionAdlQuantileEstimationResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Get current account information.
     *
     * If neither `marginAsset` nor `pair` is sent, positions of all symbols with `TRADING` status will be returned.
     * for One-way Mode user, the response  will only show the "BOTH" positions
     * for Hedge Mode user, the response will show "BOTH", "LONG", and "SHORT" positions.
     * Please use with user data stream `ACCOUNT_UPDATE` to meet your timeliness and accuracy needs.
     *
     * Weight: 1
     *
     * @summary Position Information(USER_DATA)
     * @param {PositionInformationRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<PositionInformationResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Position-Information Binance API Documentation}
     */
    public async positionInformation(
        requestParameters: PositionInformationRequest = {}
    ): Promise<RestApiResponse<PositionInformationResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.positionInformation(
            requestParameters?.marginAsset,
            requestParameters?.pair,
            requestParameters?.recvWindow
        );
        return sendRequest<PositionInformationResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Query Current Open Order
     *
     * Either`orderId` or `origClientOrderId` must be sent
     * If the queried order has been filled or cancelled, the error message "Order does not exist" will be returned.
     *
     * Weight: 1
     *
     * @summary Query Current Open Order(USER_DATA)
     * @param {QueryCurrentOpenOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryCurrentOpenOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Query-Current-Open-Order Binance API Documentation}
     */
    public async queryCurrentOpenOrder(
        requestParameters: QueryCurrentOpenOrderRequest
    ): Promise<RestApiResponse<QueryCurrentOpenOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryCurrentOpenOrder(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryCurrentOpenOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * Check an order's status.
     *
     * These orders will not be found:
     * order status is CANCELED or EXPIRED AND order has NO filled trade AND created time + 3 days < current time
     * order create time + 90 days < current time
     *
     *
     * Either `orderId` or `origClientOrderId` must be sent.
     *
     * Weight: 1
     *
     * @summary Query Order (USER_DATA)
     * @param {QueryOrderRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryOrderResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Query-Order Binance API Documentation}
     */
    public async queryOrder(
        requestParameters: QueryOrderRequest
    ): Promise<RestApiResponse<QueryOrderResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryOrder(
            requestParameters?.symbol,
            requestParameters?.orderId,
            requestParameters?.origClientOrderId,
            requestParameters?.recvWindow
        );
        return sendRequest<QueryOrderResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }

    /**
     * User's Force Orders
     *
     * If "autoCloseType" is not sent, orders with both of the types will be returned
     * If "startTime" is not sent, data within 200 days before "endTime" can be queried
     *
     * Weight: 20 with symbol, 50 without symbol
     *
     * @summary User\'s Force Orders(USER_DATA)
     * @param {UsersForceOrdersRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<UsersForceOrdersResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof TradeApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Users-Force-Orders Binance API Documentation}
     */
    public async usersForceOrders(
        requestParameters: UsersForceOrdersRequest = {}
    ): Promise<RestApiResponse<UsersForceOrdersResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.usersForceOrders(
            requestParameters?.symbol,
            requestParameters?.autoCloseType,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit,
            requestParameters?.recvWindow
        );
        return sendRequest<UsersForceOrdersResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: true }
        );
    }
}

export const ChangeMarginTypeMarginTypeEnum = {
    ISOLATED: 'ISOLATED',
    CROSSED: 'CROSSED',
} as const;
export type ChangeMarginTypeMarginTypeEnum =
    (typeof ChangeMarginTypeMarginTypeEnum)[keyof typeof ChangeMarginTypeMarginTypeEnum];

export const ModifyIsolatedPositionMarginTypeEnum = {
    LIMIT: 'LIMIT',
    MARKET: 'MARKET',
    STOP: 'STOP',
    STOP_MARKET: 'STOP_MARKET',
    TAKE_PROFIT: 'TAKE_PROFIT',
    TAKE_PROFIT_MARKET: 'TAKE_PROFIT_MARKET',
    TRAILING_STOP_MARKET: 'TRAILING_STOP_MARKET',
} as const;
export type ModifyIsolatedPositionMarginTypeEnum =
    (typeof ModifyIsolatedPositionMarginTypeEnum)[keyof typeof ModifyIsolatedPositionMarginTypeEnum];

export const ModifyIsolatedPositionMarginPositionSideEnum = {
    BOTH: 'BOTH',
    LONG: 'LONG',
    SHORT: 'SHORT',
} as const;
export type ModifyIsolatedPositionMarginPositionSideEnum =
    (typeof ModifyIsolatedPositionMarginPositionSideEnum)[keyof typeof ModifyIsolatedPositionMarginPositionSideEnum];

export const ModifyOrderSideEnum = {
    BUY: 'BUY',
    SELL: 'SELL',
} as const;
export type ModifyOrderSideEnum = (typeof ModifyOrderSideEnum)[keyof typeof ModifyOrderSideEnum];

export const ModifyOrderPriceMatchEnum = {
    NONE: 'NONE',
    OPPONENT: 'OPPONENT',
    OPPONENT_5: 'OPPONENT_5',
    OPPONENT_10: 'OPPONENT_10',
    OPPONENT_20: 'OPPONENT_20',
    QUEUE: 'QUEUE',
    QUEUE_5: 'QUEUE_5',
    QUEUE_10: 'QUEUE_10',
    QUEUE_20: 'QUEUE_20',
} as const;
export type ModifyOrderPriceMatchEnum =
    (typeof ModifyOrderPriceMatchEnum)[keyof typeof ModifyOrderPriceMatchEnum];

export const NewOrderSideEnum = {
    BUY: 'BUY',
    SELL: 'SELL',
} as const;
export type NewOrderSideEnum = (typeof NewOrderSideEnum)[keyof typeof NewOrderSideEnum];

export const NewOrderTypeEnum = {
    LIMIT: 'LIMIT',
    MARKET: 'MARKET',
    STOP: 'STOP',
    STOP_MARKET: 'STOP_MARKET',
    TAKE_PROFIT: 'TAKE_PROFIT',
    TAKE_PROFIT_MARKET: 'TAKE_PROFIT_MARKET',
    TRAILING_STOP_MARKET: 'TRAILING_STOP_MARKET',
} as const;
export type NewOrderTypeEnum = (typeof NewOrderTypeEnum)[keyof typeof NewOrderTypeEnum];

export const NewOrderPositionSideEnum = {
    BOTH: 'BOTH',
    LONG: 'LONG',
    SHORT: 'SHORT',
} as const;
export type NewOrderPositionSideEnum =
    (typeof NewOrderPositionSideEnum)[keyof typeof NewOrderPositionSideEnum];

export const NewOrderTimeInForceEnum = {
    GTC: 'GTC',
    IOC: 'IOC',
    FOK: 'FOK',
    GTX: 'GTX',
} as const;
export type NewOrderTimeInForceEnum =
    (typeof NewOrderTimeInForceEnum)[keyof typeof NewOrderTimeInForceEnum];

export const NewOrderWorkingTypeEnum = {
    MARK_PRICE: 'MARK_PRICE',
    CONTRACT_PRICE: 'CONTRACT_PRICE',
} as const;
export type NewOrderWorkingTypeEnum =
    (typeof NewOrderWorkingTypeEnum)[keyof typeof NewOrderWorkingTypeEnum];

export const NewOrderNewOrderRespTypeEnum = {
    ACK: 'ACK',
    RESULT: 'RESULT',
} as const;
export type NewOrderNewOrderRespTypeEnum =
    (typeof NewOrderNewOrderRespTypeEnum)[keyof typeof NewOrderNewOrderRespTypeEnum];

export const NewOrderPriceMatchEnum = {
    NONE: 'NONE',
    OPPONENT: 'OPPONENT',
    OPPONENT_5: 'OPPONENT_5',
    OPPONENT_10: 'OPPONENT_10',
    OPPONENT_20: 'OPPONENT_20',
    QUEUE: 'QUEUE',
    QUEUE_5: 'QUEUE_5',
    QUEUE_10: 'QUEUE_10',
    QUEUE_20: 'QUEUE_20',
} as const;
export type NewOrderPriceMatchEnum =
    (typeof NewOrderPriceMatchEnum)[keyof typeof NewOrderPriceMatchEnum];

export const NewOrderSelfTradePreventionModeEnum = {
    NONE: 'NONE',
    EXPIRE_TAKER: 'EXPIRE_TAKER',
    EXPIRE_BOTH: 'EXPIRE_BOTH',
    EXPIRE_MAKER: 'EXPIRE_MAKER',
} as const;
export type NewOrderSelfTradePreventionModeEnum =
    (typeof NewOrderSelfTradePreventionModeEnum)[keyof typeof NewOrderSelfTradePreventionModeEnum];

export const UsersForceOrdersAutoCloseTypeEnum = {
    LIQUIDATION: 'LIQUIDATION',
    ADL: 'ADL',
} as const;
export type UsersForceOrdersAutoCloseTypeEnum =
    (typeof UsersForceOrdersAutoCloseTypeEnum)[keyof typeof UsersForceOrdersAutoCloseTypeEnum];
