/**
 * Binance Derivatives Trading COIN Futures REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading COIN Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
    ConfigurationRestAPI,
    TimeUnit,
    RestApiResponse,
    assertParamExists,
    sendRequest,
    type RequestArgs,
} from '@binance/common';
import type {
    BasisResponse,
    CheckServerTimeResponse,
    CompressedAggregateTradesListResponse,
    ContinuousContractKlineCandlestickDataResponse,
    ExchangeInformationResponse,
    GetFundingRateHistoryOfPerpetualFuturesResponse,
    GetFundingRateInfoResponse,
    IndexPriceAndMarkPriceResponse,
    IndexPriceKlineCandlestickDataResponse,
    KlineCandlestickDataResponse,
    LongShortRatioResponse,
    MarkPriceKlineCandlestickDataResponse,
    OldTradesLookupResponse,
    OpenInterestResponse,
    OpenInterestStatisticsResponse,
    OrderBookResponse,
    PremiumIndexKlineDataResponse,
    QueryIndexPriceConstituentsResponse,
    RecentTradesListResponse,
    SymbolOrderBookTickerResponse,
    SymbolPriceTickerResponse,
    TakerBuySellVolumeResponse,
    Ticker24hrPriceChangeStatisticsResponse,
    TopTraderLongShortRatioAccountsResponse,
    TopTraderLongShortRatioPositionsResponse,
} from '../types';

/**
 * MarketDataApi - axios parameter creator
 */
const MarketDataApiAxiosParamCreator = function (configuration: ConfigurationRestAPI) {
    return {
        /**
         * Query basis
         *
         * If startTime and endTime are not sent, the most recent data is returned.
         * Only the data of the latest 30 days is available.
         *
         * Weight: 1
         *
         * @summary Basis
         * @param {string} pair BTCUSD
         * @param {BasisContractTypeEnum} contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {BasisPeriodEnum} period "5m","15m","30m","1h","2h","4h","6h","12h","1d"
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [startTime]
         * @param {number} [endTime]
         *
         * @throws {RequiredError}
         */
        basis: async (
            pair: string,
            contractType: BasisContractTypeEnum,
            period: BasisPeriodEnum,
            limit?: number,
            startTime?: number,
            endTime?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('basis', 'pair', pair);
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('basis', 'contractType', contractType);
            // verify required parameter 'period' is not null or undefined
            assertParamExists('basis', 'period', period);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined && contractType !== null) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (period !== undefined && period !== null) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/futures/data/basis',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Test connectivity to the Rest API and get the current server time.
         *
         * Weight: 1
         *
         * @summary Check Server time
         *
         * @throws {RequiredError}
         */
        checkServerTime: async (): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/time',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get compressed, aggregate trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
         *
         * support querying futures trade histories that are not older than one year
         * If both `startTime` and `endTime` are sent, time between `startTime` and `endTime` must be less than 1 hour.
         * If `fromId`, `startTime`, and `endTime` are not sent, the most recent aggregate trades will be returned.
         * Only market trades will be aggregated and returned, which means the insurance fund trades and ADL trades won't be aggregated.
         * Sending both `startTime`/`endTime` and `fromId` might cause response timeout, please send either `fromId` or `startTime`/`endTime`
         *
         * Weight: 20
         *
         * @summary Compressed/Aggregate Trades List
         * @param {string} symbol
         * @param {number} [fromId] ID to get aggregate trades from INCLUSIVE.
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        compressedAggregateTradesList: async (
            symbol: string,
            fromId?: number,
            startTime?: number,
            endTime?: number,
            limit?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('compressedAggregateTradesList', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (fromId !== undefined && fromId !== null) {
                localVarQueryParameter['fromId'] = fromId;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/aggTrades',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Kline/candlestick bars for a specific contract type.
         * Klines are uniquely identified by their open time.
         *
         * Contract type:
         * PERPETUAL
         * CURRENT_QUARTER
         * NEXT_QUARTER
         *
         *
         * 1000 | 10
         * The difference between `startTime` and `endTime` can only be up to 200 days
         * Between `startTime` and `endTime`, the most recent `limit` data from `endTime` will be returned:
         * If `startTime` and `endTime` are not sent, current timestamp will be set as `endTime`, and the most recent data will be returned.
         * If `startTime` is sent only, the timestamp of 200 days after `startTime` will be set as `endTime`(up to the current time)
         * If `endTime` is sent only, the timestamp of 200 days before `endTime` will be set as `startTime`
         *
         * Weight: based on parameter LIMIT
         * LIMIT | weight
         * ---|---
         * [1,100) | 1
         * [100, 500) | 2
         * [500, 1000] | 5
         * > 1000 | 10
         *
         * @summary Continuous Contract Kline/Candlestick Data
         * @param {string} pair BTCUSD
         * @param {ContinuousContractKlineCandlestickDataContractTypeEnum} contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {ContinuousContractKlineCandlestickDataIntervalEnum} interval
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        continuousContractKlineCandlestickData: async (
            pair: string,
            contractType: ContinuousContractKlineCandlestickDataContractTypeEnum,
            interval: ContinuousContractKlineCandlestickDataIntervalEnum,
            startTime?: number,
            endTime?: number,
            limit?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('continuousContractKlineCandlestickData', 'pair', pair);
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists(
                'continuousContractKlineCandlestickData',
                'contractType',
                contractType
            );
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('continuousContractKlineCandlestickData', 'interval', interval);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined && contractType !== null) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (interval !== undefined && interval !== null) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/continuousKlines',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Current exchange trading rules and symbol information
         *
         * Weight: 1
         *
         * @summary Exchange Information
         *
         * @throws {RequiredError}
         */
        exchangeInformation: async (): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/exchangeInfo',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get Funding Rate History of Perpetual Futures
         *
         * empty array will be returned for delivery symbols.
         *
         * Weight: 1
         *
         * @summary Get Funding Rate History of Perpetual Futures
         * @param {string} symbol
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        getFundingRateHistoryOfPerpetualFutures: async (
            symbol: string,
            startTime?: number,
            endTime?: number,
            limit?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getFundingRateHistoryOfPerpetualFutures', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/fundingRate',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
         *
         * Weight: 0
         *
         * @summary Get Funding Rate Info
         *
         * @throws {RequiredError}
         */
        getFundingRateInfo: async (): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/fundingInfo',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query index price and mark price
         *
         * Weight: 10
         *
         * @summary Index Price and Mark Price
         * @param {string} [symbol]
         * @param {string} [pair]
         *
         * @throws {RequiredError}
         */
        indexPriceAndMarkPrice: async (symbol?: string, pair?: string): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/premiumIndex',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
         *
         *
         * 1000 | 10
         * The difference between `startTime` and `endTime` can only be up to 200 days
         * Between `startTime` and `endTime`, the most recent `limit` data from `endTime` will be returned:
         * If `startTime` and `endTime` are not sent, current timestamp will be set as `endTime`, and the most recent data will be returned.
         * If `startTime` is sent only, the timestamp of 200 days after `startTime` will be set as `endTime`(up to the current time)
         * If `endTime` is sent only, the timestamp of 200 days before `endTime` will be set as `startTime`
         *
         * Weight: based on parameter LIMIT
         * LIMIT | weight
         * ---|---
         * [1,100) | 1
         * [100, 500) | 2
         * [500, 1000] | 5
         * > 1000 | 10
         *
         * @summary Index Price Kline/Candlestick Data
         * @param {string} pair BTCUSD
         * @param {IndexPriceKlineCandlestickDataIntervalEnum} interval
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        indexPriceKlineCandlestickData: async (
            pair: string,
            interval: IndexPriceKlineCandlestickDataIntervalEnum,
            startTime?: number,
            endTime?: number,
            limit?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('indexPriceKlineCandlestickData', 'pair', pair);
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('indexPriceKlineCandlestickData', 'interval', interval);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }

            if (interval !== undefined && interval !== null) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/indexPriceKlines',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Kline/candlestick bars for a symbol.
         * Klines are uniquely identified by their open time.
         *
         * 1000 | 10
         * The difference between `startTime` and `endTime` can only be up to 200 days
         * Between `startTime` and `endTime`, the most recent `limit` data from `endTime` will be returned:
         * If `startTime` and `endTime` are not sent, current timestamp will be set as `endTime`, and the most recent data will be returned.
         * If `startTime` is sent only, the timestamp of 200 days after `startTime` will be set as `endTime`(up to the current time)
         * If `endTime` is sent only, the timestamp of 200 days before `endTime` will be set as `startTime`
         *
         * Weight: based on parameter LIMIT
         * LIMIT | weight
         * ---|---
         * [1,100) | 1
         * [100, 500) | 2
         * [500, 1000] | 5
         * > 1000 | 10
         *
         * @summary Kline/Candlestick Data
         * @param {string} symbol
         * @param {KlineCandlestickDataIntervalEnum} interval
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        klineCandlestickData: async (
            symbol: string,
            interval: KlineCandlestickDataIntervalEnum,
            startTime?: number,
            endTime?: number,
            limit?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('klineCandlestickData', 'symbol', symbol);
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('klineCandlestickData', 'interval', interval);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined && interval !== null) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/klines',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query symbol Long/Short Ratio
         *
         * If startTime and endTime are not sent, the most recent data is returned.
         * Only the data of the latest 30 days is available.
         *
         * Weight: 1
         *
         * @summary Long/Short Ratio
         * @param {string} pair BTCUSD
         * @param {LongShortRatioPeriodEnum} period "5m","15m","30m","1h","2h","4h","6h","12h","1d"
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [startTime]
         * @param {number} [endTime]
         *
         * @throws {RequiredError}
         */
        longShortRatio: async (
            pair: string,
            period: LongShortRatioPeriodEnum,
            limit?: number,
            startTime?: number,
            endTime?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('longShortRatio', 'pair', pair);
            // verify required parameter 'period' is not null or undefined
            assertParamExists('longShortRatio', 'period', period);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }

            if (period !== undefined && period !== null) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/futures/data/globalLongShortAccountRatio',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Kline/candlestick bars for the mark price of a symbol.
         * Klines are uniquely identified by their open time.
         *
         *
         * 1000 | 10
         * The difference between `startTime` and `endTime` can only be up to 200 days
         * Between `startTime` and `endTime`, the most recent `limit` data from `endTime` will be returned:
         * If `startTime` and `endTime` are not sent, current timestamp will be set as `endTime`, and the most recent data will be returned.
         * If `startTime` is sent only, the timestamp of 200 days after `startTime` will be set as `endTime`(up to the current time)
         * If `endTime` is sent only, the timestamp of 200 days before `endTime` will be set as `startTime`
         *
         * Weight: based on parameter LIMIT
         * LIMIT | weight
         * ---|---
         * [1,100) | 1
         * [100, 500) | 2
         * [500, 1000] | 5
         * > 1000 | 10
         *
         * @summary Mark Price Kline/Candlestick Data
         * @param {string} symbol
         * @param {MarkPriceKlineCandlestickDataIntervalEnum} interval
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        markPriceKlineCandlestickData: async (
            symbol: string,
            interval: MarkPriceKlineCandlestickDataIntervalEnum,
            startTime?: number,
            endTime?: number,
            limit?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('markPriceKlineCandlestickData', 'symbol', symbol);
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('markPriceKlineCandlestickData', 'interval', interval);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined && interval !== null) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/markPriceKlines',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get older market historical trades.
         *
         * Market trades means trades filled in the order book. Only market trades will be returned, which means the insurance fund trades and ADL trades won't be returned.
         *
         * Weight: 20
         *
         * @summary Old Trades Lookup(MARKET_DATA)
         * @param {string} symbol
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [fromId] ID to get aggregate trades from INCLUSIVE.
         *
         * @throws {RequiredError}
         */
        oldTradesLookup: async (
            symbol: string,
            limit?: number,
            fromId?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('oldTradesLookup', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fromId !== undefined && fromId !== null) {
                localVarQueryParameter['fromId'] = fromId;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/historicalTrades',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get present open interest of a specific symbol.
         *
         * Weight: 1
         *
         * @summary Open Interest
         * @param {string} symbol
         *
         * @throws {RequiredError}
         */
        openInterest: async (symbol: string): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('openInterest', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/openInterest',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query open interest stats
         *
         *
         * If startTime and endTime are not sent, the most recent data is returned.
         * Only the data of the latest 30 days is available.
         *
         * Weight: 1
         *
         * @summary Open Interest Statistics
         * @param {string} pair BTCUSD
         * @param {OpenInterestStatisticsContractTypeEnum} contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {OpenInterestStatisticsPeriodEnum} period "5m","15m","30m","1h","2h","4h","6h","12h","1d"
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [startTime]
         * @param {number} [endTime]
         *
         * @throws {RequiredError}
         */
        openInterestStatistics: async (
            pair: string,
            contractType: OpenInterestStatisticsContractTypeEnum,
            period: OpenInterestStatisticsPeriodEnum,
            limit?: number,
            startTime?: number,
            endTime?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('openInterestStatistics', 'pair', pair);
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('openInterestStatistics', 'contractType', contractType);
            // verify required parameter 'period' is not null or undefined
            assertParamExists('openInterestStatistics', 'period', period);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined && contractType !== null) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (period !== undefined && period !== null) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/futures/data/openInterestHist',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query orderbook on specific symbol
         *
         * Weight: Adjusted based on the limit:
         * Limit | Weight
         * ------------ | ------------
         * 5, 10, 20, 50 | 2
         * 100 | 5
         * 500 | 10
         * 1000 | 20
         *
         * @summary Order Book
         * @param {string} symbol
         * @param {number} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        orderBook: async (symbol: string, limit?: number): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('orderBook', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/depth',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
         *
         *
         * If startTime and endTime are not sent, the most recent klines are returned.
         *
         * Weight: based on parameter LIMIT
         * | LIMIT       | weight |
         * | ----------- | ------ |
         * | [1,100)     | 1      |
         * | [100, 500)  | 2      |
         * | [500, 1000] | 5      |
         * | > 1000      | 10     |
         *
         * @summary Premium index Kline Data
         * @param {string} symbol
         * @param {PremiumIndexKlineDataIntervalEnum} interval
         * @param {number} [startTime]
         * @param {number} [endTime]
         * @param {number} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        premiumIndexKlineData: async (
            symbol: string,
            interval: PremiumIndexKlineDataIntervalEnum,
            startTime?: number,
            endTime?: number,
            limit?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('premiumIndexKlineData', 'symbol', symbol);
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('premiumIndexKlineData', 'interval', interval);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined && interval !== null) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/premiumIndexKlines',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Query index price constituents
         *
         * Weight: 2
         *
         * @summary Query Index Price Constituents
         * @param {string} symbol
         *
         * @throws {RequiredError}
         */
        queryIndexPriceConstituents: async (symbol: string): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('queryIndexPriceConstituents', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/constituents',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Get recent market trades
         *
         * Market trades means trades filled in the order book. Only market trades will be returned, which means the insurance fund trades and ADL trades won't be returned.
         *
         * Weight: 5
         *
         * @summary Recent Trades List
         * @param {string} symbol
         * @param {number} [limit] Default 100; max 1000
         *
         * @throws {RequiredError}
         */
        recentTradesList: async (symbol: string, limit?: number): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('recentTradesList', 'symbol', symbol);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/trades',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Best price/qty on the order book for a symbol or symbols.
         *
         * Symbol and pair cannot be sent together
         * If a pair is sent,tickers for all symbols of the pair will be returned
         * If either a pair or symbol is sent, tickers for all symbols of all pairs will be returned
         *
         * Weight: 2 for a single symbol, 5 when the symbol parameter is omitted
         *
         * @summary Symbol Order Book Ticker
         * @param {string} [symbol]
         * @param {string} [pair]
         *
         * @throws {RequiredError}
         */
        symbolOrderBookTicker: async (symbol?: string, pair?: string): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/ticker/bookTicker',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Latest price for a symbol or symbols.
         *
         * Symbol and pair cannot be sent together
         * If a pair is sent,tickers for all symbols of the pair will be returned
         * If either a pair or symbol is sent, tickers for all symbols of all pairs will be returned
         *
         * Weight: 1 for a single symbol, 2 when the symbol parameter is omitted
         *
         * @summary Symbol Price Ticker
         * @param {string} [symbol]
         * @param {string} [pair]
         *
         * @throws {RequiredError}
         */
        symbolPriceTicker: async (symbol?: string, pair?: string): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/ticker/price',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Taker Buy Volume: the total volume of buy orders filled by takers within the period.
         * Taker Sell Volume: the total volume of sell orders filled by takers within the period.
         *
         * If startTime and endTime are not sent, the most recent data is returned.
         * Only the data of the latest 30 days is available.
         *
         * Weight: 1
         *
         * @summary Taker Buy/Sell Volume
         * @param {string} pair BTCUSD
         * @param {TakerBuySellVolumeContractTypeEnum} contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
         * @param {TakerBuySellVolumePeriodEnum} period "5m","15m","30m","1h","2h","4h","6h","12h","1d"
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [startTime]
         * @param {number} [endTime]
         *
         * @throws {RequiredError}
         */
        takerBuySellVolume: async (
            pair: string,
            contractType: TakerBuySellVolumeContractTypeEnum,
            period: TakerBuySellVolumePeriodEnum,
            limit?: number,
            startTime?: number,
            endTime?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('takerBuySellVolume', 'pair', pair);
            // verify required parameter 'contractType' is not null or undefined
            assertParamExists('takerBuySellVolume', 'contractType', contractType);
            // verify required parameter 'period' is not null or undefined
            assertParamExists('takerBuySellVolume', 'period', period);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }

            if (contractType !== undefined && contractType !== null) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (period !== undefined && period !== null) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/futures/data/takerBuySellVol',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * Test connectivity to the Rest API.
         *
         * Weight: 1
         *
         * @summary Test Connectivity
         *
         * @throws {RequiredError}
         */
        testConnectivity: async (): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/ping',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * 24 hour rolling window price change statistics.
         *
         * Symbol and pair cannot be sent together
         * If a pair is sent,tickers for all symbols of the pair will be returned
         * If either a pair or symbol is sent, tickers for all symbols of all pairs will be returned
         *
         * Weight: 1 for a single symbol, 40 when the symbol parameter is omitted
         * Careful when accessing this with no symbol.
         *
         * @summary 24hr Ticker Price Change Statistics
         * @param {string} [symbol]
         * @param {string} [pair]
         *
         * @throws {RequiredError}
         */
        ticker24hrPriceChangeStatistics: async (
            symbol?: string,
            pair?: string
        ): Promise<RequestArgs> => {
            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/dapi/v1/ticker/24hr',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only.
         * Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions
         * Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions
         * Long/Short Ratio (Accounts) = Long Account % / Short Account %
         *
         * If startTime and endTime are not sent, the most recent data is returned.
         * Only the data of the latest 30 days is available.
         *
         * Weight: 1
         *
         * @summary Top Trader Long/Short Ratio (Accounts)
         * @param {string} symbol
         * @param {TopTraderLongShortRatioAccountsPeriodEnum} period "5m","15m","30m","1h","2h","4h","6h","12h","1d"
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [startTime]
         * @param {number} [endTime]
         *
         * @throws {RequiredError}
         */
        topTraderLongShortRatioAccounts: async (
            symbol: string,
            period: TopTraderLongShortRatioAccountsPeriodEnum,
            limit?: number,
            startTime?: number,
            endTime?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('topTraderLongShortRatioAccounts', 'symbol', symbol);
            // verify required parameter 'period' is not null or undefined
            assertParamExists('topTraderLongShortRatioAccounts', 'period', period);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (symbol !== undefined && symbol !== null) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (period !== undefined && period !== null) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/futures/data/topLongShortAccountRatio',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
        /**
         * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance.
         * Long Position % = Long positions of top traders / Total open positions of top traders
         * Short Position % = Short positions of top traders / Total open positions of top traders
         * Long/Short Ratio (Positions) = Long Position % / Short Position %
         *
         * If startTime and endTime are not sent, the most recent data is returned.
         * Only the data of the latest 30 days is available.
         *
         * Weight: 1
         *
         * @summary Top Trader Long/Short Ratio (Positions)
         * @param {string} pair BTCUSD
         * @param {TopTraderLongShortRatioPositionsPeriodEnum} period "5m","15m","30m","1h","2h","4h","6h","12h","1d"
         * @param {number} [limit] Default 100; max 1000
         * @param {number} [startTime]
         * @param {number} [endTime]
         *
         * @throws {RequiredError}
         */
        topTraderLongShortRatioPositions: async (
            pair: string,
            period: TopTraderLongShortRatioPositionsPeriodEnum,
            limit?: number,
            startTime?: number,
            endTime?: number
        ): Promise<RequestArgs> => {
            // verify required parameter 'pair' is not null or undefined
            assertParamExists('topTraderLongShortRatioPositions', 'pair', pair);
            // verify required parameter 'period' is not null or undefined
            assertParamExists('topTraderLongShortRatioPositions', 'period', period);

            const localVarQueryParameter: Record<string, unknown> = {};

            if (pair !== undefined && pair !== null) {
                localVarQueryParameter['pair'] = pair;
            }

            if (period !== undefined && period !== null) {
                localVarQueryParameter['period'] = period;
            }

            if (limit !== undefined && limit !== null) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTime !== undefined && startTime !== null) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined && endTime !== null) {
                localVarQueryParameter['endTime'] = endTime;
            }

            let _timeUnit: TimeUnit | undefined;
            if ('timeUnit' in configuration) _timeUnit = configuration.timeUnit as TimeUnit;

            return {
                endpoint: '/futures/data/topLongShortPositionRatio',
                method: 'GET',
                params: localVarQueryParameter,
                timeUnit: _timeUnit,
            };
        },
    };
};

/**
 * MarketDataApi - interface
 * @interface MarketDataApi
 */
export interface MarketDataApiInterface {
    /**
     * Query basis
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     *
     * Weight: 1
     *
     * @summary Basis
     * @param {BasisRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    basis(requestParameters: BasisRequest): Promise<RestApiResponse<BasisResponse>>;
    /**
     * Test connectivity to the Rest API and get the current server time.
     *
     * Weight: 1
     *
     * @summary Check Server time
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    checkServerTime(): Promise<RestApiResponse<CheckServerTimeResponse>>;
    /**
     * Get compressed, aggregate trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
     *
     * support querying futures trade histories that are not older than one year
     * If both `startTime` and `endTime` are sent, time between `startTime` and `endTime` must be less than 1 hour.
     * If `fromId`, `startTime`, and `endTime` are not sent, the most recent aggregate trades will be returned.
     * Only market trades will be aggregated and returned, which means the insurance fund trades and ADL trades won't be aggregated.
     * Sending both `startTime`/`endTime` and `fromId` might cause response timeout, please send either `fromId` or `startTime`/`endTime`
     *
     * Weight: 20
     *
     * @summary Compressed/Aggregate Trades List
     * @param {CompressedAggregateTradesListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    compressedAggregateTradesList(
        requestParameters: CompressedAggregateTradesListRequest
    ): Promise<RestApiResponse<CompressedAggregateTradesListResponse>>;
    /**
     * Kline/candlestick bars for a specific contract type.
     * Klines are uniquely identified by their open time.
     *
     * Contract type:
     * PERPETUAL
     * CURRENT_QUARTER
     * NEXT_QUARTER
     *
     *
     * 1000 | 10
     * The difference between `startTime` and `endTime` can only be up to 200 days
     * Between `startTime` and `endTime`, the most recent `limit` data from `endTime` will be returned:
     * If `startTime` and `endTime` are not sent, current timestamp will be set as `endTime`, and the most recent data will be returned.
     * If `startTime` is sent only, the timestamp of 200 days after `startTime` will be set as `endTime`(up to the current time)
     * If `endTime` is sent only, the timestamp of 200 days before `endTime` will be set as `startTime`
     *
     * Weight: based on parameter LIMIT
     * LIMIT | weight
     * ---|---
     * [1,100) | 1
     * [100, 500) | 2
     * [500, 1000] | 5
     * > 1000 | 10
     *
     * @summary Continuous Contract Kline/Candlestick Data
     * @param {ContinuousContractKlineCandlestickDataRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    continuousContractKlineCandlestickData(
        requestParameters: ContinuousContractKlineCandlestickDataRequest
    ): Promise<RestApiResponse<ContinuousContractKlineCandlestickDataResponse>>;
    /**
     * Current exchange trading rules and symbol information
     *
     * Weight: 1
     *
     * @summary Exchange Information
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    exchangeInformation(): Promise<RestApiResponse<ExchangeInformationResponse>>;
    /**
     * Get Funding Rate History of Perpetual Futures
     *
     * empty array will be returned for delivery symbols.
     *
     * Weight: 1
     *
     * @summary Get Funding Rate History of Perpetual Futures
     * @param {GetFundingRateHistoryOfPerpetualFuturesRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    getFundingRateHistoryOfPerpetualFutures(
        requestParameters: GetFundingRateHistoryOfPerpetualFuturesRequest
    ): Promise<RestApiResponse<GetFundingRateHistoryOfPerpetualFuturesResponse>>;
    /**
     * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
     *
     * Weight: 0
     *
     * @summary Get Funding Rate Info
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    getFundingRateInfo(): Promise<RestApiResponse<GetFundingRateInfoResponse>>;
    /**
     * Query index price and mark price
     *
     * Weight: 10
     *
     * @summary Index Price and Mark Price
     * @param {IndexPriceAndMarkPriceRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    indexPriceAndMarkPrice(
        requestParameters?: IndexPriceAndMarkPriceRequest
    ): Promise<RestApiResponse<IndexPriceAndMarkPriceResponse>>;
    /**
     * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
     *
     *
     * 1000 | 10
     * The difference between `startTime` and `endTime` can only be up to 200 days
     * Between `startTime` and `endTime`, the most recent `limit` data from `endTime` will be returned:
     * If `startTime` and `endTime` are not sent, current timestamp will be set as `endTime`, and the most recent data will be returned.
     * If `startTime` is sent only, the timestamp of 200 days after `startTime` will be set as `endTime`(up to the current time)
     * If `endTime` is sent only, the timestamp of 200 days before `endTime` will be set as `startTime`
     *
     * Weight: based on parameter LIMIT
     * LIMIT | weight
     * ---|---
     * [1,100) | 1
     * [100, 500) | 2
     * [500, 1000] | 5
     * > 1000 | 10
     *
     * @summary Index Price Kline/Candlestick Data
     * @param {IndexPriceKlineCandlestickDataRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    indexPriceKlineCandlestickData(
        requestParameters: IndexPriceKlineCandlestickDataRequest
    ): Promise<RestApiResponse<IndexPriceKlineCandlestickDataResponse>>;
    /**
     * Kline/candlestick bars for a symbol.
     * Klines are uniquely identified by their open time.
     *
     * 1000 | 10
     * The difference between `startTime` and `endTime` can only be up to 200 days
     * Between `startTime` and `endTime`, the most recent `limit` data from `endTime` will be returned:
     * If `startTime` and `endTime` are not sent, current timestamp will be set as `endTime`, and the most recent data will be returned.
     * If `startTime` is sent only, the timestamp of 200 days after `startTime` will be set as `endTime`(up to the current time)
     * If `endTime` is sent only, the timestamp of 200 days before `endTime` will be set as `startTime`
     *
     * Weight: based on parameter LIMIT
     * LIMIT | weight
     * ---|---
     * [1,100) | 1
     * [100, 500) | 2
     * [500, 1000] | 5
     * > 1000 | 10
     *
     * @summary Kline/Candlestick Data
     * @param {KlineCandlestickDataRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    klineCandlestickData(
        requestParameters: KlineCandlestickDataRequest
    ): Promise<RestApiResponse<KlineCandlestickDataResponse>>;
    /**
     * Query symbol Long/Short Ratio
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     *
     * Weight: 1
     *
     * @summary Long/Short Ratio
     * @param {LongShortRatioRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    longShortRatio(
        requestParameters: LongShortRatioRequest
    ): Promise<RestApiResponse<LongShortRatioResponse>>;
    /**
     * Kline/candlestick bars for the mark price of a symbol.
     * Klines are uniquely identified by their open time.
     *
     *
     * 1000 | 10
     * The difference between `startTime` and `endTime` can only be up to 200 days
     * Between `startTime` and `endTime`, the most recent `limit` data from `endTime` will be returned:
     * If `startTime` and `endTime` are not sent, current timestamp will be set as `endTime`, and the most recent data will be returned.
     * If `startTime` is sent only, the timestamp of 200 days after `startTime` will be set as `endTime`(up to the current time)
     * If `endTime` is sent only, the timestamp of 200 days before `endTime` will be set as `startTime`
     *
     * Weight: based on parameter LIMIT
     * LIMIT | weight
     * ---|---
     * [1,100) | 1
     * [100, 500) | 2
     * [500, 1000] | 5
     * > 1000 | 10
     *
     * @summary Mark Price Kline/Candlestick Data
     * @param {MarkPriceKlineCandlestickDataRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    markPriceKlineCandlestickData(
        requestParameters: MarkPriceKlineCandlestickDataRequest
    ): Promise<RestApiResponse<MarkPriceKlineCandlestickDataResponse>>;
    /**
     * Get older market historical trades.
     *
     * Market trades means trades filled in the order book. Only market trades will be returned, which means the insurance fund trades and ADL trades won't be returned.
     *
     * Weight: 20
     *
     * @summary Old Trades Lookup(MARKET_DATA)
     * @param {OldTradesLookupRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    oldTradesLookup(
        requestParameters: OldTradesLookupRequest
    ): Promise<RestApiResponse<OldTradesLookupResponse>>;
    /**
     * Get present open interest of a specific symbol.
     *
     * Weight: 1
     *
     * @summary Open Interest
     * @param {OpenInterestRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    openInterest(
        requestParameters: OpenInterestRequest
    ): Promise<RestApiResponse<OpenInterestResponse>>;
    /**
     * Query open interest stats
     *
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     *
     * Weight: 1
     *
     * @summary Open Interest Statistics
     * @param {OpenInterestStatisticsRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    openInterestStatistics(
        requestParameters: OpenInterestStatisticsRequest
    ): Promise<RestApiResponse<OpenInterestStatisticsResponse>>;
    /**
     * Query orderbook on specific symbol
     *
     * Weight: Adjusted based on the limit:
     * Limit | Weight
     * ------------ | ------------
     * 5, 10, 20, 50 | 2
     * 100 | 5
     * 500 | 10
     * 1000 | 20
     *
     * @summary Order Book
     * @param {OrderBookRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    orderBook(requestParameters: OrderBookRequest): Promise<RestApiResponse<OrderBookResponse>>;
    /**
     * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
     *
     *
     * If startTime and endTime are not sent, the most recent klines are returned.
     *
     * Weight: based on parameter LIMIT
     * | LIMIT       | weight |
     * | ----------- | ------ |
     * | [1,100)     | 1      |
     * | [100, 500)  | 2      |
     * | [500, 1000] | 5      |
     * | > 1000      | 10     |
     *
     * @summary Premium index Kline Data
     * @param {PremiumIndexKlineDataRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    premiumIndexKlineData(
        requestParameters: PremiumIndexKlineDataRequest
    ): Promise<RestApiResponse<PremiumIndexKlineDataResponse>>;
    /**
     * Query index price constituents
     *
     * Weight: 2
     *
     * @summary Query Index Price Constituents
     * @param {QueryIndexPriceConstituentsRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    queryIndexPriceConstituents(
        requestParameters: QueryIndexPriceConstituentsRequest
    ): Promise<RestApiResponse<QueryIndexPriceConstituentsResponse>>;
    /**
     * Get recent market trades
     *
     * Market trades means trades filled in the order book. Only market trades will be returned, which means the insurance fund trades and ADL trades won't be returned.
     *
     * Weight: 5
     *
     * @summary Recent Trades List
     * @param {RecentTradesListRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    recentTradesList(
        requestParameters: RecentTradesListRequest
    ): Promise<RestApiResponse<RecentTradesListResponse>>;
    /**
     * Best price/qty on the order book for a symbol or symbols.
     *
     * Symbol and pair cannot be sent together
     * If a pair is sent,tickers for all symbols of the pair will be returned
     * If either a pair or symbol is sent, tickers for all symbols of all pairs will be returned
     *
     * Weight: 2 for a single symbol, 5 when the symbol parameter is omitted
     *
     * @summary Symbol Order Book Ticker
     * @param {SymbolOrderBookTickerRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    symbolOrderBookTicker(
        requestParameters?: SymbolOrderBookTickerRequest
    ): Promise<RestApiResponse<SymbolOrderBookTickerResponse>>;
    /**
     * Latest price for a symbol or symbols.
     *
     * Symbol and pair cannot be sent together
     * If a pair is sent,tickers for all symbols of the pair will be returned
     * If either a pair or symbol is sent, tickers for all symbols of all pairs will be returned
     *
     * Weight: 1 for a single symbol, 2 when the symbol parameter is omitted
     *
     * @summary Symbol Price Ticker
     * @param {SymbolPriceTickerRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    symbolPriceTicker(
        requestParameters?: SymbolPriceTickerRequest
    ): Promise<RestApiResponse<SymbolPriceTickerResponse>>;
    /**
     * Taker Buy Volume: the total volume of buy orders filled by takers within the period.
     * Taker Sell Volume: the total volume of sell orders filled by takers within the period.
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     *
     * Weight: 1
     *
     * @summary Taker Buy/Sell Volume
     * @param {TakerBuySellVolumeRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    takerBuySellVolume(
        requestParameters: TakerBuySellVolumeRequest
    ): Promise<RestApiResponse<TakerBuySellVolumeResponse>>;
    /**
     * Test connectivity to the Rest API.
     *
     * Weight: 1
     *
     * @summary Test Connectivity
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    testConnectivity(): Promise<RestApiResponse<void>>;
    /**
     * 24 hour rolling window price change statistics.
     *
     * Symbol and pair cannot be sent together
     * If a pair is sent,tickers for all symbols of the pair will be returned
     * If either a pair or symbol is sent, tickers for all symbols of all pairs will be returned
     *
     * Weight: 1 for a single symbol, 40 when the symbol parameter is omitted
     * Careful when accessing this with no symbol.
     *
     * @summary 24hr Ticker Price Change Statistics
     * @param {Ticker24hrPriceChangeStatisticsRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    ticker24hrPriceChangeStatistics(
        requestParameters?: Ticker24hrPriceChangeStatisticsRequest
    ): Promise<RestApiResponse<Ticker24hrPriceChangeStatisticsResponse>>;
    /**
     * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only.
     * Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions
     * Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions
     * Long/Short Ratio (Accounts) = Long Account % / Short Account %
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     *
     * Weight: 1
     *
     * @summary Top Trader Long/Short Ratio (Accounts)
     * @param {TopTraderLongShortRatioAccountsRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    topTraderLongShortRatioAccounts(
        requestParameters: TopTraderLongShortRatioAccountsRequest
    ): Promise<RestApiResponse<TopTraderLongShortRatioAccountsResponse>>;
    /**
     * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance.
     * Long Position % = Long positions of top traders / Total open positions of top traders
     * Short Position % = Short positions of top traders / Total open positions of top traders
     * Long/Short Ratio (Positions) = Long Position % / Short Position %
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     *
     * Weight: 1
     *
     * @summary Top Trader Long/Short Ratio (Positions)
     * @param {TopTraderLongShortRatioPositionsRequest} requestParameters Request parameters.
     *
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApiInterface
     */
    topTraderLongShortRatioPositions(
        requestParameters: TopTraderLongShortRatioPositionsRequest
    ): Promise<RestApiResponse<TopTraderLongShortRatioPositionsResponse>>;
}

/**
 * Request parameters for basis operation in MarketDataApi.
 * @interface BasisRequest
 */
export interface BasisRequest {
    /**
     * BTCUSD
     * @type {string}
     * @memberof MarketDataApiBasis
     */
    readonly pair: string;

    /**
     * ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
     * @type {'PERPETUAL' | 'CURRENT_QUARTER' | 'NEXT_QUARTER' | 'CURRENT_QUARTER_DELIVERING' | 'NEXT_QUARTER_DELIVERING' | 'PERPETUAL_DELIVERING'}
     * @memberof MarketDataApiBasis
     */
    readonly contractType: BasisContractTypeEnum;

    /**
     * "5m","15m","30m","1h","2h","4h","6h","12h","1d"
     * @type {'5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '12h' | '1d'}
     * @memberof MarketDataApiBasis
     */
    readonly period: BasisPeriodEnum;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiBasis
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiBasis
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiBasis
     */
    readonly endTime?: number;
}

/**
 * Request parameters for compressedAggregateTradesList operation in MarketDataApi.
 * @interface CompressedAggregateTradesListRequest
 */
export interface CompressedAggregateTradesListRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiCompressedAggregateTradesList
     */
    readonly symbol: string;

    /**
     * ID to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof MarketDataApiCompressedAggregateTradesList
     */
    readonly fromId?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiCompressedAggregateTradesList
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiCompressedAggregateTradesList
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiCompressedAggregateTradesList
     */
    readonly limit?: number;
}

/**
 * Request parameters for continuousContractKlineCandlestickData operation in MarketDataApi.
 * @interface ContinuousContractKlineCandlestickDataRequest
 */
export interface ContinuousContractKlineCandlestickDataRequest {
    /**
     * BTCUSD
     * @type {string}
     * @memberof MarketDataApiContinuousContractKlineCandlestickData
     */
    readonly pair: string;

    /**
     * ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
     * @type {'PERPETUAL' | 'CURRENT_QUARTER' | 'NEXT_QUARTER' | 'CURRENT_QUARTER_DELIVERING' | 'NEXT_QUARTER_DELIVERING' | 'PERPETUAL_DELIVERING'}
     * @memberof MarketDataApiContinuousContractKlineCandlestickData
     */
    readonly contractType: ContinuousContractKlineCandlestickDataContractTypeEnum;

    /**
     *
     * @type {'1m' | '3m' | '5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '8h' | '12h' | '1d' | '3d' | '1w' | '1M'}
     * @memberof MarketDataApiContinuousContractKlineCandlestickData
     */
    readonly interval: ContinuousContractKlineCandlestickDataIntervalEnum;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiContinuousContractKlineCandlestickData
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiContinuousContractKlineCandlestickData
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiContinuousContractKlineCandlestickData
     */
    readonly limit?: number;
}

/**
 * Request parameters for getFundingRateHistoryOfPerpetualFutures operation in MarketDataApi.
 * @interface GetFundingRateHistoryOfPerpetualFuturesRequest
 */
export interface GetFundingRateHistoryOfPerpetualFuturesRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiGetFundingRateHistoryOfPerpetualFutures
     */
    readonly symbol: string;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiGetFundingRateHistoryOfPerpetualFutures
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiGetFundingRateHistoryOfPerpetualFutures
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiGetFundingRateHistoryOfPerpetualFutures
     */
    readonly limit?: number;
}

/**
 * Request parameters for indexPriceAndMarkPrice operation in MarketDataApi.
 * @interface IndexPriceAndMarkPriceRequest
 */
export interface IndexPriceAndMarkPriceRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiIndexPriceAndMarkPrice
     */
    readonly symbol?: string;

    /**
     *
     * @type {string}
     * @memberof MarketDataApiIndexPriceAndMarkPrice
     */
    readonly pair?: string;
}

/**
 * Request parameters for indexPriceKlineCandlestickData operation in MarketDataApi.
 * @interface IndexPriceKlineCandlestickDataRequest
 */
export interface IndexPriceKlineCandlestickDataRequest {
    /**
     * BTCUSD
     * @type {string}
     * @memberof MarketDataApiIndexPriceKlineCandlestickData
     */
    readonly pair: string;

    /**
     *
     * @type {'1m' | '3m' | '5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '8h' | '12h' | '1d' | '3d' | '1w' | '1M'}
     * @memberof MarketDataApiIndexPriceKlineCandlestickData
     */
    readonly interval: IndexPriceKlineCandlestickDataIntervalEnum;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiIndexPriceKlineCandlestickData
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiIndexPriceKlineCandlestickData
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiIndexPriceKlineCandlestickData
     */
    readonly limit?: number;
}

/**
 * Request parameters for klineCandlestickData operation in MarketDataApi.
 * @interface KlineCandlestickDataRequest
 */
export interface KlineCandlestickDataRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiKlineCandlestickData
     */
    readonly symbol: string;

    /**
     *
     * @type {'1m' | '3m' | '5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '8h' | '12h' | '1d' | '3d' | '1w' | '1M'}
     * @memberof MarketDataApiKlineCandlestickData
     */
    readonly interval: KlineCandlestickDataIntervalEnum;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiKlineCandlestickData
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiKlineCandlestickData
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiKlineCandlestickData
     */
    readonly limit?: number;
}

/**
 * Request parameters for longShortRatio operation in MarketDataApi.
 * @interface LongShortRatioRequest
 */
export interface LongShortRatioRequest {
    /**
     * BTCUSD
     * @type {string}
     * @memberof MarketDataApiLongShortRatio
     */
    readonly pair: string;

    /**
     * "5m","15m","30m","1h","2h","4h","6h","12h","1d"
     * @type {'5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '12h' | '1d'}
     * @memberof MarketDataApiLongShortRatio
     */
    readonly period: LongShortRatioPeriodEnum;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiLongShortRatio
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiLongShortRatio
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiLongShortRatio
     */
    readonly endTime?: number;
}

/**
 * Request parameters for markPriceKlineCandlestickData operation in MarketDataApi.
 * @interface MarkPriceKlineCandlestickDataRequest
 */
export interface MarkPriceKlineCandlestickDataRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiMarkPriceKlineCandlestickData
     */
    readonly symbol: string;

    /**
     *
     * @type {'1m' | '3m' | '5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '8h' | '12h' | '1d' | '3d' | '1w' | '1M'}
     * @memberof MarketDataApiMarkPriceKlineCandlestickData
     */
    readonly interval: MarkPriceKlineCandlestickDataIntervalEnum;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiMarkPriceKlineCandlestickData
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiMarkPriceKlineCandlestickData
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiMarkPriceKlineCandlestickData
     */
    readonly limit?: number;
}

/**
 * Request parameters for oldTradesLookup operation in MarketDataApi.
 * @interface OldTradesLookupRequest
 */
export interface OldTradesLookupRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiOldTradesLookup
     */
    readonly symbol: string;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiOldTradesLookup
     */
    readonly limit?: number;

    /**
     * ID to get aggregate trades from INCLUSIVE.
     * @type {number}
     * @memberof MarketDataApiOldTradesLookup
     */
    readonly fromId?: number;
}

/**
 * Request parameters for openInterest operation in MarketDataApi.
 * @interface OpenInterestRequest
 */
export interface OpenInterestRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiOpenInterest
     */
    readonly symbol: string;
}

/**
 * Request parameters for openInterestStatistics operation in MarketDataApi.
 * @interface OpenInterestStatisticsRequest
 */
export interface OpenInterestStatisticsRequest {
    /**
     * BTCUSD
     * @type {string}
     * @memberof MarketDataApiOpenInterestStatistics
     */
    readonly pair: string;

    /**
     * ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
     * @type {'PERPETUAL' | 'CURRENT_QUARTER' | 'NEXT_QUARTER' | 'CURRENT_QUARTER_DELIVERING' | 'NEXT_QUARTER_DELIVERING' | 'PERPETUAL_DELIVERING'}
     * @memberof MarketDataApiOpenInterestStatistics
     */
    readonly contractType: OpenInterestStatisticsContractTypeEnum;

    /**
     * "5m","15m","30m","1h","2h","4h","6h","12h","1d"
     * @type {'5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '12h' | '1d'}
     * @memberof MarketDataApiOpenInterestStatistics
     */
    readonly period: OpenInterestStatisticsPeriodEnum;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiOpenInterestStatistics
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiOpenInterestStatistics
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiOpenInterestStatistics
     */
    readonly endTime?: number;
}

/**
 * Request parameters for orderBook operation in MarketDataApi.
 * @interface OrderBookRequest
 */
export interface OrderBookRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiOrderBook
     */
    readonly symbol: string;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiOrderBook
     */
    readonly limit?: number;
}

/**
 * Request parameters for premiumIndexKlineData operation in MarketDataApi.
 * @interface PremiumIndexKlineDataRequest
 */
export interface PremiumIndexKlineDataRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiPremiumIndexKlineData
     */
    readonly symbol: string;

    /**
     *
     * @type {'1m' | '3m' | '5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '8h' | '12h' | '1d' | '3d' | '1w' | '1M'}
     * @memberof MarketDataApiPremiumIndexKlineData
     */
    readonly interval: PremiumIndexKlineDataIntervalEnum;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiPremiumIndexKlineData
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiPremiumIndexKlineData
     */
    readonly endTime?: number;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiPremiumIndexKlineData
     */
    readonly limit?: number;
}

/**
 * Request parameters for queryIndexPriceConstituents operation in MarketDataApi.
 * @interface QueryIndexPriceConstituentsRequest
 */
export interface QueryIndexPriceConstituentsRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiQueryIndexPriceConstituents
     */
    readonly symbol: string;
}

/**
 * Request parameters for recentTradesList operation in MarketDataApi.
 * @interface RecentTradesListRequest
 */
export interface RecentTradesListRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiRecentTradesList
     */
    readonly symbol: string;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiRecentTradesList
     */
    readonly limit?: number;
}

/**
 * Request parameters for symbolOrderBookTicker operation in MarketDataApi.
 * @interface SymbolOrderBookTickerRequest
 */
export interface SymbolOrderBookTickerRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiSymbolOrderBookTicker
     */
    readonly symbol?: string;

    /**
     *
     * @type {string}
     * @memberof MarketDataApiSymbolOrderBookTicker
     */
    readonly pair?: string;
}

/**
 * Request parameters for symbolPriceTicker operation in MarketDataApi.
 * @interface SymbolPriceTickerRequest
 */
export interface SymbolPriceTickerRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiSymbolPriceTicker
     */
    readonly symbol?: string;

    /**
     *
     * @type {string}
     * @memberof MarketDataApiSymbolPriceTicker
     */
    readonly pair?: string;
}

/**
 * Request parameters for takerBuySellVolume operation in MarketDataApi.
 * @interface TakerBuySellVolumeRequest
 */
export interface TakerBuySellVolumeRequest {
    /**
     * BTCUSD
     * @type {string}
     * @memberof MarketDataApiTakerBuySellVolume
     */
    readonly pair: string;

    /**
     * ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL
     * @type {'PERPETUAL' | 'CURRENT_QUARTER' | 'NEXT_QUARTER' | 'CURRENT_QUARTER_DELIVERING' | 'NEXT_QUARTER_DELIVERING' | 'PERPETUAL_DELIVERING'}
     * @memberof MarketDataApiTakerBuySellVolume
     */
    readonly contractType: TakerBuySellVolumeContractTypeEnum;

    /**
     * "5m","15m","30m","1h","2h","4h","6h","12h","1d"
     * @type {'5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '12h' | '1d'}
     * @memberof MarketDataApiTakerBuySellVolume
     */
    readonly period: TakerBuySellVolumePeriodEnum;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiTakerBuySellVolume
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiTakerBuySellVolume
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiTakerBuySellVolume
     */
    readonly endTime?: number;
}

/**
 * Request parameters for ticker24hrPriceChangeStatistics operation in MarketDataApi.
 * @interface Ticker24hrPriceChangeStatisticsRequest
 */
export interface Ticker24hrPriceChangeStatisticsRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiTicker24hrPriceChangeStatistics
     */
    readonly symbol?: string;

    /**
     *
     * @type {string}
     * @memberof MarketDataApiTicker24hrPriceChangeStatistics
     */
    readonly pair?: string;
}

/**
 * Request parameters for topTraderLongShortRatioAccounts operation in MarketDataApi.
 * @interface TopTraderLongShortRatioAccountsRequest
 */
export interface TopTraderLongShortRatioAccountsRequest {
    /**
     *
     * @type {string}
     * @memberof MarketDataApiTopTraderLongShortRatioAccounts
     */
    readonly symbol: string;

    /**
     * "5m","15m","30m","1h","2h","4h","6h","12h","1d"
     * @type {'5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '12h' | '1d'}
     * @memberof MarketDataApiTopTraderLongShortRatioAccounts
     */
    readonly period: TopTraderLongShortRatioAccountsPeriodEnum;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiTopTraderLongShortRatioAccounts
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiTopTraderLongShortRatioAccounts
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiTopTraderLongShortRatioAccounts
     */
    readonly endTime?: number;
}

/**
 * Request parameters for topTraderLongShortRatioPositions operation in MarketDataApi.
 * @interface TopTraderLongShortRatioPositionsRequest
 */
export interface TopTraderLongShortRatioPositionsRequest {
    /**
     * BTCUSD
     * @type {string}
     * @memberof MarketDataApiTopTraderLongShortRatioPositions
     */
    readonly pair: string;

    /**
     * "5m","15m","30m","1h","2h","4h","6h","12h","1d"
     * @type {'5m' | '15m' | '30m' | '1h' | '2h' | '4h' | '6h' | '12h' | '1d'}
     * @memberof MarketDataApiTopTraderLongShortRatioPositions
     */
    readonly period: TopTraderLongShortRatioPositionsPeriodEnum;

    /**
     * Default 100; max 1000
     * @type {number}
     * @memberof MarketDataApiTopTraderLongShortRatioPositions
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiTopTraderLongShortRatioPositions
     */
    readonly startTime?: number;

    /**
     *
     * @type {number}
     * @memberof MarketDataApiTopTraderLongShortRatioPositions
     */
    readonly endTime?: number;
}

/**
 * MarketDataApi - object-oriented interface
 * @class MarketDataApi
 */
export class MarketDataApi implements MarketDataApiInterface {
    private readonly configuration: ConfigurationRestAPI;
    private localVarAxiosParamCreator;

    constructor(configuration: ConfigurationRestAPI) {
        this.configuration = configuration;
        this.localVarAxiosParamCreator = MarketDataApiAxiosParamCreator(configuration);
    }

    /**
     * Query basis
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     *
     * Weight: 1
     *
     * @summary Basis
     * @param {BasisRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<BasisResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Basis Binance API Documentation}
     */
    public async basis(requestParameters: BasisRequest): Promise<RestApiResponse<BasisResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.basis(
            requestParameters?.pair,
            requestParameters?.contractType,
            requestParameters?.period,
            requestParameters?.limit,
            requestParameters?.startTime,
            requestParameters?.endTime
        );
        return sendRequest<BasisResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Test connectivity to the Rest API and get the current server time.
     *
     * Weight: 1
     *
     * @summary Check Server time
     * @returns {Promise<RestApiResponse<CheckServerTimeResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Check-Server-time Binance API Documentation}
     */
    public async checkServerTime(): Promise<RestApiResponse<CheckServerTimeResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.checkServerTime();
        return sendRequest<CheckServerTimeResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Get compressed, aggregate trades. Market trades that fill in 100ms with the same price and the same taking side will have the quantity aggregated.
     *
     * support querying futures trade histories that are not older than one year
     * If both `startTime` and `endTime` are sent, time between `startTime` and `endTime` must be less than 1 hour.
     * If `fromId`, `startTime`, and `endTime` are not sent, the most recent aggregate trades will be returned.
     * Only market trades will be aggregated and returned, which means the insurance fund trades and ADL trades won't be aggregated.
     * Sending both `startTime`/`endTime` and `fromId` might cause response timeout, please send either `fromId` or `startTime`/`endTime`
     *
     * Weight: 20
     *
     * @summary Compressed/Aggregate Trades List
     * @param {CompressedAggregateTradesListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<CompressedAggregateTradesListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Compressed-Aggregate-Trades-List Binance API Documentation}
     */
    public async compressedAggregateTradesList(
        requestParameters: CompressedAggregateTradesListRequest
    ): Promise<RestApiResponse<CompressedAggregateTradesListResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.compressedAggregateTradesList(
                requestParameters?.symbol,
                requestParameters?.fromId,
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.limit
            );
        return sendRequest<CompressedAggregateTradesListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Kline/candlestick bars for a specific contract type.
     * Klines are uniquely identified by their open time.
     *
     * Contract type:
     * PERPETUAL
     * CURRENT_QUARTER
     * NEXT_QUARTER
     *
     *
     * 1000 | 10
     * The difference between `startTime` and `endTime` can only be up to 200 days
     * Between `startTime` and `endTime`, the most recent `limit` data from `endTime` will be returned:
     * If `startTime` and `endTime` are not sent, current timestamp will be set as `endTime`, and the most recent data will be returned.
     * If `startTime` is sent only, the timestamp of 200 days after `startTime` will be set as `endTime`(up to the current time)
     * If `endTime` is sent only, the timestamp of 200 days before `endTime` will be set as `startTime`
     *
     * Weight: based on parameter LIMIT
     * LIMIT | weight
     * ---|---
     * [1,100) | 1
     * [100, 500) | 2
     * [500, 1000] | 5
     * > 1000 | 10
     *
     * @summary Continuous Contract Kline/Candlestick Data
     * @param {ContinuousContractKlineCandlestickDataRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<ContinuousContractKlineCandlestickDataResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Continuous-Contract-Kline-Candlestick-Data Binance API Documentation}
     */
    public async continuousContractKlineCandlestickData(
        requestParameters: ContinuousContractKlineCandlestickDataRequest
    ): Promise<RestApiResponse<ContinuousContractKlineCandlestickDataResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.continuousContractKlineCandlestickData(
                requestParameters?.pair,
                requestParameters?.contractType,
                requestParameters?.interval,
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.limit
            );
        return sendRequest<ContinuousContractKlineCandlestickDataResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Current exchange trading rules and symbol information
     *
     * Weight: 1
     *
     * @summary Exchange Information
     * @returns {Promise<RestApiResponse<ExchangeInformationResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Exchange-Information Binance API Documentation}
     */
    public async exchangeInformation(): Promise<RestApiResponse<ExchangeInformationResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.exchangeInformation();
        return sendRequest<ExchangeInformationResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Get Funding Rate History of Perpetual Futures
     *
     * empty array will be returned for delivery symbols.
     *
     * Weight: 1
     *
     * @summary Get Funding Rate History of Perpetual Futures
     * @param {GetFundingRateHistoryOfPerpetualFuturesRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<GetFundingRateHistoryOfPerpetualFuturesResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Get-Funding-Rate-History-of-Perpetual-Futures Binance API Documentation}
     */
    public async getFundingRateHistoryOfPerpetualFutures(
        requestParameters: GetFundingRateHistoryOfPerpetualFuturesRequest
    ): Promise<RestApiResponse<GetFundingRateHistoryOfPerpetualFuturesResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.getFundingRateHistoryOfPerpetualFutures(
                requestParameters?.symbol,
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.limit
            );
        return sendRequest<GetFundingRateHistoryOfPerpetualFuturesResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor / fundingIntervalHours adjustment
     *
     * Weight: 0
     *
     * @summary Get Funding Rate Info
     * @returns {Promise<RestApiResponse<GetFundingRateInfoResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Get-Funding-Info Binance API Documentation}
     */
    public async getFundingRateInfo(): Promise<RestApiResponse<GetFundingRateInfoResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.getFundingRateInfo();
        return sendRequest<GetFundingRateInfoResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Query index price and mark price
     *
     * Weight: 10
     *
     * @summary Index Price and Mark Price
     * @param {IndexPriceAndMarkPriceRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<IndexPriceAndMarkPriceResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Index-Price-and-Mark-Price Binance API Documentation}
     */
    public async indexPriceAndMarkPrice(
        requestParameters: IndexPriceAndMarkPriceRequest = {}
    ): Promise<RestApiResponse<IndexPriceAndMarkPriceResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.indexPriceAndMarkPrice(
            requestParameters?.symbol,
            requestParameters?.pair
        );
        return sendRequest<IndexPriceAndMarkPriceResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by their open time.
     *
     *
     * 1000 | 10
     * The difference between `startTime` and `endTime` can only be up to 200 days
     * Between `startTime` and `endTime`, the most recent `limit` data from `endTime` will be returned:
     * If `startTime` and `endTime` are not sent, current timestamp will be set as `endTime`, and the most recent data will be returned.
     * If `startTime` is sent only, the timestamp of 200 days after `startTime` will be set as `endTime`(up to the current time)
     * If `endTime` is sent only, the timestamp of 200 days before `endTime` will be set as `startTime`
     *
     * Weight: based on parameter LIMIT
     * LIMIT | weight
     * ---|---
     * [1,100) | 1
     * [100, 500) | 2
     * [500, 1000] | 5
     * > 1000 | 10
     *
     * @summary Index Price Kline/Candlestick Data
     * @param {IndexPriceKlineCandlestickDataRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<IndexPriceKlineCandlestickDataResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Index-Price-Kline-Candlestick-Data Binance API Documentation}
     */
    public async indexPriceKlineCandlestickData(
        requestParameters: IndexPriceKlineCandlestickDataRequest
    ): Promise<RestApiResponse<IndexPriceKlineCandlestickDataResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.indexPriceKlineCandlestickData(
                requestParameters?.pair,
                requestParameters?.interval,
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.limit
            );
        return sendRequest<IndexPriceKlineCandlestickDataResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Kline/candlestick bars for a symbol.
     * Klines are uniquely identified by their open time.
     *
     * 1000 | 10
     * The difference between `startTime` and `endTime` can only be up to 200 days
     * Between `startTime` and `endTime`, the most recent `limit` data from `endTime` will be returned:
     * If `startTime` and `endTime` are not sent, current timestamp will be set as `endTime`, and the most recent data will be returned.
     * If `startTime` is sent only, the timestamp of 200 days after `startTime` will be set as `endTime`(up to the current time)
     * If `endTime` is sent only, the timestamp of 200 days before `endTime` will be set as `startTime`
     *
     * Weight: based on parameter LIMIT
     * LIMIT | weight
     * ---|---
     * [1,100) | 1
     * [100, 500) | 2
     * [500, 1000] | 5
     * > 1000 | 10
     *
     * @summary Kline/Candlestick Data
     * @param {KlineCandlestickDataRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<KlineCandlestickDataResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Kline-Candlestick-Data Binance API Documentation}
     */
    public async klineCandlestickData(
        requestParameters: KlineCandlestickDataRequest
    ): Promise<RestApiResponse<KlineCandlestickDataResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.klineCandlestickData(
            requestParameters?.symbol,
            requestParameters?.interval,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit
        );
        return sendRequest<KlineCandlestickDataResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Query symbol Long/Short Ratio
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     *
     * Weight: 1
     *
     * @summary Long/Short Ratio
     * @param {LongShortRatioRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<LongShortRatioResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Long-Short-Ratio Binance API Documentation}
     */
    public async longShortRatio(
        requestParameters: LongShortRatioRequest
    ): Promise<RestApiResponse<LongShortRatioResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.longShortRatio(
            requestParameters?.pair,
            requestParameters?.period,
            requestParameters?.limit,
            requestParameters?.startTime,
            requestParameters?.endTime
        );
        return sendRequest<LongShortRatioResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Kline/candlestick bars for the mark price of a symbol.
     * Klines are uniquely identified by their open time.
     *
     *
     * 1000 | 10
     * The difference between `startTime` and `endTime` can only be up to 200 days
     * Between `startTime` and `endTime`, the most recent `limit` data from `endTime` will be returned:
     * If `startTime` and `endTime` are not sent, current timestamp will be set as `endTime`, and the most recent data will be returned.
     * If `startTime` is sent only, the timestamp of 200 days after `startTime` will be set as `endTime`(up to the current time)
     * If `endTime` is sent only, the timestamp of 200 days before `endTime` will be set as `startTime`
     *
     * Weight: based on parameter LIMIT
     * LIMIT | weight
     * ---|---
     * [1,100) | 1
     * [100, 500) | 2
     * [500, 1000] | 5
     * > 1000 | 10
     *
     * @summary Mark Price Kline/Candlestick Data
     * @param {MarkPriceKlineCandlestickDataRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<MarkPriceKlineCandlestickDataResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Mark-Price-Kline-Candlestick-Data Binance API Documentation}
     */
    public async markPriceKlineCandlestickData(
        requestParameters: MarkPriceKlineCandlestickDataRequest
    ): Promise<RestApiResponse<MarkPriceKlineCandlestickDataResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.markPriceKlineCandlestickData(
                requestParameters?.symbol,
                requestParameters?.interval,
                requestParameters?.startTime,
                requestParameters?.endTime,
                requestParameters?.limit
            );
        return sendRequest<MarkPriceKlineCandlestickDataResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Get older market historical trades.
     *
     * Market trades means trades filled in the order book. Only market trades will be returned, which means the insurance fund trades and ADL trades won't be returned.
     *
     * Weight: 20
     *
     * @summary Old Trades Lookup(MARKET_DATA)
     * @param {OldTradesLookupRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OldTradesLookupResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Old-Trades-Lookup Binance API Documentation}
     */
    public async oldTradesLookup(
        requestParameters: OldTradesLookupRequest
    ): Promise<RestApiResponse<OldTradesLookupResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.oldTradesLookup(
            requestParameters?.symbol,
            requestParameters?.limit,
            requestParameters?.fromId
        );
        return sendRequest<OldTradesLookupResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Get present open interest of a specific symbol.
     *
     * Weight: 1
     *
     * @summary Open Interest
     * @param {OpenInterestRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OpenInterestResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Open-Interest Binance API Documentation}
     */
    public async openInterest(
        requestParameters: OpenInterestRequest
    ): Promise<RestApiResponse<OpenInterestResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.openInterest(
            requestParameters?.symbol
        );
        return sendRequest<OpenInterestResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Query open interest stats
     *
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     *
     * Weight: 1
     *
     * @summary Open Interest Statistics
     * @param {OpenInterestStatisticsRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OpenInterestStatisticsResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Open-Interest-Statistics Binance API Documentation}
     */
    public async openInterestStatistics(
        requestParameters: OpenInterestStatisticsRequest
    ): Promise<RestApiResponse<OpenInterestStatisticsResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.openInterestStatistics(
            requestParameters?.pair,
            requestParameters?.contractType,
            requestParameters?.period,
            requestParameters?.limit,
            requestParameters?.startTime,
            requestParameters?.endTime
        );
        return sendRequest<OpenInterestStatisticsResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Query orderbook on specific symbol
     *
     * Weight: Adjusted based on the limit:
     * Limit | Weight
     * ------------ | ------------
     * 5, 10, 20, 50 | 2
     * 100 | 5
     * 500 | 10
     * 1000 | 20
     *
     * @summary Order Book
     * @param {OrderBookRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<OrderBookResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Order-Book Binance API Documentation}
     */
    public async orderBook(
        requestParameters: OrderBookRequest
    ): Promise<RestApiResponse<OrderBookResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderBook(
            requestParameters?.symbol,
            requestParameters?.limit
        );
        return sendRequest<OrderBookResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Premium index kline bars of a symbol. Klines are uniquely identified by their open time.
     *
     *
     * If startTime and endTime are not sent, the most recent klines are returned.
     *
     * Weight: based on parameter LIMIT
     * | LIMIT       | weight |
     * | ----------- | ------ |
     * | [1,100)     | 1      |
     * | [100, 500)  | 2      |
     * | [500, 1000] | 5      |
     * | > 1000      | 10     |
     *
     * @summary Premium index Kline Data
     * @param {PremiumIndexKlineDataRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<PremiumIndexKlineDataResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Premium-index-Kline-Data Binance API Documentation}
     */
    public async premiumIndexKlineData(
        requestParameters: PremiumIndexKlineDataRequest
    ): Promise<RestApiResponse<PremiumIndexKlineDataResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.premiumIndexKlineData(
            requestParameters?.symbol,
            requestParameters?.interval,
            requestParameters?.startTime,
            requestParameters?.endTime,
            requestParameters?.limit
        );
        return sendRequest<PremiumIndexKlineDataResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Query index price constituents
     *
     * Weight: 2
     *
     * @summary Query Index Price Constituents
     * @param {QueryIndexPriceConstituentsRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<QueryIndexPriceConstituentsResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Index-Constituents Binance API Documentation}
     */
    public async queryIndexPriceConstituents(
        requestParameters: QueryIndexPriceConstituentsRequest
    ): Promise<RestApiResponse<QueryIndexPriceConstituentsResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.queryIndexPriceConstituents(
            requestParameters?.symbol
        );
        return sendRequest<QueryIndexPriceConstituentsResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Get recent market trades
     *
     * Market trades means trades filled in the order book. Only market trades will be returned, which means the insurance fund trades and ADL trades won't be returned.
     *
     * Weight: 5
     *
     * @summary Recent Trades List
     * @param {RecentTradesListRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<RecentTradesListResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Recent-Trades-List Binance API Documentation}
     */
    public async recentTradesList(
        requestParameters: RecentTradesListRequest
    ): Promise<RestApiResponse<RecentTradesListResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.recentTradesList(
            requestParameters?.symbol,
            requestParameters?.limit
        );
        return sendRequest<RecentTradesListResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Best price/qty on the order book for a symbol or symbols.
     *
     * Symbol and pair cannot be sent together
     * If a pair is sent,tickers for all symbols of the pair will be returned
     * If either a pair or symbol is sent, tickers for all symbols of all pairs will be returned
     *
     * Weight: 2 for a single symbol, 5 when the symbol parameter is omitted
     *
     * @summary Symbol Order Book Ticker
     * @param {SymbolOrderBookTickerRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<SymbolOrderBookTickerResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Symbol-Order-Book-Ticker Binance API Documentation}
     */
    public async symbolOrderBookTicker(
        requestParameters: SymbolOrderBookTickerRequest = {}
    ): Promise<RestApiResponse<SymbolOrderBookTickerResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.symbolOrderBookTicker(
            requestParameters?.symbol,
            requestParameters?.pair
        );
        return sendRequest<SymbolOrderBookTickerResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Latest price for a symbol or symbols.
     *
     * Symbol and pair cannot be sent together
     * If a pair is sent,tickers for all symbols of the pair will be returned
     * If either a pair or symbol is sent, tickers for all symbols of all pairs will be returned
     *
     * Weight: 1 for a single symbol, 2 when the symbol parameter is omitted
     *
     * @summary Symbol Price Ticker
     * @param {SymbolPriceTickerRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<SymbolPriceTickerResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Symbol-Price-Ticker Binance API Documentation}
     */
    public async symbolPriceTicker(
        requestParameters: SymbolPriceTickerRequest = {}
    ): Promise<RestApiResponse<SymbolPriceTickerResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.symbolPriceTicker(
            requestParameters?.symbol,
            requestParameters?.pair
        );
        return sendRequest<SymbolPriceTickerResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Taker Buy Volume: the total volume of buy orders filled by takers within the period.
     * Taker Sell Volume: the total volume of sell orders filled by takers within the period.
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     *
     * Weight: 1
     *
     * @summary Taker Buy/Sell Volume
     * @param {TakerBuySellVolumeRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<TakerBuySellVolumeResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Taker-Buy-Sell-Volume Binance API Documentation}
     */
    public async takerBuySellVolume(
        requestParameters: TakerBuySellVolumeRequest
    ): Promise<RestApiResponse<TakerBuySellVolumeResponse>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.takerBuySellVolume(
            requestParameters?.pair,
            requestParameters?.contractType,
            requestParameters?.period,
            requestParameters?.limit,
            requestParameters?.startTime,
            requestParameters?.endTime
        );
        return sendRequest<TakerBuySellVolumeResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * Test connectivity to the Rest API.
     *
     * Weight: 1
     *
     * @summary Test Connectivity
     * @returns {Promise<RestApiResponse<void>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Test-Connectivity Binance API Documentation}
     */
    public async testConnectivity(): Promise<RestApiResponse<void>> {
        const localVarAxiosArgs = await this.localVarAxiosParamCreator.testConnectivity();
        return sendRequest<void>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * 24 hour rolling window price change statistics.
     *
     * Symbol and pair cannot be sent together
     * If a pair is sent,tickers for all symbols of the pair will be returned
     * If either a pair or symbol is sent, tickers for all symbols of all pairs will be returned
     *
     * Weight: 1 for a single symbol, 40 when the symbol parameter is omitted
     * Careful when accessing this with no symbol.
     *
     * @summary 24hr Ticker Price Change Statistics
     * @param {Ticker24hrPriceChangeStatisticsRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<Ticker24hrPriceChangeStatisticsResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/24hr-Ticker-Price-Change-Statistics Binance API Documentation}
     */
    public async ticker24hrPriceChangeStatistics(
        requestParameters: Ticker24hrPriceChangeStatisticsRequest = {}
    ): Promise<RestApiResponse<Ticker24hrPriceChangeStatisticsResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.ticker24hrPriceChangeStatistics(
                requestParameters?.symbol,
                requestParameters?.pair
            );
        return sendRequest<Ticker24hrPriceChangeStatisticsResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * The proportion of net long and net short accounts to total accounts of the top 20% users with the highest margin balance. Each account is counted once only.
     * Long Account % = Accounts of top traders with net long positions / Total accounts of top traders with open positions
     * Short Account % = Accounts of top traders with net short positions / Total accounts of top traders with open positions
     * Long/Short Ratio (Accounts) = Long Account % / Short Account %
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     *
     * Weight: 1
     *
     * @summary Top Trader Long/Short Ratio (Accounts)
     * @param {TopTraderLongShortRatioAccountsRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<TopTraderLongShortRatioAccountsResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Top-Long-Short-Account-Ratio Binance API Documentation}
     */
    public async topTraderLongShortRatioAccounts(
        requestParameters: TopTraderLongShortRatioAccountsRequest
    ): Promise<RestApiResponse<TopTraderLongShortRatioAccountsResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.topTraderLongShortRatioAccounts(
                requestParameters?.symbol,
                requestParameters?.period,
                requestParameters?.limit,
                requestParameters?.startTime,
                requestParameters?.endTime
            );
        return sendRequest<TopTraderLongShortRatioAccountsResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }

    /**
     * The proportion of net long and net short positions to total open positions of the top 20% users with the highest margin balance.
     * Long Position % = Long positions of top traders / Total open positions of top traders
     * Short Position % = Short positions of top traders / Total open positions of top traders
     * Long/Short Ratio (Positions) = Long Position % / Short Position %
     *
     * If startTime and endTime are not sent, the most recent data is returned.
     * Only the data of the latest 30 days is available.
     *
     * Weight: 1
     *
     * @summary Top Trader Long/Short Ratio (Positions)
     * @param {TopTraderLongShortRatioPositionsRequest} requestParameters Request parameters.
     * @returns {Promise<RestApiResponse<TopTraderLongShortRatioPositionsResponse>>}
     * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
     * @memberof MarketDataApi
     * @see {@link https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Top-Trader-Long-Short-Ratio Binance API Documentation}
     */
    public async topTraderLongShortRatioPositions(
        requestParameters: TopTraderLongShortRatioPositionsRequest
    ): Promise<RestApiResponse<TopTraderLongShortRatioPositionsResponse>> {
        const localVarAxiosArgs =
            await this.localVarAxiosParamCreator.topTraderLongShortRatioPositions(
                requestParameters?.pair,
                requestParameters?.period,
                requestParameters?.limit,
                requestParameters?.startTime,
                requestParameters?.endTime
            );
        return sendRequest<TopTraderLongShortRatioPositionsResponse>(
            this.configuration,
            localVarAxiosArgs.endpoint,
            localVarAxiosArgs.method,
            localVarAxiosArgs.params,
            localVarAxiosArgs?.timeUnit,
            { isSigned: false }
        );
    }
}

export const BasisContractTypeEnum = {
    PERPETUAL: 'PERPETUAL',
    CURRENT_QUARTER: 'CURRENT_QUARTER',
    NEXT_QUARTER: 'NEXT_QUARTER',
    CURRENT_QUARTER_DELIVERING: 'CURRENT_QUARTER_DELIVERING',
    NEXT_QUARTER_DELIVERING: 'NEXT_QUARTER_DELIVERING',
    PERPETUAL_DELIVERING: 'PERPETUAL_DELIVERING',
} as const;
export type BasisContractTypeEnum =
    (typeof BasisContractTypeEnum)[keyof typeof BasisContractTypeEnum];

export const BasisPeriodEnum = {
    PERIOD_5m: '5m',
    PERIOD_15m: '15m',
    PERIOD_30m: '30m',
    PERIOD_1h: '1h',
    PERIOD_2h: '2h',
    PERIOD_4h: '4h',
    PERIOD_6h: '6h',
    PERIOD_12h: '12h',
    PERIOD_1d: '1d',
} as const;
export type BasisPeriodEnum = (typeof BasisPeriodEnum)[keyof typeof BasisPeriodEnum];

export const ContinuousContractKlineCandlestickDataContractTypeEnum = {
    PERPETUAL: 'PERPETUAL',
    CURRENT_QUARTER: 'CURRENT_QUARTER',
    NEXT_QUARTER: 'NEXT_QUARTER',
    CURRENT_QUARTER_DELIVERING: 'CURRENT_QUARTER_DELIVERING',
    NEXT_QUARTER_DELIVERING: 'NEXT_QUARTER_DELIVERING',
    PERPETUAL_DELIVERING: 'PERPETUAL_DELIVERING',
} as const;
export type ContinuousContractKlineCandlestickDataContractTypeEnum =
    (typeof ContinuousContractKlineCandlestickDataContractTypeEnum)[keyof typeof ContinuousContractKlineCandlestickDataContractTypeEnum];

export const ContinuousContractKlineCandlestickDataIntervalEnum = {
    INTERVAL_1m: '1m',
    INTERVAL_3m: '3m',
    INTERVAL_5m: '5m',
    INTERVAL_15m: '15m',
    INTERVAL_30m: '30m',
    INTERVAL_1h: '1h',
    INTERVAL_2h: '2h',
    INTERVAL_4h: '4h',
    INTERVAL_6h: '6h',
    INTERVAL_8h: '8h',
    INTERVAL_12h: '12h',
    INTERVAL_1d: '1d',
    INTERVAL_3d: '3d',
    INTERVAL_1w: '1w',
    INTERVAL_1M: '1M',
} as const;
export type ContinuousContractKlineCandlestickDataIntervalEnum =
    (typeof ContinuousContractKlineCandlestickDataIntervalEnum)[keyof typeof ContinuousContractKlineCandlestickDataIntervalEnum];

export const IndexPriceKlineCandlestickDataIntervalEnum = {
    INTERVAL_1m: '1m',
    INTERVAL_3m: '3m',
    INTERVAL_5m: '5m',
    INTERVAL_15m: '15m',
    INTERVAL_30m: '30m',
    INTERVAL_1h: '1h',
    INTERVAL_2h: '2h',
    INTERVAL_4h: '4h',
    INTERVAL_6h: '6h',
    INTERVAL_8h: '8h',
    INTERVAL_12h: '12h',
    INTERVAL_1d: '1d',
    INTERVAL_3d: '3d',
    INTERVAL_1w: '1w',
    INTERVAL_1M: '1M',
} as const;
export type IndexPriceKlineCandlestickDataIntervalEnum =
    (typeof IndexPriceKlineCandlestickDataIntervalEnum)[keyof typeof IndexPriceKlineCandlestickDataIntervalEnum];

export const KlineCandlestickDataIntervalEnum = {
    INTERVAL_1m: '1m',
    INTERVAL_3m: '3m',
    INTERVAL_5m: '5m',
    INTERVAL_15m: '15m',
    INTERVAL_30m: '30m',
    INTERVAL_1h: '1h',
    INTERVAL_2h: '2h',
    INTERVAL_4h: '4h',
    INTERVAL_6h: '6h',
    INTERVAL_8h: '8h',
    INTERVAL_12h: '12h',
    INTERVAL_1d: '1d',
    INTERVAL_3d: '3d',
    INTERVAL_1w: '1w',
    INTERVAL_1M: '1M',
} as const;
export type KlineCandlestickDataIntervalEnum =
    (typeof KlineCandlestickDataIntervalEnum)[keyof typeof KlineCandlestickDataIntervalEnum];

export const LongShortRatioPeriodEnum = {
    PERIOD_5m: '5m',
    PERIOD_15m: '15m',
    PERIOD_30m: '30m',
    PERIOD_1h: '1h',
    PERIOD_2h: '2h',
    PERIOD_4h: '4h',
    PERIOD_6h: '6h',
    PERIOD_12h: '12h',
    PERIOD_1d: '1d',
} as const;
export type LongShortRatioPeriodEnum =
    (typeof LongShortRatioPeriodEnum)[keyof typeof LongShortRatioPeriodEnum];

export const MarkPriceKlineCandlestickDataIntervalEnum = {
    INTERVAL_1m: '1m',
    INTERVAL_3m: '3m',
    INTERVAL_5m: '5m',
    INTERVAL_15m: '15m',
    INTERVAL_30m: '30m',
    INTERVAL_1h: '1h',
    INTERVAL_2h: '2h',
    INTERVAL_4h: '4h',
    INTERVAL_6h: '6h',
    INTERVAL_8h: '8h',
    INTERVAL_12h: '12h',
    INTERVAL_1d: '1d',
    INTERVAL_3d: '3d',
    INTERVAL_1w: '1w',
    INTERVAL_1M: '1M',
} as const;
export type MarkPriceKlineCandlestickDataIntervalEnum =
    (typeof MarkPriceKlineCandlestickDataIntervalEnum)[keyof typeof MarkPriceKlineCandlestickDataIntervalEnum];

export const OpenInterestStatisticsContractTypeEnum = {
    PERPETUAL: 'PERPETUAL',
    CURRENT_QUARTER: 'CURRENT_QUARTER',
    NEXT_QUARTER: 'NEXT_QUARTER',
    CURRENT_QUARTER_DELIVERING: 'CURRENT_QUARTER_DELIVERING',
    NEXT_QUARTER_DELIVERING: 'NEXT_QUARTER_DELIVERING',
    PERPETUAL_DELIVERING: 'PERPETUAL_DELIVERING',
} as const;
export type OpenInterestStatisticsContractTypeEnum =
    (typeof OpenInterestStatisticsContractTypeEnum)[keyof typeof OpenInterestStatisticsContractTypeEnum];

export const OpenInterestStatisticsPeriodEnum = {
    PERIOD_5m: '5m',
    PERIOD_15m: '15m',
    PERIOD_30m: '30m',
    PERIOD_1h: '1h',
    PERIOD_2h: '2h',
    PERIOD_4h: '4h',
    PERIOD_6h: '6h',
    PERIOD_12h: '12h',
    PERIOD_1d: '1d',
} as const;
export type OpenInterestStatisticsPeriodEnum =
    (typeof OpenInterestStatisticsPeriodEnum)[keyof typeof OpenInterestStatisticsPeriodEnum];

export const PremiumIndexKlineDataIntervalEnum = {
    INTERVAL_1m: '1m',
    INTERVAL_3m: '3m',
    INTERVAL_5m: '5m',
    INTERVAL_15m: '15m',
    INTERVAL_30m: '30m',
    INTERVAL_1h: '1h',
    INTERVAL_2h: '2h',
    INTERVAL_4h: '4h',
    INTERVAL_6h: '6h',
    INTERVAL_8h: '8h',
    INTERVAL_12h: '12h',
    INTERVAL_1d: '1d',
    INTERVAL_3d: '3d',
    INTERVAL_1w: '1w',
    INTERVAL_1M: '1M',
} as const;
export type PremiumIndexKlineDataIntervalEnum =
    (typeof PremiumIndexKlineDataIntervalEnum)[keyof typeof PremiumIndexKlineDataIntervalEnum];

export const TakerBuySellVolumeContractTypeEnum = {
    PERPETUAL: 'PERPETUAL',
    CURRENT_QUARTER: 'CURRENT_QUARTER',
    NEXT_QUARTER: 'NEXT_QUARTER',
    CURRENT_QUARTER_DELIVERING: 'CURRENT_QUARTER_DELIVERING',
    NEXT_QUARTER_DELIVERING: 'NEXT_QUARTER_DELIVERING',
    PERPETUAL_DELIVERING: 'PERPETUAL_DELIVERING',
} as const;
export type TakerBuySellVolumeContractTypeEnum =
    (typeof TakerBuySellVolumeContractTypeEnum)[keyof typeof TakerBuySellVolumeContractTypeEnum];

export const TakerBuySellVolumePeriodEnum = {
    PERIOD_5m: '5m',
    PERIOD_15m: '15m',
    PERIOD_30m: '30m',
    PERIOD_1h: '1h',
    PERIOD_2h: '2h',
    PERIOD_4h: '4h',
    PERIOD_6h: '6h',
    PERIOD_12h: '12h',
    PERIOD_1d: '1d',
} as const;
export type TakerBuySellVolumePeriodEnum =
    (typeof TakerBuySellVolumePeriodEnum)[keyof typeof TakerBuySellVolumePeriodEnum];

export const TopTraderLongShortRatioAccountsPeriodEnum = {
    PERIOD_5m: '5m',
    PERIOD_15m: '15m',
    PERIOD_30m: '30m',
    PERIOD_1h: '1h',
    PERIOD_2h: '2h',
    PERIOD_4h: '4h',
    PERIOD_6h: '6h',
    PERIOD_12h: '12h',
    PERIOD_1d: '1d',
} as const;
export type TopTraderLongShortRatioAccountsPeriodEnum =
    (typeof TopTraderLongShortRatioAccountsPeriodEnum)[keyof typeof TopTraderLongShortRatioAccountsPeriodEnum];

export const TopTraderLongShortRatioPositionsPeriodEnum = {
    PERIOD_5m: '5m',
    PERIOD_15m: '15m',
    PERIOD_30m: '30m',
    PERIOD_1h: '1h',
    PERIOD_2h: '2h',
    PERIOD_4h: '4h',
    PERIOD_6h: '6h',
    PERIOD_12h: '12h',
    PERIOD_1d: '1d',
} as const;
export type TopTraderLongShortRatioPositionsPeriodEnum =
    (typeof TopTraderLongShortRatioPositionsPeriodEnum)[keyof typeof TopTraderLongShortRatioPositionsPeriodEnum];
