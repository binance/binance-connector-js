/**
 * Binance Public Derivatives Trading COIN Futures REST API
 *
 * OpenAPI Specification for the Binance Public Derivatives Trading COIN Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { AccountApi } from '../../../src/rest-api';
import {
    AccountInformationRequest,
    FuturesAccountBalanceRequest,
    GetCurrentPositionModeRequest,
    GetDownloadIdForFuturesOrderHistoryRequest,
    GetDownloadIdForFuturesTradeHistoryRequest,
    GetDownloadIdForFuturesTransactionHistoryRequest,
    GetFuturesOrderHistoryDownloadLinkByIdRequest,
    GetFuturesTradeDownloadLinkByIdRequest,
    GetFuturesTransactionHistoryDownloadLinkByIdRequest,
    GetIncomeHistoryRequest,
    NotionalBracketForPairRequest,
    NotionalBracketForSymbolRequest,
    UserCommissionRateRequest,
} from '../../../src/rest-api';
import type {
    AccountInformationResponse,
    FuturesAccountBalanceResponse,
    GetCurrentPositionModeResponse,
    GetDownloadIdForFuturesOrderHistoryResponse,
    GetDownloadIdForFuturesTradeHistoryResponse,
    GetDownloadIdForFuturesTransactionHistoryResponse,
    GetFuturesOrderHistoryDownloadLinkByIdResponse,
    GetFuturesTradeDownloadLinkByIdResponse,
    GetFuturesTransactionHistoryDownloadLinkByIdResponse,
    GetIncomeHistoryResponse,
    NotionalBracketForPairResponse,
    NotionalBracketForSymbolResponse,
    UserCommissionRateResponse,
} from '../../../src/rest-api/types';

describe('AccountApi', () => {
    let client: AccountApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new AccountApi(config);
    });

    describe('accountInformation()', () => {
        it('should execute accountInformation() successfully with required parameters only', async () => {
            mockResponse = {
                assets: [
                    {
                        asset: 'BTC',
                        walletBalance: '0.00241969',
                        unrealizedProfit: '0.00000000',
                        marginBalance: '0.00241969',
                        maintMargin: '0.00000000',
                        initialMargin: '0.00000000',
                        positionInitialMargin: '0.00000000',
                        openOrderInitialMargin: '0.00000000',
                        maxWithdrawAmount: '0.00241969',
                        crossWalletBalance: '0.00241969',
                        crossUnPnl: '0.00000000',
                        availableBalance: '0.00241969',
                        updateTime: 1625474304765,
                    },
                ],
                positions: [
                    {
                        symbol: 'BTCUSD_201225',
                        positionAmt: '0',
                        initialMargin: '0',
                        maintMargin: '0',
                        unrealizedProfit: '0.00000000',
                        positionInitialMargin: '0',
                        openOrderInitialMargin: '0',
                        leverage: '125',
                        isolated: false,
                        positionSide: 'BOTH',
                        entryPrice: '0.0',
                        breakEvenPrice: '0.0',
                        maxQty: '50',
                        updateTime: 0,
                    },
                    {
                        symbol: 'BTCUSD_201225',
                        positionAmt: '0',
                        initialMargin: '0',
                        maintMargin: '0',
                        unrealizedProfit: '0.00000000',
                        positionInitialMargin: '0',
                        openOrderInitialMargin: '0',
                        leverage: '125',
                        isolated: false,
                        positionSide: 'LONG',
                        entryPrice: '0.0',
                        breakEvenPrice: '0.0',
                        maxQty: '50',
                        updateTime: 0,
                    },
                    {
                        symbol: 'BTCUSD_201225',
                        positionAmt: '0',
                        initialMargin: '0',
                        maintMargin: '0',
                        unrealizedProfit: '0.00000000',
                        positionInitialMargin: '0',
                        openOrderInitialMargin: '0',
                        leverage: '125',
                        isolated: false,
                        positionSide: 'SHORT',
                        entryPrice: '0.0',
                        breakEvenPrice: '0.0',
                        maxQty: '50',
                        notionalValue: '0',
                        updateTime: 1627026881327,
                    },
                ],
                canDeposit: true,
                canTrade: true,
                canWithdraw: true,
                feeTier: 2,
                updateTime: 0,
            };

            const spy = jest.spyOn(client, 'accountInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountInformationResponse>)
            );
            const response = await client.accountInformation();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute accountInformation() successfully with optional parameters', async () => {
            const params: AccountInformationRequest = {
                recvWindow: 5000,
            };

            mockResponse = {
                assets: [
                    {
                        asset: 'BTC',
                        walletBalance: '0.00241969',
                        unrealizedProfit: '0.00000000',
                        marginBalance: '0.00241969',
                        maintMargin: '0.00000000',
                        initialMargin: '0.00000000',
                        positionInitialMargin: '0.00000000',
                        openOrderInitialMargin: '0.00000000',
                        maxWithdrawAmount: '0.00241969',
                        crossWalletBalance: '0.00241969',
                        crossUnPnl: '0.00000000',
                        availableBalance: '0.00241969',
                        updateTime: 1625474304765,
                    },
                ],
                positions: [
                    {
                        symbol: 'BTCUSD_201225',
                        positionAmt: '0',
                        initialMargin: '0',
                        maintMargin: '0',
                        unrealizedProfit: '0.00000000',
                        positionInitialMargin: '0',
                        openOrderInitialMargin: '0',
                        leverage: '125',
                        isolated: false,
                        positionSide: 'BOTH',
                        entryPrice: '0.0',
                        breakEvenPrice: '0.0',
                        maxQty: '50',
                        updateTime: 0,
                    },
                    {
                        symbol: 'BTCUSD_201225',
                        positionAmt: '0',
                        initialMargin: '0',
                        maintMargin: '0',
                        unrealizedProfit: '0.00000000',
                        positionInitialMargin: '0',
                        openOrderInitialMargin: '0',
                        leverage: '125',
                        isolated: false,
                        positionSide: 'LONG',
                        entryPrice: '0.0',
                        breakEvenPrice: '0.0',
                        maxQty: '50',
                        updateTime: 0,
                    },
                    {
                        symbol: 'BTCUSD_201225',
                        positionAmt: '0',
                        initialMargin: '0',
                        maintMargin: '0',
                        unrealizedProfit: '0.00000000',
                        positionInitialMargin: '0',
                        openOrderInitialMargin: '0',
                        leverage: '125',
                        isolated: false,
                        positionSide: 'SHORT',
                        entryPrice: '0.0',
                        breakEvenPrice: '0.0',
                        maxQty: '50',
                        notionalValue: '0',
                        updateTime: 1627026881327,
                    },
                ],
                canDeposit: true,
                canTrade: true,
                canWithdraw: true,
                feeTier: 2,
                updateTime: 0,
            };

            const spy = jest.spyOn(client, 'accountInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<AccountInformationResponse>)
            );
            const response = await client.accountInformation(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'accountInformation').mockRejectedValueOnce(mockError);
            await expect(client.accountInformation()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('futuresAccountBalance()', () => {
        it('should execute futuresAccountBalance() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    accountAlias: 'SgsR',
                    asset: 'BTC',
                    balance: '0.00250000',
                    withdrawAvailable: '0.00250000',
                    crossWalletBalance: '0.00241969',
                    crossUnPnl: '0.00000000',
                    availableBalance: '0.00241969',
                    updateTime: 1592468353979,
                },
            ];

            const spy = jest.spyOn(client, 'futuresAccountBalance').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FuturesAccountBalanceResponse>)
            );
            const response = await client.futuresAccountBalance();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute futuresAccountBalance() successfully with optional parameters', async () => {
            const params: FuturesAccountBalanceRequest = {
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    accountAlias: 'SgsR',
                    asset: 'BTC',
                    balance: '0.00250000',
                    withdrawAvailable: '0.00250000',
                    crossWalletBalance: '0.00241969',
                    crossUnPnl: '0.00000000',
                    availableBalance: '0.00241969',
                    updateTime: 1592468353979,
                },
            ];

            const spy = jest.spyOn(client, 'futuresAccountBalance').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FuturesAccountBalanceResponse>)
            );
            const response = await client.futuresAccountBalance(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'futuresAccountBalance')
                .mockRejectedValueOnce(mockError);
            await expect(client.futuresAccountBalance()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getCurrentPositionMode()', () => {
        it('should execute getCurrentPositionMode() successfully with required parameters only', async () => {
            mockResponse = { dualSidePosition: true };

            const spy = jest.spyOn(client, 'getCurrentPositionMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCurrentPositionModeResponse>)
            );
            const response = await client.getCurrentPositionMode();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getCurrentPositionMode() successfully with optional parameters', async () => {
            const params: GetCurrentPositionModeRequest = {
                recvWindow: 5000,
            };

            mockResponse = { dualSidePosition: true };

            const spy = jest.spyOn(client, 'getCurrentPositionMode').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetCurrentPositionModeResponse>)
            );
            const response = await client.getCurrentPositionMode(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getCurrentPositionMode')
                .mockRejectedValueOnce(mockError);
            await expect(client.getCurrentPositionMode()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getDownloadIdForFuturesOrderHistory()', () => {
        it('should execute getDownloadIdForFuturesOrderHistory() successfully with required parameters only', async () => {
            const params: GetDownloadIdForFuturesOrderHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = { avgCostTimestampOfLast30d: 7241837, downloadId: '546975389218332672' };

            const spy = jest.spyOn(client, 'getDownloadIdForFuturesOrderHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDownloadIdForFuturesOrderHistoryResponse>)
            );
            const response = await client.getDownloadIdForFuturesOrderHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getDownloadIdForFuturesOrderHistory() successfully with optional parameters', async () => {
            const params: GetDownloadIdForFuturesOrderHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = { avgCostTimestampOfLast30d: 7241837, downloadId: '546975389218332672' };

            const spy = jest.spyOn(client, 'getDownloadIdForFuturesOrderHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDownloadIdForFuturesOrderHistoryResponse>)
            );
            const response = await client.getDownloadIdForFuturesOrderHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: GetDownloadIdForFuturesOrderHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(client.getDownloadIdForFuturesOrderHistory(params)).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling getDownloadIdForFuturesOrderHistory.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: GetDownloadIdForFuturesOrderHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(client.getDownloadIdForFuturesOrderHistory(params)).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling getDownloadIdForFuturesOrderHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetDownloadIdForFuturesOrderHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getDownloadIdForFuturesOrderHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getDownloadIdForFuturesOrderHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getDownloadIdForFuturesTradeHistory()', () => {
        it('should execute getDownloadIdForFuturesTradeHistory() successfully with required parameters only', async () => {
            const params: GetDownloadIdForFuturesTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = { avgCostTimestampOfLast30d: 7241837, downloadId: '546975389218332672' };

            const spy = jest.spyOn(client, 'getDownloadIdForFuturesTradeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDownloadIdForFuturesTradeHistoryResponse>)
            );
            const response = await client.getDownloadIdForFuturesTradeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getDownloadIdForFuturesTradeHistory() successfully with optional parameters', async () => {
            const params: GetDownloadIdForFuturesTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = { avgCostTimestampOfLast30d: 7241837, downloadId: '546975389218332672' };

            const spy = jest.spyOn(client, 'getDownloadIdForFuturesTradeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetDownloadIdForFuturesTradeHistoryResponse>)
            );
            const response = await client.getDownloadIdForFuturesTradeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: GetDownloadIdForFuturesTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(client.getDownloadIdForFuturesTradeHistory(params)).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling getDownloadIdForFuturesTradeHistory.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: GetDownloadIdForFuturesTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(client.getDownloadIdForFuturesTradeHistory(params)).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling getDownloadIdForFuturesTradeHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetDownloadIdForFuturesTradeHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getDownloadIdForFuturesTradeHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getDownloadIdForFuturesTradeHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getDownloadIdForFuturesTransactionHistory()', () => {
        it('should execute getDownloadIdForFuturesTransactionHistory() successfully with required parameters only', async () => {
            const params: GetDownloadIdForFuturesTransactionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = { avgCostTimestampOfLast30d: 7241837, downloadId: '546975389218332672' };

            const spy = jest
                .spyOn(client, 'getDownloadIdForFuturesTransactionHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetDownloadIdForFuturesTransactionHistoryResponse>)
                );
            const response = await client.getDownloadIdForFuturesTransactionHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getDownloadIdForFuturesTransactionHistory() successfully with optional parameters', async () => {
            const params: GetDownloadIdForFuturesTransactionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                recvWindow: 5000,
            };

            mockResponse = { avgCostTimestampOfLast30d: 7241837, downloadId: '546975389218332672' };

            const spy = jest
                .spyOn(client, 'getDownloadIdForFuturesTransactionHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetDownloadIdForFuturesTransactionHistoryResponse>)
                );
            const response = await client.getDownloadIdForFuturesTransactionHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when startTime is missing', async () => {
            const _params: GetDownloadIdForFuturesTransactionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.startTime;

            await expect(client.getDownloadIdForFuturesTransactionHistory(params)).rejects.toThrow(
                'Required parameter startTime was null or undefined when calling getDownloadIdForFuturesTransactionHistory.'
            );
        });

        it('should throw RequiredError when endTime is missing', async () => {
            const _params: GetDownloadIdForFuturesTransactionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };
            const params = Object.assign({ ..._params });
            delete params?.endTime;

            await expect(client.getDownloadIdForFuturesTransactionHistory(params)).rejects.toThrow(
                'Required parameter endTime was null or undefined when calling getDownloadIdForFuturesTransactionHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetDownloadIdForFuturesTransactionHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getDownloadIdForFuturesTransactionHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.getDownloadIdForFuturesTransactionHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getFuturesOrderHistoryDownloadLinkById()', () => {
        it('should execute getFuturesOrderHistoryDownloadLinkById() successfully with required parameters only', async () => {
            const params: GetFuturesOrderHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            mockResponse = {
                downloadId: '545923594199212032',
                status: 'completed',
                url: 'www.binance.com',
                notified: true,
                expirationTimestamp: 1645009771000,
                isExpired: null,
            };

            const spy = jest
                .spyOn(client, 'getFuturesOrderHistoryDownloadLinkById')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetFuturesOrderHistoryDownloadLinkByIdResponse>)
                );
            const response = await client.getFuturesOrderHistoryDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFuturesOrderHistoryDownloadLinkById() successfully with optional parameters', async () => {
            const params: GetFuturesOrderHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                downloadId: '545923594199212032',
                status: 'completed',
                url: 'www.binance.com',
                notified: true,
                expirationTimestamp: 1645009771000,
                isExpired: null,
            };

            const spy = jest
                .spyOn(client, 'getFuturesOrderHistoryDownloadLinkById')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetFuturesOrderHistoryDownloadLinkByIdResponse>)
                );
            const response = await client.getFuturesOrderHistoryDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when downloadId is missing', async () => {
            const _params: GetFuturesOrderHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.downloadId;

            await expect(client.getFuturesOrderHistoryDownloadLinkById(params)).rejects.toThrow(
                'Required parameter downloadId was null or undefined when calling getFuturesOrderHistoryDownloadLinkById.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFuturesOrderHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFuturesOrderHistoryDownloadLinkById')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFuturesOrderHistoryDownloadLinkById(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getFuturesTradeDownloadLinkById()', () => {
        it('should execute getFuturesTradeDownloadLinkById() successfully with required parameters only', async () => {
            const params: GetFuturesTradeDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            mockResponse = {
                downloadId: '545923594199212032',
                status: 'completed',
                url: 'www.binance.com',
                notified: true,
                expirationTimestamp: 1645009771000,
                isExpired: null,
            };

            const spy = jest.spyOn(client, 'getFuturesTradeDownloadLinkById').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFuturesTradeDownloadLinkByIdResponse>)
            );
            const response = await client.getFuturesTradeDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFuturesTradeDownloadLinkById() successfully with optional parameters', async () => {
            const params: GetFuturesTradeDownloadLinkByIdRequest = {
                downloadId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                downloadId: '545923594199212032',
                status: 'completed',
                url: 'www.binance.com',
                notified: true,
                expirationTimestamp: 1645009771000,
                isExpired: null,
            };

            const spy = jest.spyOn(client, 'getFuturesTradeDownloadLinkById').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFuturesTradeDownloadLinkByIdResponse>)
            );
            const response = await client.getFuturesTradeDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when downloadId is missing', async () => {
            const _params: GetFuturesTradeDownloadLinkByIdRequest = {
                downloadId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.downloadId;

            await expect(client.getFuturesTradeDownloadLinkById(params)).rejects.toThrow(
                'Required parameter downloadId was null or undefined when calling getFuturesTradeDownloadLinkById.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFuturesTradeDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFuturesTradeDownloadLinkById')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFuturesTradeDownloadLinkById(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getFuturesTransactionHistoryDownloadLinkById()', () => {
        it('should execute getFuturesTransactionHistoryDownloadLinkById() successfully with required parameters only', async () => {
            const params: GetFuturesTransactionHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            mockResponse = {
                downloadId: '545923594199212032',
                status: 'completed',
                url: 'www.binance.com',
                notified: true,
                expirationTimestamp: 1645009771000,
                isExpired: null,
            };

            const spy = jest
                .spyOn(client, 'getFuturesTransactionHistoryDownloadLinkById')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetFuturesTransactionHistoryDownloadLinkByIdResponse>)
                );
            const response = await client.getFuturesTransactionHistoryDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFuturesTransactionHistoryDownloadLinkById() successfully with optional parameters', async () => {
            const params: GetFuturesTransactionHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                downloadId: '545923594199212032',
                status: 'completed',
                url: 'www.binance.com',
                notified: true,
                expirationTimestamp: 1645009771000,
                isExpired: null,
            };

            const spy = jest
                .spyOn(client, 'getFuturesTransactionHistoryDownloadLinkById')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetFuturesTransactionHistoryDownloadLinkByIdResponse>)
                );
            const response = await client.getFuturesTransactionHistoryDownloadLinkById(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when downloadId is missing', async () => {
            const _params: GetFuturesTransactionHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.downloadId;

            await expect(
                client.getFuturesTransactionHistoryDownloadLinkById(params)
            ).rejects.toThrow(
                'Required parameter downloadId was null or undefined when calling getFuturesTransactionHistoryDownloadLinkById.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFuturesTransactionHistoryDownloadLinkByIdRequest = {
                downloadId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFuturesTransactionHistoryDownloadLinkById')
                .mockRejectedValueOnce(mockError);
            await expect(
                client.getFuturesTransactionHistoryDownloadLinkById(params)
            ).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getIncomeHistory()', () => {
        it('should execute getIncomeHistory() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    symbol: '',
                    incomeType: 'TRANSFER',
                    income: '-0.37500000',
                    asset: 'BTC',
                    info: 'WITHDRAW',
                    time: 1570608000000,
                    tranId: '9689322392',
                    tradeId: '',
                },
                {
                    symbol: 'BTCUSD_200925',
                    incomeType: 'COMMISSION',
                    income: '-0.01000000',
                    asset: 'BTC',
                    info: '',
                    time: 1570636800000,
                    tranId: '9689322392',
                    tradeId: '2059192',
                },
            ];

            const spy = jest.spyOn(client, 'getIncomeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetIncomeHistoryResponse>)
            );
            const response = await client.getIncomeHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getIncomeHistory() successfully with optional parameters', async () => {
            const params: GetIncomeHistoryRequest = {
                symbol: 'symbol_example',
                incomeType: 'incomeType_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                page: 789,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: '',
                    incomeType: 'TRANSFER',
                    income: '-0.37500000',
                    asset: 'BTC',
                    info: 'WITHDRAW',
                    time: 1570608000000,
                    tranId: '9689322392',
                    tradeId: '',
                },
                {
                    symbol: 'BTCUSD_200925',
                    incomeType: 'COMMISSION',
                    income: '-0.01000000',
                    asset: 'BTC',
                    info: '',
                    time: 1570636800000,
                    tranId: '9689322392',
                    tradeId: '2059192',
                },
            ];

            const spy = jest.spyOn(client, 'getIncomeHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetIncomeHistoryResponse>)
            );
            const response = await client.getIncomeHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getIncomeHistory').mockRejectedValueOnce(mockError);
            await expect(client.getIncomeHistory()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('notionalBracketForPair()', () => {
        it('should execute notionalBracketForPair() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    pair: 'BTCUSD',
                    brackets: [
                        {
                            bracket: 1,
                            initialLeverage: 125,
                            qtyCap: 50,
                            qtylFloor: 0,
                            maintMarginRatio: 0.004,
                            cum: 0,
                        },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'notionalBracketForPair').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NotionalBracketForPairResponse>)
            );
            const response = await client.notionalBracketForPair();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute notionalBracketForPair() successfully with optional parameters', async () => {
            const params: NotionalBracketForPairRequest = {
                pair: 'pair_example',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    pair: 'BTCUSD',
                    brackets: [
                        {
                            bracket: 1,
                            initialLeverage: 125,
                            qtyCap: 50,
                            qtylFloor: 0,
                            maintMarginRatio: 0.004,
                            cum: 0,
                        },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'notionalBracketForPair').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NotionalBracketForPairResponse>)
            );
            const response = await client.notionalBracketForPair(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'notionalBracketForPair')
                .mockRejectedValueOnce(mockError);
            await expect(client.notionalBracketForPair()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('notionalBracketForSymbol()', () => {
        it('should execute notionalBracketForSymbol() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    symbol: 'BTCUSD_PERP',
                    notionalCoef: 1.5,
                    brackets: [
                        {
                            bracket: 1,
                            initialLeverage: 125,
                            qtyCap: 50,
                            qtylFloor: 0,
                            maintMarginRatio: 0.004,
                            cum: 0,
                        },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'notionalBracketForSymbol').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NotionalBracketForSymbolResponse>)
            );
            const response = await client.notionalBracketForSymbol();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute notionalBracketForSymbol() successfully with optional parameters', async () => {
            const params: NotionalBracketForSymbolRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSD_PERP',
                    notionalCoef: 1.5,
                    brackets: [
                        {
                            bracket: 1,
                            initialLeverage: 125,
                            qtyCap: 50,
                            qtylFloor: 0,
                            maintMarginRatio: 0.004,
                            cum: 0,
                        },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'notionalBracketForSymbol').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NotionalBracketForSymbolResponse>)
            );
            const response = await client.notionalBracketForSymbol(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'notionalBracketForSymbol')
                .mockRejectedValueOnce(mockError);
            await expect(client.notionalBracketForSymbol()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('userCommissionRate()', () => {
        it('should execute userCommissionRate() successfully with required parameters only', async () => {
            const params: UserCommissionRateRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                symbol: 'BTCUSD_PERP',
                makerCommissionRate: '0.00015',
                takerCommissionRate: '0.00040',
            };

            const spy = jest.spyOn(client, 'userCommissionRate').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UserCommissionRateResponse>)
            );
            const response = await client.userCommissionRate(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute userCommissionRate() successfully with optional parameters', async () => {
            const params: UserCommissionRateRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = {
                symbol: 'BTCUSD_PERP',
                makerCommissionRate: '0.00015',
                takerCommissionRate: '0.00040',
            };

            const spy = jest.spyOn(client, 'userCommissionRate').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UserCommissionRateResponse>)
            );
            const response = await client.userCommissionRate(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: UserCommissionRateRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.userCommissionRate(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling userCommissionRate.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: UserCommissionRateRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'userCommissionRate').mockRejectedValueOnce(mockError);
            await expect(client.userCommissionRate(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
