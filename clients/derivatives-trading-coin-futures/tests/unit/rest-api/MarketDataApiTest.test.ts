/**
 * Binance Public Derivatives Trading COIN Futures REST API
 *
 * OpenAPI Specification for the Binance Public Derivatives Trading COIN Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import {
    MarketDataApi,
    BasisContractTypeEnum,
    BasisPeriodEnum,
    ContinuousContractKlineCandlestickDataContractTypeEnum,
    ContinuousContractKlineCandlestickDataIntervalEnum,
    IndexPriceKlineCandlestickDataIntervalEnum,
    KlineCandlestickDataIntervalEnum,
    LongShortRatioPeriodEnum,
    MarkPriceKlineCandlestickDataIntervalEnum,
    OpenInterestStatisticsContractTypeEnum,
    OpenInterestStatisticsPeriodEnum,
    PremiumIndexKlineDataIntervalEnum,
    TakerBuySellVolumeContractTypeEnum,
    TakerBuySellVolumePeriodEnum,
    TopTraderLongShortRatioAccountsPeriodEnum,
    TopTraderLongShortRatioPositionsPeriodEnum,
} from '../../../src/rest-api';
import {
    BasisRequest,
    CompressedAggregateTradesListRequest,
    ContinuousContractKlineCandlestickDataRequest,
    GetFundingRateHistoryOfPerpetualFuturesRequest,
    IndexPriceAndMarkPriceRequest,
    IndexPriceKlineCandlestickDataRequest,
    KlineCandlestickDataRequest,
    LongShortRatioRequest,
    MarkPriceKlineCandlestickDataRequest,
    OldTradesLookupRequest,
    OpenInterestRequest,
    OpenInterestStatisticsRequest,
    OrderBookRequest,
    PremiumIndexKlineDataRequest,
    QueryIndexPriceConstituentsRequest,
    RecentTradesListRequest,
    SymbolOrderBookTickerRequest,
    SymbolPriceTickerRequest,
    TakerBuySellVolumeRequest,
    Ticker24hrPriceChangeStatisticsRequest,
    TopTraderLongShortRatioAccountsRequest,
    TopTraderLongShortRatioPositionsRequest,
} from '../../../src/rest-api';
import type {
    BasisResponse,
    CheckServerTimeResponse,
    CompressedAggregateTradesListResponse,
    ContinuousContractKlineCandlestickDataResponse,
    ExchangeInformationResponse,
    GetFundingRateHistoryOfPerpetualFuturesResponse,
    GetFundingRateInfoResponse,
    IndexPriceAndMarkPriceResponse,
    IndexPriceKlineCandlestickDataResponse,
    KlineCandlestickDataResponse,
    LongShortRatioResponse,
    MarkPriceKlineCandlestickDataResponse,
    OldTradesLookupResponse,
    OpenInterestResponse,
    OpenInterestStatisticsResponse,
    OrderBookResponse,
    PremiumIndexKlineDataResponse,
    QueryIndexPriceConstituentsResponse,
    RecentTradesListResponse,
    SymbolOrderBookTickerResponse,
    SymbolPriceTickerResponse,
    TakerBuySellVolumeResponse,
    Ticker24hrPriceChangeStatisticsResponse,
    TopTraderLongShortRatioAccountsResponse,
    TopTraderLongShortRatioPositionsResponse,
} from '../../../src/rest-api/types';

describe('MarketDataApi', () => {
    let client: MarketDataApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new MarketDataApi(config);
    });

    describe('basis()', () => {
        it('should execute basis() successfully with required parameters only', async () => {
            const params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
            };

            mockResponse = [
                {
                    indexPrice: '29269.93972727',
                    contractType: 'CURRENT_QUARTER',
                    basisRate: '0.0024',
                    futuresPrice: '29341.3',
                    annualizedBasisRate: '0.0283',
                    basis: '71.36027273',
                    pair: 'BTCUSD',
                    timestamp: 1653381600000,
                },
            ];

            const spy = jest.spyOn(client, 'basis').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<BasisResponse>)
            );
            const response = await client.basis(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute basis() successfully with optional parameters', async () => {
            const params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
                limit: 100,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = [
                {
                    indexPrice: '29269.93972727',
                    contractType: 'CURRENT_QUARTER',
                    basisRate: '0.0024',
                    futuresPrice: '29341.3',
                    annualizedBasisRate: '0.0283',
                    basis: '71.36027273',
                    pair: 'BTCUSD',
                    timestamp: 1653381600000,
                },
            ];

            const spy = jest.spyOn(client, 'basis').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<BasisResponse>)
            );
            const response = await client.basis(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when pair is missing', async () => {
            const _params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.pair;

            await expect(client.basis(params)).rejects.toThrow(
                'Required parameter pair was null or undefined when calling basis.'
            );
        });

        it('should throw RequiredError when contractType is missing', async () => {
            const _params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.contractType;

            await expect(client.basis(params)).rejects.toThrow(
                'Required parameter contractType was null or undefined when calling basis.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.basis(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling basis.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: BasisRequest = {
                pair: 'pair_example',
                contractType: BasisContractTypeEnum.PERPETUAL,
                period: BasisPeriodEnum.PERIOD_5m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'basis').mockRejectedValueOnce(mockError);
            await expect(client.basis(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('checkServerTime()', () => {
        it('should execute checkServerTime() successfully with required parameters only', async () => {
            mockResponse = { serverTime: 1499827319559 };

            const spy = jest.spyOn(client, 'checkServerTime').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CheckServerTimeResponse>)
            );
            const response = await client.checkServerTime();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'checkServerTime').mockRejectedValueOnce(mockError);
            await expect(client.checkServerTime()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('compressedAggregateTradesList()', () => {
        it('should execute compressedAggregateTradesList() successfully with required parameters only', async () => {
            const params: CompressedAggregateTradesListRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    a: 416690,
                    p: '9642.4',
                    q: '3',
                    f: 595259,
                    l: 595259,
                    T: 1591250548649,
                    m: false,
                },
            ];

            const spy = jest.spyOn(client, 'compressedAggregateTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CompressedAggregateTradesListResponse>)
            );
            const response = await client.compressedAggregateTradesList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute compressedAggregateTradesList() successfully with optional parameters', async () => {
            const params: CompressedAggregateTradesListRequest = {
                symbol: 'symbol_example',
                fromId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = [
                {
                    a: 416690,
                    p: '9642.4',
                    q: '3',
                    f: 595259,
                    l: 595259,
                    T: 1591250548649,
                    m: false,
                },
            ];

            const spy = jest.spyOn(client, 'compressedAggregateTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CompressedAggregateTradesListResponse>)
            );
            const response = await client.compressedAggregateTradesList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CompressedAggregateTradesListRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.compressedAggregateTradesList(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling compressedAggregateTradesList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CompressedAggregateTradesListRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'compressedAggregateTradesList')
                .mockRejectedValueOnce(mockError);
            await expect(client.compressedAggregateTradesList(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('continuousContractKlineCandlestickData()', () => {
        it('should execute continuousContractKlineCandlestickData() successfully with required parameters only', async () => {
            const params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            mockResponse = [
                [
                    1591258320000,
                    '9640.7',
                    '9642.4',
                    '9640.6',
                    '9642.0',
                    '206',
                    1591258379999,
                    '2.13660389',
                    48,
                    '119',
                    '1.23424865',
                    '0',
                ],
            ];

            const spy = jest
                .spyOn(client, 'continuousContractKlineCandlestickData')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<ContinuousContractKlineCandlestickDataResponse>)
                );
            const response = await client.continuousContractKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute continuousContractKlineCandlestickData() successfully with optional parameters', async () => {
            const params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = [
                [
                    1591258320000,
                    '9640.7',
                    '9642.4',
                    '9640.6',
                    '9642.0',
                    '206',
                    1591258379999,
                    '2.13660389',
                    48,
                    '119',
                    '1.23424865',
                    '0',
                ],
            ];

            const spy = jest
                .spyOn(client, 'continuousContractKlineCandlestickData')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<ContinuousContractKlineCandlestickDataResponse>)
                );
            const response = await client.continuousContractKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when pair is missing', async () => {
            const _params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.pair;

            await expect(client.continuousContractKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter pair was null or undefined when calling continuousContractKlineCandlestickData.'
            );
        });

        it('should throw RequiredError when contractType is missing', async () => {
            const _params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.contractType;

            await expect(client.continuousContractKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter contractType was null or undefined when calling continuousContractKlineCandlestickData.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.continuousContractKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling continuousContractKlineCandlestickData.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ContinuousContractKlineCandlestickDataRequest = {
                pair: 'pair_example',
                contractType: ContinuousContractKlineCandlestickDataContractTypeEnum.PERPETUAL,
                interval: ContinuousContractKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'continuousContractKlineCandlestickData')
                .mockRejectedValueOnce(mockError);
            await expect(client.continuousContractKlineCandlestickData(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('exchangeInformation()', () => {
        it('should execute exchangeInformation() successfully with required parameters only', async () => {
            mockResponse = {
                exchangeFilters: [],
                rateLimits: [
                    {
                        interval: 'MINUTE',
                        intervalNum: 1,
                        limit: 6000,
                        rateLimitType: 'REQUEST_WEIGHT',
                    },
                    { interval: 'MINUTE', intervalNum: 1, limit: 6000, rateLimitType: 'ORDERS' },
                ],
                serverTime: 1565613908500,
                symbols: [
                    {
                        filters: [
                            {
                                filterType: 'PRICE_FILTER',
                                maxPrice: '100000',
                                minPrice: '0.1',
                                tickSize: '0.1',
                            },
                            {
                                filterType: 'LOT_SIZE',
                                maxQty: '100000',
                                minQty: '1',
                                stepSize: '1',
                            },
                            {
                                filterType: 'MARKET_LOT_SIZE',
                                maxQty: '100000',
                                minQty: '1',
                                stepSize: '1',
                            },
                            { filterType: 'MAX_NUM_ORDERS', limit: 200 },
                            {
                                filterType: 'PERCENT_PRICE',
                                multiplierUp: '1.0500',
                                multiplierDown: '0.9500',
                                multiplierDecimal: 4,
                            },
                        ],
                        OrderType: [
                            'LIMIT',
                            'MARKET',
                            'STOP',
                            'TAKE_PROFIT',
                            'TRAILING_STOP_MARKET',
                        ],
                        timeInForce: ['GTC', 'IOC', 'FOK', 'GTX'],
                        liquidationFee: '0.010000',
                        marketTakeBound: '0.30',
                        symbol: 'BTCUSD_200925',
                        pair: 'BTCUSD',
                        contractType: 'CURRENT_QUARTER',
                        deliveryDate: 1601020800000,
                        onboardDate: 1590739200000,
                        contractStatus: 'TRADING',
                        contractSize: 100,
                        quoteAsset: 'USD',
                        baseAsset: 'BTC',
                        marginAsset: 'BTC',
                        pricePrecision: 1,
                        quantityPrecision: 0,
                        baseAssetPrecision: 8,
                        quotePrecision: 8,
                        equalQtyPrecision: 4,
                        triggerProtect: '0.0500',
                        maintMarginPercent: '2.5000',
                        requiredMarginPercent: '5.0000',
                        underlyingType: 'COIN',
                        underlyingSubType: [],
                    },
                ],
                timezone: 'UTC',
            };

            const spy = jest.spyOn(client, 'exchangeInformation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ExchangeInformationResponse>)
            );
            const response = await client.exchangeInformation();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'exchangeInformation').mockRejectedValueOnce(mockError);
            await expect(client.exchangeInformation()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getFundingRateHistoryOfPerpetualFutures()', () => {
        it('should execute getFundingRateHistoryOfPerpetualFutures() successfully with required parameters only', async () => {
            const params: GetFundingRateHistoryOfPerpetualFuturesRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                { symbol: 'BTCUSD_PERP', fundingTime: 1596038400000, fundingRate: '-0.00300000' },
                { symbol: 'BTCUSD_PERP', fundingTime: 1596067200000, fundingRate: '-0.00300000' },
            ];

            const spy = jest
                .spyOn(client, 'getFundingRateHistoryOfPerpetualFutures')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetFundingRateHistoryOfPerpetualFuturesResponse>)
                );
            const response = await client.getFundingRateHistoryOfPerpetualFutures(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFundingRateHistoryOfPerpetualFutures() successfully with optional parameters', async () => {
            const params: GetFundingRateHistoryOfPerpetualFuturesRequest = {
                symbol: 'symbol_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = [
                { symbol: 'BTCUSD_PERP', fundingTime: 1596038400000, fundingRate: '-0.00300000' },
                { symbol: 'BTCUSD_PERP', fundingTime: 1596067200000, fundingRate: '-0.00300000' },
            ];

            const spy = jest
                .spyOn(client, 'getFundingRateHistoryOfPerpetualFutures')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<GetFundingRateHistoryOfPerpetualFuturesResponse>)
                );
            const response = await client.getFundingRateHistoryOfPerpetualFutures(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: GetFundingRateHistoryOfPerpetualFuturesRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.getFundingRateHistoryOfPerpetualFutures(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling getFundingRateHistoryOfPerpetualFutures.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFundingRateHistoryOfPerpetualFuturesRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFundingRateHistoryOfPerpetualFutures')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFundingRateHistoryOfPerpetualFutures(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getFundingRateInfo()', () => {
        it('should execute getFundingRateInfo() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    symbol: 'BLZUSDT',
                    adjustedFundingRateCap: '0.02500000',
                    adjustedFundingRateFloor: '-0.02500000',
                    fundingIntervalHours: 8,
                    disclaimer: false,
                },
            ];

            const spy = jest.spyOn(client, 'getFundingRateInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFundingRateInfoResponse>)
            );
            const response = await client.getFundingRateInfo();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'getFundingRateInfo').mockRejectedValueOnce(mockError);
            await expect(client.getFundingRateInfo()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('indexPriceAndMarkPrice()', () => {
        it('should execute indexPriceAndMarkPrice() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    symbol: 'BTCUSD_PERP',
                    pair: 'BTCUSD',
                    markPrice: '11029.69574559',
                    indexPrice: '10979.14437500',
                    estimatedSettlePrice: '10981.74168236',
                    lastFundingRate: '0.00071003',
                    interestRate: '0.00010000',
                    nextFundingTime: 1596096000000,
                    time: 1596094042000,
                },
                {
                    symbol: 'BTCUSD_200925',
                    pair: 'BTCUSD',
                    markPrice: '12077.01343750',
                    indexPrice: '10979.10312500',
                    estimatedSettlePrice: '10981.74168236',
                    lastFundingRate: '',
                    interestRate: '',
                    nextFundingTime: 0,
                    time: 1596094042000,
                },
            ];

            const spy = jest.spyOn(client, 'indexPriceAndMarkPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<IndexPriceAndMarkPriceResponse>)
            );
            const response = await client.indexPriceAndMarkPrice();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute indexPriceAndMarkPrice() successfully with optional parameters', async () => {
            const params: IndexPriceAndMarkPriceRequest = {
                symbol: 'symbol_example',
                pair: 'pair_example',
            };

            mockResponse = [
                {
                    symbol: 'BTCUSD_PERP',
                    pair: 'BTCUSD',
                    markPrice: '11029.69574559',
                    indexPrice: '10979.14437500',
                    estimatedSettlePrice: '10981.74168236',
                    lastFundingRate: '0.00071003',
                    interestRate: '0.00010000',
                    nextFundingTime: 1596096000000,
                    time: 1596094042000,
                },
                {
                    symbol: 'BTCUSD_200925',
                    pair: 'BTCUSD',
                    markPrice: '12077.01343750',
                    indexPrice: '10979.10312500',
                    estimatedSettlePrice: '10981.74168236',
                    lastFundingRate: '',
                    interestRate: '',
                    nextFundingTime: 0,
                    time: 1596094042000,
                },
            ];

            const spy = jest.spyOn(client, 'indexPriceAndMarkPrice').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<IndexPriceAndMarkPriceResponse>)
            );
            const response = await client.indexPriceAndMarkPrice(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'indexPriceAndMarkPrice')
                .mockRejectedValueOnce(mockError);
            await expect(client.indexPriceAndMarkPrice()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('indexPriceKlineCandlestickData()', () => {
        it('should execute indexPriceKlineCandlestickData() successfully with required parameters only', async () => {
            const params: IndexPriceKlineCandlestickDataRequest = {
                pair: 'pair_example',
                interval: IndexPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            mockResponse = [
                [
                    1591256400000,
                    '9653.69440000',
                    '9653.69640000',
                    '9651.38600000',
                    '9651.55200000',
                    '0',
                    1591256459999,
                    '0',
                    60,
                    '0',
                    '0',
                    '0',
                ],
            ];

            const spy = jest.spyOn(client, 'indexPriceKlineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<IndexPriceKlineCandlestickDataResponse>)
            );
            const response = await client.indexPriceKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute indexPriceKlineCandlestickData() successfully with optional parameters', async () => {
            const params: IndexPriceKlineCandlestickDataRequest = {
                pair: 'pair_example',
                interval: IndexPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = [
                [
                    1591256400000,
                    '9653.69440000',
                    '9653.69640000',
                    '9651.38600000',
                    '9651.55200000',
                    '0',
                    1591256459999,
                    '0',
                    60,
                    '0',
                    '0',
                    '0',
                ],
            ];

            const spy = jest.spyOn(client, 'indexPriceKlineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<IndexPriceKlineCandlestickDataResponse>)
            );
            const response = await client.indexPriceKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when pair is missing', async () => {
            const _params: IndexPriceKlineCandlestickDataRequest = {
                pair: 'pair_example',
                interval: IndexPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.pair;

            await expect(client.indexPriceKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter pair was null or undefined when calling indexPriceKlineCandlestickData.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: IndexPriceKlineCandlestickDataRequest = {
                pair: 'pair_example',
                interval: IndexPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.indexPriceKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling indexPriceKlineCandlestickData.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: IndexPriceKlineCandlestickDataRequest = {
                pair: 'pair_example',
                interval: IndexPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'indexPriceKlineCandlestickData')
                .mockRejectedValueOnce(mockError);
            await expect(client.indexPriceKlineCandlestickData(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('klineCandlestickData()', () => {
        it('should execute klineCandlestickData() successfully with required parameters only', async () => {
            const params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: KlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            mockResponse = [
                [
                    1591258320000,
                    '9640.7',
                    '9642.4',
                    '9640.6',
                    '9642.0',
                    '206',
                    1591258379999,
                    '2.13660389',
                    48,
                    '119',
                    '1.23424865',
                    '0',
                ],
            ];

            const spy = jest.spyOn(client, 'klineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<KlineCandlestickDataResponse>)
            );
            const response = await client.klineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute klineCandlestickData() successfully with optional parameters', async () => {
            const params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: KlineCandlestickDataIntervalEnum.INTERVAL_1m,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = [
                [
                    1591258320000,
                    '9640.7',
                    '9642.4',
                    '9640.6',
                    '9642.0',
                    '206',
                    1591258379999,
                    '2.13660389',
                    48,
                    '119',
                    '1.23424865',
                    '0',
                ],
            ];

            const spy = jest.spyOn(client, 'klineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<KlineCandlestickDataResponse>)
            );
            const response = await client.klineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: KlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.klineCandlestickData(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling klineCandlestickData.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: KlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.klineCandlestickData(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling klineCandlestickData.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: KlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: KlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'klineCandlestickData').mockRejectedValueOnce(mockError);
            await expect(client.klineCandlestickData(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('longShortRatio()', () => {
        it('should execute longShortRatio() successfully with required parameters only', async () => {
            const params: LongShortRatioRequest = {
                pair: 'pair_example',
                period: LongShortRatioPeriodEnum.PERIOD_5m,
            };

            mockResponse = [
                {
                    pair: 'BTCUSD',
                    longShortRatio: '0.1960',
                    longAccount: '0.6622',
                    shortAccount: '0.3378',
                    timestamp: 1583139600000,
                },
                {
                    pair: 'BTCUSD',
                    longShortRatio: '1.9559',
                    longAccount: '0.6617',
                    shortAccount: '0.3382',
                    timestamp: 1583139900000,
                },
            ];

            const spy = jest.spyOn(client, 'longShortRatio').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<LongShortRatioResponse>)
            );
            const response = await client.longShortRatio(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute longShortRatio() successfully with optional parameters', async () => {
            const params: LongShortRatioRequest = {
                pair: 'pair_example',
                period: LongShortRatioPeriodEnum.PERIOD_5m,
                limit: 100,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = [
                {
                    pair: 'BTCUSD',
                    longShortRatio: '0.1960',
                    longAccount: '0.6622',
                    shortAccount: '0.3378',
                    timestamp: 1583139600000,
                },
                {
                    pair: 'BTCUSD',
                    longShortRatio: '1.9559',
                    longAccount: '0.6617',
                    shortAccount: '0.3382',
                    timestamp: 1583139900000,
                },
            ];

            const spy = jest.spyOn(client, 'longShortRatio').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<LongShortRatioResponse>)
            );
            const response = await client.longShortRatio(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when pair is missing', async () => {
            const _params: LongShortRatioRequest = {
                pair: 'pair_example',
                period: LongShortRatioPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.pair;

            await expect(client.longShortRatio(params)).rejects.toThrow(
                'Required parameter pair was null or undefined when calling longShortRatio.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: LongShortRatioRequest = {
                pair: 'pair_example',
                period: LongShortRatioPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.longShortRatio(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling longShortRatio.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: LongShortRatioRequest = {
                pair: 'pair_example',
                period: LongShortRatioPeriodEnum.PERIOD_5m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'longShortRatio').mockRejectedValueOnce(mockError);
            await expect(client.longShortRatio(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('markPriceKlineCandlestickData()', () => {
        it('should execute markPriceKlineCandlestickData() successfully with required parameters only', async () => {
            const params: MarkPriceKlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: MarkPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            mockResponse = [
                [
                    1591256460000,
                    '9653.29201333',
                    '9654.56401333',
                    '9653.07367333',
                    '9653.07367333',
                    '0',
                    1591256519999,
                    '0',
                    60,
                    '0',
                    '0',
                    '0',
                ],
            ];

            const spy = jest.spyOn(client, 'markPriceKlineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarkPriceKlineCandlestickDataResponse>)
            );
            const response = await client.markPriceKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute markPriceKlineCandlestickData() successfully with optional parameters', async () => {
            const params: MarkPriceKlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: MarkPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = [
                [
                    1591256460000,
                    '9653.29201333',
                    '9654.56401333',
                    '9653.07367333',
                    '9653.07367333',
                    '0',
                    1591256519999,
                    '0',
                    60,
                    '0',
                    '0',
                    '0',
                ],
            ];

            const spy = jest.spyOn(client, 'markPriceKlineCandlestickData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarkPriceKlineCandlestickDataResponse>)
            );
            const response = await client.markPriceKlineCandlestickData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MarkPriceKlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: MarkPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.markPriceKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling markPriceKlineCandlestickData.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: MarkPriceKlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: MarkPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.markPriceKlineCandlestickData(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling markPriceKlineCandlestickData.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MarkPriceKlineCandlestickDataRequest = {
                symbol: 'symbol_example',
                interval: MarkPriceKlineCandlestickDataIntervalEnum.INTERVAL_1m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'markPriceKlineCandlestickData')
                .mockRejectedValueOnce(mockError);
            await expect(client.markPriceKlineCandlestickData(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('oldTradesLookup()', () => {
        it('should execute oldTradesLookup() successfully with required parameters only', async () => {
            const params: OldTradesLookupRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    id: 595103,
                    price: '9642.2',
                    qty: '1',
                    baseQty: '0.01037108',
                    time: 1499865549590,
                    isBuyerMaker: true,
                },
            ];

            const spy = jest.spyOn(client, 'oldTradesLookup').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OldTradesLookupResponse>)
            );
            const response = await client.oldTradesLookup(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute oldTradesLookup() successfully with optional parameters', async () => {
            const params: OldTradesLookupRequest = {
                symbol: 'symbol_example',
                limit: 100,
                fromId: 1,
            };

            mockResponse = [
                {
                    id: 595103,
                    price: '9642.2',
                    qty: '1',
                    baseQty: '0.01037108',
                    time: 1499865549590,
                    isBuyerMaker: true,
                },
            ];

            const spy = jest.spyOn(client, 'oldTradesLookup').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OldTradesLookupResponse>)
            );
            const response = await client.oldTradesLookup(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OldTradesLookupRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.oldTradesLookup(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling oldTradesLookup.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OldTradesLookupRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'oldTradesLookup').mockRejectedValueOnce(mockError);
            await expect(client.oldTradesLookup(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('openInterest()', () => {
        it('should execute openInterest() successfully with required parameters only', async () => {
            const params: OpenInterestRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                symbol: 'BTCUSD_200626',
                pair: 'BTCUSD',
                openInterest: '15004',
                contractType: 'CURRENT_QUARTER',
                time: 1591261042378,
            };

            const spy = jest.spyOn(client, 'openInterest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenInterestResponse>)
            );
            const response = await client.openInterest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute openInterest() successfully with optional parameters', async () => {
            const params: OpenInterestRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                symbol: 'BTCUSD_200626',
                pair: 'BTCUSD',
                openInterest: '15004',
                contractType: 'CURRENT_QUARTER',
                time: 1591261042378,
            };

            const spy = jest.spyOn(client, 'openInterest').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenInterestResponse>)
            );
            const response = await client.openInterest(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OpenInterestRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.openInterest(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling openInterest.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OpenInterestRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'openInterest').mockRejectedValueOnce(mockError);
            await expect(client.openInterest(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('openInterestStatistics()', () => {
        it('should execute openInterestStatistics() successfully with required parameters only', async () => {
            const params: OpenInterestStatisticsRequest = {
                pair: 'pair_example',
                contractType: OpenInterestStatisticsContractTypeEnum.PERPETUAL,
                period: OpenInterestStatisticsPeriodEnum.PERIOD_5m,
            };

            mockResponse = [
                {
                    pair: 'BTCUSD',
                    contractType: 'CURRENT_QUARTER',
                    sumOpenInterest: '20403',
                    sumOpenInterestValue: '176196512.23400000',
                    timestamp: 1591261042378,
                },
                {
                    pair: 'BTCUSD',
                    contractType: 'CURRENT_QUARTER',
                    sumOpenInterest: '20401',
                    sumOpenInterestValue: '176178704.98700000',
                    timestamp: 1583128200000,
                },
            ];

            const spy = jest.spyOn(client, 'openInterestStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenInterestStatisticsResponse>)
            );
            const response = await client.openInterestStatistics(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute openInterestStatistics() successfully with optional parameters', async () => {
            const params: OpenInterestStatisticsRequest = {
                pair: 'pair_example',
                contractType: OpenInterestStatisticsContractTypeEnum.PERPETUAL,
                period: OpenInterestStatisticsPeriodEnum.PERIOD_5m,
                limit: 100,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = [
                {
                    pair: 'BTCUSD',
                    contractType: 'CURRENT_QUARTER',
                    sumOpenInterest: '20403',
                    sumOpenInterestValue: '176196512.23400000',
                    timestamp: 1591261042378,
                },
                {
                    pair: 'BTCUSD',
                    contractType: 'CURRENT_QUARTER',
                    sumOpenInterest: '20401',
                    sumOpenInterestValue: '176178704.98700000',
                    timestamp: 1583128200000,
                },
            ];

            const spy = jest.spyOn(client, 'openInterestStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OpenInterestStatisticsResponse>)
            );
            const response = await client.openInterestStatistics(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when pair is missing', async () => {
            const _params: OpenInterestStatisticsRequest = {
                pair: 'pair_example',
                contractType: OpenInterestStatisticsContractTypeEnum.PERPETUAL,
                period: OpenInterestStatisticsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.pair;

            await expect(client.openInterestStatistics(params)).rejects.toThrow(
                'Required parameter pair was null or undefined when calling openInterestStatistics.'
            );
        });

        it('should throw RequiredError when contractType is missing', async () => {
            const _params: OpenInterestStatisticsRequest = {
                pair: 'pair_example',
                contractType: OpenInterestStatisticsContractTypeEnum.PERPETUAL,
                period: OpenInterestStatisticsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.contractType;

            await expect(client.openInterestStatistics(params)).rejects.toThrow(
                'Required parameter contractType was null or undefined when calling openInterestStatistics.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: OpenInterestStatisticsRequest = {
                pair: 'pair_example',
                contractType: OpenInterestStatisticsContractTypeEnum.PERPETUAL,
                period: OpenInterestStatisticsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.openInterestStatistics(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling openInterestStatistics.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OpenInterestStatisticsRequest = {
                pair: 'pair_example',
                contractType: OpenInterestStatisticsContractTypeEnum.PERPETUAL,
                period: OpenInterestStatisticsPeriodEnum.PERIOD_5m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'openInterestStatistics')
                .mockRejectedValueOnce(mockError);
            await expect(client.openInterestStatistics(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('orderBook()', () => {
        it('should execute orderBook() successfully with required parameters only', async () => {
            const params: OrderBookRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                lastUpdateId: 16769853,
                symbol: 'BTCUSD_PERP',
                pair: 'BTCUSD',
                E: 1591250106370,
                T: 1591250106368,
                bids: [['9638.0', '431']],
                asks: [['9638.2', '12']],
            };

            const spy = jest.spyOn(client, 'orderBook').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderBookResponse>)
            );
            const response = await client.orderBook(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute orderBook() successfully with optional parameters', async () => {
            const params: OrderBookRequest = {
                symbol: 'symbol_example',
                limit: 100,
            };

            mockResponse = {
                lastUpdateId: 16769853,
                symbol: 'BTCUSD_PERP',
                pair: 'BTCUSD',
                E: 1591250106370,
                T: 1591250106368,
                bids: [['9638.0', '431']],
                asks: [['9638.2', '12']],
            };

            const spy = jest.spyOn(client, 'orderBook').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<OrderBookResponse>)
            );
            const response = await client.orderBook(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: OrderBookRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.orderBook(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling orderBook.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: OrderBookRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'orderBook').mockRejectedValueOnce(mockError);
            await expect(client.orderBook(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('premiumIndexKlineData()', () => {
        it('should execute premiumIndexKlineData() successfully with required parameters only', async () => {
            const params: PremiumIndexKlineDataRequest = {
                symbol: 'symbol_example',
                interval: PremiumIndexKlineDataIntervalEnum.INTERVAL_1m,
            };

            mockResponse = [
                [
                    1691603820000,
                    '-0.00042931',
                    '-0.00023641',
                    '-0.00059406',
                    '-0.00043659',
                    '0',
                    1691603879999,
                    '0',
                    12,
                    '0',
                    '0',
                    '0',
                ],
            ];

            const spy = jest.spyOn(client, 'premiumIndexKlineData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PremiumIndexKlineDataResponse>)
            );
            const response = await client.premiumIndexKlineData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute premiumIndexKlineData() successfully with optional parameters', async () => {
            const params: PremiumIndexKlineDataRequest = {
                symbol: 'symbol_example',
                interval: PremiumIndexKlineDataIntervalEnum.INTERVAL_1m,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
            };

            mockResponse = [
                [
                    1691603820000,
                    '-0.00042931',
                    '-0.00023641',
                    '-0.00059406',
                    '-0.00043659',
                    '0',
                    1691603879999,
                    '0',
                    12,
                    '0',
                    '0',
                    '0',
                ],
            ];

            const spy = jest.spyOn(client, 'premiumIndexKlineData').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PremiumIndexKlineDataResponse>)
            );
            const response = await client.premiumIndexKlineData(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: PremiumIndexKlineDataRequest = {
                symbol: 'symbol_example',
                interval: PremiumIndexKlineDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.premiumIndexKlineData(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling premiumIndexKlineData.'
            );
        });

        it('should throw RequiredError when interval is missing', async () => {
            const _params: PremiumIndexKlineDataRequest = {
                symbol: 'symbol_example',
                interval: PremiumIndexKlineDataIntervalEnum.INTERVAL_1m,
            };
            const params = Object.assign({ ..._params });
            delete params?.interval;

            await expect(client.premiumIndexKlineData(params)).rejects.toThrow(
                'Required parameter interval was null or undefined when calling premiumIndexKlineData.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: PremiumIndexKlineDataRequest = {
                symbol: 'symbol_example',
                interval: PremiumIndexKlineDataIntervalEnum.INTERVAL_1m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'premiumIndexKlineData')
                .mockRejectedValueOnce(mockError);
            await expect(client.premiumIndexKlineData(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryIndexPriceConstituents()', () => {
        it('should execute queryIndexPriceConstituents() successfully with required parameters only', async () => {
            const params: QueryIndexPriceConstituentsRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                symbol: 'BTCUSD',
                time: 1697422647853,
                constituents: [
                    { exchange: 'bitstamp', symbol: 'btcusd' },
                    { exchange: 'coinbase', symbol: 'BTC-USD' },
                    { exchange: 'kraken', symbol: 'XBT/USD' },
                    { exchange: 'binance_cross', symbol: 'BTCUSDC*index(USDCUSD)' },
                ],
            };

            const spy = jest.spyOn(client, 'queryIndexPriceConstituents').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryIndexPriceConstituentsResponse>)
            );
            const response = await client.queryIndexPriceConstituents(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryIndexPriceConstituents() successfully with optional parameters', async () => {
            const params: QueryIndexPriceConstituentsRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                symbol: 'BTCUSD',
                time: 1697422647853,
                constituents: [
                    { exchange: 'bitstamp', symbol: 'btcusd' },
                    { exchange: 'coinbase', symbol: 'BTC-USD' },
                    { exchange: 'kraken', symbol: 'XBT/USD' },
                    { exchange: 'binance_cross', symbol: 'BTCUSDC*index(USDCUSD)' },
                ],
            };

            const spy = jest.spyOn(client, 'queryIndexPriceConstituents').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryIndexPriceConstituentsResponse>)
            );
            const response = await client.queryIndexPriceConstituents(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryIndexPriceConstituentsRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryIndexPriceConstituents(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryIndexPriceConstituents.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryIndexPriceConstituentsRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryIndexPriceConstituents')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryIndexPriceConstituents(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('recentTradesList()', () => {
        it('should execute recentTradesList() successfully with required parameters only', async () => {
            const params: RecentTradesListRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    id: 28457,
                    price: '9635.0',
                    qty: '1',
                    baseQty: '0.01037883',
                    time: 1591250192508,
                    isBuyerMaker: true,
                },
            ];

            const spy = jest.spyOn(client, 'recentTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RecentTradesListResponse>)
            );
            const response = await client.recentTradesList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute recentTradesList() successfully with optional parameters', async () => {
            const params: RecentTradesListRequest = {
                symbol: 'symbol_example',
                limit: 100,
            };

            mockResponse = [
                {
                    id: 28457,
                    price: '9635.0',
                    qty: '1',
                    baseQty: '0.01037883',
                    time: 1591250192508,
                    isBuyerMaker: true,
                },
            ];

            const spy = jest.spyOn(client, 'recentTradesList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RecentTradesListResponse>)
            );
            const response = await client.recentTradesList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: RecentTradesListRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.recentTradesList(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling recentTradesList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: RecentTradesListRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'recentTradesList').mockRejectedValueOnce(mockError);
            await expect(client.recentTradesList(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('symbolOrderBookTicker()', () => {
        it('should execute symbolOrderBookTicker() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    lastUpdateId: 1027024,
                    symbol: 'BTCUSD_200626',
                    pair: 'BTCUSD',
                    bidPrice: '9650.1',
                    bidQty: '16',
                    askPrice: '9650.3',
                    askQty: '7',
                    time: 1591257300345,
                },
            ];

            const spy = jest.spyOn(client, 'symbolOrderBookTicker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolOrderBookTickerResponse>)
            );
            const response = await client.symbolOrderBookTicker();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute symbolOrderBookTicker() successfully with optional parameters', async () => {
            const params: SymbolOrderBookTickerRequest = {
                symbol: 'symbol_example',
                pair: 'pair_example',
            };

            mockResponse = [
                {
                    lastUpdateId: 1027024,
                    symbol: 'BTCUSD_200626',
                    pair: 'BTCUSD',
                    bidPrice: '9650.1',
                    bidQty: '16',
                    askPrice: '9650.3',
                    askQty: '7',
                    time: 1591257300345,
                },
            ];

            const spy = jest.spyOn(client, 'symbolOrderBookTicker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolOrderBookTickerResponse>)
            );
            const response = await client.symbolOrderBookTicker(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'symbolOrderBookTicker')
                .mockRejectedValueOnce(mockError);
            await expect(client.symbolOrderBookTicker()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('symbolPriceTicker()', () => {
        it('should execute symbolPriceTicker() successfully with required parameters only', async () => {
            mockResponse = [
                { symbol: 'BTCUSD_200626', ps: '9647.8', price: '9647.8', time: 1591257246176 },
            ];

            const spy = jest.spyOn(client, 'symbolPriceTicker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolPriceTickerResponse>)
            );
            const response = await client.symbolPriceTicker();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute symbolPriceTicker() successfully with optional parameters', async () => {
            const params: SymbolPriceTickerRequest = {
                symbol: 'symbol_example',
                pair: 'pair_example',
            };

            mockResponse = [
                { symbol: 'BTCUSD_200626', ps: '9647.8', price: '9647.8', time: 1591257246176 },
            ];

            const spy = jest.spyOn(client, 'symbolPriceTicker').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SymbolPriceTickerResponse>)
            );
            const response = await client.symbolPriceTicker(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'symbolPriceTicker').mockRejectedValueOnce(mockError);
            await expect(client.symbolPriceTicker()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('takerBuySellVolume()', () => {
        it('should execute takerBuySellVolume() successfully with required parameters only', async () => {
            const params: TakerBuySellVolumeRequest = {
                pair: 'pair_example',
                contractType: TakerBuySellVolumeContractTypeEnum.PERPETUAL,
                period: TakerBuySellVolumePeriodEnum.PERIOD_5m,
            };

            mockResponse = [
                {
                    pair: 'BTCUSD',
                    contractType: 'CURRENT_QUARTER',
                    takerBuyVol: '387',
                    takerSellVol: '248',
                    takerBuyVolValue: '2342.1220',
                    takerSellVolValue: '4213.9800',
                    timestamp: 1591261042378,
                },
                {
                    pair: 'BTCUSD',
                    contractType: 'CURRENT_QUARTER',
                    takerBuyVol: '234',
                    takerSellVol: '121',
                    takerBuyVolValue: '4563.1320',
                    takerSellVolValue: '3313.3940',
                    timestamp: 1585615200000,
                },
            ];

            const spy = jest.spyOn(client, 'takerBuySellVolume').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TakerBuySellVolumeResponse>)
            );
            const response = await client.takerBuySellVolume(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute takerBuySellVolume() successfully with optional parameters', async () => {
            const params: TakerBuySellVolumeRequest = {
                pair: 'pair_example',
                contractType: TakerBuySellVolumeContractTypeEnum.PERPETUAL,
                period: TakerBuySellVolumePeriodEnum.PERIOD_5m,
                limit: 100,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = [
                {
                    pair: 'BTCUSD',
                    contractType: 'CURRENT_QUARTER',
                    takerBuyVol: '387',
                    takerSellVol: '248',
                    takerBuyVolValue: '2342.1220',
                    takerSellVolValue: '4213.9800',
                    timestamp: 1591261042378,
                },
                {
                    pair: 'BTCUSD',
                    contractType: 'CURRENT_QUARTER',
                    takerBuyVol: '234',
                    takerSellVol: '121',
                    takerBuyVolValue: '4563.1320',
                    takerSellVolValue: '3313.3940',
                    timestamp: 1585615200000,
                },
            ];

            const spy = jest.spyOn(client, 'takerBuySellVolume').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TakerBuySellVolumeResponse>)
            );
            const response = await client.takerBuySellVolume(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when pair is missing', async () => {
            const _params: TakerBuySellVolumeRequest = {
                pair: 'pair_example',
                contractType: TakerBuySellVolumeContractTypeEnum.PERPETUAL,
                period: TakerBuySellVolumePeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.pair;

            await expect(client.takerBuySellVolume(params)).rejects.toThrow(
                'Required parameter pair was null or undefined when calling takerBuySellVolume.'
            );
        });

        it('should throw RequiredError when contractType is missing', async () => {
            const _params: TakerBuySellVolumeRequest = {
                pair: 'pair_example',
                contractType: TakerBuySellVolumeContractTypeEnum.PERPETUAL,
                period: TakerBuySellVolumePeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.contractType;

            await expect(client.takerBuySellVolume(params)).rejects.toThrow(
                'Required parameter contractType was null or undefined when calling takerBuySellVolume.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: TakerBuySellVolumeRequest = {
                pair: 'pair_example',
                contractType: TakerBuySellVolumeContractTypeEnum.PERPETUAL,
                period: TakerBuySellVolumePeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.takerBuySellVolume(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling takerBuySellVolume.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TakerBuySellVolumeRequest = {
                pair: 'pair_example',
                contractType: TakerBuySellVolumeContractTypeEnum.PERPETUAL,
                period: TakerBuySellVolumePeriodEnum.PERIOD_5m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'takerBuySellVolume').mockRejectedValueOnce(mockError);
            await expect(client.takerBuySellVolume(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('testConnectivity()', () => {
        it('should execute testConnectivity() successfully with required parameters only', async () => {
            const spy = jest.spyOn(client, 'testConnectivity').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<void>)
            );
            const response = await client.testConnectivity();

            await expect(response.data()).resolves.toBeUndefined();
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'testConnectivity').mockRejectedValueOnce(mockError);
            await expect(client.testConnectivity()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('ticker24hrPriceChangeStatistics()', () => {
        it('should execute ticker24hrPriceChangeStatistics() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    symbol: 'BTCUSD_200925',
                    pair: 'BTCUSD',
                    priceChange: '136.6',
                    priceChangePercent: '1.436',
                    weightedAvgPrice: '9547.3',
                    lastPrice: '9651.6',
                    lastQty: '1',
                    openPrice: '9515.0',
                    highPrice: '9687.0',
                    lowPrice: '9499.5',
                    volume: '494109',
                    baseVolume: '5192.94797687',
                    openTime: 1591170300000,
                    closeTime: 1591256718418,
                    firstId: 600507,
                    lastId: 697803,
                    count: 97297,
                },
            ];

            const spy = jest.spyOn(client, 'ticker24hrPriceChangeStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<Ticker24hrPriceChangeStatisticsResponse>)
            );
            const response = await client.ticker24hrPriceChangeStatistics();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute ticker24hrPriceChangeStatistics() successfully with optional parameters', async () => {
            const params: Ticker24hrPriceChangeStatisticsRequest = {
                symbol: 'symbol_example',
                pair: 'pair_example',
            };

            mockResponse = [
                {
                    symbol: 'BTCUSD_200925',
                    pair: 'BTCUSD',
                    priceChange: '136.6',
                    priceChangePercent: '1.436',
                    weightedAvgPrice: '9547.3',
                    lastPrice: '9651.6',
                    lastQty: '1',
                    openPrice: '9515.0',
                    highPrice: '9687.0',
                    lowPrice: '9499.5',
                    volume: '494109',
                    baseVolume: '5192.94797687',
                    openTime: 1591170300000,
                    closeTime: 1591256718418,
                    firstId: 600507,
                    lastId: 697803,
                    count: 97297,
                },
            ];

            const spy = jest.spyOn(client, 'ticker24hrPriceChangeStatistics').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<Ticker24hrPriceChangeStatisticsResponse>)
            );
            const response = await client.ticker24hrPriceChangeStatistics(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'ticker24hrPriceChangeStatistics')
                .mockRejectedValueOnce(mockError);
            await expect(client.ticker24hrPriceChangeStatistics()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('topTraderLongShortRatioAccounts()', () => {
        it('should execute topTraderLongShortRatioAccounts() successfully with required parameters only', async () => {
            const params: TopTraderLongShortRatioAccountsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioAccountsPeriodEnum.PERIOD_5m,
            };

            mockResponse = [
                {
                    pair: 'BTCUSD',
                    longShortRatio: '1.8105',
                    longAccount: '0.6442',
                    shortAccount: '0.3558',
                    timestamp: 1591261042378,
                },
                {
                    pair: 'BTCUSD',
                    longShortRatio: '1.1110',
                    longAccount: '0.5263',
                    shortAccount: '0.4737',
                    timestamp: 1592870400000,
                },
            ];

            const spy = jest.spyOn(client, 'topTraderLongShortRatioAccounts').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TopTraderLongShortRatioAccountsResponse>)
            );
            const response = await client.topTraderLongShortRatioAccounts(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute topTraderLongShortRatioAccounts() successfully with optional parameters', async () => {
            const params: TopTraderLongShortRatioAccountsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioAccountsPeriodEnum.PERIOD_5m,
                limit: 100,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = [
                {
                    pair: 'BTCUSD',
                    longShortRatio: '1.8105',
                    longAccount: '0.6442',
                    shortAccount: '0.3558',
                    timestamp: 1591261042378,
                },
                {
                    pair: 'BTCUSD',
                    longShortRatio: '1.1110',
                    longAccount: '0.5263',
                    shortAccount: '0.4737',
                    timestamp: 1592870400000,
                },
            ];

            const spy = jest.spyOn(client, 'topTraderLongShortRatioAccounts').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TopTraderLongShortRatioAccountsResponse>)
            );
            const response = await client.topTraderLongShortRatioAccounts(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: TopTraderLongShortRatioAccountsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioAccountsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.topTraderLongShortRatioAccounts(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling topTraderLongShortRatioAccounts.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: TopTraderLongShortRatioAccountsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioAccountsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.topTraderLongShortRatioAccounts(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling topTraderLongShortRatioAccounts.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TopTraderLongShortRatioAccountsRequest = {
                symbol: 'symbol_example',
                period: TopTraderLongShortRatioAccountsPeriodEnum.PERIOD_5m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'topTraderLongShortRatioAccounts')
                .mockRejectedValueOnce(mockError);
            await expect(client.topTraderLongShortRatioAccounts(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('topTraderLongShortRatioPositions()', () => {
        it('should execute topTraderLongShortRatioPositions() successfully with required parameters only', async () => {
            const params: TopTraderLongShortRatioPositionsRequest = {
                pair: 'pair_example',
                period: TopTraderLongShortRatioPositionsPeriodEnum.PERIOD_5m,
            };

            mockResponse = [
                {
                    pair: 'BTCUSD',
                    longShortRatio: '0.7869',
                    longPosition: '0.6442',
                    shortPosition: '0.4404',
                    timestamp: 1592870400000,
                },
                {
                    pair: 'BTCUSD',
                    longShortRatio: '1.1231',
                    longPosition: '0.2363',
                    shortPosition: '0.4537',
                    timestamp: 1592956800000,
                },
            ];

            const spy = jest.spyOn(client, 'topTraderLongShortRatioPositions').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TopTraderLongShortRatioPositionsResponse>)
            );
            const response = await client.topTraderLongShortRatioPositions(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute topTraderLongShortRatioPositions() successfully with optional parameters', async () => {
            const params: TopTraderLongShortRatioPositionsRequest = {
                pair: 'pair_example',
                period: TopTraderLongShortRatioPositionsPeriodEnum.PERIOD_5m,
                limit: 100,
                startTime: 1623319461670,
                endTime: 1641782889000,
            };

            mockResponse = [
                {
                    pair: 'BTCUSD',
                    longShortRatio: '0.7869',
                    longPosition: '0.6442',
                    shortPosition: '0.4404',
                    timestamp: 1592870400000,
                },
                {
                    pair: 'BTCUSD',
                    longShortRatio: '1.1231',
                    longPosition: '0.2363',
                    shortPosition: '0.4537',
                    timestamp: 1592956800000,
                },
            ];

            const spy = jest.spyOn(client, 'topTraderLongShortRatioPositions').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<TopTraderLongShortRatioPositionsResponse>)
            );
            const response = await client.topTraderLongShortRatioPositions(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when pair is missing', async () => {
            const _params: TopTraderLongShortRatioPositionsRequest = {
                pair: 'pair_example',
                period: TopTraderLongShortRatioPositionsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.pair;

            await expect(client.topTraderLongShortRatioPositions(params)).rejects.toThrow(
                'Required parameter pair was null or undefined when calling topTraderLongShortRatioPositions.'
            );
        });

        it('should throw RequiredError when period is missing', async () => {
            const _params: TopTraderLongShortRatioPositionsRequest = {
                pair: 'pair_example',
                period: TopTraderLongShortRatioPositionsPeriodEnum.PERIOD_5m,
            };
            const params = Object.assign({ ..._params });
            delete params?.period;

            await expect(client.topTraderLongShortRatioPositions(params)).rejects.toThrow(
                'Required parameter period was null or undefined when calling topTraderLongShortRatioPositions.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: TopTraderLongShortRatioPositionsRequest = {
                pair: 'pair_example',
                period: TopTraderLongShortRatioPositionsPeriodEnum.PERIOD_5m,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'topTraderLongShortRatioPositions')
                .mockRejectedValueOnce(mockError);
            await expect(client.topTraderLongShortRatioPositions(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });
});
