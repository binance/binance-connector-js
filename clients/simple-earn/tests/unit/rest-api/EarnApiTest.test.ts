/**
 * Binance Public Simple Earn REST API
 *
 * OpenAPI Specification for the Binance Public Simple Earn REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { EarnApi } from '../../../src/rest-api';
import {
    GetFlexibleSubscriptionPreviewRequest,
    GetLockedSubscriptionPreviewRequest,
    RedeemFlexibleProductRequest,
    RedeemLockedProductRequest,
    SetFlexibleAutoSubscribeRequest,
    SetLockedAutoSubscribeRequest,
    SetLockedProductRedeemOptionRequest,
    SubscribeFlexibleProductRequest,
    SubscribeLockedProductRequest,
} from '../../../src/rest-api';
import type {
    GetFlexibleSubscriptionPreviewResponse,
    GetLockedSubscriptionPreviewResponse,
    RedeemFlexibleProductResponse,
    RedeemLockedProductResponse,
    SetFlexibleAutoSubscribeResponse,
    SetLockedAutoSubscribeResponse,
    SetLockedProductRedeemOptionResponse,
    SubscribeFlexibleProductResponse,
    SubscribeLockedProductResponse,
} from '../../../src/rest-api/types';

describe('EarnApi', () => {
    let client: EarnApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new EarnApi(config);
    });

    describe('getFlexibleSubscriptionPreview()', () => {
        it('should execute getFlexibleSubscriptionPreview() successfully with required parameters only', async () => {
            const params: GetFlexibleSubscriptionPreviewRequest = {
                productId: '1',
                amount: 1,
            };

            mockResponse = {
                totalAmount: '1232.32230982',
                rewardAsset: 'BUSD',
                airDropAsset: 'BETH',
                estDailyBonusRewards: '0.22759183',
                estDailyRealTimeRewards: '0.22759183',
                estDailyAirdropRewards: '0.22759183',
            };

            const spy = jest.spyOn(client, 'getFlexibleSubscriptionPreview').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleSubscriptionPreviewResponse>)
            );
            const response = await client.getFlexibleSubscriptionPreview(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getFlexibleSubscriptionPreview() successfully with optional parameters', async () => {
            const params: GetFlexibleSubscriptionPreviewRequest = {
                productId: '1',
                amount: 1,
                recvWindow: 5000,
            };

            mockResponse = {
                totalAmount: '1232.32230982',
                rewardAsset: 'BUSD',
                airDropAsset: 'BETH',
                estDailyBonusRewards: '0.22759183',
                estDailyRealTimeRewards: '0.22759183',
                estDailyAirdropRewards: '0.22759183',
            };

            const spy = jest.spyOn(client, 'getFlexibleSubscriptionPreview').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetFlexibleSubscriptionPreviewResponse>)
            );
            const response = await client.getFlexibleSubscriptionPreview(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when productId is missing', async () => {
            const _params: GetFlexibleSubscriptionPreviewRequest = {
                productId: '1',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.productId;

            await expect(client.getFlexibleSubscriptionPreview(params)).rejects.toThrow(
                'Required parameter productId was null or undefined when calling getFlexibleSubscriptionPreview.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: GetFlexibleSubscriptionPreviewRequest = {
                productId: '1',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.getFlexibleSubscriptionPreview(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling getFlexibleSubscriptionPreview.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetFlexibleSubscriptionPreviewRequest = {
                productId: '1',
                amount: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getFlexibleSubscriptionPreview')
                .mockRejectedValueOnce(mockError);
            await expect(client.getFlexibleSubscriptionPreview(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getLockedSubscriptionPreview()', () => {
        it('should execute getLockedSubscriptionPreview() successfully with required parameters only', async () => {
            const params: GetLockedSubscriptionPreviewRequest = {
                projectId: '1',
                amount: 1,
            };

            mockResponse = [
                {
                    rewardAsset: 'AXS',
                    totalRewardAmt: '5.17181528',
                    extraRewardAsset: 'BNB',
                    estTotalExtraRewardAmt: '5.17181528',
                    boostRewardAsset: 'AXS',
                    estDailyRewardAmt: '1.20928901',
                    nextPay: '1.29295383',
                    nextPayDate: '1646697600000',
                    valueDate: '1646697600000',
                    rewardsEndDate: '1651449600000',
                    deliverDate: '1651536000000',
                    nextSubscriptionDate: '1651536000000',
                },
            ];

            const spy = jest.spyOn(client, 'getLockedSubscriptionPreview').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLockedSubscriptionPreviewResponse>)
            );
            const response = await client.getLockedSubscriptionPreview(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getLockedSubscriptionPreview() successfully with optional parameters', async () => {
            const params: GetLockedSubscriptionPreviewRequest = {
                projectId: '1',
                amount: 1,
                autoSubscribe: true,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    rewardAsset: 'AXS',
                    totalRewardAmt: '5.17181528',
                    extraRewardAsset: 'BNB',
                    estTotalExtraRewardAmt: '5.17181528',
                    boostRewardAsset: 'AXS',
                    estDailyRewardAmt: '1.20928901',
                    nextPay: '1.29295383',
                    nextPayDate: '1646697600000',
                    valueDate: '1646697600000',
                    rewardsEndDate: '1651449600000',
                    deliverDate: '1651536000000',
                    nextSubscriptionDate: '1651536000000',
                },
            ];

            const spy = jest.spyOn(client, 'getLockedSubscriptionPreview').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetLockedSubscriptionPreviewResponse>)
            );
            const response = await client.getLockedSubscriptionPreview(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when projectId is missing', async () => {
            const _params: GetLockedSubscriptionPreviewRequest = {
                projectId: '1',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.projectId;

            await expect(client.getLockedSubscriptionPreview(params)).rejects.toThrow(
                'Required parameter projectId was null or undefined when calling getLockedSubscriptionPreview.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: GetLockedSubscriptionPreviewRequest = {
                projectId: '1',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.getLockedSubscriptionPreview(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling getLockedSubscriptionPreview.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: GetLockedSubscriptionPreviewRequest = {
                projectId: '1',
                amount: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getLockedSubscriptionPreview')
                .mockRejectedValueOnce(mockError);
            await expect(client.getLockedSubscriptionPreview(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('redeemFlexibleProduct()', () => {
        it('should execute redeemFlexibleProduct() successfully with required parameters only', async () => {
            const params: RedeemFlexibleProductRequest = {
                productId: '1',
            };

            mockResponse = { redeemId: 40607, success: true };

            const spy = jest.spyOn(client, 'redeemFlexibleProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RedeemFlexibleProductResponse>)
            );
            const response = await client.redeemFlexibleProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute redeemFlexibleProduct() successfully with optional parameters', async () => {
            const params: RedeemFlexibleProductRequest = {
                productId: '1',
                redeemAll: false,
                amount: 1,
                destAccount: 'SPOT',
                recvWindow: 5000,
            };

            mockResponse = { redeemId: 40607, success: true };

            const spy = jest.spyOn(client, 'redeemFlexibleProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RedeemFlexibleProductResponse>)
            );
            const response = await client.redeemFlexibleProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when productId is missing', async () => {
            const _params: RedeemFlexibleProductRequest = {
                productId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.productId;

            await expect(client.redeemFlexibleProduct(params)).rejects.toThrow(
                'Required parameter productId was null or undefined when calling redeemFlexibleProduct.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: RedeemFlexibleProductRequest = {
                productId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'redeemFlexibleProduct')
                .mockRejectedValueOnce(mockError);
            await expect(client.redeemFlexibleProduct(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('redeemLockedProduct()', () => {
        it('should execute redeemLockedProduct() successfully with required parameters only', async () => {
            const params: RedeemLockedProductRequest = {
                positionId: '1',
            };

            mockResponse = { redeemId: 40607, success: true };

            const spy = jest.spyOn(client, 'redeemLockedProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RedeemLockedProductResponse>)
            );
            const response = await client.redeemLockedProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute redeemLockedProduct() successfully with optional parameters', async () => {
            const params: RedeemLockedProductRequest = {
                positionId: '1',
                recvWindow: 5000,
            };

            mockResponse = { redeemId: 40607, success: true };

            const spy = jest.spyOn(client, 'redeemLockedProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RedeemLockedProductResponse>)
            );
            const response = await client.redeemLockedProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when positionId is missing', async () => {
            const _params: RedeemLockedProductRequest = {
                positionId: '1',
            };
            const params = Object.assign({ ..._params });
            delete params?.positionId;

            await expect(client.redeemLockedProduct(params)).rejects.toThrow(
                'Required parameter positionId was null or undefined when calling redeemLockedProduct.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: RedeemLockedProductRequest = {
                positionId: '1',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'redeemLockedProduct').mockRejectedValueOnce(mockError);
            await expect(client.redeemLockedProduct(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('setFlexibleAutoSubscribe()', () => {
        it('should execute setFlexibleAutoSubscribe() successfully with required parameters only', async () => {
            const params: SetFlexibleAutoSubscribeRequest = {
                productId: '1',
                autoSubscribe: true,
            };

            mockResponse = { success: true };

            const spy = jest.spyOn(client, 'setFlexibleAutoSubscribe').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SetFlexibleAutoSubscribeResponse>)
            );
            const response = await client.setFlexibleAutoSubscribe(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute setFlexibleAutoSubscribe() successfully with optional parameters', async () => {
            const params: SetFlexibleAutoSubscribeRequest = {
                productId: '1',
                autoSubscribe: true,
                recvWindow: 5000,
            };

            mockResponse = { success: true };

            const spy = jest.spyOn(client, 'setFlexibleAutoSubscribe').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SetFlexibleAutoSubscribeResponse>)
            );
            const response = await client.setFlexibleAutoSubscribe(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when productId is missing', async () => {
            const _params: SetFlexibleAutoSubscribeRequest = {
                productId: '1',
                autoSubscribe: true,
            };
            const params = Object.assign({ ..._params });
            delete params?.productId;

            await expect(client.setFlexibleAutoSubscribe(params)).rejects.toThrow(
                'Required parameter productId was null or undefined when calling setFlexibleAutoSubscribe.'
            );
        });

        it('should throw RequiredError when autoSubscribe is missing', async () => {
            const _params: SetFlexibleAutoSubscribeRequest = {
                productId: '1',
                autoSubscribe: true,
            };
            const params = Object.assign({ ..._params });
            delete params?.autoSubscribe;

            await expect(client.setFlexibleAutoSubscribe(params)).rejects.toThrow(
                'Required parameter autoSubscribe was null or undefined when calling setFlexibleAutoSubscribe.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SetFlexibleAutoSubscribeRequest = {
                productId: '1',
                autoSubscribe: true,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'setFlexibleAutoSubscribe')
                .mockRejectedValueOnce(mockError);
            await expect(client.setFlexibleAutoSubscribe(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('setLockedAutoSubscribe()', () => {
        it('should execute setLockedAutoSubscribe() successfully with required parameters only', async () => {
            const params: SetLockedAutoSubscribeRequest = {
                positionId: '1',
                autoSubscribe: true,
            };

            mockResponse = { success: true };

            const spy = jest.spyOn(client, 'setLockedAutoSubscribe').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SetLockedAutoSubscribeResponse>)
            );
            const response = await client.setLockedAutoSubscribe(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute setLockedAutoSubscribe() successfully with optional parameters', async () => {
            const params: SetLockedAutoSubscribeRequest = {
                positionId: '1',
                autoSubscribe: true,
                recvWindow: 5000,
            };

            mockResponse = { success: true };

            const spy = jest.spyOn(client, 'setLockedAutoSubscribe').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SetLockedAutoSubscribeResponse>)
            );
            const response = await client.setLockedAutoSubscribe(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when positionId is missing', async () => {
            const _params: SetLockedAutoSubscribeRequest = {
                positionId: '1',
                autoSubscribe: true,
            };
            const params = Object.assign({ ..._params });
            delete params?.positionId;

            await expect(client.setLockedAutoSubscribe(params)).rejects.toThrow(
                'Required parameter positionId was null or undefined when calling setLockedAutoSubscribe.'
            );
        });

        it('should throw RequiredError when autoSubscribe is missing', async () => {
            const _params: SetLockedAutoSubscribeRequest = {
                positionId: '1',
                autoSubscribe: true,
            };
            const params = Object.assign({ ..._params });
            delete params?.autoSubscribe;

            await expect(client.setLockedAutoSubscribe(params)).rejects.toThrow(
                'Required parameter autoSubscribe was null or undefined when calling setLockedAutoSubscribe.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SetLockedAutoSubscribeRequest = {
                positionId: '1',
                autoSubscribe: true,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'setLockedAutoSubscribe')
                .mockRejectedValueOnce(mockError);
            await expect(client.setLockedAutoSubscribe(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('setLockedProductRedeemOption()', () => {
        it('should execute setLockedProductRedeemOption() successfully with required parameters only', async () => {
            const params: SetLockedProductRedeemOptionRequest = {
                positionId: '1',
                redeemTo: 'redeemTo_example',
            };

            mockResponse = { success: true };

            const spy = jest.spyOn(client, 'setLockedProductRedeemOption').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SetLockedProductRedeemOptionResponse>)
            );
            const response = await client.setLockedProductRedeemOption(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute setLockedProductRedeemOption() successfully with optional parameters', async () => {
            const params: SetLockedProductRedeemOptionRequest = {
                positionId: '1',
                redeemTo: 'redeemTo_example',
                recvWindow: 5000,
            };

            mockResponse = { success: true };

            const spy = jest.spyOn(client, 'setLockedProductRedeemOption').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SetLockedProductRedeemOptionResponse>)
            );
            const response = await client.setLockedProductRedeemOption(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when positionId is missing', async () => {
            const _params: SetLockedProductRedeemOptionRequest = {
                positionId: '1',
                redeemTo: 'redeemTo_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.positionId;

            await expect(client.setLockedProductRedeemOption(params)).rejects.toThrow(
                'Required parameter positionId was null or undefined when calling setLockedProductRedeemOption.'
            );
        });

        it('should throw RequiredError when redeemTo is missing', async () => {
            const _params: SetLockedProductRedeemOptionRequest = {
                positionId: '1',
                redeemTo: 'redeemTo_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.redeemTo;

            await expect(client.setLockedProductRedeemOption(params)).rejects.toThrow(
                'Required parameter redeemTo was null or undefined when calling setLockedProductRedeemOption.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SetLockedProductRedeemOptionRequest = {
                positionId: '1',
                redeemTo: 'redeemTo_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'setLockedProductRedeemOption')
                .mockRejectedValueOnce(mockError);
            await expect(client.setLockedProductRedeemOption(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('subscribeFlexibleProduct()', () => {
        it('should execute subscribeFlexibleProduct() successfully with required parameters only', async () => {
            const params: SubscribeFlexibleProductRequest = {
                productId: '1',
                amount: 1,
            };

            mockResponse = { purchaseId: 40607, success: true };

            const spy = jest.spyOn(client, 'subscribeFlexibleProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubscribeFlexibleProductResponse>)
            );
            const response = await client.subscribeFlexibleProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute subscribeFlexibleProduct() successfully with optional parameters', async () => {
            const params: SubscribeFlexibleProductRequest = {
                productId: '1',
                amount: 1,
                autoSubscribe: true,
                sourceAccount: 'SPOT',
                recvWindow: 5000,
            };

            mockResponse = { purchaseId: 40607, success: true };

            const spy = jest.spyOn(client, 'subscribeFlexibleProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubscribeFlexibleProductResponse>)
            );
            const response = await client.subscribeFlexibleProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when productId is missing', async () => {
            const _params: SubscribeFlexibleProductRequest = {
                productId: '1',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.productId;

            await expect(client.subscribeFlexibleProduct(params)).rejects.toThrow(
                'Required parameter productId was null or undefined when calling subscribeFlexibleProduct.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: SubscribeFlexibleProductRequest = {
                productId: '1',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.subscribeFlexibleProduct(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling subscribeFlexibleProduct.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SubscribeFlexibleProductRequest = {
                productId: '1',
                amount: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'subscribeFlexibleProduct')
                .mockRejectedValueOnce(mockError);
            await expect(client.subscribeFlexibleProduct(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('subscribeLockedProduct()', () => {
        it('should execute subscribeLockedProduct() successfully with required parameters only', async () => {
            const params: SubscribeLockedProductRequest = {
                projectId: '1',
                amount: 1,
            };

            mockResponse = { purchaseId: 40607, positionId: '12345', success: true };

            const spy = jest.spyOn(client, 'subscribeLockedProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubscribeLockedProductResponse>)
            );
            const response = await client.subscribeLockedProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute subscribeLockedProduct() successfully with optional parameters', async () => {
            const params: SubscribeLockedProductRequest = {
                projectId: '1',
                amount: 1,
                autoSubscribe: true,
                sourceAccount: 'SPOT',
                redeemTo: '',
                recvWindow: 5000,
            };

            mockResponse = { purchaseId: 40607, positionId: '12345', success: true };

            const spy = jest.spyOn(client, 'subscribeLockedProduct').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<SubscribeLockedProductResponse>)
            );
            const response = await client.subscribeLockedProduct(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when projectId is missing', async () => {
            const _params: SubscribeLockedProductRequest = {
                projectId: '1',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.projectId;

            await expect(client.subscribeLockedProduct(params)).rejects.toThrow(
                'Required parameter projectId was null or undefined when calling subscribeLockedProduct.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: SubscribeLockedProductRequest = {
                projectId: '1',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.subscribeLockedProduct(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling subscribeLockedProduct.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: SubscribeLockedProductRequest = {
                projectId: '1',
                amount: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'subscribeLockedProduct')
                .mockRejectedValueOnce(mockError);
            await expect(client.subscribeLockedProduct(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
