/**
 * Binance Derivatives Trading Portfolio Margin REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading Portfolio Margin REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import {
    TradeApi,
    MarginAccountNewOcoSideEnum,
    MarginAccountNewOcoStopLimitTimeInForceEnum,
    MarginAccountNewOcoNewOrderRespTypeEnum,
    MarginAccountNewOcoSideEffectTypeEnum,
    ModifyCmOrderSideEnum,
    ModifyCmOrderPriceMatchEnum,
    ModifyUmOrderSideEnum,
    ModifyUmOrderPriceMatchEnum,
    NewCmConditionalOrderSideEnum,
    NewCmConditionalOrderStrategyTypeEnum,
    NewCmConditionalOrderPositionSideEnum,
    NewCmConditionalOrderTimeInForceEnum,
    NewCmConditionalOrderWorkingTypeEnum,
    NewCmOrderSideEnum,
    NewCmOrderTypeEnum,
    NewCmOrderPositionSideEnum,
    NewCmOrderTimeInForceEnum,
    NewCmOrderPriceMatchEnum,
    NewCmOrderNewOrderRespTypeEnum,
    NewMarginOrderSideEnum,
    NewMarginOrderTypeEnum,
    NewMarginOrderNewOrderRespTypeEnum,
    NewMarginOrderSideEffectTypeEnum,
    NewMarginOrderTimeInForceEnum,
    NewMarginOrderSelfTradePreventionModeEnum,
    NewUmConditionalOrderSideEnum,
    NewUmConditionalOrderStrategyTypeEnum,
    NewUmConditionalOrderPositionSideEnum,
    NewUmConditionalOrderTimeInForceEnum,
    NewUmConditionalOrderWorkingTypeEnum,
    NewUmConditionalOrderPriceMatchEnum,
    NewUmConditionalOrderSelfTradePreventionModeEnum,
    NewUmOrderSideEnum,
    NewUmOrderTypeEnum,
    NewUmOrderPositionSideEnum,
    NewUmOrderTimeInForceEnum,
    NewUmOrderNewOrderRespTypeEnum,
    NewUmOrderPriceMatchEnum,
    NewUmOrderSelfTradePreventionModeEnum,
    QueryUsersCmForceOrdersAutoCloseTypeEnum,
    QueryUsersUmForceOrdersAutoCloseTypeEnum,
} from '../../../src/rest-api';
import {
    CancelAllCmOpenConditionalOrdersRequest,
    CancelAllCmOpenOrdersRequest,
    CancelAllUmOpenConditionalOrdersRequest,
    CancelAllUmOpenOrdersRequest,
    CancelCmConditionalOrderRequest,
    CancelCmOrderRequest,
    CancelMarginAccountAllOpenOrdersOnASymbolRequest,
    CancelMarginAccountOcoOrdersRequest,
    CancelMarginAccountOrderRequest,
    CancelUmConditionalOrderRequest,
    CancelUmOrderRequest,
    CmAccountTradeListRequest,
    CmPositionAdlQuantileEstimationRequest,
    GetUmFuturesBnbBurnStatusRequest,
    MarginAccountBorrowRequest,
    MarginAccountNewOcoRequest,
    MarginAccountRepayRequest,
    MarginAccountRepayDebtRequest,
    MarginAccountTradeListRequest,
    ModifyCmOrderRequest,
    ModifyUmOrderRequest,
    NewCmConditionalOrderRequest,
    NewCmOrderRequest,
    NewMarginOrderRequest,
    NewUmConditionalOrderRequest,
    NewUmOrderRequest,
    QueryAllCmConditionalOrdersRequest,
    QueryAllCmOrdersRequest,
    QueryAllCurrentCmOpenConditionalOrdersRequest,
    QueryAllCurrentCmOpenOrdersRequest,
    QueryAllCurrentUmOpenConditionalOrdersRequest,
    QueryAllCurrentUmOpenOrdersRequest,
    QueryAllMarginAccountOrdersRequest,
    QueryAllUmConditionalOrdersRequest,
    QueryAllUmOrdersRequest,
    QueryCmConditionalOrderHistoryRequest,
    QueryCmModifyOrderHistoryRequest,
    QueryCmOrderRequest,
    QueryCurrentCmOpenConditionalOrderRequest,
    QueryCurrentCmOpenOrderRequest,
    QueryCurrentMarginOpenOrderRequest,
    QueryCurrentUmOpenConditionalOrderRequest,
    QueryCurrentUmOpenOrderRequest,
    QueryMarginAccountOrderRequest,
    QueryMarginAccountsAllOcoRequest,
    QueryMarginAccountsOcoRequest,
    QueryMarginAccountsOpenOcoRequest,
    QueryUmConditionalOrderHistoryRequest,
    QueryUmModifyOrderHistoryRequest,
    QueryUmOrderRequest,
    QueryUsersCmForceOrdersRequest,
    QueryUsersMarginForceOrdersRequest,
    QueryUsersUmForceOrdersRequest,
    ToggleBnbBurnOnUmFuturesTradeRequest,
    UmAccountTradeListRequest,
    UmPositionAdlQuantileEstimationRequest,
} from '../../../src/rest-api';
import type {
    CancelAllCmOpenConditionalOrdersResponse,
    CancelAllCmOpenOrdersResponse,
    CancelAllUmOpenConditionalOrdersResponse,
    CancelAllUmOpenOrdersResponse,
    CancelCmConditionalOrderResponse,
    CancelCmOrderResponse,
    CancelMarginAccountAllOpenOrdersOnASymbolResponse,
    CancelMarginAccountOcoOrdersResponse,
    CancelMarginAccountOrderResponse,
    CancelUmConditionalOrderResponse,
    CancelUmOrderResponse,
    CmAccountTradeListResponse,
    CmPositionAdlQuantileEstimationResponse,
    GetUmFuturesBnbBurnStatusResponse,
    MarginAccountBorrowResponse,
    MarginAccountNewOcoResponse,
    MarginAccountRepayDebtResponse,
    MarginAccountRepayResponse,
    MarginAccountTradeListResponse,
    ModifyCmOrderResponse,
    ModifyUmOrderResponse,
    NewCmConditionalOrderResponse,
    NewCmOrderResponse,
    NewMarginOrderResponse,
    NewUmConditionalOrderResponse,
    NewUmOrderResponse,
    QueryAllCmConditionalOrdersResponse,
    QueryAllCmOrdersResponse,
    QueryAllCurrentCmOpenConditionalOrdersResponse,
    QueryAllCurrentCmOpenOrdersResponse,
    QueryAllCurrentUmOpenConditionalOrdersResponse,
    QueryAllCurrentUmOpenOrdersResponse,
    QueryAllMarginAccountOrdersResponse,
    QueryAllUmConditionalOrdersResponse,
    QueryAllUmOrdersResponse,
    QueryCmConditionalOrderHistoryResponse,
    QueryCmModifyOrderHistoryResponse,
    QueryCmOrderResponse,
    QueryCurrentCmOpenConditionalOrderResponse,
    QueryCurrentCmOpenOrderResponse,
    QueryCurrentMarginOpenOrderResponse,
    QueryCurrentUmOpenConditionalOrderResponse,
    QueryCurrentUmOpenOrderResponse,
    QueryMarginAccountOrderResponse,
    QueryMarginAccountsAllOcoResponse,
    QueryMarginAccountsOcoResponse,
    QueryMarginAccountsOpenOcoResponse,
    QueryUmConditionalOrderHistoryResponse,
    QueryUmModifyOrderHistoryResponse,
    QueryUmOrderResponse,
    QueryUsersCmForceOrdersResponse,
    QueryUsersMarginForceOrdersResponse,
    QueryUsersUmForceOrdersResponse,
    ToggleBnbBurnOnUmFuturesTradeResponse,
    UmAccountTradeListResponse,
    UmPositionAdlQuantileEstimationResponse,
} from '../../../src/rest-api/types';

describe('TradeApi', () => {
    let client: TradeApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new TradeApi(config);
    });

    describe('cancelAllCmOpenConditionalOrders()', () => {
        it('should execute cancelAllCmOpenConditionalOrders() successfully with required parameters only', async () => {
            const params: CancelAllCmOpenConditionalOrdersRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                code: '200',
                msg: 'The operation of cancel all conditional open order is done.',
            };

            const spy = jest.spyOn(client, 'cancelAllCmOpenConditionalOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelAllCmOpenConditionalOrdersResponse>)
            );
            const response = await client.cancelAllCmOpenConditionalOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelAllCmOpenConditionalOrders() successfully with optional parameters', async () => {
            const params: CancelAllCmOpenConditionalOrdersRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = {
                code: '200',
                msg: 'The operation of cancel all conditional open order is done.',
            };

            const spy = jest.spyOn(client, 'cancelAllCmOpenConditionalOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelAllCmOpenConditionalOrdersResponse>)
            );
            const response = await client.cancelAllCmOpenConditionalOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelAllCmOpenConditionalOrdersRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelAllCmOpenConditionalOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelAllCmOpenConditionalOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelAllCmOpenConditionalOrdersRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'cancelAllCmOpenConditionalOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.cancelAllCmOpenConditionalOrders(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('cancelAllCmOpenOrders()', () => {
        it('should execute cancelAllCmOpenOrders() successfully with required parameters only', async () => {
            const params: CancelAllCmOpenOrdersRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = { code: 200, msg: 'The operation of cancel all open order is done.' };

            const spy = jest.spyOn(client, 'cancelAllCmOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelAllCmOpenOrdersResponse>)
            );
            const response = await client.cancelAllCmOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelAllCmOpenOrders() successfully with optional parameters', async () => {
            const params: CancelAllCmOpenOrdersRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = { code: 200, msg: 'The operation of cancel all open order is done.' };

            const spy = jest.spyOn(client, 'cancelAllCmOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelAllCmOpenOrdersResponse>)
            );
            const response = await client.cancelAllCmOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelAllCmOpenOrdersRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelAllCmOpenOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelAllCmOpenOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelAllCmOpenOrdersRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'cancelAllCmOpenOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.cancelAllCmOpenOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cancelAllUmOpenConditionalOrders()', () => {
        it('should execute cancelAllUmOpenConditionalOrders() successfully with required parameters only', async () => {
            const params: CancelAllUmOpenConditionalOrdersRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                code: '200',
                msg: 'The operation of cancel all conditional open order is done.',
            };

            const spy = jest.spyOn(client, 'cancelAllUmOpenConditionalOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelAllUmOpenConditionalOrdersResponse>)
            );
            const response = await client.cancelAllUmOpenConditionalOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelAllUmOpenConditionalOrders() successfully with optional parameters', async () => {
            const params: CancelAllUmOpenConditionalOrdersRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = {
                code: '200',
                msg: 'The operation of cancel all conditional open order is done.',
            };

            const spy = jest.spyOn(client, 'cancelAllUmOpenConditionalOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelAllUmOpenConditionalOrdersResponse>)
            );
            const response = await client.cancelAllUmOpenConditionalOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelAllUmOpenConditionalOrdersRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelAllUmOpenConditionalOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelAllUmOpenConditionalOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelAllUmOpenConditionalOrdersRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'cancelAllUmOpenConditionalOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.cancelAllUmOpenConditionalOrders(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('cancelAllUmOpenOrders()', () => {
        it('should execute cancelAllUmOpenOrders() successfully with required parameters only', async () => {
            const params: CancelAllUmOpenOrdersRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = { code: 200, msg: 'The operation of cancel all open order is done.' };

            const spy = jest.spyOn(client, 'cancelAllUmOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelAllUmOpenOrdersResponse>)
            );
            const response = await client.cancelAllUmOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelAllUmOpenOrders() successfully with optional parameters', async () => {
            const params: CancelAllUmOpenOrdersRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = { code: 200, msg: 'The operation of cancel all open order is done.' };

            const spy = jest.spyOn(client, 'cancelAllUmOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelAllUmOpenOrdersResponse>)
            );
            const response = await client.cancelAllUmOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelAllUmOpenOrdersRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelAllUmOpenOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelAllUmOpenOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelAllUmOpenOrdersRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'cancelAllUmOpenOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.cancelAllUmOpenOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cancelCmConditionalOrder()', () => {
        it('should execute cancelCmConditionalOrder() successfully with required parameters only', async () => {
            const params: CancelCmConditionalOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                newClientStrategyId: 'myOrder1',
                strategyId: 123445,
                strategyStatus: 'CANCELED',
                strategyType: 'TRAILING_STOP_MARKET',
                origQty: '11',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                stopPrice: '9300',
                symbol: 'BTCUSD',
                timeInForce: 'GTC',
                activatePrice: '9020',
                priceRate: '0.3',
                bookTime: 1566818724710,
                updateTime: 1566818724722,
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
            };

            const spy = jest.spyOn(client, 'cancelCmConditionalOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelCmConditionalOrderResponse>)
            );
            const response = await client.cancelCmConditionalOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelCmConditionalOrder() successfully with optional parameters', async () => {
            const params: CancelCmConditionalOrderRequest = {
                symbol: 'symbol_example',
                strategyId: 1,
                newClientStrategyId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                newClientStrategyId: 'myOrder1',
                strategyId: 123445,
                strategyStatus: 'CANCELED',
                strategyType: 'TRAILING_STOP_MARKET',
                origQty: '11',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                stopPrice: '9300',
                symbol: 'BTCUSD',
                timeInForce: 'GTC',
                activatePrice: '9020',
                priceRate: '0.3',
                bookTime: 1566818724710,
                updateTime: 1566818724722,
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
            };

            const spy = jest.spyOn(client, 'cancelCmConditionalOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelCmConditionalOrderResponse>)
            );
            const response = await client.cancelCmConditionalOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelCmConditionalOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelCmConditionalOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelCmConditionalOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelCmConditionalOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'cancelCmConditionalOrder')
                .mockRejectedValueOnce(mockError);
            await expect(client.cancelCmConditionalOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cancelCmOrder()', () => {
        it('should execute cancelCmOrder() successfully with required parameters only', async () => {
            const params: CancelCmOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                avgPrice: '0.0',
                clientOrderId: 'myOrder1',
                cumQty: '0',
                cumBase: '0',
                executedQty: '0',
                orderId: 283194212,
                origQty: '2',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'CANCELED',
                symbol: 'BTCUSD_200925',
                pair: 'BTCUSD',
                timeInForce: 'GTC',
                type: 'LIMIT',
                updateTime: 1571110484038,
            };

            const spy = jest.spyOn(client, 'cancelCmOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelCmOrderResponse>)
            );
            const response = await client.cancelCmOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelCmOrder() successfully with optional parameters', async () => {
            const params: CancelCmOrderRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                origClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                avgPrice: '0.0',
                clientOrderId: 'myOrder1',
                cumQty: '0',
                cumBase: '0',
                executedQty: '0',
                orderId: 283194212,
                origQty: '2',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'CANCELED',
                symbol: 'BTCUSD_200925',
                pair: 'BTCUSD',
                timeInForce: 'GTC',
                type: 'LIMIT',
                updateTime: 1571110484038,
            };

            const spy = jest.spyOn(client, 'cancelCmOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelCmOrderResponse>)
            );
            const response = await client.cancelCmOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelCmOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelCmOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelCmOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelCmOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'cancelCmOrder').mockRejectedValueOnce(mockError);
            await expect(client.cancelCmOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cancelMarginAccountAllOpenOrdersOnASymbol()', () => {
        it('should execute cancelMarginAccountAllOpenOrdersOnASymbol() successfully with required parameters only', async () => {
            const params: CancelMarginAccountAllOpenOrdersOnASymbolRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    origClientOrderId: 'E6APeyTJvkMvLMYMqu1KQ4',
                    orderId: 11,
                    orderListId: -1,
                    clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                    price: '0.089853',
                    origQty: '0.178622',
                    executedQty: '0.000000',
                    cummulativeQuoteQty: '0.000000',
                    status: 'CANCELED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                },
                {
                    orderListId: 1929,
                    contingencyType: 'OCO',
                    listStatusType: 'ALL_DONE',
                    listOrderStatus: 'ALL_DONE',
                    listClientOrderId: '2inzWQdDvZLHbbAmAozX2N',
                    transactionTime: 1585230948299,
                    symbol: 'BTCUSDT',
                    orders: [
                        { symbol: 'BTCUSDT', orderId: 20, clientOrderId: 'CwOOIPHSmYywx6jZX77TdL' },
                        { symbol: 'BTCUSDT', orderId: 21, clientOrderId: '461cPg51vQjV3zIMOXNz39' },
                    ],
                    orderReports: [
                        {
                            symbol: 'BTCUSDT',
                            origClientOrderId: 'CwOOIPHSmYywx6jZX77TdL',
                            orderId: 20,
                            orderListId: 1929,
                            clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                            price: '0.668611',
                            origQty: '0.690354',
                            executedQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'STOP_LOSS_LIMIT',
                            side: 'BUY',
                            stopPrice: '0.378131',
                            icebergQty: '0.017083',
                        },
                        {
                            symbol: 'BTCUSDT',
                            origClientOrderId: '461cPg51vQjV3zIMOXNz39',
                            orderId: 21,
                            orderListId: 1929,
                            clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                            price: '0.008791',
                            origQty: '0.690354',
                            executedQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'BUY',
                            icebergQty: '0.639962',
                        },
                    ],
                },
            ];

            const spy = jest
                .spyOn(client, 'cancelMarginAccountAllOpenOrdersOnASymbol')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<CancelMarginAccountAllOpenOrdersOnASymbolResponse>)
                );
            const response = await client.cancelMarginAccountAllOpenOrdersOnASymbol(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelMarginAccountAllOpenOrdersOnASymbol() successfully with optional parameters', async () => {
            const params: CancelMarginAccountAllOpenOrdersOnASymbolRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    origClientOrderId: 'E6APeyTJvkMvLMYMqu1KQ4',
                    orderId: 11,
                    orderListId: -1,
                    clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                    price: '0.089853',
                    origQty: '0.178622',
                    executedQty: '0.000000',
                    cummulativeQuoteQty: '0.000000',
                    status: 'CANCELED',
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    side: 'BUY',
                },
                {
                    orderListId: 1929,
                    contingencyType: 'OCO',
                    listStatusType: 'ALL_DONE',
                    listOrderStatus: 'ALL_DONE',
                    listClientOrderId: '2inzWQdDvZLHbbAmAozX2N',
                    transactionTime: 1585230948299,
                    symbol: 'BTCUSDT',
                    orders: [
                        { symbol: 'BTCUSDT', orderId: 20, clientOrderId: 'CwOOIPHSmYywx6jZX77TdL' },
                        { symbol: 'BTCUSDT', orderId: 21, clientOrderId: '461cPg51vQjV3zIMOXNz39' },
                    ],
                    orderReports: [
                        {
                            symbol: 'BTCUSDT',
                            origClientOrderId: 'CwOOIPHSmYywx6jZX77TdL',
                            orderId: 20,
                            orderListId: 1929,
                            clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                            price: '0.668611',
                            origQty: '0.690354',
                            executedQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'STOP_LOSS_LIMIT',
                            side: 'BUY',
                            stopPrice: '0.378131',
                            icebergQty: '0.017083',
                        },
                        {
                            symbol: 'BTCUSDT',
                            origClientOrderId: '461cPg51vQjV3zIMOXNz39',
                            orderId: 21,
                            orderListId: 1929,
                            clientOrderId: 'pXLV6Hz6mprAcVYpVMTGgx',
                            price: '0.008791',
                            origQty: '0.690354',
                            executedQty: '0.000000',
                            cummulativeQuoteQty: '0.000000',
                            status: 'CANCELED',
                            timeInForce: 'GTC',
                            type: 'LIMIT_MAKER',
                            side: 'BUY',
                            icebergQty: '0.639962',
                        },
                    ],
                },
            ];

            const spy = jest
                .spyOn(client, 'cancelMarginAccountAllOpenOrdersOnASymbol')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<CancelMarginAccountAllOpenOrdersOnASymbolResponse>)
                );
            const response = await client.cancelMarginAccountAllOpenOrdersOnASymbol(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelMarginAccountAllOpenOrdersOnASymbolRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelMarginAccountAllOpenOrdersOnASymbol(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelMarginAccountAllOpenOrdersOnASymbol.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelMarginAccountAllOpenOrdersOnASymbolRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'cancelMarginAccountAllOpenOrdersOnASymbol')
                .mockRejectedValueOnce(mockError);
            await expect(client.cancelMarginAccountAllOpenOrdersOnASymbol(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('cancelMarginAccountOcoOrders()', () => {
        it('should execute cancelMarginAccountOcoOrders() successfully with required parameters only', async () => {
            const params: CancelMarginAccountOcoOrdersRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                orderListId: 0,
                contingencyType: 'OCO',
                listStatusType: 'ALL_DONE',
                listOrderStatus: 'ALL_DONE',
                listClientOrderId: 'C3wyj4WVEktd7u9aVBRXcN',
                transactionTime: 1574040868128,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'pO9ufTiFGg3nw2fOdgeOXa' },
                    { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'TXOvglzXuaubXAaENpaRCB' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        origClientOrderId: 'pO9ufTiFGg3nw2fOdgeOXa',
                        orderId: 2,
                        orderListId: 0,
                        clientOrderId: 'unfWT8ig8i0uj6lPuYLez6',
                        price: '1.00000000',
                        origQty: '10.00000000',
                        executedQty: '0.00000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'STOP_LOSS_LIMIT',
                        side: 'SELL',
                        stopPrice: '1.00000000',
                    },
                    {
                        symbol: 'LTCBTC',
                        origClientOrderId: 'TXOvglzXuaubXAaENpaRCB',
                        orderId: 3,
                        orderListId: 0,
                        clientOrderId: 'unfWT8ig8i0uj6lPuYLez6',
                        price: '3.00000000',
                        origQty: '10.00000000',
                        executedQty: '0.00000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'SELL',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'cancelMarginAccountOcoOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelMarginAccountOcoOrdersResponse>)
            );
            const response = await client.cancelMarginAccountOcoOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelMarginAccountOcoOrders() successfully with optional parameters', async () => {
            const params: CancelMarginAccountOcoOrdersRequest = {
                symbol: 'symbol_example',
                orderListId: 1,
                listClientOrderId: '1',
                newClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                orderListId: 0,
                contingencyType: 'OCO',
                listStatusType: 'ALL_DONE',
                listOrderStatus: 'ALL_DONE',
                listClientOrderId: 'C3wyj4WVEktd7u9aVBRXcN',
                transactionTime: 1574040868128,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'pO9ufTiFGg3nw2fOdgeOXa' },
                    { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'TXOvglzXuaubXAaENpaRCB' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        origClientOrderId: 'pO9ufTiFGg3nw2fOdgeOXa',
                        orderId: 2,
                        orderListId: 0,
                        clientOrderId: 'unfWT8ig8i0uj6lPuYLez6',
                        price: '1.00000000',
                        origQty: '10.00000000',
                        executedQty: '0.00000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'STOP_LOSS_LIMIT',
                        side: 'SELL',
                        stopPrice: '1.00000000',
                    },
                    {
                        symbol: 'LTCBTC',
                        origClientOrderId: 'TXOvglzXuaubXAaENpaRCB',
                        orderId: 3,
                        orderListId: 0,
                        clientOrderId: 'unfWT8ig8i0uj6lPuYLez6',
                        price: '3.00000000',
                        origQty: '10.00000000',
                        executedQty: '0.00000000',
                        cummulativeQuoteQty: '0.00000000',
                        status: 'CANCELED',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'SELL',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'cancelMarginAccountOcoOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelMarginAccountOcoOrdersResponse>)
            );
            const response = await client.cancelMarginAccountOcoOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelMarginAccountOcoOrdersRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelMarginAccountOcoOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelMarginAccountOcoOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelMarginAccountOcoOrdersRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'cancelMarginAccountOcoOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.cancelMarginAccountOcoOrders(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('cancelMarginAccountOrder()', () => {
        it('should execute cancelMarginAccountOrder() successfully with required parameters only', async () => {
            const params: CancelMarginAccountOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                symbol: 'LTCBTC',
                orderId: 28,
                origClientOrderId: 'myOrder1',
                clientOrderId: 'cancelMyOrder1',
                price: '1.00000000',
                origQty: '10.00000000',
                executedQty: '8.00000000',
                cummulativeQuoteQty: '8.00000000',
                status: 'CANCELED',
                timeInForce: 'GTC',
                type: 'LIMIT',
                side: 'SELL',
            };

            const spy = jest.spyOn(client, 'cancelMarginAccountOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelMarginAccountOrderResponse>)
            );
            const response = await client.cancelMarginAccountOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelMarginAccountOrder() successfully with optional parameters', async () => {
            const params: CancelMarginAccountOrderRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                origClientOrderId: '1',
                newClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                symbol: 'LTCBTC',
                orderId: 28,
                origClientOrderId: 'myOrder1',
                clientOrderId: 'cancelMyOrder1',
                price: '1.00000000',
                origQty: '10.00000000',
                executedQty: '8.00000000',
                cummulativeQuoteQty: '8.00000000',
                status: 'CANCELED',
                timeInForce: 'GTC',
                type: 'LIMIT',
                side: 'SELL',
            };

            const spy = jest.spyOn(client, 'cancelMarginAccountOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelMarginAccountOrderResponse>)
            );
            const response = await client.cancelMarginAccountOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelMarginAccountOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelMarginAccountOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelMarginAccountOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelMarginAccountOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'cancelMarginAccountOrder')
                .mockRejectedValueOnce(mockError);
            await expect(client.cancelMarginAccountOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cancelUmConditionalOrder()', () => {
        it('should execute cancelUmConditionalOrder() successfully with required parameters only', async () => {
            const params: CancelUmConditionalOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                newClientStrategyId: 'myOrder1',
                strategyId: 123445,
                strategyStatus: 'CANCELED',
                strategyType: 'TRAILING_STOP_MARKET',
                origQty: '11',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                stopPrice: '9300',
                symbol: 'BTCUSDT',
                timeInForce: 'GTC',
                activatePrice: '9020',
                priceRate: '0.3',
                bookTime: 1566818724710,
                updateTime: 1566818724722,
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
                selfTradePreventionMode: 'NONE',
                goodTillDate: 0,
                priceMatch: 'NONE',
            };

            const spy = jest.spyOn(client, 'cancelUmConditionalOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelUmConditionalOrderResponse>)
            );
            const response = await client.cancelUmConditionalOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelUmConditionalOrder() successfully with optional parameters', async () => {
            const params: CancelUmConditionalOrderRequest = {
                symbol: 'symbol_example',
                strategyId: 1,
                newClientStrategyId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                newClientStrategyId: 'myOrder1',
                strategyId: 123445,
                strategyStatus: 'CANCELED',
                strategyType: 'TRAILING_STOP_MARKET',
                origQty: '11',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                stopPrice: '9300',
                symbol: 'BTCUSDT',
                timeInForce: 'GTC',
                activatePrice: '9020',
                priceRate: '0.3',
                bookTime: 1566818724710,
                updateTime: 1566818724722,
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
                selfTradePreventionMode: 'NONE',
                goodTillDate: 0,
                priceMatch: 'NONE',
            };

            const spy = jest.spyOn(client, 'cancelUmConditionalOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelUmConditionalOrderResponse>)
            );
            const response = await client.cancelUmConditionalOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelUmConditionalOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelUmConditionalOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelUmConditionalOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelUmConditionalOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'cancelUmConditionalOrder')
                .mockRejectedValueOnce(mockError);
            await expect(client.cancelUmConditionalOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cancelUmOrder()', () => {
        it('should execute cancelUmOrder() successfully with required parameters only', async () => {
            const params: CancelUmOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                avgPrice: '0.00000',
                clientOrderId: 'myOrder1',
                cumQty: '0',
                cumQuote: '0',
                executedQty: '0',
                orderId: 4611875134427365000,
                origQty: '0.40',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'CANCELED',
                symbol: 'BTCUSDT',
                timeInForce: 'GTC',
                type: 'LIMIT',
                updateTime: 1571110484038,
                selfTradePreventionMode: 'NONE',
                goodTillDate: 0,
                priceMatch: 'NONE',
            };

            const spy = jest.spyOn(client, 'cancelUmOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelUmOrderResponse>)
            );
            const response = await client.cancelUmOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cancelUmOrder() successfully with optional parameters', async () => {
            const params: CancelUmOrderRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                origClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                avgPrice: '0.00000',
                clientOrderId: 'myOrder1',
                cumQty: '0',
                cumQuote: '0',
                executedQty: '0',
                orderId: 4611875134427365000,
                origQty: '0.40',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'CANCELED',
                symbol: 'BTCUSDT',
                timeInForce: 'GTC',
                type: 'LIMIT',
                updateTime: 1571110484038,
                selfTradePreventionMode: 'NONE',
                goodTillDate: 0,
                priceMatch: 'NONE',
            };

            const spy = jest.spyOn(client, 'cancelUmOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CancelUmOrderResponse>)
            );
            const response = await client.cancelUmOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: CancelUmOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.cancelUmOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling cancelUmOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: CancelUmOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'cancelUmOrder').mockRejectedValueOnce(mockError);
            await expect(client.cancelUmOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cmAccountTradeList()', () => {
        it('should execute cmAccountTradeList() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    symbol: 'BTCUSD_200626',
                    id: 6,
                    orderId: 28,
                    pair: 'BTCUSD',
                    side: 'SELL',
                    price: '8800',
                    qty: '1',
                    realizedPnl: '0',
                    marginAsset: 'BTC',
                    baseQty: '0.01136364',
                    commission: '0.00000454',
                    commissionAsset: 'BTC',
                    time: 1590743483586,
                    positionSide: 'BOTH',
                    buyer: false,
                    maker: false,
                },
            ];

            const spy = jest.spyOn(client, 'cmAccountTradeList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CmAccountTradeListResponse>)
            );
            const response = await client.cmAccountTradeList();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cmAccountTradeList() successfully with optional parameters', async () => {
            const params: CmAccountTradeListRequest = {
                symbol: 'symbol_example',
                pair: 'pair_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                fromId: 1,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSD_200626',
                    id: 6,
                    orderId: 28,
                    pair: 'BTCUSD',
                    side: 'SELL',
                    price: '8800',
                    qty: '1',
                    realizedPnl: '0',
                    marginAsset: 'BTC',
                    baseQty: '0.01136364',
                    commission: '0.00000454',
                    commissionAsset: 'BTC',
                    time: 1590743483586,
                    positionSide: 'BOTH',
                    buyer: false,
                    maker: false,
                },
            ];

            const spy = jest.spyOn(client, 'cmAccountTradeList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CmAccountTradeListResponse>)
            );
            const response = await client.cmAccountTradeList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'cmAccountTradeList').mockRejectedValueOnce(mockError);
            await expect(client.cmAccountTradeList()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('cmPositionAdlQuantileEstimation()', () => {
        it('should execute cmPositionAdlQuantileEstimation() successfully with required parameters only', async () => {
            mockResponse = [
                { symbol: 'BTCUSD_200925', adlQuantile: { LONG: 3, SHORT: 3, HEDGE: 0 } },
                { symbol: 'BTCUSD_201225', adlQuantile: { LONG: 1, SHORT: 2, BOTH: 0 } },
            ];

            const spy = jest.spyOn(client, 'cmPositionAdlQuantileEstimation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CmPositionAdlQuantileEstimationResponse>)
            );
            const response = await client.cmPositionAdlQuantileEstimation();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute cmPositionAdlQuantileEstimation() successfully with optional parameters', async () => {
            const params: CmPositionAdlQuantileEstimationRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = [
                { symbol: 'BTCUSD_200925', adlQuantile: { LONG: 3, SHORT: 3, HEDGE: 0 } },
                { symbol: 'BTCUSD_201225', adlQuantile: { LONG: 1, SHORT: 2, BOTH: 0 } },
            ];

            const spy = jest.spyOn(client, 'cmPositionAdlQuantileEstimation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<CmPositionAdlQuantileEstimationResponse>)
            );
            const response = await client.cmPositionAdlQuantileEstimation(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'cmPositionAdlQuantileEstimation')
                .mockRejectedValueOnce(mockError);
            await expect(client.cmPositionAdlQuantileEstimation()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getUmFuturesBnbBurnStatus()', () => {
        it('should execute getUmFuturesBnbBurnStatus() successfully with required parameters only', async () => {
            mockResponse = { feeBurn: true };

            const spy = jest.spyOn(client, 'getUmFuturesBnbBurnStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetUmFuturesBnbBurnStatusResponse>)
            );
            const response = await client.getUmFuturesBnbBurnStatus();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getUmFuturesBnbBurnStatus() successfully with optional parameters', async () => {
            const params: GetUmFuturesBnbBurnStatusRequest = {
                recvWindow: 5000,
            };

            mockResponse = { feeBurn: true };

            const spy = jest.spyOn(client, 'getUmFuturesBnbBurnStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetUmFuturesBnbBurnStatusResponse>)
            );
            const response = await client.getUmFuturesBnbBurnStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getUmFuturesBnbBurnStatus')
                .mockRejectedValueOnce(mockError);
            await expect(client.getUmFuturesBnbBurnStatus()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('marginAccountBorrow()', () => {
        it('should execute marginAccountBorrow() successfully with required parameters only', async () => {
            const params: MarginAccountBorrowRequest = {
                asset: 'asset_example',
                amount: 1,
            };

            mockResponse = { tranId: 100000001 };

            const spy = jest.spyOn(client, 'marginAccountBorrow').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountBorrowResponse>)
            );
            const response = await client.marginAccountBorrow(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute marginAccountBorrow() successfully with optional parameters', async () => {
            const params: MarginAccountBorrowRequest = {
                asset: 'asset_example',
                amount: 1,
                recvWindow: 5000,
            };

            mockResponse = { tranId: 100000001 };

            const spy = jest.spyOn(client, 'marginAccountBorrow').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountBorrowResponse>)
            );
            const response = await client.marginAccountBorrow(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: MarginAccountBorrowRequest = {
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.marginAccountBorrow(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling marginAccountBorrow.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: MarginAccountBorrowRequest = {
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.marginAccountBorrow(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling marginAccountBorrow.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MarginAccountBorrowRequest = {
                asset: 'asset_example',
                amount: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'marginAccountBorrow').mockRejectedValueOnce(mockError);
            await expect(client.marginAccountBorrow(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('marginAccountNewOco()', () => {
        it('should execute marginAccountNewOco() successfully with required parameters only', async () => {
            const params: MarginAccountNewOcoRequest = {
                symbol: 'symbol_example',
                side: MarginAccountNewOcoSideEnum.BUY,
                quantity: 1,
                price: 1,
                stopPrice: 1,
            };

            mockResponse = {
                orderListId: 0,
                contingencyType: 'OCO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'JYVpp3F0f5CAG15DhtrqLp',
                transactionTime: 1563417480525,
                symbol: 'LTCBTC',
                marginBuyBorrowAmount: '5',
                marginBuyBorrowAsset: 'BTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'Kk7sqHb9J6mJWTMDVW7Vos' },
                    { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'xTXKaGYd4bluPVp78IVRvl' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        orderId: 2,
                        orderListId: 0,
                        clientOrderId: 'Kk7sqHb9J6mJWTMDVW7Vos',
                        transactTime: 1563417480525,
                        price: '0.000000',
                        origQty: '0.624363',
                        executedQty: '0.000000',
                        cummulativeQuoteQty: '0.000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'STOP_LOSS',
                        side: 'BUY',
                        stopPrice: '0.960664',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 3,
                        orderListId: 0,
                        clientOrderId: 'xTXKaGYd4bluPVp78IVRvl',
                        transactTime: 1563417480525,
                        price: '0.036435',
                        origQty: '0.624363',
                        executedQty: '0.000000',
                        cummulativeQuoteQty: '0.000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'BUY',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'marginAccountNewOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountNewOcoResponse>)
            );
            const response = await client.marginAccountNewOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute marginAccountNewOco() successfully with optional parameters', async () => {
            const params: MarginAccountNewOcoRequest = {
                symbol: 'symbol_example',
                side: MarginAccountNewOcoSideEnum.BUY,
                quantity: 1,
                price: 1,
                stopPrice: 1,
                listClientOrderId: '1',
                limitClientOrderId: '1',
                limitIcebergQty: 1,
                stopClientOrderId: '1',
                stopLimitPrice: 1,
                stopIcebergQty: 1,
                stopLimitTimeInForce: MarginAccountNewOcoStopLimitTimeInForceEnum.GTC,
                newOrderRespType: MarginAccountNewOcoNewOrderRespTypeEnum.ACK,
                sideEffectType: MarginAccountNewOcoSideEffectTypeEnum.NO_SIDE_EFFECT,
                recvWindow: 5000,
            };

            mockResponse = {
                orderListId: 0,
                contingencyType: 'OCO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'JYVpp3F0f5CAG15DhtrqLp',
                transactionTime: 1563417480525,
                symbol: 'LTCBTC',
                marginBuyBorrowAmount: '5',
                marginBuyBorrowAsset: 'BTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'Kk7sqHb9J6mJWTMDVW7Vos' },
                    { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'xTXKaGYd4bluPVp78IVRvl' },
                ],
                orderReports: [
                    {
                        symbol: 'LTCBTC',
                        orderId: 2,
                        orderListId: 0,
                        clientOrderId: 'Kk7sqHb9J6mJWTMDVW7Vos',
                        transactTime: 1563417480525,
                        price: '0.000000',
                        origQty: '0.624363',
                        executedQty: '0.000000',
                        cummulativeQuoteQty: '0.000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'STOP_LOSS',
                        side: 'BUY',
                        stopPrice: '0.960664',
                    },
                    {
                        symbol: 'LTCBTC',
                        orderId: 3,
                        orderListId: 0,
                        clientOrderId: 'xTXKaGYd4bluPVp78IVRvl',
                        transactTime: 1563417480525,
                        price: '0.036435',
                        origQty: '0.624363',
                        executedQty: '0.000000',
                        cummulativeQuoteQty: '0.000000',
                        status: 'NEW',
                        timeInForce: 'GTC',
                        type: 'LIMIT_MAKER',
                        side: 'BUY',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'marginAccountNewOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountNewOcoResponse>)
            );
            const response = await client.marginAccountNewOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MarginAccountNewOcoRequest = {
                symbol: 'symbol_example',
                side: MarginAccountNewOcoSideEnum.BUY,
                quantity: 1,
                price: 1,
                stopPrice: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.marginAccountNewOco(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling marginAccountNewOco.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: MarginAccountNewOcoRequest = {
                symbol: 'symbol_example',
                side: MarginAccountNewOcoSideEnum.BUY,
                quantity: 1,
                price: 1,
                stopPrice: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.marginAccountNewOco(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling marginAccountNewOco.'
            );
        });

        it('should throw RequiredError when quantity is missing', async () => {
            const _params: MarginAccountNewOcoRequest = {
                symbol: 'symbol_example',
                side: MarginAccountNewOcoSideEnum.BUY,
                quantity: 1,
                price: 1,
                stopPrice: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.quantity;

            await expect(client.marginAccountNewOco(params)).rejects.toThrow(
                'Required parameter quantity was null or undefined when calling marginAccountNewOco.'
            );
        });

        it('should throw RequiredError when price is missing', async () => {
            const _params: MarginAccountNewOcoRequest = {
                symbol: 'symbol_example',
                side: MarginAccountNewOcoSideEnum.BUY,
                quantity: 1,
                price: 1,
                stopPrice: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.price;

            await expect(client.marginAccountNewOco(params)).rejects.toThrow(
                'Required parameter price was null or undefined when calling marginAccountNewOco.'
            );
        });

        it('should throw RequiredError when stopPrice is missing', async () => {
            const _params: MarginAccountNewOcoRequest = {
                symbol: 'symbol_example',
                side: MarginAccountNewOcoSideEnum.BUY,
                quantity: 1,
                price: 1,
                stopPrice: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.stopPrice;

            await expect(client.marginAccountNewOco(params)).rejects.toThrow(
                'Required parameter stopPrice was null or undefined when calling marginAccountNewOco.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MarginAccountNewOcoRequest = {
                symbol: 'symbol_example',
                side: MarginAccountNewOcoSideEnum.BUY,
                quantity: 1,
                price: 1,
                stopPrice: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'marginAccountNewOco').mockRejectedValueOnce(mockError);
            await expect(client.marginAccountNewOco(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('marginAccountRepay()', () => {
        it('should execute marginAccountRepay() successfully with required parameters only', async () => {
            const params: MarginAccountRepayRequest = {
                asset: 'asset_example',
                amount: 1,
            };

            mockResponse = { tranId: 100000001 };

            const spy = jest.spyOn(client, 'marginAccountRepay').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountRepayResponse>)
            );
            const response = await client.marginAccountRepay(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute marginAccountRepay() successfully with optional parameters', async () => {
            const params: MarginAccountRepayRequest = {
                asset: 'asset_example',
                amount: 1,
                recvWindow: 5000,
            };

            mockResponse = { tranId: 100000001 };

            const spy = jest.spyOn(client, 'marginAccountRepay').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountRepayResponse>)
            );
            const response = await client.marginAccountRepay(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: MarginAccountRepayRequest = {
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.marginAccountRepay(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling marginAccountRepay.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: MarginAccountRepayRequest = {
                asset: 'asset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.marginAccountRepay(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling marginAccountRepay.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MarginAccountRepayRequest = {
                asset: 'asset_example',
                amount: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'marginAccountRepay').mockRejectedValueOnce(mockError);
            await expect(client.marginAccountRepay(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('marginAccountRepayDebt()', () => {
        it('should execute marginAccountRepayDebt() successfully with required parameters only', async () => {
            const params: MarginAccountRepayDebtRequest = {
                asset: 'asset_example',
            };

            mockResponse = {
                amount: '0.10000000',
                asset: 'BNB',
                specifyRepayAssets: ['USDT', 'BTC'],
                updateTime: 1636371437000,
                success: true,
            };

            const spy = jest.spyOn(client, 'marginAccountRepayDebt').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountRepayDebtResponse>)
            );
            const response = await client.marginAccountRepayDebt(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute marginAccountRepayDebt() successfully with optional parameters', async () => {
            const params: MarginAccountRepayDebtRequest = {
                asset: 'asset_example',
                amount: 'amount_example',
                specifyRepayAssets: 'specifyRepayAssets_example',
                recvWindow: 5000,
            };

            mockResponse = {
                amount: '0.10000000',
                asset: 'BNB',
                specifyRepayAssets: ['USDT', 'BTC'],
                updateTime: 1636371437000,
                success: true,
            };

            const spy = jest.spyOn(client, 'marginAccountRepayDebt').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountRepayDebtResponse>)
            );
            const response = await client.marginAccountRepayDebt(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: MarginAccountRepayDebtRequest = {
                asset: 'asset_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.marginAccountRepayDebt(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling marginAccountRepayDebt.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MarginAccountRepayDebtRequest = {
                asset: 'asset_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'marginAccountRepayDebt')
                .mockRejectedValueOnce(mockError);
            await expect(client.marginAccountRepayDebt(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('marginAccountTradeList()', () => {
        it('should execute marginAccountTradeList() successfully with required parameters only', async () => {
            const params: MarginAccountTradeListRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    commission: '0.00006000',
                    commissionAsset: 'BTC',
                    id: 34,
                    isBestMatch: true,
                    isBuyer: false,
                    isMaker: false,
                    orderId: 39324,
                    price: '0.02000000',
                    qty: '3.00000000',
                    symbol: 'BNBBTC',
                    time: 1561973357171,
                },
            ];

            const spy = jest.spyOn(client, 'marginAccountTradeList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountTradeListResponse>)
            );
            const response = await client.marginAccountTradeList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute marginAccountTradeList() successfully with optional parameters', async () => {
            const params: MarginAccountTradeListRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                fromId: 1,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    commission: '0.00006000',
                    commissionAsset: 'BTC',
                    id: 34,
                    isBestMatch: true,
                    isBuyer: false,
                    isMaker: false,
                    orderId: 39324,
                    price: '0.02000000',
                    qty: '3.00000000',
                    symbol: 'BNBBTC',
                    time: 1561973357171,
                },
            ];

            const spy = jest.spyOn(client, 'marginAccountTradeList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MarginAccountTradeListResponse>)
            );
            const response = await client.marginAccountTradeList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: MarginAccountTradeListRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.marginAccountTradeList(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling marginAccountTradeList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MarginAccountTradeListRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'marginAccountTradeList')
                .mockRejectedValueOnce(mockError);
            await expect(client.marginAccountTradeList(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('modifyCmOrder()', () => {
        it('should execute modifyCmOrder() successfully with required parameters only', async () => {
            const params: ModifyCmOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyCmOrderSideEnum.BUY,
                quantity: 1,
                price: 1,
            };

            mockResponse = {
                orderId: 20072994037,
                symbol: 'BTCUSD_PERP',
                pair: 'BTCUSD',
                status: 'NEW',
                clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                price: '30005',
                avgPrice: '0.0',
                origQty: '1',
                executedQty: '0',
                cumQty: '0',
                cumBase: '0',
                timeInForce: 'GTC',
                type: 'LIMIT',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'LONG',
                origType: 'LIMIT',
                updateTime: 1629182711600,
            };

            const spy = jest.spyOn(client, 'modifyCmOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ModifyCmOrderResponse>)
            );
            const response = await client.modifyCmOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute modifyCmOrder() successfully with optional parameters', async () => {
            const params: ModifyCmOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyCmOrderSideEnum.BUY,
                quantity: 1,
                price: 1,
                orderId: 1,
                origClientOrderId: '1',
                priceMatch: ModifyCmOrderPriceMatchEnum.NONE,
                recvWindow: 5000,
            };

            mockResponse = {
                orderId: 20072994037,
                symbol: 'BTCUSD_PERP',
                pair: 'BTCUSD',
                status: 'NEW',
                clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                price: '30005',
                avgPrice: '0.0',
                origQty: '1',
                executedQty: '0',
                cumQty: '0',
                cumBase: '0',
                timeInForce: 'GTC',
                type: 'LIMIT',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'LONG',
                origType: 'LIMIT',
                updateTime: 1629182711600,
            };

            const spy = jest.spyOn(client, 'modifyCmOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ModifyCmOrderResponse>)
            );
            const response = await client.modifyCmOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: ModifyCmOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyCmOrderSideEnum.BUY,
                quantity: 1,
                price: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.modifyCmOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling modifyCmOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: ModifyCmOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyCmOrderSideEnum.BUY,
                quantity: 1,
                price: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.modifyCmOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling modifyCmOrder.'
            );
        });

        it('should throw RequiredError when quantity is missing', async () => {
            const _params: ModifyCmOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyCmOrderSideEnum.BUY,
                quantity: 1,
                price: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.quantity;

            await expect(client.modifyCmOrder(params)).rejects.toThrow(
                'Required parameter quantity was null or undefined when calling modifyCmOrder.'
            );
        });

        it('should throw RequiredError when price is missing', async () => {
            const _params: ModifyCmOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyCmOrderSideEnum.BUY,
                quantity: 1,
                price: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.price;

            await expect(client.modifyCmOrder(params)).rejects.toThrow(
                'Required parameter price was null or undefined when calling modifyCmOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ModifyCmOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyCmOrderSideEnum.BUY,
                quantity: 1,
                price: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'modifyCmOrder').mockRejectedValueOnce(mockError);
            await expect(client.modifyCmOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('modifyUmOrder()', () => {
        it('should execute modifyUmOrder() successfully with required parameters only', async () => {
            const params: ModifyUmOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyUmOrderSideEnum.BUY,
                quantity: 1,
                price: 1,
            };

            mockResponse = {
                orderId: 20072994037,
                symbol: 'BTCUSDT',
                status: 'NEW',
                clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                price: '30005',
                avgPrice: '0.0',
                origQty: '1',
                executedQty: '0',
                cumQty: '0',
                cumQuote: '0',
                timeInForce: 'GTC',
                type: 'LIMIT',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'LONG',
                origType: 'LIMIT',
                selfTradePreventionMode: 'NONE',
                goodTillDate: 0,
                updateTime: 1629182711600,
                priceMatch: 'NONE',
            };

            const spy = jest.spyOn(client, 'modifyUmOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ModifyUmOrderResponse>)
            );
            const response = await client.modifyUmOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute modifyUmOrder() successfully with optional parameters', async () => {
            const params: ModifyUmOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyUmOrderSideEnum.BUY,
                quantity: 1,
                price: 1,
                orderId: 1,
                origClientOrderId: '1',
                priceMatch: ModifyUmOrderPriceMatchEnum.NONE,
                recvWindow: 5000,
            };

            mockResponse = {
                orderId: 20072994037,
                symbol: 'BTCUSDT',
                status: 'NEW',
                clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                price: '30005',
                avgPrice: '0.0',
                origQty: '1',
                executedQty: '0',
                cumQty: '0',
                cumQuote: '0',
                timeInForce: 'GTC',
                type: 'LIMIT',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'LONG',
                origType: 'LIMIT',
                selfTradePreventionMode: 'NONE',
                goodTillDate: 0,
                updateTime: 1629182711600,
                priceMatch: 'NONE',
            };

            const spy = jest.spyOn(client, 'modifyUmOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ModifyUmOrderResponse>)
            );
            const response = await client.modifyUmOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: ModifyUmOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyUmOrderSideEnum.BUY,
                quantity: 1,
                price: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.modifyUmOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling modifyUmOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: ModifyUmOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyUmOrderSideEnum.BUY,
                quantity: 1,
                price: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.modifyUmOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling modifyUmOrder.'
            );
        });

        it('should throw RequiredError when quantity is missing', async () => {
            const _params: ModifyUmOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyUmOrderSideEnum.BUY,
                quantity: 1,
                price: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.quantity;

            await expect(client.modifyUmOrder(params)).rejects.toThrow(
                'Required parameter quantity was null or undefined when calling modifyUmOrder.'
            );
        });

        it('should throw RequiredError when price is missing', async () => {
            const _params: ModifyUmOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyUmOrderSideEnum.BUY,
                quantity: 1,
                price: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.price;

            await expect(client.modifyUmOrder(params)).rejects.toThrow(
                'Required parameter price was null or undefined when calling modifyUmOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ModifyUmOrderRequest = {
                symbol: 'symbol_example',
                side: ModifyUmOrderSideEnum.BUY,
                quantity: 1,
                price: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'modifyUmOrder').mockRejectedValueOnce(mockError);
            await expect(client.modifyUmOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('newCmConditionalOrder()', () => {
        it('should execute newCmConditionalOrder() successfully with required parameters only', async () => {
            const params: NewCmConditionalOrderRequest = {
                symbol: 'symbol_example',
                side: NewCmConditionalOrderSideEnum.BUY,
                strategyType: NewCmConditionalOrderStrategyTypeEnum.STOP,
            };

            mockResponse = {
                newClientStrategyId: 'testOrder',
                strategyId: 123445,
                strategyStatus: 'NEW',
                strategyType: 'TRAILING_STOP_MARKET',
                origQty: '10',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                stopPrice: '9300',
                symbol: 'BTCUSD_200925',
                pair: 'BTCUSD',
                timeInForce: 'GTC',
                activatePrice: '9020',
                priceRate: '0.3',
                bookTime: 1566818724710,
                updateTime: 1566818724722,
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
            };

            const spy = jest.spyOn(client, 'newCmConditionalOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewCmConditionalOrderResponse>)
            );
            const response = await client.newCmConditionalOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute newCmConditionalOrder() successfully with optional parameters', async () => {
            const params: NewCmConditionalOrderRequest = {
                symbol: 'symbol_example',
                side: NewCmConditionalOrderSideEnum.BUY,
                strategyType: NewCmConditionalOrderStrategyTypeEnum.STOP,
                positionSide: NewCmConditionalOrderPositionSideEnum.BOTH,
                timeInForce: NewCmConditionalOrderTimeInForceEnum.GTC,
                quantity: 1,
                reduceOnly: 'false',
                price: 1,
                workingType: NewCmConditionalOrderWorkingTypeEnum.MARK_PRICE,
                priceProtect: 'false',
                newClientStrategyId: '1',
                stopPrice: 1,
                activationPrice: 1,
                callbackRate: 1,
                recvWindow: 5000,
            };

            mockResponse = {
                newClientStrategyId: 'testOrder',
                strategyId: 123445,
                strategyStatus: 'NEW',
                strategyType: 'TRAILING_STOP_MARKET',
                origQty: '10',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                stopPrice: '9300',
                symbol: 'BTCUSD_200925',
                pair: 'BTCUSD',
                timeInForce: 'GTC',
                activatePrice: '9020',
                priceRate: '0.3',
                bookTime: 1566818724710,
                updateTime: 1566818724722,
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
            };

            const spy = jest.spyOn(client, 'newCmConditionalOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewCmConditionalOrderResponse>)
            );
            const response = await client.newCmConditionalOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: NewCmConditionalOrderRequest = {
                symbol: 'symbol_example',
                side: NewCmConditionalOrderSideEnum.BUY,
                strategyType: NewCmConditionalOrderStrategyTypeEnum.STOP,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.newCmConditionalOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling newCmConditionalOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: NewCmConditionalOrderRequest = {
                symbol: 'symbol_example',
                side: NewCmConditionalOrderSideEnum.BUY,
                strategyType: NewCmConditionalOrderStrategyTypeEnum.STOP,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.newCmConditionalOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling newCmConditionalOrder.'
            );
        });

        it('should throw RequiredError when strategyType is missing', async () => {
            const _params: NewCmConditionalOrderRequest = {
                symbol: 'symbol_example',
                side: NewCmConditionalOrderSideEnum.BUY,
                strategyType: NewCmConditionalOrderStrategyTypeEnum.STOP,
            };
            const params = Object.assign({ ..._params });
            delete params?.strategyType;

            await expect(client.newCmConditionalOrder(params)).rejects.toThrow(
                'Required parameter strategyType was null or undefined when calling newCmConditionalOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: NewCmConditionalOrderRequest = {
                symbol: 'symbol_example',
                side: NewCmConditionalOrderSideEnum.BUY,
                strategyType: NewCmConditionalOrderStrategyTypeEnum.STOP,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'newCmConditionalOrder')
                .mockRejectedValueOnce(mockError);
            await expect(client.newCmConditionalOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('newCmOrder()', () => {
        it('should execute newCmOrder() successfully with required parameters only', async () => {
            const params: NewCmOrderRequest = {
                symbol: 'symbol_example',
                side: NewCmOrderSideEnum.BUY,
                type: NewCmOrderTypeEnum.LIMIT,
            };

            mockResponse = {
                clientOrderId: 'testOrder',
                cumQty: '0',
                cumBase: '0',
                executedQty: '0',
                orderId: 22542179,
                avgPrice: '0.0',
                origQty: '10',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'NEW',
                symbol: 'BTCUSD_200925',
                pair: 'BTCUSD',
                timeInForce: 'GTC',
                type: 'MARKET',
                updateTime: 1566818724722,
            };

            const spy = jest.spyOn(client, 'newCmOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewCmOrderResponse>)
            );
            const response = await client.newCmOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute newCmOrder() successfully with optional parameters', async () => {
            const params: NewCmOrderRequest = {
                symbol: 'symbol_example',
                side: NewCmOrderSideEnum.BUY,
                type: NewCmOrderTypeEnum.LIMIT,
                positionSide: NewCmOrderPositionSideEnum.BOTH,
                timeInForce: NewCmOrderTimeInForceEnum.GTC,
                quantity: 1,
                reduceOnly: 'false',
                price: 1,
                priceMatch: NewCmOrderPriceMatchEnum.NONE,
                newClientOrderId: '1',
                newOrderRespType: NewCmOrderNewOrderRespTypeEnum.ACK,
                recvWindow: 5000,
            };

            mockResponse = {
                clientOrderId: 'testOrder',
                cumQty: '0',
                cumBase: '0',
                executedQty: '0',
                orderId: 22542179,
                avgPrice: '0.0',
                origQty: '10',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'NEW',
                symbol: 'BTCUSD_200925',
                pair: 'BTCUSD',
                timeInForce: 'GTC',
                type: 'MARKET',
                updateTime: 1566818724722,
            };

            const spy = jest.spyOn(client, 'newCmOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewCmOrderResponse>)
            );
            const response = await client.newCmOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: NewCmOrderRequest = {
                symbol: 'symbol_example',
                side: NewCmOrderSideEnum.BUY,
                type: NewCmOrderTypeEnum.LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.newCmOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling newCmOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: NewCmOrderRequest = {
                symbol: 'symbol_example',
                side: NewCmOrderSideEnum.BUY,
                type: NewCmOrderTypeEnum.LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.newCmOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling newCmOrder.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: NewCmOrderRequest = {
                symbol: 'symbol_example',
                side: NewCmOrderSideEnum.BUY,
                type: NewCmOrderTypeEnum.LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.newCmOrder(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling newCmOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: NewCmOrderRequest = {
                symbol: 'symbol_example',
                side: NewCmOrderSideEnum.BUY,
                type: NewCmOrderTypeEnum.LIMIT,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'newCmOrder').mockRejectedValueOnce(mockError);
            await expect(client.newCmOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('newMarginOrder()', () => {
        it('should execute newMarginOrder() successfully with required parameters only', async () => {
            const params: NewMarginOrderRequest = {
                symbol: 'symbol_example',
                side: NewMarginOrderSideEnum.BUY,
                type: NewMarginOrderTypeEnum.LIMIT,
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                orderId: 28,
                clientOrderId: '6gCrw2kRUAF9CvJDGP16IP',
                transactTime: 1507725176595,
                price: '1.00000000',
                origQty: '10.00000000',
                executedQty: '10.00000000',
                cummulativeQuoteQty: '10.00000000',
                status: 'FILLED',
                timeInForce: 'GTC',
                type: 'MARKET',
                side: 'SELL',
                marginBuyBorrowAmount: 5,
                marginBuyBorrowAsset: 'BTC',
                fills: [
                    {
                        price: '4000.00000000',
                        qty: '1.00000000',
                        commission: '4.00000000',
                        commissionAsset: 'USDT',
                    },
                    {
                        price: '3999.00000000',
                        qty: '5.00000000',
                        commission: '19.99500000',
                        commissionAsset: 'USDT',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'newMarginOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewMarginOrderResponse>)
            );
            const response = await client.newMarginOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute newMarginOrder() successfully with optional parameters', async () => {
            const params: NewMarginOrderRequest = {
                symbol: 'symbol_example',
                side: NewMarginOrderSideEnum.BUY,
                type: NewMarginOrderTypeEnum.LIMIT,
                quantity: 1,
                quoteOrderQty: 1,
                price: 1,
                stopPrice: 1,
                newClientOrderId: '1',
                newOrderRespType: NewMarginOrderNewOrderRespTypeEnum.ACK,
                icebergQty: 1,
                sideEffectType: NewMarginOrderSideEffectTypeEnum.NO_SIDE_EFFECT,
                timeInForce: NewMarginOrderTimeInForceEnum.GTC,
                selfTradePreventionMode: NewMarginOrderSelfTradePreventionModeEnum.NONE,
                autoRepayAtCancel: true,
                recvWindow: 5000,
            };

            mockResponse = {
                symbol: 'BTCUSDT',
                orderId: 28,
                clientOrderId: '6gCrw2kRUAF9CvJDGP16IP',
                transactTime: 1507725176595,
                price: '1.00000000',
                origQty: '10.00000000',
                executedQty: '10.00000000',
                cummulativeQuoteQty: '10.00000000',
                status: 'FILLED',
                timeInForce: 'GTC',
                type: 'MARKET',
                side: 'SELL',
                marginBuyBorrowAmount: 5,
                marginBuyBorrowAsset: 'BTC',
                fills: [
                    {
                        price: '4000.00000000',
                        qty: '1.00000000',
                        commission: '4.00000000',
                        commissionAsset: 'USDT',
                    },
                    {
                        price: '3999.00000000',
                        qty: '5.00000000',
                        commission: '19.99500000',
                        commissionAsset: 'USDT',
                    },
                ],
            };

            const spy = jest.spyOn(client, 'newMarginOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewMarginOrderResponse>)
            );
            const response = await client.newMarginOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: NewMarginOrderRequest = {
                symbol: 'symbol_example',
                side: NewMarginOrderSideEnum.BUY,
                type: NewMarginOrderTypeEnum.LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.newMarginOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling newMarginOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: NewMarginOrderRequest = {
                symbol: 'symbol_example',
                side: NewMarginOrderSideEnum.BUY,
                type: NewMarginOrderTypeEnum.LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.newMarginOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling newMarginOrder.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: NewMarginOrderRequest = {
                symbol: 'symbol_example',
                side: NewMarginOrderSideEnum.BUY,
                type: NewMarginOrderTypeEnum.LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.newMarginOrder(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling newMarginOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: NewMarginOrderRequest = {
                symbol: 'symbol_example',
                side: NewMarginOrderSideEnum.BUY,
                type: NewMarginOrderTypeEnum.LIMIT,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'newMarginOrder').mockRejectedValueOnce(mockError);
            await expect(client.newMarginOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('newUmConditionalOrder()', () => {
        it('should execute newUmConditionalOrder() successfully with required parameters only', async () => {
            const params: NewUmConditionalOrderRequest = {
                symbol: 'symbol_example',
                side: NewUmConditionalOrderSideEnum.BUY,
                strategyType: NewUmConditionalOrderStrategyTypeEnum.STOP,
            };

            mockResponse = {
                newClientStrategyId: 'testOrder',
                strategyId: 123445,
                strategyStatus: 'NEW',
                strategyType: 'TRAILING_STOP_MARKET',
                origQty: '10',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                stopPrice: '9300',
                symbol: 'BTCUSDT',
                timeInForce: 'GTD',
                activatePrice: '9020',
                priceRate: '0.3',
                bookTime: 1566818724710,
                updateTime: 1566818724722,
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
                selfTradePreventionMode: 'NONE',
                goodTillDate: 1693207680000,
                priceMatch: 'NONE',
            };

            const spy = jest.spyOn(client, 'newUmConditionalOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewUmConditionalOrderResponse>)
            );
            const response = await client.newUmConditionalOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute newUmConditionalOrder() successfully with optional parameters', async () => {
            const params: NewUmConditionalOrderRequest = {
                symbol: 'symbol_example',
                side: NewUmConditionalOrderSideEnum.BUY,
                strategyType: NewUmConditionalOrderStrategyTypeEnum.STOP,
                positionSide: NewUmConditionalOrderPositionSideEnum.BOTH,
                timeInForce: NewUmConditionalOrderTimeInForceEnum.GTC,
                quantity: 1,
                reduceOnly: 'false',
                price: 1,
                workingType: NewUmConditionalOrderWorkingTypeEnum.MARK_PRICE,
                priceProtect: 'false',
                newClientStrategyId: '1',
                stopPrice: 1,
                activationPrice: 1,
                callbackRate: 1,
                priceMatch: NewUmConditionalOrderPriceMatchEnum.NONE,
                selfTradePreventionMode: NewUmConditionalOrderSelfTradePreventionModeEnum.NONE,
                goodTillDate: 789,
                recvWindow: 5000,
            };

            mockResponse = {
                newClientStrategyId: 'testOrder',
                strategyId: 123445,
                strategyStatus: 'NEW',
                strategyType: 'TRAILING_STOP_MARKET',
                origQty: '10',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                stopPrice: '9300',
                symbol: 'BTCUSDT',
                timeInForce: 'GTD',
                activatePrice: '9020',
                priceRate: '0.3',
                bookTime: 1566818724710,
                updateTime: 1566818724722,
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
                selfTradePreventionMode: 'NONE',
                goodTillDate: 1693207680000,
                priceMatch: 'NONE',
            };

            const spy = jest.spyOn(client, 'newUmConditionalOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewUmConditionalOrderResponse>)
            );
            const response = await client.newUmConditionalOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: NewUmConditionalOrderRequest = {
                symbol: 'symbol_example',
                side: NewUmConditionalOrderSideEnum.BUY,
                strategyType: NewUmConditionalOrderStrategyTypeEnum.STOP,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.newUmConditionalOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling newUmConditionalOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: NewUmConditionalOrderRequest = {
                symbol: 'symbol_example',
                side: NewUmConditionalOrderSideEnum.BUY,
                strategyType: NewUmConditionalOrderStrategyTypeEnum.STOP,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.newUmConditionalOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling newUmConditionalOrder.'
            );
        });

        it('should throw RequiredError when strategyType is missing', async () => {
            const _params: NewUmConditionalOrderRequest = {
                symbol: 'symbol_example',
                side: NewUmConditionalOrderSideEnum.BUY,
                strategyType: NewUmConditionalOrderStrategyTypeEnum.STOP,
            };
            const params = Object.assign({ ..._params });
            delete params?.strategyType;

            await expect(client.newUmConditionalOrder(params)).rejects.toThrow(
                'Required parameter strategyType was null or undefined when calling newUmConditionalOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: NewUmConditionalOrderRequest = {
                symbol: 'symbol_example',
                side: NewUmConditionalOrderSideEnum.BUY,
                strategyType: NewUmConditionalOrderStrategyTypeEnum.STOP,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'newUmConditionalOrder')
                .mockRejectedValueOnce(mockError);
            await expect(client.newUmConditionalOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('newUmOrder()', () => {
        it('should execute newUmOrder() successfully with required parameters only', async () => {
            const params: NewUmOrderRequest = {
                symbol: 'symbol_example',
                side: NewUmOrderSideEnum.BUY,
                type: NewUmOrderTypeEnum.LIMIT,
            };

            mockResponse = {
                clientOrderId: 'testOrder',
                cumQty: '0',
                cumQuote: '0',
                executedQty: '0',
                orderId: 22542179,
                avgPrice: '0.00000',
                origQty: '10',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'NEW',
                symbol: 'BTCUSDT',
                timeInForce: 'GTD',
                type: 'MARKET',
                selfTradePreventionMode: 'NONE',
                goodTillDate: 1693207680000,
                updateTime: 1566818724722,
                priceMatch: 'NONE',
            };

            const spy = jest.spyOn(client, 'newUmOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewUmOrderResponse>)
            );
            const response = await client.newUmOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute newUmOrder() successfully with optional parameters', async () => {
            const params: NewUmOrderRequest = {
                symbol: 'symbol_example',
                side: NewUmOrderSideEnum.BUY,
                type: NewUmOrderTypeEnum.LIMIT,
                positionSide: NewUmOrderPositionSideEnum.BOTH,
                timeInForce: NewUmOrderTimeInForceEnum.GTC,
                quantity: 1,
                reduceOnly: 'false',
                price: 1,
                newClientOrderId: '1',
                newOrderRespType: NewUmOrderNewOrderRespTypeEnum.ACK,
                priceMatch: NewUmOrderPriceMatchEnum.NONE,
                selfTradePreventionMode: NewUmOrderSelfTradePreventionModeEnum.NONE,
                goodTillDate: 789,
                recvWindow: 5000,
            };

            mockResponse = {
                clientOrderId: 'testOrder',
                cumQty: '0',
                cumQuote: '0',
                executedQty: '0',
                orderId: 22542179,
                avgPrice: '0.00000',
                origQty: '10',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'NEW',
                symbol: 'BTCUSDT',
                timeInForce: 'GTD',
                type: 'MARKET',
                selfTradePreventionMode: 'NONE',
                goodTillDate: 1693207680000,
                updateTime: 1566818724722,
                priceMatch: 'NONE',
            };

            const spy = jest.spyOn(client, 'newUmOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<NewUmOrderResponse>)
            );
            const response = await client.newUmOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: NewUmOrderRequest = {
                symbol: 'symbol_example',
                side: NewUmOrderSideEnum.BUY,
                type: NewUmOrderTypeEnum.LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.newUmOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling newUmOrder.'
            );
        });

        it('should throw RequiredError when side is missing', async () => {
            const _params: NewUmOrderRequest = {
                symbol: 'symbol_example',
                side: NewUmOrderSideEnum.BUY,
                type: NewUmOrderTypeEnum.LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.side;

            await expect(client.newUmOrder(params)).rejects.toThrow(
                'Required parameter side was null or undefined when calling newUmOrder.'
            );
        });

        it('should throw RequiredError when type is missing', async () => {
            const _params: NewUmOrderRequest = {
                symbol: 'symbol_example',
                side: NewUmOrderSideEnum.BUY,
                type: NewUmOrderTypeEnum.LIMIT,
            };
            const params = Object.assign({ ..._params });
            delete params?.type;

            await expect(client.newUmOrder(params)).rejects.toThrow(
                'Required parameter type was null or undefined when calling newUmOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: NewUmOrderRequest = {
                symbol: 'symbol_example',
                side: NewUmOrderSideEnum.BUY,
                type: NewUmOrderTypeEnum.LIMIT,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'newUmOrder').mockRejectedValueOnce(mockError);
            await expect(client.newUmOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryAllCmConditionalOrders()', () => {
        it('should execute queryAllCmConditionalOrders() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    newClientStrategyId: 'abc',
                    strategyId: 123445,
                    strategyStatus: 'TRIGGERED',
                    strategyType: 'TRAILING_STOP_MARKET',
                    origQty: '0.40',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    stopPrice: '9300',
                    symbol: 'BTCUSD',
                    orderId: 12123343534,
                    status: 'NEW',
                    bookTime: 1566818724710,
                    updateTime: 1566818724722,
                    triggerTime: 1566818724750,
                    timeInForce: 'GTC',
                    type: 'MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                },
            ];

            const spy = jest.spyOn(client, 'queryAllCmConditionalOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryAllCmConditionalOrdersResponse>)
            );
            const response = await client.queryAllCmConditionalOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryAllCmConditionalOrders() successfully with optional parameters', async () => {
            const params: QueryAllCmConditionalOrdersRequest = {
                symbol: 'symbol_example',
                strategyId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    newClientStrategyId: 'abc',
                    strategyId: 123445,
                    strategyStatus: 'TRIGGERED',
                    strategyType: 'TRAILING_STOP_MARKET',
                    origQty: '0.40',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    stopPrice: '9300',
                    symbol: 'BTCUSD',
                    orderId: 12123343534,
                    status: 'NEW',
                    bookTime: 1566818724710,
                    updateTime: 1566818724722,
                    triggerTime: 1566818724750,
                    timeInForce: 'GTC',
                    type: 'MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                },
            ];

            const spy = jest.spyOn(client, 'queryAllCmConditionalOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryAllCmConditionalOrdersResponse>)
            );
            const response = await client.queryAllCmConditionalOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryAllCmConditionalOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryAllCmConditionalOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryAllCmOrders()', () => {
        it('should execute queryAllCmOrders() successfully with required parameters only', async () => {
            const params: QueryAllCmOrdersRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    avgPrice: '0.0',
                    clientOrderId: 'abc',
                    cumBase: '0',
                    executedQty: '0',
                    orderId: 1917641,
                    origQty: '0.40',
                    origType: 'LIMIT',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    symbol: 'BTCUSD_200925',
                    pair: 'BTCUSD',
                    time: 1579276756075,
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    updateTime: 1579276756075,
                },
            ];

            const spy = jest.spyOn(client, 'queryAllCmOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryAllCmOrdersResponse>)
            );
            const response = await client.queryAllCmOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryAllCmOrders() successfully with optional parameters', async () => {
            const params: QueryAllCmOrdersRequest = {
                symbol: 'symbol_example',
                pair: 'pair_example',
                orderId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    avgPrice: '0.0',
                    clientOrderId: 'abc',
                    cumBase: '0',
                    executedQty: '0',
                    orderId: 1917641,
                    origQty: '0.40',
                    origType: 'LIMIT',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    symbol: 'BTCUSD_200925',
                    pair: 'BTCUSD',
                    time: 1579276756075,
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    updateTime: 1579276756075,
                },
            ];

            const spy = jest.spyOn(client, 'queryAllCmOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryAllCmOrdersResponse>)
            );
            const response = await client.queryAllCmOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryAllCmOrdersRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryAllCmOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryAllCmOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryAllCmOrdersRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'queryAllCmOrders').mockRejectedValueOnce(mockError);
            await expect(client.queryAllCmOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryAllCurrentCmOpenConditionalOrders()', () => {
        it('should execute queryAllCurrentCmOpenConditionalOrders() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    newClientStrategyId: 'abc',
                    strategyId: 123445,
                    strategyStatus: 'NEW',
                    strategyType: 'TRAILING_STOP_MARKET',
                    origQty: '0.40',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    stopPrice: '9300',
                    symbol: 'BTCUSD',
                    bookTime: 1566818724710,
                    updateTime: 1566818724722,
                    timeInForce: 'GTC',
                    activatePrice: '9020',
                    priceRate: '0.3',
                },
            ];

            const spy = jest
                .spyOn(client, 'queryAllCurrentCmOpenConditionalOrders')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryAllCurrentCmOpenConditionalOrdersResponse>)
                );
            const response = await client.queryAllCurrentCmOpenConditionalOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryAllCurrentCmOpenConditionalOrders() successfully with optional parameters', async () => {
            const params: QueryAllCurrentCmOpenConditionalOrdersRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    newClientStrategyId: 'abc',
                    strategyId: 123445,
                    strategyStatus: 'NEW',
                    strategyType: 'TRAILING_STOP_MARKET',
                    origQty: '0.40',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    stopPrice: '9300',
                    symbol: 'BTCUSD',
                    bookTime: 1566818724710,
                    updateTime: 1566818724722,
                    timeInForce: 'GTC',
                    activatePrice: '9020',
                    priceRate: '0.3',
                },
            ];

            const spy = jest
                .spyOn(client, 'queryAllCurrentCmOpenConditionalOrders')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryAllCurrentCmOpenConditionalOrdersResponse>)
                );
            const response = await client.queryAllCurrentCmOpenConditionalOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryAllCurrentCmOpenConditionalOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryAllCurrentCmOpenConditionalOrders()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryAllCurrentCmOpenOrders()', () => {
        it('should execute queryAllCurrentCmOpenOrders() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    avgPrice: '0.0',
                    clientOrderId: 'abc',
                    cumBase: '0',
                    executedQty: '0',
                    orderId: 1917641,
                    origQty: '0.40',
                    origType: 'LIMIT',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    symbol: 'BTCUSD_200925',
                    pair: 'BTCUSD',
                    time: 1579276756075,
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    updateTime: 1579276756075,
                },
            ];

            const spy = jest.spyOn(client, 'queryAllCurrentCmOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryAllCurrentCmOpenOrdersResponse>)
            );
            const response = await client.queryAllCurrentCmOpenOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryAllCurrentCmOpenOrders() successfully with optional parameters', async () => {
            const params: QueryAllCurrentCmOpenOrdersRequest = {
                symbol: 'symbol_example',
                pair: 'pair_example',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    avgPrice: '0.0',
                    clientOrderId: 'abc',
                    cumBase: '0',
                    executedQty: '0',
                    orderId: 1917641,
                    origQty: '0.40',
                    origType: 'LIMIT',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    symbol: 'BTCUSD_200925',
                    pair: 'BTCUSD',
                    time: 1579276756075,
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    updateTime: 1579276756075,
                },
            ];

            const spy = jest.spyOn(client, 'queryAllCurrentCmOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryAllCurrentCmOpenOrdersResponse>)
            );
            const response = await client.queryAllCurrentCmOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryAllCurrentCmOpenOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryAllCurrentCmOpenOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryAllCurrentUmOpenConditionalOrders()', () => {
        it('should execute queryAllCurrentUmOpenConditionalOrders() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    newClientStrategyId: 'abc',
                    strategyId: 123445,
                    strategyStatus: 'NEW',
                    strategyType: 'TRAILING_STOP_MARKET',
                    origQty: '0.40',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    stopPrice: '9300',
                    symbol: 'BTCUSDT',
                    bookTime: 1566818724710,
                    updateTime: 1566818724722,
                    timeInForce: 'GTC',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 0,
                    priceMatch: 'NONE',
                },
            ];

            const spy = jest
                .spyOn(client, 'queryAllCurrentUmOpenConditionalOrders')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryAllCurrentUmOpenConditionalOrdersResponse>)
                );
            const response = await client.queryAllCurrentUmOpenConditionalOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryAllCurrentUmOpenConditionalOrders() successfully with optional parameters', async () => {
            const params: QueryAllCurrentUmOpenConditionalOrdersRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    newClientStrategyId: 'abc',
                    strategyId: 123445,
                    strategyStatus: 'NEW',
                    strategyType: 'TRAILING_STOP_MARKET',
                    origQty: '0.40',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    stopPrice: '9300',
                    symbol: 'BTCUSDT',
                    bookTime: 1566818724710,
                    updateTime: 1566818724722,
                    timeInForce: 'GTC',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 0,
                    priceMatch: 'NONE',
                },
            ];

            const spy = jest
                .spyOn(client, 'queryAllCurrentUmOpenConditionalOrders')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryAllCurrentUmOpenConditionalOrdersResponse>)
                );
            const response = await client.queryAllCurrentUmOpenConditionalOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryAllCurrentUmOpenConditionalOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryAllCurrentUmOpenConditionalOrders()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryAllCurrentUmOpenOrders()', () => {
        it('should execute queryAllCurrentUmOpenOrders() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    avgPrice: '0.00000',
                    clientOrderId: 'abc',
                    cumQuote: '0',
                    executedQty: '0',
                    orderId: 1917641,
                    origQty: '0.40',
                    origType: 'LIMIT',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    symbol: 'BTCUSDT',
                    time: 1579276756075,
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    updateTime: 1579276756075,
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 0,
                    priceMatch: 'NONE',
                },
            ];

            const spy = jest.spyOn(client, 'queryAllCurrentUmOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryAllCurrentUmOpenOrdersResponse>)
            );
            const response = await client.queryAllCurrentUmOpenOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryAllCurrentUmOpenOrders() successfully with optional parameters', async () => {
            const params: QueryAllCurrentUmOpenOrdersRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    avgPrice: '0.00000',
                    clientOrderId: 'abc',
                    cumQuote: '0',
                    executedQty: '0',
                    orderId: 1917641,
                    origQty: '0.40',
                    origType: 'LIMIT',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    symbol: 'BTCUSDT',
                    time: 1579276756075,
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    updateTime: 1579276756075,
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 0,
                    priceMatch: 'NONE',
                },
            ];

            const spy = jest.spyOn(client, 'queryAllCurrentUmOpenOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryAllCurrentUmOpenOrdersResponse>)
            );
            const response = await client.queryAllCurrentUmOpenOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryAllCurrentUmOpenOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryAllCurrentUmOpenOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryAllMarginAccountOrders()', () => {
        it('should execute queryAllMarginAccountOrders() successfully with required parameters only', async () => {
            const params: QueryAllMarginAccountOrdersRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    clientOrderId: 'D2KDy4DIeS56PvkM13f8cP',
                    cummulativeQuoteQty: '0.00000000',
                    executedQty: '0.00000000',
                    icebergQty: '0.00000000',
                    isWorking: false,
                    orderId: 41295,
                    origQty: '5.31000000',
                    price: '0.22500000',
                    side: 'SELL',
                    status: 'CANCELED',
                    stopPrice: '0.18000000',
                    symbol: 'BNBBTC',
                    time: 1565769338806,
                    timeInForce: 'GTC',
                    type: 'TAKE_PROFIT_LIMIT',
                    updateTime: 1565769342148,
                    accountId: 152950866,
                    selfTradePreventionMode: 'EXPIRE_TAKER',
                    preventedMatchId: null,
                    preventedQuantity: null,
                },
            ];

            const spy = jest.spyOn(client, 'queryAllMarginAccountOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryAllMarginAccountOrdersResponse>)
            );
            const response = await client.queryAllMarginAccountOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryAllMarginAccountOrders() successfully with optional parameters', async () => {
            const params: QueryAllMarginAccountOrdersRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    clientOrderId: 'D2KDy4DIeS56PvkM13f8cP',
                    cummulativeQuoteQty: '0.00000000',
                    executedQty: '0.00000000',
                    icebergQty: '0.00000000',
                    isWorking: false,
                    orderId: 41295,
                    origQty: '5.31000000',
                    price: '0.22500000',
                    side: 'SELL',
                    status: 'CANCELED',
                    stopPrice: '0.18000000',
                    symbol: 'BNBBTC',
                    time: 1565769338806,
                    timeInForce: 'GTC',
                    type: 'TAKE_PROFIT_LIMIT',
                    updateTime: 1565769342148,
                    accountId: 152950866,
                    selfTradePreventionMode: 'EXPIRE_TAKER',
                    preventedMatchId: null,
                    preventedQuantity: null,
                },
            ];

            const spy = jest.spyOn(client, 'queryAllMarginAccountOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryAllMarginAccountOrdersResponse>)
            );
            const response = await client.queryAllMarginAccountOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryAllMarginAccountOrdersRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryAllMarginAccountOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryAllMarginAccountOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryAllMarginAccountOrdersRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryAllMarginAccountOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryAllMarginAccountOrders(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryAllUmConditionalOrders()', () => {
        it('should execute queryAllUmConditionalOrders() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    newClientStrategyId: 'abc',
                    strategyId: 123445,
                    strategyStatus: 'TRIGGERED',
                    strategyType: 'TRAILING_STOP_MARKET',
                    origQty: '0.40',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    stopPrice: '9300',
                    symbol: 'BTCUSDT',
                    orderId: 12132343435,
                    status: 'NEW',
                    bookTime: 1566818724710,
                    updateTime: 1566818724722,
                    triggerTime: 1566818724750,
                    timeInForce: 'GTC',
                    type: 'MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 0,
                    priceMatch: 'NONE',
                },
            ];

            const spy = jest.spyOn(client, 'queryAllUmConditionalOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryAllUmConditionalOrdersResponse>)
            );
            const response = await client.queryAllUmConditionalOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryAllUmConditionalOrders() successfully with optional parameters', async () => {
            const params: QueryAllUmConditionalOrdersRequest = {
                symbol: 'symbol_example',
                strategyId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    newClientStrategyId: 'abc',
                    strategyId: 123445,
                    strategyStatus: 'TRIGGERED',
                    strategyType: 'TRAILING_STOP_MARKET',
                    origQty: '0.40',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    stopPrice: '9300',
                    symbol: 'BTCUSDT',
                    orderId: 12132343435,
                    status: 'NEW',
                    bookTime: 1566818724710,
                    updateTime: 1566818724722,
                    triggerTime: 1566818724750,
                    timeInForce: 'GTC',
                    type: 'MARKET',
                    activatePrice: '9020',
                    priceRate: '0.3',
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 0,
                    priceMatch: 'NONE',
                },
            ];

            const spy = jest.spyOn(client, 'queryAllUmConditionalOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryAllUmConditionalOrdersResponse>)
            );
            const response = await client.queryAllUmConditionalOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryAllUmConditionalOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryAllUmConditionalOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryAllUmOrders()', () => {
        it('should execute queryAllUmOrders() successfully with required parameters only', async () => {
            const params: QueryAllUmOrdersRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    avgPrice: '0.00000',
                    clientOrderId: 'abc',
                    cumQuote: '0',
                    executedQty: '0',
                    orderId: 1917641,
                    origQty: '0.40',
                    origType: 'LIMIT',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    symbol: 'BTCUSDT',
                    time: 1579276756075,
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    updateTime: 1579276756075,
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 0,
                    priceMatch: 'NONE',
                },
            ];

            const spy = jest.spyOn(client, 'queryAllUmOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryAllUmOrdersResponse>)
            );
            const response = await client.queryAllUmOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryAllUmOrders() successfully with optional parameters', async () => {
            const params: QueryAllUmOrdersRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    avgPrice: '0.00000',
                    clientOrderId: 'abc',
                    cumQuote: '0',
                    executedQty: '0',
                    orderId: 1917641,
                    origQty: '0.40',
                    origType: 'LIMIT',
                    price: '0',
                    reduceOnly: false,
                    side: 'BUY',
                    positionSide: 'SHORT',
                    status: 'NEW',
                    symbol: 'BTCUSDT',
                    time: 1579276756075,
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    updateTime: 1579276756075,
                    selfTradePreventionMode: 'NONE',
                    goodTillDate: 0,
                    priceMatch: 'NONE',
                },
            ];

            const spy = jest.spyOn(client, 'queryAllUmOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryAllUmOrdersResponse>)
            );
            const response = await client.queryAllUmOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryAllUmOrdersRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryAllUmOrders(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryAllUmOrders.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryAllUmOrdersRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'queryAllUmOrders').mockRejectedValueOnce(mockError);
            await expect(client.queryAllUmOrders(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryCmConditionalOrderHistory()', () => {
        it('should execute queryCmConditionalOrderHistory() successfully with required parameters only', async () => {
            const params: QueryCmConditionalOrderHistoryRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                newClientStrategyId: 'abc',
                strategyId: 123445,
                strategyStatus: 'TRIGGERED',
                strategyType: 'TRAILING_STOP_MARKET',
                origQty: '0.40',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                stopPrice: '9300',
                symbol: 'BTCUSD',
                orderId: 12123343534,
                status: 'NEW',
                bookTime: 1566818724710,
                updateTime: 1566818724722,
                triggerTime: 1566818724750,
                timeInForce: 'GTC',
                type: 'MARKET',
                activatePrice: '9020',
                priceRate: '0.3',
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
                priceMatch: 'NONE',
            };

            const spy = jest.spyOn(client, 'queryCmConditionalOrderHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCmConditionalOrderHistoryResponse>)
            );
            const response = await client.queryCmConditionalOrderHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryCmConditionalOrderHistory() successfully with optional parameters', async () => {
            const params: QueryCmConditionalOrderHistoryRequest = {
                symbol: 'symbol_example',
                strategyId: 1,
                newClientStrategyId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                newClientStrategyId: 'abc',
                strategyId: 123445,
                strategyStatus: 'TRIGGERED',
                strategyType: 'TRAILING_STOP_MARKET',
                origQty: '0.40',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                stopPrice: '9300',
                symbol: 'BTCUSD',
                orderId: 12123343534,
                status: 'NEW',
                bookTime: 1566818724710,
                updateTime: 1566818724722,
                triggerTime: 1566818724750,
                timeInForce: 'GTC',
                type: 'MARKET',
                activatePrice: '9020',
                priceRate: '0.3',
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
                priceMatch: 'NONE',
            };

            const spy = jest.spyOn(client, 'queryCmConditionalOrderHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCmConditionalOrderHistoryResponse>)
            );
            const response = await client.queryCmConditionalOrderHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryCmConditionalOrderHistoryRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryCmConditionalOrderHistory(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryCmConditionalOrderHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryCmConditionalOrderHistoryRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryCmConditionalOrderHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryCmConditionalOrderHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryCmModifyOrderHistory()', () => {
        it('should execute queryCmModifyOrderHistory() successfully with required parameters only', async () => {
            const params: QueryCmModifyOrderHistoryRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    amendmentId: 5363,
                    symbol: 'BTCUSD_PERP',
                    pair: 'BTCUSD',
                    orderId: 20072994037,
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    time: 1629184560899,
                    amendment: {
                        price: { before: '30004', after: '30003.2' },
                        origQty: { before: '1', after: '1' },
                        count: 3,
                    },
                },
                {
                    amendmentId: 5361,
                    symbol: 'BTCUSD_PERP',
                    pair: 'BTCUSD',
                    orderId: 20072994037,
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    time: 1629184533946,
                    amendment: {
                        price: { before: '30005', after: '30004' },
                        origQty: { before: '1', after: '1' },
                        count: 2,
                    },
                },
                {
                    amendmentId: 5325,
                    symbol: 'BTCUSD_PERP',
                    pair: 'BTCUSD',
                    orderId: 20072994037,
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    time: 1629182711787,
                    amendment: {
                        price: { before: '30002', after: '30005' },
                        origQty: { before: '1', after: '1' },
                        count: 1,
                    },
                },
            ];

            const spy = jest.spyOn(client, 'queryCmModifyOrderHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCmModifyOrderHistoryResponse>)
            );
            const response = await client.queryCmModifyOrderHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryCmModifyOrderHistory() successfully with optional parameters', async () => {
            const params: QueryCmModifyOrderHistoryRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                origClientOrderId: '1',
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    amendmentId: 5363,
                    symbol: 'BTCUSD_PERP',
                    pair: 'BTCUSD',
                    orderId: 20072994037,
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    time: 1629184560899,
                    amendment: {
                        price: { before: '30004', after: '30003.2' },
                        origQty: { before: '1', after: '1' },
                        count: 3,
                    },
                },
                {
                    amendmentId: 5361,
                    symbol: 'BTCUSD_PERP',
                    pair: 'BTCUSD',
                    orderId: 20072994037,
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    time: 1629184533946,
                    amendment: {
                        price: { before: '30005', after: '30004' },
                        origQty: { before: '1', after: '1' },
                        count: 2,
                    },
                },
                {
                    amendmentId: 5325,
                    symbol: 'BTCUSD_PERP',
                    pair: 'BTCUSD',
                    orderId: 20072994037,
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    time: 1629182711787,
                    amendment: {
                        price: { before: '30002', after: '30005' },
                        origQty: { before: '1', after: '1' },
                        count: 1,
                    },
                },
            ];

            const spy = jest.spyOn(client, 'queryCmModifyOrderHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCmModifyOrderHistoryResponse>)
            );
            const response = await client.queryCmModifyOrderHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryCmModifyOrderHistoryRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryCmModifyOrderHistory(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryCmModifyOrderHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryCmModifyOrderHistoryRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryCmModifyOrderHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryCmModifyOrderHistory(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryCmOrder()', () => {
        it('should execute queryCmOrder() successfully with required parameters only', async () => {
            const params: QueryCmOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                avgPrice: '0.0',
                clientOrderId: 'abc',
                cumBase: '0',
                executedQty: '0',
                orderId: 1917641,
                origQty: '0.40',
                origType: 'LIMIT',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                status: 'NEW',
                symbol: 'BTCUSD_200925',
                pair: 'BTCUSD',
                positionSide: 'SHORT',
                time: 1579276756075,
                timeInForce: 'GTC',
                type: 'LIMIT',
                updateTime: 1579276756075,
            };

            const spy = jest.spyOn(client, 'queryCmOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCmOrderResponse>)
            );
            const response = await client.queryCmOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryCmOrder() successfully with optional parameters', async () => {
            const params: QueryCmOrderRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                origClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                avgPrice: '0.0',
                clientOrderId: 'abc',
                cumBase: '0',
                executedQty: '0',
                orderId: 1917641,
                origQty: '0.40',
                origType: 'LIMIT',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                status: 'NEW',
                symbol: 'BTCUSD_200925',
                pair: 'BTCUSD',
                positionSide: 'SHORT',
                time: 1579276756075,
                timeInForce: 'GTC',
                type: 'LIMIT',
                updateTime: 1579276756075,
            };

            const spy = jest.spyOn(client, 'queryCmOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCmOrderResponse>)
            );
            const response = await client.queryCmOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryCmOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryCmOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryCmOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryCmOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'queryCmOrder').mockRejectedValueOnce(mockError);
            await expect(client.queryCmOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryCurrentCmOpenConditionalOrder()', () => {
        it('should execute queryCurrentCmOpenConditionalOrder() successfully with required parameters only', async () => {
            const params: QueryCurrentCmOpenConditionalOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                newClientStrategyId: 'abc',
                strategyId: 123445,
                strategyStatus: 'NEW',
                strategyType: 'TRAILING_STOP_MARKET',
                origQty: '0.40',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                stopPrice: '9300',
                symbol: 'BTCUSD',
                bookTime: 1566818724710,
                updateTime: 1566818724722,
                timeInForce: 'GTC',
                activatePrice: '9020',
                priceRate: '0.3',
            };

            const spy = jest.spyOn(client, 'queryCurrentCmOpenConditionalOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCurrentCmOpenConditionalOrderResponse>)
            );
            const response = await client.queryCurrentCmOpenConditionalOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryCurrentCmOpenConditionalOrder() successfully with optional parameters', async () => {
            const params: QueryCurrentCmOpenConditionalOrderRequest = {
                symbol: 'symbol_example',
                strategyId: 1,
                newClientStrategyId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                newClientStrategyId: 'abc',
                strategyId: 123445,
                strategyStatus: 'NEW',
                strategyType: 'TRAILING_STOP_MARKET',
                origQty: '0.40',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                stopPrice: '9300',
                symbol: 'BTCUSD',
                bookTime: 1566818724710,
                updateTime: 1566818724722,
                timeInForce: 'GTC',
                activatePrice: '9020',
                priceRate: '0.3',
            };

            const spy = jest.spyOn(client, 'queryCurrentCmOpenConditionalOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCurrentCmOpenConditionalOrderResponse>)
            );
            const response = await client.queryCurrentCmOpenConditionalOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryCurrentCmOpenConditionalOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryCurrentCmOpenConditionalOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryCurrentCmOpenConditionalOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryCurrentCmOpenConditionalOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryCurrentCmOpenConditionalOrder')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryCurrentCmOpenConditionalOrder(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryCurrentCmOpenOrder()', () => {
        it('should execute queryCurrentCmOpenOrder() successfully with required parameters only', async () => {
            const params: QueryCurrentCmOpenOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                avgPrice: '0.0',
                clientOrderId: 'abc',
                cumBase: '0',
                executedQty: '0',
                orderId: 1917641,
                origQty: '0.40',
                origType: 'LIMIT',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'NEW',
                symbol: 'BTCUSD_200925',
                pair: 'BTCUSD',
                time: 1579276756075,
                timeInForce: 'GTC',
                type: 'LIMIT',
                updateTime: 1579276756075,
            };

            const spy = jest.spyOn(client, 'queryCurrentCmOpenOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCurrentCmOpenOrderResponse>)
            );
            const response = await client.queryCurrentCmOpenOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryCurrentCmOpenOrder() successfully with optional parameters', async () => {
            const params: QueryCurrentCmOpenOrderRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                origClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                avgPrice: '0.0',
                clientOrderId: 'abc',
                cumBase: '0',
                executedQty: '0',
                orderId: 1917641,
                origQty: '0.40',
                origType: 'LIMIT',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'NEW',
                symbol: 'BTCUSD_200925',
                pair: 'BTCUSD',
                time: 1579276756075,
                timeInForce: 'GTC',
                type: 'LIMIT',
                updateTime: 1579276756075,
            };

            const spy = jest.spyOn(client, 'queryCurrentCmOpenOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCurrentCmOpenOrderResponse>)
            );
            const response = await client.queryCurrentCmOpenOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryCurrentCmOpenOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryCurrentCmOpenOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryCurrentCmOpenOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryCurrentCmOpenOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryCurrentCmOpenOrder')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryCurrentCmOpenOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryCurrentMarginOpenOrder()', () => {
        it('should execute queryCurrentMarginOpenOrder() successfully with required parameters only', async () => {
            const params: QueryCurrentMarginOpenOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    clientOrderId: 'qhcZw71gAkCCTv0t0k8LUK',
                    cummulativeQuoteQty: '0.00000000',
                    executedQty: '0.00000000',
                    icebergQty: '0.00000000',
                    isWorking: true,
                    orderId: 211842552,
                    origQty: '0.30000000',
                    price: '0.00475010',
                    side: 'SELL',
                    status: 'NEW',
                    stopPrice: '0.00000000',
                    symbol: 'BNBBTC',
                    time: 1562040170089,
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    updateTime: 1562040170089,
                    accountId: 152950866,
                    selfTradePreventionMode: 'EXPIRE_TAKER',
                    preventedMatchId: null,
                    preventedQuantity: null,
                },
            ];

            const spy = jest.spyOn(client, 'queryCurrentMarginOpenOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCurrentMarginOpenOrderResponse>)
            );
            const response = await client.queryCurrentMarginOpenOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryCurrentMarginOpenOrder() successfully with optional parameters', async () => {
            const params: QueryCurrentMarginOpenOrderRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    clientOrderId: 'qhcZw71gAkCCTv0t0k8LUK',
                    cummulativeQuoteQty: '0.00000000',
                    executedQty: '0.00000000',
                    icebergQty: '0.00000000',
                    isWorking: true,
                    orderId: 211842552,
                    origQty: '0.30000000',
                    price: '0.00475010',
                    side: 'SELL',
                    status: 'NEW',
                    stopPrice: '0.00000000',
                    symbol: 'BNBBTC',
                    time: 1562040170089,
                    timeInForce: 'GTC',
                    type: 'LIMIT',
                    updateTime: 1562040170089,
                    accountId: 152950866,
                    selfTradePreventionMode: 'EXPIRE_TAKER',
                    preventedMatchId: null,
                    preventedQuantity: null,
                },
            ];

            const spy = jest.spyOn(client, 'queryCurrentMarginOpenOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCurrentMarginOpenOrderResponse>)
            );
            const response = await client.queryCurrentMarginOpenOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryCurrentMarginOpenOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryCurrentMarginOpenOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryCurrentMarginOpenOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryCurrentMarginOpenOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryCurrentMarginOpenOrder')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryCurrentMarginOpenOrder(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryCurrentUmOpenConditionalOrder()', () => {
        it('should execute queryCurrentUmOpenConditionalOrder() successfully with required parameters only', async () => {
            const params: QueryCurrentUmOpenConditionalOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                newClientStrategyId: 'abc',
                strategyId: 123445,
                strategyStatus: 'NEW',
                strategyType: 'TRAILING_STOP_MARKET',
                origQty: '0.40',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                stopPrice: '9300',
                symbol: 'BTCUSDT',
                bookTime: 1566818724710,
                updateTime: 1566818724722,
                timeInForce: 'GTC',
                activatePrice: '9020',
                priceRate: '0.3',
                selfTradePreventionMode: 'NONE',
                goodTillDate: 0,
                priceMatch: 'NONE',
            };

            const spy = jest.spyOn(client, 'queryCurrentUmOpenConditionalOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCurrentUmOpenConditionalOrderResponse>)
            );
            const response = await client.queryCurrentUmOpenConditionalOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryCurrentUmOpenConditionalOrder() successfully with optional parameters', async () => {
            const params: QueryCurrentUmOpenConditionalOrderRequest = {
                symbol: 'symbol_example',
                strategyId: 1,
                newClientStrategyId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                newClientStrategyId: 'abc',
                strategyId: 123445,
                strategyStatus: 'NEW',
                strategyType: 'TRAILING_STOP_MARKET',
                origQty: '0.40',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                stopPrice: '9300',
                symbol: 'BTCUSDT',
                bookTime: 1566818724710,
                updateTime: 1566818724722,
                timeInForce: 'GTC',
                activatePrice: '9020',
                priceRate: '0.3',
                selfTradePreventionMode: 'NONE',
                goodTillDate: 0,
                priceMatch: 'NONE',
            };

            const spy = jest.spyOn(client, 'queryCurrentUmOpenConditionalOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCurrentUmOpenConditionalOrderResponse>)
            );
            const response = await client.queryCurrentUmOpenConditionalOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryCurrentUmOpenConditionalOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryCurrentUmOpenConditionalOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryCurrentUmOpenConditionalOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryCurrentUmOpenConditionalOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryCurrentUmOpenConditionalOrder')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryCurrentUmOpenConditionalOrder(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryCurrentUmOpenOrder()', () => {
        it('should execute queryCurrentUmOpenOrder() successfully with required parameters only', async () => {
            const params: QueryCurrentUmOpenOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                avgPrice: '0.00000',
                clientOrderId: 'abc',
                cumQuote: '0',
                executedQty: '0',
                orderId: 1917641,
                origQty: '0.40',
                origType: 'LIMIT',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'NEW',
                symbol: 'BTCUSDT',
                time: 1579276756075,
                timeInForce: 'GTC',
                type: 'LIMIT',
                updateTime: 1579276756075,
                selfTradePreventionMode: 'NONE',
                goodTillDate: 0,
                priceMatch: 'NONE',
            };

            const spy = jest.spyOn(client, 'queryCurrentUmOpenOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCurrentUmOpenOrderResponse>)
            );
            const response = await client.queryCurrentUmOpenOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryCurrentUmOpenOrder() successfully with optional parameters', async () => {
            const params: QueryCurrentUmOpenOrderRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                origClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                avgPrice: '0.00000',
                clientOrderId: 'abc',
                cumQuote: '0',
                executedQty: '0',
                orderId: 1917641,
                origQty: '0.40',
                origType: 'LIMIT',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'NEW',
                symbol: 'BTCUSDT',
                time: 1579276756075,
                timeInForce: 'GTC',
                type: 'LIMIT',
                updateTime: 1579276756075,
                selfTradePreventionMode: 'NONE',
                goodTillDate: 0,
                priceMatch: 'NONE',
            };

            const spy = jest.spyOn(client, 'queryCurrentUmOpenOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryCurrentUmOpenOrderResponse>)
            );
            const response = await client.queryCurrentUmOpenOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryCurrentUmOpenOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryCurrentUmOpenOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryCurrentUmOpenOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryCurrentUmOpenOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryCurrentUmOpenOrder')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryCurrentUmOpenOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryMarginAccountOrder()', () => {
        it('should execute queryMarginAccountOrder() successfully with required parameters only', async () => {
            const params: QueryMarginAccountOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                clientOrderId: 'ZwfQzuDIGpceVhKW5DvCmO',
                cummulativeQuoteQty: '0.00000000',
                executedQty: '0.00000000',
                icebergQty: '0.00000000',
                isWorking: true,
                orderId: 213205622,
                origQty: '0.30000000',
                price: '0.00493630',
                side: 'SELL',
                status: 'NEW',
                stopPrice: '0.00000000',
                symbol: 'BNBBTC',
                time: 1562133008725,
                timeInForce: 'GTC',
                type: 'LIMIT',
                updateTime: 1562133008725,
                accountId: 152950866,
                selfTradePreventionMode: 'EXPIRE_TAKER',
                preventedMatchId: null,
                preventedQuantity: null,
            };

            const spy = jest.spyOn(client, 'queryMarginAccountOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginAccountOrderResponse>)
            );
            const response = await client.queryMarginAccountOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryMarginAccountOrder() successfully with optional parameters', async () => {
            const params: QueryMarginAccountOrderRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                origClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                clientOrderId: 'ZwfQzuDIGpceVhKW5DvCmO',
                cummulativeQuoteQty: '0.00000000',
                executedQty: '0.00000000',
                icebergQty: '0.00000000',
                isWorking: true,
                orderId: 213205622,
                origQty: '0.30000000',
                price: '0.00493630',
                side: 'SELL',
                status: 'NEW',
                stopPrice: '0.00000000',
                symbol: 'BNBBTC',
                time: 1562133008725,
                timeInForce: 'GTC',
                type: 'LIMIT',
                updateTime: 1562133008725,
                accountId: 152950866,
                selfTradePreventionMode: 'EXPIRE_TAKER',
                preventedMatchId: null,
                preventedQuantity: null,
            };

            const spy = jest.spyOn(client, 'queryMarginAccountOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginAccountOrderResponse>)
            );
            const response = await client.queryMarginAccountOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryMarginAccountOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryMarginAccountOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryMarginAccountOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryMarginAccountOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryMarginAccountOrder')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryMarginAccountOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryMarginAccountsAllOco()', () => {
        it('should execute queryMarginAccountsAllOco() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    orderListId: 29,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'amEEAXryFzFwYF1FeRpUoZ',
                    transactionTime: 1565245913483,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'oD7aesZqjEGlZrbtRpy5zB' },
                        { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'Jr1h6xirOxgeJOUuYQS7V3' },
                    ],
                },
                {
                    orderListId: 28,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'hG7hFNxJV6cZy3Ze4AUT4d',
                    transactionTime: 1565245913407,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'j6lFOfbmFMRjTYA7rRJ0LP' },
                        { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'z0KCjOdditiLS5ekAFtK81' },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'queryMarginAccountsAllOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginAccountsAllOcoResponse>)
            );
            const response = await client.queryMarginAccountsAllOco();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryMarginAccountsAllOco() successfully with optional parameters', async () => {
            const params: QueryMarginAccountsAllOcoRequest = {
                fromId: 1,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    orderListId: 29,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'amEEAXryFzFwYF1FeRpUoZ',
                    transactionTime: 1565245913483,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'oD7aesZqjEGlZrbtRpy5zB' },
                        { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'Jr1h6xirOxgeJOUuYQS7V3' },
                    ],
                },
                {
                    orderListId: 28,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'hG7hFNxJV6cZy3Ze4AUT4d',
                    transactionTime: 1565245913407,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 2, clientOrderId: 'j6lFOfbmFMRjTYA7rRJ0LP' },
                        { symbol: 'LTCBTC', orderId: 3, clientOrderId: 'z0KCjOdditiLS5ekAFtK81' },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'queryMarginAccountsAllOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginAccountsAllOcoResponse>)
            );
            const response = await client.queryMarginAccountsAllOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryMarginAccountsAllOco')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryMarginAccountsAllOco()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryMarginAccountsOco()', () => {
        it('should execute queryMarginAccountsOco() successfully with required parameters only', async () => {
            mockResponse = {
                orderListId: 27,
                contingencyType: 'OCO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'h2USkA5YQpaXHPIrkd96xE',
                transactionTime: 1565245656253,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'qD1gy3kc3Gx0rihm9Y3xwS' },
                    { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'ARzZ9I00CPM8i3NhmU9Ega' },
                ],
            };

            const spy = jest.spyOn(client, 'queryMarginAccountsOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginAccountsOcoResponse>)
            );
            const response = await client.queryMarginAccountsOco();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryMarginAccountsOco() successfully with optional parameters', async () => {
            const params: QueryMarginAccountsOcoRequest = {
                orderListId: 1,
                origClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                orderListId: 27,
                contingencyType: 'OCO',
                listStatusType: 'EXEC_STARTED',
                listOrderStatus: 'EXECUTING',
                listClientOrderId: 'h2USkA5YQpaXHPIrkd96xE',
                transactionTime: 1565245656253,
                symbol: 'LTCBTC',
                orders: [
                    { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'qD1gy3kc3Gx0rihm9Y3xwS' },
                    { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'ARzZ9I00CPM8i3NhmU9Ega' },
                ],
            };

            const spy = jest.spyOn(client, 'queryMarginAccountsOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginAccountsOcoResponse>)
            );
            const response = await client.queryMarginAccountsOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryMarginAccountsOco')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryMarginAccountsOco()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryMarginAccountsOpenOco()', () => {
        it('should execute queryMarginAccountsOpenOco() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    orderListId: 31,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'wuB13fmulKj3YjdqWEcsnp',
                    transactionTime: 1565246080644,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'r3EH2N76dHfLoSZWIUw1bT' },
                        { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'Cv1SnyPD3qhqpbjpYEHbd2' },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'queryMarginAccountsOpenOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginAccountsOpenOcoResponse>)
            );
            const response = await client.queryMarginAccountsOpenOco();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryMarginAccountsOpenOco() successfully with optional parameters', async () => {
            const params: QueryMarginAccountsOpenOcoRequest = {
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    orderListId: 31,
                    contingencyType: 'OCO',
                    listStatusType: 'EXEC_STARTED',
                    listOrderStatus: 'EXECUTING',
                    listClientOrderId: 'wuB13fmulKj3YjdqWEcsnp',
                    transactionTime: 1565246080644,
                    symbol: 'LTCBTC',
                    orders: [
                        { symbol: 'LTCBTC', orderId: 4, clientOrderId: 'r3EH2N76dHfLoSZWIUw1bT' },
                        { symbol: 'LTCBTC', orderId: 5, clientOrderId: 'Cv1SnyPD3qhqpbjpYEHbd2' },
                    ],
                },
            ];

            const spy = jest.spyOn(client, 'queryMarginAccountsOpenOco').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryMarginAccountsOpenOcoResponse>)
            );
            const response = await client.queryMarginAccountsOpenOco(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryMarginAccountsOpenOco')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryMarginAccountsOpenOco()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryUmConditionalOrderHistory()', () => {
        it('should execute queryUmConditionalOrderHistory() successfully with required parameters only', async () => {
            const params: QueryUmConditionalOrderHistoryRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                newClientStrategyId: 'abc',
                strategyId: 123445,
                strategyStatus: 'TRIGGERED',
                strategyType: 'TRAILING_STOP_MARKET',
                origQty: '0.40',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                stopPrice: '9300',
                symbol: 'BTCUSDT',
                orderId: 12132343435,
                status: 'NEW',
                bookTime: 1566818724710,
                updateTime: 1566818724722,
                triggerTime: 1566818724750,
                timeInForce: 'GTC',
                type: 'MARKET',
                activatePrice: '9020',
                priceRate: '0.3',
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
                selfTradePreventionMode: 'NONE',
                goodTillDate: 0,
            };

            const spy = jest.spyOn(client, 'queryUmConditionalOrderHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUmConditionalOrderHistoryResponse>)
            );
            const response = await client.queryUmConditionalOrderHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryUmConditionalOrderHistory() successfully with optional parameters', async () => {
            const params: QueryUmConditionalOrderHistoryRequest = {
                symbol: 'symbol_example',
                strategyId: 1,
                newClientStrategyId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                newClientStrategyId: 'abc',
                strategyId: 123445,
                strategyStatus: 'TRIGGERED',
                strategyType: 'TRAILING_STOP_MARKET',
                origQty: '0.40',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                stopPrice: '9300',
                symbol: 'BTCUSDT',
                orderId: 12132343435,
                status: 'NEW',
                bookTime: 1566818724710,
                updateTime: 1566818724722,
                triggerTime: 1566818724750,
                timeInForce: 'GTC',
                type: 'MARKET',
                activatePrice: '9020',
                priceRate: '0.3',
                workingType: 'CONTRACT_PRICE',
                priceProtect: false,
                selfTradePreventionMode: 'NONE',
                goodTillDate: 0,
            };

            const spy = jest.spyOn(client, 'queryUmConditionalOrderHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUmConditionalOrderHistoryResponse>)
            );
            const response = await client.queryUmConditionalOrderHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryUmConditionalOrderHistoryRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryUmConditionalOrderHistory(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryUmConditionalOrderHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryUmConditionalOrderHistoryRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryUmConditionalOrderHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryUmConditionalOrderHistory(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryUmModifyOrderHistory()', () => {
        it('should execute queryUmModifyOrderHistory() successfully with required parameters only', async () => {
            const params: QueryUmModifyOrderHistoryRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    amendmentId: 5363,
                    symbol: 'BTCUSDT',
                    pair: 'BTCUSDT',
                    orderId: 20072994037,
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    time: 1629184560899,
                    amendment: {
                        price: { before: '30004', after: '30003.2' },
                        origQty: { before: '1', after: '1' },
                        count: 3,
                    },
                    priceMatch: 'NONE',
                },
                {
                    amendmentId: 5361,
                    symbol: 'BTCUSDT',
                    pair: 'BTCUSDT',
                    orderId: 20072994037,
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    time: 1629184533946,
                    amendment: {
                        price: { before: '30005', after: '30004' },
                        origQty: { before: '1', after: '1' },
                        count: 2,
                    },
                    priceMatch: 'NONE',
                },
                {
                    amendmentId: 5325,
                    symbol: 'BTCUSDT',
                    pair: 'BTCUSDT',
                    orderId: 20072994037,
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    time: 1629182711787,
                    amendment: {
                        price: { before: '30002', after: '30005' },
                        origQty: { before: '1', after: '1' },
                        count: 1,
                    },
                    priceMatch: 'NONE',
                },
            ];

            const spy = jest.spyOn(client, 'queryUmModifyOrderHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUmModifyOrderHistoryResponse>)
            );
            const response = await client.queryUmModifyOrderHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryUmModifyOrderHistory() successfully with optional parameters', async () => {
            const params: QueryUmModifyOrderHistoryRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                origClientOrderId: '1',
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    amendmentId: 5363,
                    symbol: 'BTCUSDT',
                    pair: 'BTCUSDT',
                    orderId: 20072994037,
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    time: 1629184560899,
                    amendment: {
                        price: { before: '30004', after: '30003.2' },
                        origQty: { before: '1', after: '1' },
                        count: 3,
                    },
                    priceMatch: 'NONE',
                },
                {
                    amendmentId: 5361,
                    symbol: 'BTCUSDT',
                    pair: 'BTCUSDT',
                    orderId: 20072994037,
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    time: 1629184533946,
                    amendment: {
                        price: { before: '30005', after: '30004' },
                        origQty: { before: '1', after: '1' },
                        count: 2,
                    },
                    priceMatch: 'NONE',
                },
                {
                    amendmentId: 5325,
                    symbol: 'BTCUSDT',
                    pair: 'BTCUSDT',
                    orderId: 20072994037,
                    clientOrderId: 'LJ9R4QZDihCaS8UAOOLpgW',
                    time: 1629182711787,
                    amendment: {
                        price: { before: '30002', after: '30005' },
                        origQty: { before: '1', after: '1' },
                        count: 1,
                    },
                    priceMatch: 'NONE',
                },
            ];

            const spy = jest.spyOn(client, 'queryUmModifyOrderHistory').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUmModifyOrderHistoryResponse>)
            );
            const response = await client.queryUmModifyOrderHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryUmModifyOrderHistoryRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryUmModifyOrderHistory(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryUmModifyOrderHistory.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryUmModifyOrderHistoryRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryUmModifyOrderHistory')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryUmModifyOrderHistory(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryUmOrder()', () => {
        it('should execute queryUmOrder() successfully with required parameters only', async () => {
            const params: QueryUmOrderRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = {
                avgPrice: '0.00000',
                clientOrderId: 'abc',
                cumQuote: '0',
                executedQty: '0',
                orderId: 1917641,
                origQty: '0.40',
                origType: 'LIMIT',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'NEW',
                symbol: 'BTCUSDT',
                time: 1579276756075,
                timeInForce: 'GTC',
                type: 'LIMIT',
                updateTime: 1579276756075,
                selfTradePreventionMode: 'NONE',
                goodTillDate: 0,
                priceMatch: 'NONE',
            };

            const spy = jest.spyOn(client, 'queryUmOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUmOrderResponse>)
            );
            const response = await client.queryUmOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryUmOrder() successfully with optional parameters', async () => {
            const params: QueryUmOrderRequest = {
                symbol: 'symbol_example',
                orderId: 1,
                origClientOrderId: '1',
                recvWindow: 5000,
            };

            mockResponse = {
                avgPrice: '0.00000',
                clientOrderId: 'abc',
                cumQuote: '0',
                executedQty: '0',
                orderId: 1917641,
                origQty: '0.40',
                origType: 'LIMIT',
                price: '0',
                reduceOnly: false,
                side: 'BUY',
                positionSide: 'SHORT',
                status: 'NEW',
                symbol: 'BTCUSDT',
                time: 1579276756075,
                timeInForce: 'GTC',
                type: 'LIMIT',
                updateTime: 1579276756075,
                selfTradePreventionMode: 'NONE',
                goodTillDate: 0,
                priceMatch: 'NONE',
            };

            const spy = jest.spyOn(client, 'queryUmOrder').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUmOrderResponse>)
            );
            const response = await client.queryUmOrder(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: QueryUmOrderRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.queryUmOrder(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling queryUmOrder.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: QueryUmOrderRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'queryUmOrder').mockRejectedValueOnce(mockError);
            await expect(client.queryUmOrder(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryUsersCmForceOrders()', () => {
        it('should execute queryUsersCmForceOrders() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    orderId: 165123080,
                    symbol: 'BTCUSD_200925',
                    pair: 'BTCUSD',
                    status: 'FILLED',
                    clientOrderId: 'autoclose-1596542005017000006',
                    price: '11326.9',
                    avgPrice: '11326.9',
                    origQty: '1',
                    executedQty: '1',
                    cumBase: '0.00882854',
                    timeInForce: 'IOC',
                    type: 'LIMIT',
                    reduceOnly: false,
                    side: 'SELL',
                    positionSide: 'BOTH',
                    origType: 'LIMIT',
                    time: 1596542005019,
                    updateTime: 1596542005050,
                },
            ];

            const spy = jest.spyOn(client, 'queryUsersCmForceOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUsersCmForceOrdersResponse>)
            );
            const response = await client.queryUsersCmForceOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryUsersCmForceOrders() successfully with optional parameters', async () => {
            const params: QueryUsersCmForceOrdersRequest = {
                symbol: 'symbol_example',
                autoCloseType: QueryUsersCmForceOrdersAutoCloseTypeEnum.LIQUIDATION,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    orderId: 165123080,
                    symbol: 'BTCUSD_200925',
                    pair: 'BTCUSD',
                    status: 'FILLED',
                    clientOrderId: 'autoclose-1596542005017000006',
                    price: '11326.9',
                    avgPrice: '11326.9',
                    origQty: '1',
                    executedQty: '1',
                    cumBase: '0.00882854',
                    timeInForce: 'IOC',
                    type: 'LIMIT',
                    reduceOnly: false,
                    side: 'SELL',
                    positionSide: 'BOTH',
                    origType: 'LIMIT',
                    time: 1596542005019,
                    updateTime: 1596542005050,
                },
            ];

            const spy = jest.spyOn(client, 'queryUsersCmForceOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUsersCmForceOrdersResponse>)
            );
            const response = await client.queryUsersCmForceOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryUsersCmForceOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryUsersCmForceOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryUsersMarginForceOrders()', () => {
        it('should execute queryUsersMarginForceOrders() successfully with required parameters only', async () => {
            mockResponse = {
                rows: [
                    {
                        avgPrice: '0.00388359',
                        executedQty: '31.39000000',
                        orderId: 180015097,
                        price: '0.00388110',
                        qty: '31.39000000',
                        side: 'SELL',
                        symbol: 'BNBBTC',
                        timeInForce: 'GTC',
                        updatedTime: 1558941374745,
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'queryUsersMarginForceOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUsersMarginForceOrdersResponse>)
            );
            const response = await client.queryUsersMarginForceOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryUsersMarginForceOrders() successfully with optional parameters', async () => {
            const params: QueryUsersMarginForceOrdersRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = {
                rows: [
                    {
                        avgPrice: '0.00388359',
                        executedQty: '31.39000000',
                        orderId: 180015097,
                        price: '0.00388110',
                        qty: '31.39000000',
                        side: 'SELL',
                        symbol: 'BNBBTC',
                        timeInForce: 'GTC',
                        updatedTime: 1558941374745,
                    },
                ],
                total: 1,
            };

            const spy = jest.spyOn(client, 'queryUsersMarginForceOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUsersMarginForceOrdersResponse>)
            );
            const response = await client.queryUsersMarginForceOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryUsersMarginForceOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryUsersMarginForceOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryUsersUmForceOrders()', () => {
        it('should execute queryUsersUmForceOrders() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    orderId: 6071832819,
                    symbol: 'BTCUSDT',
                    status: 'FILLED',
                    clientOrderId: 'autoclose-1596107620040000020',
                    price: '10871.09',
                    avgPrice: '10913.21000',
                    origQty: '0.001',
                    executedQty: '0.001',
                    cumQuote: '10.91321',
                    timeInForce: 'IOC',
                    type: 'LIMIT',
                    reduceOnly: false,
                    side: 'SELL',
                    positionSide: 'BOTH',
                    origType: 'LIMIT',
                    time: 1596107620044,
                    updateTime: 1596107620087,
                },
            ];

            const spy = jest.spyOn(client, 'queryUsersUmForceOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUsersUmForceOrdersResponse>)
            );
            const response = await client.queryUsersUmForceOrders();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryUsersUmForceOrders() successfully with optional parameters', async () => {
            const params: QueryUsersUmForceOrdersRequest = {
                symbol: 'symbol_example',
                autoCloseType: QueryUsersUmForceOrdersAutoCloseTypeEnum.LIQUIDATION,
                startTime: 1623319461670,
                endTime: 1641782889000,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    orderId: 6071832819,
                    symbol: 'BTCUSDT',
                    status: 'FILLED',
                    clientOrderId: 'autoclose-1596107620040000020',
                    price: '10871.09',
                    avgPrice: '10913.21000',
                    origQty: '0.001',
                    executedQty: '0.001',
                    cumQuote: '10.91321',
                    timeInForce: 'IOC',
                    type: 'LIMIT',
                    reduceOnly: false,
                    side: 'SELL',
                    positionSide: 'BOTH',
                    origType: 'LIMIT',
                    time: 1596107620044,
                    updateTime: 1596107620087,
                },
            ];

            const spy = jest.spyOn(client, 'queryUsersUmForceOrders').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<QueryUsersUmForceOrdersResponse>)
            );
            const response = await client.queryUsersUmForceOrders(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryUsersUmForceOrders')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryUsersUmForceOrders()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('toggleBnbBurnOnUmFuturesTrade()', () => {
        it('should execute toggleBnbBurnOnUmFuturesTrade() successfully with required parameters only', async () => {
            const params: ToggleBnbBurnOnUmFuturesTradeRequest = {
                feeBurn: 'feeBurn_example',
            };

            mockResponse = { code: 200, msg: 'success' };

            const spy = jest.spyOn(client, 'toggleBnbBurnOnUmFuturesTrade').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ToggleBnbBurnOnUmFuturesTradeResponse>)
            );
            const response = await client.toggleBnbBurnOnUmFuturesTrade(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute toggleBnbBurnOnUmFuturesTrade() successfully with optional parameters', async () => {
            const params: ToggleBnbBurnOnUmFuturesTradeRequest = {
                feeBurn: 'feeBurn_example',
                recvWindow: 5000,
            };

            mockResponse = { code: 200, msg: 'success' };

            const spy = jest.spyOn(client, 'toggleBnbBurnOnUmFuturesTrade').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ToggleBnbBurnOnUmFuturesTradeResponse>)
            );
            const response = await client.toggleBnbBurnOnUmFuturesTrade(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when feeBurn is missing', async () => {
            const _params: ToggleBnbBurnOnUmFuturesTradeRequest = {
                feeBurn: 'feeBurn_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.feeBurn;

            await expect(client.toggleBnbBurnOnUmFuturesTrade(params)).rejects.toThrow(
                'Required parameter feeBurn was null or undefined when calling toggleBnbBurnOnUmFuturesTrade.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ToggleBnbBurnOnUmFuturesTradeRequest = {
                feeBurn: 'feeBurn_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'toggleBnbBurnOnUmFuturesTrade')
                .mockRejectedValueOnce(mockError);
            await expect(client.toggleBnbBurnOnUmFuturesTrade(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('umAccountTradeList()', () => {
        it('should execute umAccountTradeList() successfully with required parameters only', async () => {
            const params: UmAccountTradeListRequest = {
                symbol: 'symbol_example',
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    id: 67880589,
                    orderId: 270093109,
                    side: 'SELL',
                    price: '28511.00',
                    qty: '0.010',
                    realizedPnl: '2.58500000',
                    quoteQty: '285.11000',
                    commission: '-0.11404400',
                    commissionAsset: 'USDT',
                    time: 1680688557875,
                    buyer: false,
                    maker: false,
                    positionSide: 'BOTH',
                },
            ];

            const spy = jest.spyOn(client, 'umAccountTradeList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UmAccountTradeListResponse>)
            );
            const response = await client.umAccountTradeList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute umAccountTradeList() successfully with optional parameters', async () => {
            const params: UmAccountTradeListRequest = {
                symbol: 'symbol_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                fromId: 1,
                limit: 100,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    symbol: 'BTCUSDT',
                    id: 67880589,
                    orderId: 270093109,
                    side: 'SELL',
                    price: '28511.00',
                    qty: '0.010',
                    realizedPnl: '2.58500000',
                    quoteQty: '285.11000',
                    commission: '-0.11404400',
                    commissionAsset: 'USDT',
                    time: 1680688557875,
                    buyer: false,
                    maker: false,
                    positionSide: 'BOTH',
                },
            ];

            const spy = jest.spyOn(client, 'umAccountTradeList').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UmAccountTradeListResponse>)
            );
            const response = await client.umAccountTradeList(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when symbol is missing', async () => {
            const _params: UmAccountTradeListRequest = {
                symbol: 'symbol_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.symbol;

            await expect(client.umAccountTradeList(params)).rejects.toThrow(
                'Required parameter symbol was null or undefined when calling umAccountTradeList.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: UmAccountTradeListRequest = {
                symbol: 'symbol_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'umAccountTradeList').mockRejectedValueOnce(mockError);
            await expect(client.umAccountTradeList(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('umPositionAdlQuantileEstimation()', () => {
        it('should execute umPositionAdlQuantileEstimation() successfully with required parameters only', async () => {
            mockResponse = [
                { symbol: 'ETHUSDT', adlQuantile: { LONG: 3, SHORT: 3, HEDGE: 0 } },
                { symbol: 'BTCUSDT', adlQuantile: { LONG: 1, SHORT: 2, BOTH: 0 } },
            ];

            const spy = jest.spyOn(client, 'umPositionAdlQuantileEstimation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UmPositionAdlQuantileEstimationResponse>)
            );
            const response = await client.umPositionAdlQuantileEstimation();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute umPositionAdlQuantileEstimation() successfully with optional parameters', async () => {
            const params: UmPositionAdlQuantileEstimationRequest = {
                symbol: 'symbol_example',
                recvWindow: 5000,
            };

            mockResponse = [
                { symbol: 'ETHUSDT', adlQuantile: { LONG: 3, SHORT: 3, HEDGE: 0 } },
                { symbol: 'BTCUSDT', adlQuantile: { LONG: 1, SHORT: 2, BOTH: 0 } },
            ];

            const spy = jest.spyOn(client, 'umPositionAdlQuantileEstimation').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<UmPositionAdlQuantileEstimationResponse>)
            );
            const response = await client.umPositionAdlQuantileEstimation(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'umPositionAdlQuantileEstimation')
                .mockRejectedValueOnce(mockError);
            await expect(client.umPositionAdlQuantileEstimation()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
