/**
 * Binance Derivatives Trading Portfolio Margin Pro REST API
 *
 * OpenAPI Specification for the Binance Derivatives Trading Portfolio Margin Pro REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { jest, expect, beforeEach, describe, it } from '@jest/globals';
import { ConfigurationRestAPI, type RestApiResponse } from '@binance/common';

import { AccountApi } from '../../../src/rest-api';
import {
    BnbTransferRequest,
    ChangeAutoRepayFuturesStatusRequest,
    FundAutoCollectionRequest,
    FundCollectionByAssetRequest,
    GetAutoRepayFuturesStatusRequest,
    GetPortfolioMarginProAccountBalanceRequest,
    GetPortfolioMarginProAccountInfoRequest,
    GetPortfolioMarginProSpanAccountInfoRequest,
    MintBfusdForPortfolioMarginRequest,
    PortfolioMarginProBankruptcyLoanRepayRequest,
    QueryPortfolioMarginProBankruptcyLoanAmountRequest,
    QueryPortfolioMarginProBankruptcyLoanRepayHistoryRequest,
    QueryPortfolioMarginProNegativeBalanceInterestHistoryRequest,
    RedeemBfusdForPortfolioMarginRequest,
    RepayFuturesNegativeBalanceRequest,
} from '../../../src/rest-api';
import type {
    BnbTransferResponse,
    ChangeAutoRepayFuturesStatusResponse,
    FundAutoCollectionResponse,
    FundCollectionByAssetResponse,
    GetAutoRepayFuturesStatusResponse,
    GetPortfolioMarginProAccountBalanceResponse,
    GetPortfolioMarginProAccountInfoResponse,
    GetPortfolioMarginProSpanAccountInfoResponse,
    MintBfusdForPortfolioMarginResponse,
    PortfolioMarginProBankruptcyLoanRepayResponse,
    QueryPortfolioMarginProBankruptcyLoanAmountResponse,
    QueryPortfolioMarginProBankruptcyLoanRepayHistoryResponse,
    QueryPortfolioMarginProNegativeBalanceInterestHistoryResponse,
    RedeemBfusdForPortfolioMarginResponse,
    RepayFuturesNegativeBalanceResponse,
} from '../../../src/rest-api/types';

describe('AccountApi', () => {
    let client: AccountApi;
    let config: ConfigurationRestAPI;
    let mockResponse: object = {};

    beforeEach(() => {
        config = new ConfigurationRestAPI({
            apiKey: 'test-api-key',
            apiSecret: 'test-api-secret',
            basePath: '',
        });
        client = new AccountApi(config);
    });

    describe('bnbTransfer()', () => {
        it('should execute bnbTransfer() successfully with required parameters only', async () => {
            const params: BnbTransferRequest = {
                amount: 1,
                transferSide: 'transferSide_example',
            };

            mockResponse = { tranId: 100000001 };

            const spy = jest.spyOn(client, 'bnbTransfer').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<BnbTransferResponse>)
            );
            const response = await client.bnbTransfer(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute bnbTransfer() successfully with optional parameters', async () => {
            const params: BnbTransferRequest = {
                amount: 1,
                transferSide: 'transferSide_example',
                recvWindow: 5000,
            };

            mockResponse = { tranId: 100000001 };

            const spy = jest.spyOn(client, 'bnbTransfer').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<BnbTransferResponse>)
            );
            const response = await client.bnbTransfer(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: BnbTransferRequest = {
                amount: 1,
                transferSide: 'transferSide_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.bnbTransfer(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling bnbTransfer.'
            );
        });

        it('should throw RequiredError when transferSide is missing', async () => {
            const _params: BnbTransferRequest = {
                amount: 1,
                transferSide: 'transferSide_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.transferSide;

            await expect(client.bnbTransfer(params)).rejects.toThrow(
                'Required parameter transferSide was null or undefined when calling bnbTransfer.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: BnbTransferRequest = {
                amount: 1,
                transferSide: 'transferSide_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'bnbTransfer').mockRejectedValueOnce(mockError);
            await expect(client.bnbTransfer(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('changeAutoRepayFuturesStatus()', () => {
        it('should execute changeAutoRepayFuturesStatus() successfully with required parameters only', async () => {
            const params: ChangeAutoRepayFuturesStatusRequest = {
                autoRepay: '',
            };

            mockResponse = { msg: 'success' };

            const spy = jest.spyOn(client, 'changeAutoRepayFuturesStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeAutoRepayFuturesStatusResponse>)
            );
            const response = await client.changeAutoRepayFuturesStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute changeAutoRepayFuturesStatus() successfully with optional parameters', async () => {
            const params: ChangeAutoRepayFuturesStatusRequest = {
                autoRepay: '',
                recvWindow: 5000,
            };

            mockResponse = { msg: 'success' };

            const spy = jest.spyOn(client, 'changeAutoRepayFuturesStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<ChangeAutoRepayFuturesStatusResponse>)
            );
            const response = await client.changeAutoRepayFuturesStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when autoRepay is missing', async () => {
            const _params: ChangeAutoRepayFuturesStatusRequest = {
                autoRepay: '',
            };
            const params = Object.assign({ ..._params });
            delete params?.autoRepay;

            await expect(client.changeAutoRepayFuturesStatus(params)).rejects.toThrow(
                'Required parameter autoRepay was null or undefined when calling changeAutoRepayFuturesStatus.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: ChangeAutoRepayFuturesStatusRequest = {
                autoRepay: '',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'changeAutoRepayFuturesStatus')
                .mockRejectedValueOnce(mockError);
            await expect(client.changeAutoRepayFuturesStatus(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('fundAutoCollection()', () => {
        it('should execute fundAutoCollection() successfully with required parameters only', async () => {
            mockResponse = { msg: 'success' };

            const spy = jest.spyOn(client, 'fundAutoCollection').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FundAutoCollectionResponse>)
            );
            const response = await client.fundAutoCollection();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute fundAutoCollection() successfully with optional parameters', async () => {
            const params: FundAutoCollectionRequest = {
                recvWindow: 5000,
            };

            mockResponse = { msg: 'success' };

            const spy = jest.spyOn(client, 'fundAutoCollection').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FundAutoCollectionResponse>)
            );
            const response = await client.fundAutoCollection(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest.spyOn(client, 'fundAutoCollection').mockRejectedValueOnce(mockError);
            await expect(client.fundAutoCollection()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('fundCollectionByAsset()', () => {
        it('should execute fundCollectionByAsset() successfully with required parameters only', async () => {
            const params: FundCollectionByAssetRequest = {
                asset: 'asset_example',
            };

            mockResponse = { msg: 'success' };

            const spy = jest.spyOn(client, 'fundCollectionByAsset').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FundCollectionByAssetResponse>)
            );
            const response = await client.fundCollectionByAsset(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute fundCollectionByAsset() successfully with optional parameters', async () => {
            const params: FundCollectionByAssetRequest = {
                asset: 'asset_example',
                recvWindow: 5000,
            };

            mockResponse = { msg: 'success' };

            const spy = jest.spyOn(client, 'fundCollectionByAsset').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<FundCollectionByAssetResponse>)
            );
            const response = await client.fundCollectionByAsset(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when asset is missing', async () => {
            const _params: FundCollectionByAssetRequest = {
                asset: 'asset_example',
            };
            const params = Object.assign({ ..._params });
            delete params?.asset;

            await expect(client.fundCollectionByAsset(params)).rejects.toThrow(
                'Required parameter asset was null or undefined when calling fundCollectionByAsset.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: FundCollectionByAssetRequest = {
                asset: 'asset_example',
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'fundCollectionByAsset')
                .mockRejectedValueOnce(mockError);
            await expect(client.fundCollectionByAsset(params)).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getAutoRepayFuturesStatus()', () => {
        it('should execute getAutoRepayFuturesStatus() successfully with required parameters only', async () => {
            mockResponse = { autoRepay: true };

            const spy = jest.spyOn(client, 'getAutoRepayFuturesStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetAutoRepayFuturesStatusResponse>)
            );
            const response = await client.getAutoRepayFuturesStatus();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getAutoRepayFuturesStatus() successfully with optional parameters', async () => {
            const params: GetAutoRepayFuturesStatusRequest = {
                recvWindow: 5000,
            };

            mockResponse = { autoRepay: true };

            const spy = jest.spyOn(client, 'getAutoRepayFuturesStatus').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetAutoRepayFuturesStatusResponse>)
            );
            const response = await client.getAutoRepayFuturesStatus(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getAutoRepayFuturesStatus')
                .mockRejectedValueOnce(mockError);
            await expect(client.getAutoRepayFuturesStatus()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('getPortfolioMarginProAccountBalance()', () => {
        it('should execute getPortfolioMarginProAccountBalance() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    asset: 'BTC',
                    totalWalletBalance: '100',
                    crossMarginAsset: '100',
                    crossMarginBorrowed: '0',
                    crossMarginFree: '100',
                    crossMarginInterest: '0',
                    crossMarginLocked: '0',
                    umWalletBalance: '0',
                    umUnrealizedPNL: '0',
                    cmWalletBalance: '0',
                    cmUnrealizedPNL: '0',
                    updateTime: 0,
                    negativeBalance: '0',
                    optionWalletBalance: '0',
                    optionEquity: '0',
                },
            ];

            const spy = jest.spyOn(client, 'getPortfolioMarginProAccountBalance').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetPortfolioMarginProAccountBalanceResponse>)
            );
            const response = await client.getPortfolioMarginProAccountBalance();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getPortfolioMarginProAccountBalance() successfully with optional parameters', async () => {
            const params: GetPortfolioMarginProAccountBalanceRequest = {
                asset: 'asset_example',
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    asset: 'BTC',
                    totalWalletBalance: '100',
                    crossMarginAsset: '100',
                    crossMarginBorrowed: '0',
                    crossMarginFree: '100',
                    crossMarginInterest: '0',
                    crossMarginLocked: '0',
                    umWalletBalance: '0',
                    umUnrealizedPNL: '0',
                    cmWalletBalance: '0',
                    cmUnrealizedPNL: '0',
                    updateTime: 0,
                    negativeBalance: '0',
                    optionWalletBalance: '0',
                    optionEquity: '0',
                },
            ];

            const spy = jest.spyOn(client, 'getPortfolioMarginProAccountBalance').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetPortfolioMarginProAccountBalanceResponse>)
            );
            const response = await client.getPortfolioMarginProAccountBalance(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getPortfolioMarginProAccountBalance')
                .mockRejectedValueOnce(mockError);
            await expect(client.getPortfolioMarginProAccountBalance()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getPortfolioMarginProAccountInfo()', () => {
        it('should execute getPortfolioMarginProAccountInfo() successfully with required parameters only', async () => {
            mockResponse = {
                uniMMR: '5167.92171923',
                accountEquity: '122607.35137903',
                actualEquity: '142607.35137903',
                accountMaintMargin: '23.72469206',
                accountInitialMargin: '47.44938412',
                totalAvailableBalance: '122,559.90199491',
                accountStatus: 'NORMAL',
                accountType: 'PM_1',
            };

            const spy = jest.spyOn(client, 'getPortfolioMarginProAccountInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetPortfolioMarginProAccountInfoResponse>)
            );
            const response = await client.getPortfolioMarginProAccountInfo();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getPortfolioMarginProAccountInfo() successfully with optional parameters', async () => {
            const params: GetPortfolioMarginProAccountInfoRequest = {
                recvWindow: 5000,
            };

            mockResponse = {
                uniMMR: '5167.92171923',
                accountEquity: '122607.35137903',
                actualEquity: '142607.35137903',
                accountMaintMargin: '23.72469206',
                accountInitialMargin: '47.44938412',
                totalAvailableBalance: '122,559.90199491',
                accountStatus: 'NORMAL',
                accountType: 'PM_1',
            };

            const spy = jest.spyOn(client, 'getPortfolioMarginProAccountInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetPortfolioMarginProAccountInfoResponse>)
            );
            const response = await client.getPortfolioMarginProAccountInfo(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getPortfolioMarginProAccountInfo')
                .mockRejectedValueOnce(mockError);
            await expect(client.getPortfolioMarginProAccountInfo()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('getPortfolioMarginProSpanAccountInfo()', () => {
        it('should execute getPortfolioMarginProSpanAccountInfo() successfully with required parameters only', async () => {
            mockResponse = {
                uniMMR: '5167.92171923',
                accountEquity: '122607.35137903',
                actualEquity: '142607.35137903',
                accountMaintMargin: '23.72469206',
                riskUnitMMList: [{ asset: 'BTC', uniMaintainUsd: '23.72469206' }],
                marginMM: '0.00000000',
                otherMM: '0.00000000',
                accountStatus: 'NORMAL',
                accountType: 'PM_3',
            };

            const spy = jest.spyOn(client, 'getPortfolioMarginProSpanAccountInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetPortfolioMarginProSpanAccountInfoResponse>)
            );
            const response = await client.getPortfolioMarginProSpanAccountInfo();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute getPortfolioMarginProSpanAccountInfo() successfully with optional parameters', async () => {
            const params: GetPortfolioMarginProSpanAccountInfoRequest = {
                recvWindow: 5000,
            };

            mockResponse = {
                uniMMR: '5167.92171923',
                accountEquity: '122607.35137903',
                actualEquity: '142607.35137903',
                accountMaintMargin: '23.72469206',
                riskUnitMMList: [{ asset: 'BTC', uniMaintainUsd: '23.72469206' }],
                marginMM: '0.00000000',
                otherMM: '0.00000000',
                accountStatus: 'NORMAL',
                accountType: 'PM_3',
            };

            const spy = jest.spyOn(client, 'getPortfolioMarginProSpanAccountInfo').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<GetPortfolioMarginProSpanAccountInfoResponse>)
            );
            const response = await client.getPortfolioMarginProSpanAccountInfo(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'getPortfolioMarginProSpanAccountInfo')
                .mockRejectedValueOnce(mockError);
            await expect(client.getPortfolioMarginProSpanAccountInfo()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('mintBfusdForPortfolioMargin()', () => {
        it('should execute mintBfusdForPortfolioMargin() successfully with required parameters only', async () => {
            const params: MintBfusdForPortfolioMarginRequest = {
                fromAsset: 'fromAsset_example',
                targetAsset: 'targetAsset_example',
                amount: 1,
            };

            mockResponse = {
                fromAsset: 'USDT',
                targetAsset: 'BFUSD',
                fromAssetQty: 10,
                targetAssetQty: 9.998,
                rate: 0.9998,
            };

            const spy = jest.spyOn(client, 'mintBfusdForPortfolioMargin').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MintBfusdForPortfolioMarginResponse>)
            );
            const response = await client.mintBfusdForPortfolioMargin(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute mintBfusdForPortfolioMargin() successfully with optional parameters', async () => {
            const params: MintBfusdForPortfolioMarginRequest = {
                fromAsset: 'fromAsset_example',
                targetAsset: 'targetAsset_example',
                amount: 1,
                recvWindow: 5000,
            };

            mockResponse = {
                fromAsset: 'USDT',
                targetAsset: 'BFUSD',
                fromAssetQty: 10,
                targetAssetQty: 9.998,
                rate: 0.9998,
            };

            const spy = jest.spyOn(client, 'mintBfusdForPortfolioMargin').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<MintBfusdForPortfolioMarginResponse>)
            );
            const response = await client.mintBfusdForPortfolioMargin(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when fromAsset is missing', async () => {
            const _params: MintBfusdForPortfolioMarginRequest = {
                fromAsset: 'fromAsset_example',
                targetAsset: 'targetAsset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.fromAsset;

            await expect(client.mintBfusdForPortfolioMargin(params)).rejects.toThrow(
                'Required parameter fromAsset was null or undefined when calling mintBfusdForPortfolioMargin.'
            );
        });

        it('should throw RequiredError when targetAsset is missing', async () => {
            const _params: MintBfusdForPortfolioMarginRequest = {
                fromAsset: 'fromAsset_example',
                targetAsset: 'targetAsset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.targetAsset;

            await expect(client.mintBfusdForPortfolioMargin(params)).rejects.toThrow(
                'Required parameter targetAsset was null or undefined when calling mintBfusdForPortfolioMargin.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: MintBfusdForPortfolioMarginRequest = {
                fromAsset: 'fromAsset_example',
                targetAsset: 'targetAsset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.mintBfusdForPortfolioMargin(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling mintBfusdForPortfolioMargin.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: MintBfusdForPortfolioMarginRequest = {
                fromAsset: 'fromAsset_example',
                targetAsset: 'targetAsset_example',
                amount: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'mintBfusdForPortfolioMargin')
                .mockRejectedValueOnce(mockError);
            await expect(client.mintBfusdForPortfolioMargin(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('portfolioMarginProBankruptcyLoanRepay()', () => {
        it('should execute portfolioMarginProBankruptcyLoanRepay() successfully with required parameters only', async () => {
            mockResponse = { tranId: 58203331886213500 };

            const spy = jest.spyOn(client, 'portfolioMarginProBankruptcyLoanRepay').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PortfolioMarginProBankruptcyLoanRepayResponse>)
            );
            const response = await client.portfolioMarginProBankruptcyLoanRepay();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute portfolioMarginProBankruptcyLoanRepay() successfully with optional parameters', async () => {
            const params: PortfolioMarginProBankruptcyLoanRepayRequest = {
                from: 'SPOT',
                recvWindow: 5000,
            };

            mockResponse = { tranId: 58203331886213500 };

            const spy = jest.spyOn(client, 'portfolioMarginProBankruptcyLoanRepay').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<PortfolioMarginProBankruptcyLoanRepayResponse>)
            );
            const response = await client.portfolioMarginProBankruptcyLoanRepay(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'portfolioMarginProBankruptcyLoanRepay')
                .mockRejectedValueOnce(mockError);
            await expect(client.portfolioMarginProBankruptcyLoanRepay()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryPortfolioMarginProBankruptcyLoanAmount()', () => {
        it('should execute queryPortfolioMarginProBankruptcyLoanAmount() successfully with required parameters only', async () => {
            mockResponse = { asset: 'BUSD', amount: '579.45' };

            const spy = jest
                .spyOn(client, 'queryPortfolioMarginProBankruptcyLoanAmount')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryPortfolioMarginProBankruptcyLoanAmountResponse>)
                );
            const response = await client.queryPortfolioMarginProBankruptcyLoanAmount();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryPortfolioMarginProBankruptcyLoanAmount() successfully with optional parameters', async () => {
            const params: QueryPortfolioMarginProBankruptcyLoanAmountRequest = {
                recvWindow: 5000,
            };

            mockResponse = { asset: 'BUSD', amount: '579.45' };

            const spy = jest
                .spyOn(client, 'queryPortfolioMarginProBankruptcyLoanAmount')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryPortfolioMarginProBankruptcyLoanAmountResponse>)
                );
            const response = await client.queryPortfolioMarginProBankruptcyLoanAmount(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryPortfolioMarginProBankruptcyLoanAmount')
                .mockRejectedValueOnce(mockError);
            await expect(client.queryPortfolioMarginProBankruptcyLoanAmount()).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('queryPortfolioMarginProBankruptcyLoanRepayHistory()', () => {
        it('should execute queryPortfolioMarginProBankruptcyLoanRepayHistory() successfully with required parameters only', async () => {
            mockResponse = {
                total: 3,
                rows: [
                    { asset: 'USDT', amount: '404.80294503', repayTime: 1731336427804 },
                    { asset: 'USDT', amount: '4620.41204574', repayTime: 1726125090016 },
                ],
            };

            const spy = jest
                .spyOn(client, 'queryPortfolioMarginProBankruptcyLoanRepayHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryPortfolioMarginProBankruptcyLoanRepayHistoryResponse>)
                );
            const response = await client.queryPortfolioMarginProBankruptcyLoanRepayHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryPortfolioMarginProBankruptcyLoanRepayHistory() successfully with optional parameters', async () => {
            const params: QueryPortfolioMarginProBankruptcyLoanRepayHistoryRequest = {
                startTime: 1623319461670,
                endTime: 1641782889000,
                current: 1,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = {
                total: 3,
                rows: [
                    { asset: 'USDT', amount: '404.80294503', repayTime: 1731336427804 },
                    { asset: 'USDT', amount: '4620.41204574', repayTime: 1726125090016 },
                ],
            };

            const spy = jest
                .spyOn(client, 'queryPortfolioMarginProBankruptcyLoanRepayHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryPortfolioMarginProBankruptcyLoanRepayHistoryResponse>)
                );
            const response = await client.queryPortfolioMarginProBankruptcyLoanRepayHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryPortfolioMarginProBankruptcyLoanRepayHistory')
                .mockRejectedValueOnce(mockError);
            await expect(
                client.queryPortfolioMarginProBankruptcyLoanRepayHistory()
            ).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('queryPortfolioMarginProNegativeBalanceInterestHistory()', () => {
        it('should execute queryPortfolioMarginProNegativeBalanceInterestHistory() successfully with required parameters only', async () => {
            mockResponse = [
                {
                    asset: 'USDT',
                    interest: '24.4440',
                    interestAccruedTime: 1670227200000,
                    interestRate: '0.0001164',
                    principal: '210000',
                },
            ];

            const spy = jest
                .spyOn(client, 'queryPortfolioMarginProNegativeBalanceInterestHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryPortfolioMarginProNegativeBalanceInterestHistoryResponse>)
                );
            const response = await client.queryPortfolioMarginProNegativeBalanceInterestHistory();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute queryPortfolioMarginProNegativeBalanceInterestHistory() successfully with optional parameters', async () => {
            const params: QueryPortfolioMarginProNegativeBalanceInterestHistoryRequest = {
                asset: 'asset_example',
                startTime: 1623319461670,
                endTime: 1641782889000,
                size: 10,
                recvWindow: 5000,
            };

            mockResponse = [
                {
                    asset: 'USDT',
                    interest: '24.4440',
                    interestAccruedTime: 1670227200000,
                    interestRate: '0.0001164',
                    principal: '210000',
                },
            ];

            const spy = jest
                .spyOn(client, 'queryPortfolioMarginProNegativeBalanceInterestHistory')
                .mockReturnValue(
                    Promise.resolve({
                        data: () => Promise.resolve(mockResponse),
                        status: 200,
                        headers: {},
                        rateLimits: [],
                    } as RestApiResponse<QueryPortfolioMarginProNegativeBalanceInterestHistoryResponse>)
                );
            const response =
                await client.queryPortfolioMarginProNegativeBalanceInterestHistory(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'queryPortfolioMarginProNegativeBalanceInterestHistory')
                .mockRejectedValueOnce(mockError);
            await expect(
                client.queryPortfolioMarginProNegativeBalanceInterestHistory()
            ).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });

    describe('redeemBfusdForPortfolioMargin()', () => {
        it('should execute redeemBfusdForPortfolioMargin() successfully with required parameters only', async () => {
            const params: RedeemBfusdForPortfolioMarginRequest = {
                fromAsset: 'fromAsset_example',
                targetAsset: 'targetAsset_example',
                amount: 1,
            };

            mockResponse = {
                fromAsset: 'BFUSD',
                targetAsset: 'USDT',
                fromAssetQty: 9.99800001,
                targetAssetQty: 9.996000409998,
                rate: 0.9998,
            };

            const spy = jest.spyOn(client, 'redeemBfusdForPortfolioMargin').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RedeemBfusdForPortfolioMarginResponse>)
            );
            const response = await client.redeemBfusdForPortfolioMargin(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute redeemBfusdForPortfolioMargin() successfully with optional parameters', async () => {
            const params: RedeemBfusdForPortfolioMarginRequest = {
                fromAsset: 'fromAsset_example',
                targetAsset: 'targetAsset_example',
                amount: 1,
                recvWindow: 5000,
            };

            mockResponse = {
                fromAsset: 'BFUSD',
                targetAsset: 'USDT',
                fromAssetQty: 9.99800001,
                targetAssetQty: 9.996000409998,
                rate: 0.9998,
            };

            const spy = jest.spyOn(client, 'redeemBfusdForPortfolioMargin').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RedeemBfusdForPortfolioMarginResponse>)
            );
            const response = await client.redeemBfusdForPortfolioMargin(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw RequiredError when fromAsset is missing', async () => {
            const _params: RedeemBfusdForPortfolioMarginRequest = {
                fromAsset: 'fromAsset_example',
                targetAsset: 'targetAsset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.fromAsset;

            await expect(client.redeemBfusdForPortfolioMargin(params)).rejects.toThrow(
                'Required parameter fromAsset was null or undefined when calling redeemBfusdForPortfolioMargin.'
            );
        });

        it('should throw RequiredError when targetAsset is missing', async () => {
            const _params: RedeemBfusdForPortfolioMarginRequest = {
                fromAsset: 'fromAsset_example',
                targetAsset: 'targetAsset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.targetAsset;

            await expect(client.redeemBfusdForPortfolioMargin(params)).rejects.toThrow(
                'Required parameter targetAsset was null or undefined when calling redeemBfusdForPortfolioMargin.'
            );
        });

        it('should throw RequiredError when amount is missing', async () => {
            const _params: RedeemBfusdForPortfolioMarginRequest = {
                fromAsset: 'fromAsset_example',
                targetAsset: 'targetAsset_example',
                amount: 1,
            };
            const params = Object.assign({ ..._params });
            delete params?.amount;

            await expect(client.redeemBfusdForPortfolioMargin(params)).rejects.toThrow(
                'Required parameter amount was null or undefined when calling redeemBfusdForPortfolioMargin.'
            );
        });

        it('should throw an error when server is returning an error', async () => {
            const params: RedeemBfusdForPortfolioMarginRequest = {
                fromAsset: 'fromAsset_example',
                targetAsset: 'targetAsset_example',
                amount: 1,
            };

            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'redeemBfusdForPortfolioMargin')
                .mockRejectedValueOnce(mockError);
            await expect(client.redeemBfusdForPortfolioMargin(params)).rejects.toThrow(
                'ResponseError'
            );
            spy.mockRestore();
        });
    });

    describe('repayFuturesNegativeBalance()', () => {
        it('should execute repayFuturesNegativeBalance() successfully with required parameters only', async () => {
            mockResponse = { msg: 'success' };

            const spy = jest.spyOn(client, 'repayFuturesNegativeBalance').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RepayFuturesNegativeBalanceResponse>)
            );
            const response = await client.repayFuturesNegativeBalance();
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should execute repayFuturesNegativeBalance() successfully with optional parameters', async () => {
            const params: RepayFuturesNegativeBalanceRequest = {
                from: 'SPOT',
                recvWindow: 5000,
            };

            mockResponse = { msg: 'success' };

            const spy = jest.spyOn(client, 'repayFuturesNegativeBalance').mockReturnValue(
                Promise.resolve({
                    data: () => Promise.resolve(mockResponse),
                    status: 200,
                    headers: {},
                    rateLimits: [],
                } as RestApiResponse<RepayFuturesNegativeBalanceResponse>)
            );
            const response = await client.repayFuturesNegativeBalance(params);
            expect(response).toBeDefined();
            await expect(response.data()).resolves.toBe(mockResponse);
            spy.mockRestore();
        });

        it('should throw an error when server is returning an error', async () => {
            const errorResponse = {
                code: -1111,
                msg: 'Server Error',
            };

            const mockError = new Error('ResponseError') as Error & {
                response?: { status: number; data: unknown };
            };
            mockError.response = { status: 400, data: errorResponse };
            const spy = jest
                .spyOn(client, 'repayFuturesNegativeBalance')
                .mockRejectedValueOnce(mockError);
            await expect(client.repayFuturesNegativeBalance()).rejects.toThrow('ResponseError');
            spy.mockRestore();
        });
    });
});
